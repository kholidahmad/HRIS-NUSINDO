{"version":3,"sources":["D:/project/projek_angular/hris_rni/node_modules/ngx-videogular/fesm2015/ngx-videogular.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;;;wFACE;;;;gCAI8B,AAGnB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAiNX,6EAGQ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wyEA+BR;;;;;;;;;;iDAU+C,AA0FjC;;;;;EAGd,yKAWoB;;;;;;;;;;;;EAUpB,8GAGmB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0jBAmFnB;;;;;;;;;;;;;;;;;;;;mDAoBiD,AA0BpC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4EA8Bb;0IACwI,AAK9H;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA0IV,2GAGkB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;slBAiDlB;;;;;;;;;;;8CAW4C,AAoC7B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wkBAqDf;;;;;;;;;;;;;wCAasC,AAqC7B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ujDAoET;;;;;;;;;;;;;;;;;;;kDAmBgD,AA6ErC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;olBAkDX;;;;;;;;;;;;;6CAa2C,AAmC7B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4tBAiDd;;;;;;;;;;;;;;;;kDAgBgD,AAqC7B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6nDAsJnB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oDAsCkD,AAuErC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0qBAmCb;;;;;;;uDAOqD,AA4B3B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+kBA4E1B;;;;;;;;;;mDAUiD,AA8B3B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4lCA2BtB;;;;;;;;;;wDAUsD,AA0C9B;;;;;;;;;;;;;;;;;;;;;;;;;;EAwBxB,oFAGY;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4nBAgCZ;;;;;;;;;;;;;gDAa8C,AA6B9B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0tDAwDhB;;;;;;;+CAO6C,AAmF3B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mvDA0BlB;;;;;;;;;;2DAUyD,AAmFrC;;;;;EAGpB,qMAsCmB;;;;;wFAGnB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+BA6B6B,AAGlB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mJA+YX;;;;;;;;;;0CAUwC,AAM9B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4QA4DV;;;;;;;;;;;;;;;wDAesD,AAMxC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;igBA4Cd;;;;;;;;;;;;;;;;;;;;;;;;;;;yCA2BuC,AA6B5B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA2CX,mNAOe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yWAgMf;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+CAsC6C,AAqBlC;;;;;;;;;;;;;;EAYX,gKAWiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2wCAwEjB;;;;;;;;;;;;;;;6CAe2C,AAsD3B;;;;;EAGhB,+KAWsB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0SAyHtB;;;;;;;;;;;;;;;;8CAgB4C,AASnC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8PA+HT;;;;;;;;;;;;;6CAa2C,AASnC;;;;;EAGR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAWoB","file":"ngx-videogular.js","sourcesContent":["import { __decorate } from 'tslib';\nimport { Injectable, EventEmitter, ElementRef, Input, HostBinding, Component, ViewEncapsulation, NgModule, ɵɵdefineInjectable, HostListener, ViewChild, Pipe, Output, ChangeDetectorRef, Directive, ContentChildren } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { Subject, fromEvent, Observable, combineLatest, timer } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nlet VgStates = class VgStates {\n};\nVgStates.VG_ENDED = 'ended';\nVgStates.VG_PAUSED = 'paused';\nVgStates.VG_PLAYING = 'playing';\nVgStates.VG_LOADING = 'waiting';\nVgStates = __decorate([\n    Injectable()\n], VgStates);\n\nlet VgAPI = class VgAPI {\n    constructor() {\n        // tslint:disable-next-line:ban-types\n        this.medias = {}; // TODO: refactor to Set<IPlayable>\n        this.playerReadyEvent = new EventEmitter(true);\n        this.isPlayerReady = false;\n    }\n    onPlayerReady(fsAPI) {\n        this.fsAPI = fsAPI;\n        this.isPlayerReady = true;\n        this.playerReadyEvent.emit(this);\n    }\n    getDefaultMedia() {\n        for (const item in this.medias) {\n            if (this.medias[item]) {\n                return this.medias[item];\n            }\n        }\n    }\n    getMasterMedia() {\n        let master;\n        for (const id in this.medias) {\n            if (this.medias[id].vgMaster === 'true' || this.medias[id].vgMaster === true) {\n                master = this.medias[id];\n                break;\n            }\n        }\n        return master || this.getDefaultMedia();\n    }\n    isMasterDefined() {\n        let result = false;\n        for (const id in this.medias) {\n            if (this.medias[id].vgMaster === 'true' || this.medias[id].vgMaster === true) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n    getMediaById(id = null) {\n        let media = this.medias[id];\n        if (!id || id === '*') {\n            media = this;\n        }\n        return media;\n    }\n    play() {\n        for (const id in this.medias) {\n            if (this.medias[id]) {\n                this.medias[id].play();\n            }\n        }\n    }\n    pause() {\n        for (const id in this.medias) {\n            if (this.medias[id]) {\n                this.medias[id].pause();\n            }\n        }\n    }\n    get duration() {\n        return this.$$getAllProperties('duration');\n    }\n    set currentTime(seconds) {\n        this.$$setAllProperties('currentTime', seconds);\n    }\n    get currentTime() {\n        return this.$$getAllProperties('currentTime');\n    }\n    set state(state) {\n        this.$$setAllProperties('state', state);\n    }\n    get state() {\n        return this.$$getAllProperties('state');\n    }\n    set volume(volume) {\n        this.$$setAllProperties('volume', volume);\n    }\n    get volume() {\n        return this.$$getAllProperties('volume');\n    }\n    set playbackRate(rate) {\n        this.$$setAllProperties('playbackRate', rate);\n    }\n    get playbackRate() {\n        return this.$$getAllProperties('playbackRate');\n    }\n    get canPlay() {\n        return this.$$getAllProperties('canPlay');\n    }\n    get canPlayThrough() {\n        return this.$$getAllProperties('canPlayThrough');\n    }\n    get isMetadataLoaded() {\n        return this.$$getAllProperties('isMetadataLoaded');\n    }\n    get isWaiting() {\n        return this.$$getAllProperties('isWaiting');\n    }\n    get isCompleted() {\n        return this.$$getAllProperties('isCompleted');\n    }\n    get isLive() {\n        return this.$$getAllProperties('isLive');\n    }\n    get isMaster() {\n        return this.$$getAllProperties('isMaster');\n    }\n    get time() {\n        return this.$$getAllProperties('time');\n    }\n    get buffer() {\n        return this.$$getAllProperties('buffer');\n    }\n    get buffered() {\n        return this.$$getAllProperties('buffered');\n    }\n    get subscriptions() {\n        return this.$$getAllProperties('subscriptions');\n    }\n    get textTracks() {\n        return this.$$getAllProperties('textTracks');\n    }\n    seekTime(value, byPercent = false) {\n        for (const id in this.medias) {\n            if (this.medias[id]) {\n                this.$$seek(this.medias[id], value, byPercent);\n            }\n        }\n    }\n    $$seek(media, value, byPercent = false) {\n        let second;\n        let duration = media.duration;\n        if (byPercent) {\n            if (this.isMasterDefined()) {\n                duration = this.getMasterMedia().duration;\n            }\n            second = value * duration / 100;\n        }\n        else {\n            second = value;\n        }\n        media.currentTime = second;\n    }\n    addTextTrack(type, label, language) {\n        for (const id in this.medias) {\n            if (this.medias[id]) {\n                this.$$addTextTrack(this.medias[id], type, label, language);\n            }\n        }\n    }\n    $$addTextTrack(media, type, label, language) {\n        media.addTextTrack(type, label, language);\n    }\n    $$getAllProperties(property) {\n        const medias = {};\n        let result;\n        for (const id in this.medias) {\n            if (this.medias[id]) {\n                medias[id] = this.medias[id];\n            }\n        }\n        const nMedias = Object.keys(medias).length;\n        switch (nMedias) {\n            case 0:\n                // Return default values until vgMedia is initialized\n                switch (property) {\n                    case 'state':\n                        result = VgStates.VG_PAUSED;\n                        break;\n                    case 'playbackRate':\n                    case 'volume':\n                        result = 1;\n                        break;\n                    case 'time':\n                        result = { current: 0, total: 0, left: 0 };\n                        break;\n                }\n                break;\n            case 1:\n                // If there's only one media element then return the plain value\n                const firstMediaId = Object.keys(medias)[0];\n                result = medias[firstMediaId][property];\n                break;\n            default:\n                // TODO: return 'master' value\n                const master = this.getMasterMedia();\n                result = medias[master.id][property];\n        }\n        return result;\n    }\n    $$setAllProperties(property, value) {\n        for (const id in this.medias) {\n            if (this.medias[id]) {\n                this.medias[id][property] = value;\n            }\n        }\n    }\n    registerElement(elem) {\n        this.videogularElement = elem;\n    }\n    registerMedia(media) {\n        this.medias[media.id] = media;\n    }\n    unregisterMedia(media) {\n        delete this.medias[media.id];\n    }\n};\nVgAPI = __decorate([\n    Injectable()\n], VgAPI);\n\n// tslint:disable:component-class-suffix\nlet VgBuffering = class VgBuffering {\n    constructor(ref, API) {\n        this.API = API;\n        this.checkInterval = 50;\n        this.currentPlayPos = 0;\n        this.lastPlayPos = 0;\n        this.subscriptions = [];\n        this.isBuffering = false;\n        this.elem = ref.nativeElement;\n    }\n    ngOnInit() {\n        if (this.API.isPlayerReady) {\n            this.onPlayerReady();\n        }\n        else {\n            this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n        }\n    }\n    onPlayerReady() {\n        this.target = this.API.getMediaById(this.vgFor);\n        this.subscriptions.push(this.target.subscriptions.bufferDetected.subscribe(isBuffering => this.onUpdateBuffer(isBuffering)));\n    }\n    onUpdateBuffer(isBuffering) {\n        this.isBuffering = isBuffering;\n    }\n    ngOnDestroy() {\n        this.subscriptions.forEach(s => s.unsubscribe());\n    }\n};\nVgBuffering.ctorParameters = () => [\n    { type: ElementRef },\n    { type: VgAPI }\n];\n__decorate([\n    Input()\n], VgBuffering.prototype, \"vgFor\", void 0);\n__decorate([\n    HostBinding('class.is-buffering')\n], VgBuffering.prototype, \"isBuffering\", void 0);\nVgBuffering = __decorate([\n    Component({\n        selector: 'vg-buffering',\n        encapsulation: ViewEncapsulation.None,\n        template: `<div class=\"vg-buffering\">\n            <div class=\"bufferingContainer\">\n                <div class=\"loadingSpinner\"></div>\n            </div>\n        </div>`,\n        styles: [`\n        vg-buffering {\n            display: none;\n            z-index: 201;\n        }\n        vg-buffering.is-buffering {\n            display: block;\n        }\n\n        .vg-buffering {\n            position: absolute;\n            display: block;\n            width: 100%;\n            height: 100%;\n        }\n        .vg-buffering .bufferingContainer {\n            width: 100%;\n            position: absolute;\n            cursor: pointer;\n            top: 50%;\n            margin-top: -50px;\n            zoom: 1;\n            filter: alpha(opacity=60);\n            opacity: 0.6;\n        }\n        /* Loading Spinner\n        * http://www.alessioatzeni.com/blog/css3-loading-animation-loop/\n        */\n        .vg-buffering .loadingSpinner {\n            background-color: rgba(0, 0, 0, 0);\n            border: 5px solid rgba(255, 255, 255, 1);\n            opacity: .9;\n            border-top: 5px solid rgba(0, 0, 0, 0);\n            border-left: 5px solid rgba(0, 0, 0, 0);\n            border-radius: 50px;\n            box-shadow: 0 0 35px #FFFFFF;\n            width: 50px;\n            height: 50px;\n            margin: 0 auto;\n            -moz-animation: spin .5s infinite linear;\n            -webkit-animation: spin .5s infinite linear;\n        }\n        .vg-buffering .loadingSpinner .stop {\n            -webkit-animation-play-state: paused;\n            -moz-animation-play-state: paused;\n        }\n        @-moz-keyframes spin {\n            0% {\n                -moz-transform: rotate(0deg);\n            }\n            100% {\n                -moz-transform: rotate(360deg);\n            }\n        }\n        @-moz-keyframes spinoff {\n            0% {\n                -moz-transform: rotate(0deg);\n            }\n            100% {\n                -moz-transform: rotate(-360deg);\n            }\n        }\n        @-webkit-keyframes spin {\n            0% {\n                -webkit-transform: rotate(0deg);\n            }\n            100% {\n                -webkit-transform: rotate(360deg);\n            }\n        }\n        @-webkit-keyframes spinoff {\n            0% {\n                -webkit-transform: rotate(0deg);\n            }\n            100% {\n                -webkit-transform: rotate(-360deg);\n            }\n        }\n    `]\n    })\n], VgBuffering);\n\nlet VgBufferingModule = class VgBufferingModule {\n};\nVgBufferingModule = __decorate([\n    NgModule({\n        imports: [CommonModule],\n        declarations: [\n            VgBuffering\n        ],\n        exports: [\n            VgBuffering\n        ]\n    })\n], VgBufferingModule);\n\nlet VgControlsHidden = class VgControlsHidden {\n    constructor() {\n        this.isHiddenSubject = new Subject();\n        this.isHidden = this.isHiddenSubject.asObservable();\n    }\n    state(hidden) {\n        this.isHiddenSubject.next(hidden);\n    }\n};\nVgControlsHidden = __decorate([\n    Injectable()\n], VgControlsHidden);\n\n// tslint:disable:component-class-suffix\nlet VgControls = class VgControls {\n    constructor(API, ref, hidden) {\n        this.API = API;\n        this.ref = ref;\n        this.hidden = hidden;\n        this.isAdsPlaying = 'initial';\n        this.hideControls = false;\n        this.vgAutohide = false;\n        this.vgAutohideTime = 3;\n        this.subscriptions = [];\n        this.elem = ref.nativeElement;\n    }\n    ngOnInit() {\n        this.mouseMove$ = fromEvent(this.API.videogularElement, 'mousemove');\n        this.subscriptions.push(this.mouseMove$.subscribe(this.show.bind(this)));\n        this.touchStart$ = fromEvent(this.API.videogularElement, 'touchstart');\n        this.subscriptions.push(this.touchStart$.subscribe(this.show.bind(this)));\n        if (this.API.isPlayerReady) {\n            this.onPlayerReady();\n        }\n        else {\n            this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n        }\n    }\n    onPlayerReady() {\n        this.target = this.API.getMediaById(this.vgFor);\n        this.subscriptions.push(this.target.subscriptions.play.subscribe(this.onPlay.bind(this)));\n        this.subscriptions.push(this.target.subscriptions.pause.subscribe(this.onPause.bind(this)));\n        this.subscriptions.push(this.target.subscriptions.startAds.subscribe(this.onStartAds.bind(this)));\n        this.subscriptions.push(this.target.subscriptions.endAds.subscribe(this.onEndAds.bind(this)));\n    }\n    ngAfterViewInit() {\n        if (this.vgAutohide) {\n            this.hide();\n        }\n        else {\n            this.show();\n        }\n    }\n    onPlay() {\n        if (this.vgAutohide) {\n            this.hide();\n        }\n    }\n    onPause() {\n        clearTimeout(this.timer);\n        this.hideControls = false;\n        this.hidden.state(false);\n    }\n    onStartAds() {\n        this.isAdsPlaying = 'none';\n    }\n    onEndAds() {\n        this.isAdsPlaying = 'initial';\n    }\n    hide() {\n        if (this.vgAutohide) {\n            clearTimeout(this.timer);\n            this.hideAsync();\n        }\n    }\n    show() {\n        clearTimeout(this.timer);\n        this.hideControls = false;\n        this.hidden.state(false);\n        if (this.vgAutohide) {\n            this.hideAsync();\n        }\n    }\n    hideAsync() {\n        if (this.API.state === VgStates.VG_PLAYING) {\n            this.timer = setTimeout(() => {\n                this.hideControls = true;\n                this.hidden.state(true);\n            }, this.vgAutohideTime * 1000);\n        }\n    }\n    ngOnDestroy() {\n        this.subscriptions.forEach(s => s.unsubscribe());\n    }\n};\nVgControls.ctorParameters = () => [\n    { type: VgAPI },\n    { type: ElementRef },\n    { type: VgControlsHidden }\n];\n__decorate([\n    HostBinding('style.pointer-events')\n], VgControls.prototype, \"isAdsPlaying\", void 0);\n__decorate([\n    HostBinding('class.hide')\n], VgControls.prototype, \"hideControls\", void 0);\n__decorate([\n    Input()\n], VgControls.prototype, \"vgFor\", void 0);\n__decorate([\n    Input()\n], VgControls.prototype, \"vgAutohide\", void 0);\n__decorate([\n    Input()\n], VgControls.prototype, \"vgAutohideTime\", void 0);\nVgControls = __decorate([\n    Component({\n        selector: 'vg-controls',\n        encapsulation: ViewEncapsulation.None,\n        template: `<ng-content></ng-content>`,\n        styles: [`\n        vg-controls {\n            position: absolute;\n            display: flex;\n            width: 100%;\n            height: 50px;\n            z-index: 300;\n            bottom: 0;\n            background-color: rgba(0, 0, 0, 0.5);\n            -webkit-transition: bottom 1s;\n            -khtml-transition: bottom 1s;\n            -moz-transition: bottom 1s;\n            -ms-transition: bottom 1s;\n            transition: bottom 1s;\n        }\n        vg-controls.hide {\n            bottom: -50px;\n        }\n    `]\n    })\n], VgControls);\n\nlet VgUtils = class VgUtils {\n    /**\n     * Inspired by Paul Irish\n     * https://gist.github.com/paulirish/211209\n     * @returns z-Index\n     */\n    static getZIndex() {\n        let zIndex = 1;\n        let elementZIndex;\n        const tags = document.getElementsByTagName('*');\n        for (let i = 0, l = tags.length; i < l; i++) {\n            elementZIndex = parseInt(window.getComputedStyle(tags[i])['z-index'], 10);\n            if (elementZIndex > zIndex) {\n                zIndex = elementZIndex + 1;\n            }\n        }\n        return zIndex;\n    }\n    // Very simple mobile detection, not 100% reliable\n    static isMobileDevice() {\n        return (typeof window.orientation !== 'undefined') || (navigator.userAgent.indexOf('IEMobile') !== -1);\n    }\n    static isiOSDevice() {\n        return (navigator.userAgent.match(/ip(hone|ad|od)/i) && !navigator.userAgent.match(/(iemobile)[\\/\\s]?([\\w\\.]*)/i));\n    }\n    static isCordova() {\n        return document.URL.indexOf('http://') === -1 && document.URL.indexOf('https://') === -1;\n    }\n};\nVgUtils.ɵprov = ɵɵdefineInjectable({ factory: function VgUtils_Factory() { return new VgUtils(); }, token: VgUtils, providedIn: \"root\" });\nVgUtils = __decorate([\n    Injectable({\n        providedIn: 'root'\n    })\n], VgUtils);\n\nlet VgFullscreenAPI = class VgFullscreenAPI {\n    constructor() {\n        this.nativeFullscreen = true;\n        this.isFullscreen = false;\n        this.onChangeFullscreen = new EventEmitter();\n    }\n    init(elem, medias) {\n        this.videogularElement = elem;\n        this.medias = medias;\n        const APIs = {\n            w3: {\n                enabled: 'fullscreenEnabled',\n                element: 'fullscreenElement',\n                request: 'requestFullscreen',\n                exit: 'exitFullscreen',\n                onchange: 'fullscreenchange',\n                onerror: 'fullscreenerror'\n            },\n            newWebkit: {\n                enabled: 'webkitFullscreenEnabled',\n                element: 'webkitFullscreenElement',\n                request: 'webkitRequestFullscreen',\n                exit: 'webkitExitFullscreen',\n                onchange: 'webkitfullscreenchange',\n                onerror: 'webkitfullscreenerror'\n            },\n            oldWebkit: {\n                enabled: 'webkitIsFullScreen',\n                element: 'webkitCurrentFullScreenElement',\n                request: 'webkitRequestFullScreen',\n                exit: 'webkitCancelFullScreen',\n                onchange: 'webkitfullscreenchange',\n                onerror: 'webkitfullscreenerror'\n            },\n            moz: {\n                enabled: 'mozFullScreen',\n                element: 'mozFullScreenElement',\n                request: 'mozRequestFullScreen',\n                exit: 'mozCancelFullScreen',\n                onchange: 'mozfullscreenchange',\n                onerror: 'mozfullscreenerror'\n            },\n            ios: {\n                enabled: 'webkitFullscreenEnabled',\n                element: 'webkitFullscreenElement',\n                request: 'webkitEnterFullscreen',\n                exit: 'webkitExitFullscreen',\n                onchange: 'webkitendfullscreen',\n                onerror: 'webkitfullscreenerror'\n            },\n            ms: {\n                enabled: 'msFullscreenEnabled',\n                element: 'msFullscreenElement',\n                request: 'msRequestFullscreen',\n                exit: 'msExitFullscreen',\n                onchange: 'MSFullscreenChange',\n                onerror: 'MSFullscreenError'\n            }\n        };\n        for (const browser in APIs) {\n            if (APIs[browser].enabled in document) {\n                this.polyfill = APIs[browser];\n                break;\n            }\n        }\n        if (VgUtils.isiOSDevice()) {\n            this.polyfill = APIs.ios;\n        }\n        this.isAvailable = (this.polyfill != null);\n        if (this.polyfill == null) {\n            return;\n        }\n        let fsElemDispatcher;\n        switch (this.polyfill.onchange) {\n            // Mozilla dispatches the fullscreen change event from document, not the element\n            // See: https://bugzilla.mozilla.org/show_bug.cgi?id=724816#c3\n            case 'mozfullscreenchange':\n                fsElemDispatcher = document;\n                break;\n            // iOS dispatches the fullscreen change event from video element\n            case 'webkitendfullscreen':\n                fsElemDispatcher = this.medias.toArray()[0].elem;\n                break;\n            // HTML5 implementation dispatches the fullscreen change event from the element\n            default:\n                fsElemDispatcher = elem;\n        }\n        this.fsChangeSubscription = fromEvent(fsElemDispatcher, this.polyfill.onchange).subscribe(() => {\n            this.onFullscreenChange();\n        });\n    }\n    onFullscreenChange() {\n        this.isFullscreen = !!document[this.polyfill.element];\n        this.onChangeFullscreen.emit(this.isFullscreen);\n    }\n    toggleFullscreen(element = null) {\n        if (this.isFullscreen) {\n            this.exit();\n        }\n        else {\n            this.request(element);\n        }\n    }\n    request(elem) {\n        if (!elem) {\n            elem = this.videogularElement;\n        }\n        this.isFullscreen = true;\n        this.onChangeFullscreen.emit(true);\n        // Perform native full screen support\n        if (this.isAvailable && this.nativeFullscreen) {\n            // Fullscreen for mobile devices\n            if (VgUtils.isMobileDevice()) {\n                // We should make fullscreen the video object if it doesn't have native fullscreen support\n                // Fallback! We can't set vg-player on fullscreen, only video/audio objects\n                if ((!this.polyfill.enabled && elem === this.videogularElement) || VgUtils.isiOSDevice()) {\n                    elem = this.medias.toArray()[0].elem;\n                }\n                this.enterElementInFullScreen(elem);\n            }\n            else {\n                this.enterElementInFullScreen(this.videogularElement);\n            }\n        }\n    }\n    enterElementInFullScreen(elem) {\n        elem[this.polyfill.request]();\n    }\n    exit() {\n        this.isFullscreen = false;\n        this.onChangeFullscreen.emit(false);\n        // Exit from native fullscreen\n        if (this.isAvailable && this.nativeFullscreen) {\n            document[this.polyfill.exit]();\n        }\n    }\n};\nVgFullscreenAPI = __decorate([\n    Injectable()\n], VgFullscreenAPI);\n\n// tslint:disable:component-class-suffix\n// tslint:disable:ban-types\nlet VgFullscreen = class VgFullscreen {\n    constructor(ref, API, fsAPI) {\n        this.API = API;\n        this.fsAPI = fsAPI;\n        this.isFullscreen = false;\n        this.subscriptions = [];\n        this.ariaValue = 'normal mode';\n        this.elem = ref.nativeElement;\n        this.subscriptions.push(this.fsAPI.onChangeFullscreen.subscribe(this.onChangeFullscreen.bind(this)));\n    }\n    ngOnInit() {\n        if (this.API.isPlayerReady) {\n            this.onPlayerReady();\n        }\n        else {\n            this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n        }\n    }\n    onPlayerReady() {\n        this.target = this.API.getMediaById(this.vgFor);\n    }\n    onChangeFullscreen(fsState) {\n        this.ariaValue = fsState ? 'fullscren mode' : 'normal mode';\n        this.isFullscreen = fsState;\n    }\n    onClick() {\n        this.changeFullscreenState();\n    }\n    onKeyDown(event) {\n        // On press Enter (13) or Space (32)\n        if (event.keyCode === 13 || event.keyCode === 32) {\n            event.preventDefault();\n            this.changeFullscreenState();\n        }\n    }\n    changeFullscreenState() {\n        let element = this.target;\n        if (this.target instanceof VgAPI) {\n            element = null;\n        }\n        this.fsAPI.toggleFullscreen(element);\n    }\n    ngOnDestroy() {\n        this.subscriptions.forEach(s => s.unsubscribe());\n    }\n};\nVgFullscreen.ctorParameters = () => [\n    { type: ElementRef },\n    { type: VgAPI },\n    { type: VgFullscreenAPI }\n];\n__decorate([\n    HostListener('click')\n], VgFullscreen.prototype, \"onClick\", null);\n__decorate([\n    HostListener('keydown', ['$event'])\n], VgFullscreen.prototype, \"onKeyDown\", null);\nVgFullscreen = __decorate([\n    Component({\n        selector: 'vg-fullscreen',\n        encapsulation: ViewEncapsulation.None,\n        template: `\n        <div class=\"icon\"\n             [class.vg-icon-fullscreen]=\"!isFullscreen\"\n             [class.vg-icon-fullscreen_exit]=\"isFullscreen\"\n             tabindex=\"0\"\n             role=\"button\"\n             aria-label=\"fullscreen button\"\n             [attr.aria-valuetext]=\"ariaValue\">\n        </div>`,\n        styles: [`\n        vg-fullscreen {\n            -webkit-touch-callout: none;\n            -webkit-user-select: none;\n            -khtml-user-select: none;\n            -moz-user-select: none;\n            -ms-user-select: none;\n            user-select: none;\n            display: flex;\n            justify-content: center;\n            height: 50px;\n            width: 50px;\n            cursor: pointer;\n            color: white;\n            line-height: 50px;\n        }\n\n        vg-fullscreen .icon {\n            pointer-events: none;\n        }\n    `]\n    })\n], VgFullscreen);\n\n// tslint:disable:component-class-suffix\nlet VgMute = class VgMute {\n    constructor(ref, API) {\n        this.API = API;\n        this.subscriptions = [];\n        this.ariaValue = 'unmuted';\n        this.elem = ref.nativeElement;\n    }\n    ngOnInit() {\n        if (this.API.isPlayerReady) {\n            this.onPlayerReady();\n        }\n        else {\n            this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n        }\n    }\n    onPlayerReady() {\n        this.target = this.API.getMediaById(this.vgFor);\n        this.currentVolume = this.target.volume;\n    }\n    onClick() {\n        this.changeMuteState();\n    }\n    onKeyDown(event) {\n        // On press Enter (13) or Space (32)\n        if (event.keyCode === 13 || event.keyCode === 32) {\n            event.preventDefault();\n            this.changeMuteState();\n        }\n    }\n    changeMuteState() {\n        const volume = this.getVolume();\n        if (volume === 0) {\n            if (this.target.volume === 0 && this.currentVolume === 0) {\n                this.currentVolume = 1;\n            }\n            this.target.volume = this.currentVolume;\n        }\n        else {\n            this.currentVolume = volume;\n            this.target.volume = 0;\n        }\n    }\n    getVolume() {\n        const volume = this.target ? this.target.volume : 0;\n        this.ariaValue = volume ? 'unmuted' : 'muted';\n        return volume;\n    }\n    ngOnDestroy() {\n        this.subscriptions.forEach(s => s.unsubscribe());\n    }\n};\nVgMute.ctorParameters = () => [\n    { type: ElementRef },\n    { type: VgAPI }\n];\n__decorate([\n    Input()\n], VgMute.prototype, \"vgFor\", void 0);\n__decorate([\n    HostListener('click')\n], VgMute.prototype, \"onClick\", null);\n__decorate([\n    HostListener('keydown', ['$event'])\n], VgMute.prototype, \"onKeyDown\", null);\nVgMute = __decorate([\n    Component({\n        selector: 'vg-mute',\n        encapsulation: ViewEncapsulation.None,\n        template: `\n        <div class=\"icon\"\n             [class.vg-icon-volume_up]=\"getVolume() >= 0.75\"\n             [class.vg-icon-volume_down]=\"getVolume() >= 0.25 && getVolume() < 0.75\"\n             [class.vg-icon-volume_mute]=\"getVolume() > 0 && getVolume() < 0.25\"\n             [class.vg-icon-volume_off]=\"getVolume() === 0\"\n             tabindex=\"0\"\n             role=\"button\"\n             aria-label=\"mute button\"\n             [attr.aria-valuetext]=\"ariaValue\">\n        </div>`,\n        styles: [`\n        vg-mute {\n            -webkit-touch-callout: none;\n            -webkit-user-select: none;\n            -khtml-user-select: none;\n            -moz-user-select: none;\n            -ms-user-select: none;\n            user-select: none;\n            display: flex;\n            justify-content: center;\n            height: 50px;\n            width: 50px;\n            cursor: pointer;\n            color: white;\n            line-height: 50px;\n        }\n        vg-mute .icon {\n            pointer-events: none;\n        }\n    `]\n    })\n], VgMute);\n\n// tslint:disable:component-class-suffix\nlet VgVolume = class VgVolume {\n    constructor(ref, API) {\n        this.API = API;\n        this.subscriptions = [];\n        this.elem = ref.nativeElement;\n        this.isDragging = false;\n    }\n    ngOnInit() {\n        if (this.API.isPlayerReady) {\n            this.onPlayerReady();\n        }\n        else {\n            this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n        }\n    }\n    onPlayerReady() {\n        this.target = this.API.getMediaById(this.vgFor);\n        this.ariaValue = this.getVolume() * 100;\n    }\n    onClick(event) {\n        this.setVolume(this.calculateVolume(event.clientX));\n    }\n    onMouseDown(event) {\n        this.mouseDownPosX = event.clientX;\n        this.isDragging = true;\n    }\n    onDrag(event) {\n        if (this.isDragging) {\n            this.setVolume(this.calculateVolume(event.clientX));\n        }\n    }\n    onStopDrag(event) {\n        if (this.isDragging) {\n            this.isDragging = false;\n            if (this.mouseDownPosX === event.clientX) {\n                this.setVolume(this.calculateVolume(event.clientX));\n            }\n        }\n    }\n    arrowAdjustVolume(event) {\n        if (event.keyCode === 38 || event.keyCode === 39) {\n            event.preventDefault();\n            this.setVolume(Math.max(0, Math.min(100, this.getVolume() * 100 + 10)));\n        }\n        else if (event.keyCode === 37 || event.keyCode === 40) {\n            event.preventDefault();\n            this.setVolume(Math.max(0, Math.min(100, this.getVolume() * 100 - 10)));\n        }\n    }\n    calculateVolume(mousePosX) {\n        const recObj = this.volumeBarRef.nativeElement.getBoundingClientRect();\n        const volumeBarOffsetLeft = recObj.left;\n        const volumeBarWidth = recObj.width;\n        return (mousePosX - volumeBarOffsetLeft) / volumeBarWidth * 100;\n    }\n    setVolume(vol) {\n        this.target.volume = Math.max(0, Math.min(1, vol / 100));\n        this.ariaValue = this.target.volume * 100;\n    }\n    getVolume() {\n        return this.target ? this.target.volume : 0;\n    }\n    ngOnDestroy() {\n        this.subscriptions.forEach((s) => s.unsubscribe());\n    }\n};\nVgVolume.ctorParameters = () => [\n    { type: ElementRef },\n    { type: VgAPI }\n];\n__decorate([\n    Input()\n], VgVolume.prototype, \"vgFor\", void 0);\n__decorate([\n    ViewChild('volumeBar', { static: true })\n], VgVolume.prototype, \"volumeBarRef\", void 0);\n__decorate([\n    HostListener('document:mousemove', ['$event'])\n], VgVolume.prototype, \"onDrag\", null);\n__decorate([\n    HostListener('document:mouseup', ['$event'])\n], VgVolume.prototype, \"onStopDrag\", null);\n__decorate([\n    HostListener('keydown', ['$event'])\n], VgVolume.prototype, \"arrowAdjustVolume\", null);\nVgVolume = __decorate([\n    Component({\n        selector: 'vg-volume',\n        encapsulation: ViewEncapsulation.None,\n        template: `\n        <div\n            #volumeBar\n            class=\"volumeBar\"\n            tabindex=\"0\"\n            role=\"slider\"\n            aria-label=\"volume level\"\n            aria-level=\"polite\"\n            [attr.aria-valuenow]=\"ariaValue\"\n            aria-valuemin=\"0\"\n            aria-valuemax=\"100\"\n            aria-orientation=\"horizontal\"\n            [attr.aria-valuetext]=\"ariaValue + '%'\"\n            (click)=\"onClick($event)\"\n            (mousedown)=\"onMouseDown($event)\">\n            <div class=\"volumeBackground\" [ngClass]=\"{dragging: isDragging}\">\n                <div class=\"volumeValue\" [style.width]=\"(getVolume() * (100-15)) + '%'\"></div>\n                <div class=\"volumeKnob\" [style.left]=\"(getVolume() * (100-15)) + '%'\"></div>\n            </div>\n        </div>\n    `,\n        styles: [`\n        vg-volume {\n            -webkit-touch-callout: none;\n            -webkit-user-select: none;\n            -moz-user-select: none;\n            -ms-user-select: none;\n            user-select: none;\n            display: flex;\n            justify-content: center;\n            height: 50px;\n            width: 100px;\n            cursor: pointer;\n            color: white;\n            line-height: 50px;\n        }\n        vg-volume .volumeBar {\n            position: relative;\n            display: flex;\n            flex-grow: 1;\n            align-items: center;\n        }\n        vg-volume .volumeBackground {\n            display: flex;\n            flex-grow: 1;\n            height: 5px;\n            pointer-events: none;\n            background-color: #333;\n        }\n        vg-volume .volumeValue {\n            display: flex;\n            height: 5px;\n            pointer-events: none;\n            background-color: #FFF;\n            transition:all 0.2s ease-out;\n        }\n        vg-volume .volumeKnob {\n            position: absolute;\n            width: 15px; height: 15px;\n            left: 0; top: 50%;\n            transform: translateY(-50%);\n            border-radius: 15px;\n            pointer-events: none;\n            background-color: #FFF;\n            transition:all 0.2s ease-out;\n        }\n        vg-volume .volumeBackground.dragging .volumeValue,\n        vg-volume .volumeBackground.dragging .volumeKnob {\n            transition: none;\n        }\n    `]\n    })\n], VgVolume);\n\n// tslint:disable:component-class-suffix\nlet VgPlayPause = class VgPlayPause {\n    constructor(ref, API) {\n        this.API = API;\n        this.subscriptions = [];\n        this.ariaValue = VgStates.VG_PAUSED;\n        this.elem = ref.nativeElement;\n    }\n    ngOnInit() {\n        if (this.API.isPlayerReady) {\n            this.onPlayerReady();\n        }\n        else {\n            this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n        }\n    }\n    onPlayerReady() {\n        this.target = this.API.getMediaById(this.vgFor);\n    }\n    onClick() {\n        this.playPause();\n    }\n    onKeyDown(event) {\n        // On press Enter (13) or Space (32)\n        if (event.keyCode === 13 || event.keyCode === 32) {\n            event.preventDefault();\n            this.playPause();\n        }\n    }\n    playPause() {\n        const state = this.getState();\n        switch (state) {\n            case VgStates.VG_PLAYING:\n                this.target.pause();\n                break;\n            case VgStates.VG_PAUSED:\n            case VgStates.VG_ENDED:\n                this.target.play();\n                break;\n        }\n    }\n    getState() {\n        this.ariaValue = this.target ? this.target.state : VgStates.VG_PAUSED;\n        return this.ariaValue;\n    }\n    ngOnDestroy() {\n        this.subscriptions.forEach(s => s.unsubscribe());\n    }\n};\nVgPlayPause.ctorParameters = () => [\n    { type: ElementRef },\n    { type: VgAPI }\n];\n__decorate([\n    Input()\n], VgPlayPause.prototype, \"vgFor\", void 0);\n__decorate([\n    HostListener('click')\n], VgPlayPause.prototype, \"onClick\", null);\n__decorate([\n    HostListener('keydown', ['$event'])\n], VgPlayPause.prototype, \"onKeyDown\", null);\nVgPlayPause = __decorate([\n    Component({\n        selector: 'vg-play-pause',\n        encapsulation: ViewEncapsulation.None,\n        template: `\n        <div class=\"icon\"\n             [class.vg-icon-pause]=\"getState() === 'playing'\"\n             [class.vg-icon-play_arrow]=\"getState() === 'paused' || getState() === 'ended'\"\n             tabindex=\"0\"\n             role=\"button\"\n             [attr.aria-label]=\"getState() === 'paused'?'play':'pause'\"\n             [attr.aria-valuetext]=\"ariaValue\">\n        </div>`,\n        styles: [`\n        vg-play-pause {\n            -webkit-touch-callout: none;\n            -webkit-user-select: none;\n            -khtml-user-select: none;\n            -moz-user-select: none;\n            -ms-user-select: none;\n            user-select: none;\n            display: flex;\n            justify-content: center;\n            height: 50px;\n            width: 50px;\n            cursor: pointer;\n            color: white;\n            line-height: 50px;\n        }\n        vg-play-pause .icon {\n            pointer-events: none;\n        }\n    `]\n    })\n], VgPlayPause);\n\n// tslint:disable:component-class-suffix\nlet VgPlaybackButton = class VgPlaybackButton {\n    constructor(ref, API) {\n        this.API = API;\n        this.subscriptions = [];\n        this.ariaValue = 1;\n        this.elem = ref.nativeElement;\n        this.playbackValues = ['0.5', '1.0', '1.5', '2.0'];\n        this.playbackIndex = 1;\n    }\n    ngOnInit() {\n        if (this.API.isPlayerReady) {\n            this.onPlayerReady();\n        }\n        else {\n            this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n        }\n    }\n    onPlayerReady() {\n        this.target = this.API.getMediaById(this.vgFor);\n    }\n    onClick() {\n        this.updatePlaybackSpeed();\n    }\n    onKeyDown(event) {\n        // On press Enter (13) or Space (32)\n        if (event.keyCode === 13 || event.keyCode === 32) {\n            event.preventDefault();\n            this.updatePlaybackSpeed();\n        }\n    }\n    updatePlaybackSpeed() {\n        this.playbackIndex = ++this.playbackIndex % this.playbackValues.length;\n        if (this.target instanceof VgAPI) {\n            this.target.playbackRate = (this.playbackValues[this.playbackIndex]);\n        }\n        else {\n            this.target.playbackRate[this.vgFor] = (this.playbackValues[this.playbackIndex]);\n        }\n    }\n    getPlaybackRate() {\n        this.ariaValue = this.target ? this.target.playbackRate : 1.0;\n        return this.ariaValue;\n    }\n    ngOnDestroy() {\n        this.subscriptions.forEach(s => s.unsubscribe());\n    }\n};\nVgPlaybackButton.ctorParameters = () => [\n    { type: ElementRef },\n    { type: VgAPI }\n];\n__decorate([\n    Input()\n], VgPlaybackButton.prototype, \"vgFor\", void 0);\n__decorate([\n    Input()\n], VgPlaybackButton.prototype, \"playbackValues\", void 0);\n__decorate([\n    HostListener('click')\n], VgPlaybackButton.prototype, \"onClick\", null);\n__decorate([\n    HostListener('keydown', ['$event'])\n], VgPlaybackButton.prototype, \"onKeyDown\", null);\nVgPlaybackButton = __decorate([\n    Component({\n        selector: 'vg-playback-button',\n        encapsulation: ViewEncapsulation.None,\n        template: `\n    <span class=\"button\"\n          tabindex=\"0\"\n          role=\"button\"\n          aria-label=\"playback speed button\"\n          [attr.aria-valuetext]=\"ariaValue\">\n        {{getPlaybackRate()}}x\n    </span>`,\n        styles: [`\n        vg-playback-button {\n            -webkit-touch-callout: none;\n            -webkit-user-select: none;\n            -moz-user-select: none;\n            -ms-user-select: none;\n            user-select: none;\n            display: flex;\n            justify-content: center;\n            height: 50px;\n            width: 50px;\n            cursor: pointer;\n            color: white;\n            line-height: 50px;\n            font-family: Helvetica Neue, Helvetica, Arial, sans-serif;\n        }\n        vg-playback-button .button {\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            width: 50px;\n        }\n    `]\n    })\n], VgPlaybackButton);\n\n// tslint:disable:component-class-suffix\nlet VgScrubBar = class VgScrubBar {\n    constructor(ref, API, vgControlsHiddenState) {\n        this.API = API;\n        this.hideScrubBar = false;\n        this.vgSlider = true;\n        this.isSeeking = false;\n        this.wasPlaying = false;\n        this.subscriptions = [];\n        this.elem = ref.nativeElement;\n        this.subscriptions.push(vgControlsHiddenState.isHidden.subscribe(hide => this.onHideScrubBar(hide)));\n    }\n    ngOnInit() {\n        if (this.API.isPlayerReady) {\n            this.onPlayerReady();\n        }\n        else {\n            this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n        }\n    }\n    onPlayerReady() {\n        this.target = this.API.getMediaById(this.vgFor);\n    }\n    seekStart() {\n        if (this.target.canPlay) {\n            this.isSeeking = true;\n            if (this.target.state === VgStates.VG_PLAYING) {\n                this.wasPlaying = true;\n            }\n            this.target.pause();\n        }\n    }\n    seekMove(offset) {\n        if (this.isSeeking) {\n            const percentage = Math.max(Math.min(offset * 100 / this.elem.scrollWidth, 99.9), 0);\n            this.target.time.current = percentage * this.target.time.total / 100;\n            this.target.seekTime(percentage, true);\n        }\n    }\n    seekEnd(offset) {\n        this.isSeeking = false;\n        if (this.target.canPlay) {\n            const percentage = Math.max(Math.min(offset * 100 / this.elem.scrollWidth, 99.9), 0);\n            this.target.seekTime(percentage, true);\n            if (this.wasPlaying) {\n                this.wasPlaying = false;\n                this.target.play();\n            }\n        }\n    }\n    touchEnd() {\n        this.isSeeking = false;\n        if (this.wasPlaying) {\n            this.wasPlaying = false;\n            this.target.play();\n        }\n    }\n    getTouchOffset(event) {\n        let offsetLeft = 0;\n        let element = event.target;\n        while (element) {\n            offsetLeft += element.offsetLeft;\n            element = element.offsetParent;\n        }\n        return event.touches[0].pageX - offsetLeft;\n    }\n    onMouseDownScrubBar($event) {\n        if (this.target) {\n            if (!this.target.isLive) {\n                if (!this.vgSlider) {\n                    this.seekEnd($event.offsetX);\n                }\n                else {\n                    this.seekStart();\n                }\n            }\n        }\n    }\n    onMouseMoveScrubBar($event) {\n        if (this.target) {\n            if (!this.target.isLive && this.vgSlider && this.isSeeking) {\n                this.seekMove($event.offsetX);\n            }\n        }\n    }\n    onMouseUpScrubBar($event) {\n        if (this.target) {\n            if (!this.target.isLive && this.vgSlider && this.isSeeking) {\n                this.seekEnd($event.offsetX);\n            }\n        }\n    }\n    onTouchStartScrubBar($event) {\n        if (this.target) {\n            if (!this.target.isLive) {\n                if (!this.vgSlider) {\n                    this.seekEnd(this.getTouchOffset($event));\n                }\n                else {\n                    this.seekStart();\n                }\n            }\n        }\n    }\n    onTouchMoveScrubBar($event) {\n        if (this.target) {\n            if (!this.target.isLive && this.vgSlider && this.isSeeking) {\n                this.seekMove(this.getTouchOffset($event));\n            }\n        }\n    }\n    // @ts-ignore\n    onTouchCancelScrubBar($event) {\n        if (this.target) {\n            if (!this.target.isLive && this.vgSlider && this.isSeeking) {\n                this.touchEnd();\n            }\n        }\n    }\n    // @ts-ignore\n    onTouchEndScrubBar($event) {\n        if (this.target) {\n            if (!this.target.isLive && this.vgSlider && this.isSeeking) {\n                this.touchEnd();\n            }\n        }\n    }\n    arrowAdjustVolume(event) {\n        if (this.target) {\n            if (event.keyCode === 38 || event.keyCode === 39) {\n                event.preventDefault();\n                this.target.seekTime((this.target.time.current + 5000) / 1000, false);\n            }\n            else if (event.keyCode === 37 || event.keyCode === 40) {\n                event.preventDefault();\n                this.target.seekTime((this.target.time.current - 5000) / 1000, false);\n            }\n        }\n    }\n    getPercentage() {\n        return this.target ? ((this.target.time.current * 100) / this.target.time.total) + '%' : '0%';\n    }\n    onHideScrubBar(hide) {\n        this.hideScrubBar = hide;\n    }\n    ngOnDestroy() {\n        this.subscriptions.forEach(s => s.unsubscribe());\n    }\n};\nVgScrubBar.ctorParameters = () => [\n    { type: ElementRef },\n    { type: VgAPI },\n    { type: VgControlsHidden }\n];\n__decorate([\n    HostBinding('class.hide')\n], VgScrubBar.prototype, \"hideScrubBar\", void 0);\n__decorate([\n    Input()\n], VgScrubBar.prototype, \"vgFor\", void 0);\n__decorate([\n    Input()\n], VgScrubBar.prototype, \"vgSlider\", void 0);\n__decorate([\n    HostListener('mousedown', ['$event'])\n], VgScrubBar.prototype, \"onMouseDownScrubBar\", null);\n__decorate([\n    HostListener('document:mousemove', ['$event'])\n], VgScrubBar.prototype, \"onMouseMoveScrubBar\", null);\n__decorate([\n    HostListener('document:mouseup', ['$event'])\n], VgScrubBar.prototype, \"onMouseUpScrubBar\", null);\n__decorate([\n    HostListener('touchstart', ['$event'])\n], VgScrubBar.prototype, \"onTouchStartScrubBar\", null);\n__decorate([\n    HostListener('document:touchmove', ['$event'])\n], VgScrubBar.prototype, \"onTouchMoveScrubBar\", null);\n__decorate([\n    HostListener('document:touchcancel', ['$event'])\n], VgScrubBar.prototype, \"onTouchCancelScrubBar\", null);\n__decorate([\n    HostListener('document:touchend', ['$event'])\n], VgScrubBar.prototype, \"onTouchEndScrubBar\", null);\n__decorate([\n    HostListener('keydown', ['$event'])\n], VgScrubBar.prototype, \"arrowAdjustVolume\", null);\nVgScrubBar = __decorate([\n    Component({\n        selector: 'vg-scrub-bar',\n        encapsulation: ViewEncapsulation.None,\n        template: `\n        <div class=\"scrubBar\"\n             tabindex=\"0\"\n             role=\"slider\"\n             aria-label=\"scrub bar\"\n             aria-level=\"polite\"\n             [attr.aria-valuenow]=\"getPercentage()\"\n             aria-valuemin=\"0\"\n             aria-valuemax=\"100\"\n             [attr.aria-valuetext]=\"getPercentage() + '%'\">\n            <ng-content></ng-content>\n        </div>\n    `,\n        styles: [`\n        vg-scrub-bar {\n            -webkit-touch-callout: none;\n            -webkit-user-select: none;\n            -moz-user-select: none;\n            -ms-user-select: none;\n            user-select: none;\n            position: absolute;\n            width: 100%;\n            height: 5px;\n            bottom: 50px;\n            margin: 0;\n            cursor: pointer;\n            align-items: center;\n            background: rgba(0, 0, 0, 0.75);\n            z-index: 250;\n            -webkit-transition: bottom 1s, opacity 0.5s;\n            -khtml-transition: bottom 1s, opacity 0.5s;\n            -moz-transition: bottom 1s, opacity 0.5s;\n            -ms-transition: bottom 1s, opacity 0.5s;\n            transition: bottom 1s, opacity 0.5s;\n        }\n        vg-scrub-bar .scrubBar {\n            position: relative;\n            display: flex;\n            flex-grow: 1;\n            align-items: center;\n            height: 100%;\n        }\n        vg-controls vg-scrub-bar {\n            position: relative;\n            bottom: 0;\n            background: transparent;\n            height: 50px;\n            flex-grow: 1;\n            flex-basis: 0;\n            margin: 0 10px;\n            -webkit-transition: initial;\n            -khtml-transition: initial;\n            -moz-transition: initial;\n            -ms-transition: initial;\n            transition: initial;\n        }\n        vg-scrub-bar.hide {\n            bottom: 0;\n            opacity: 0;\n        }\n        vg-controls vg-scrub-bar.hide {\n            bottom: initial;\n            opacity: initial;\n        }\n    `]\n    })\n], VgScrubBar);\n\n// tslint:disable:component-class-suffix\nlet VgScrubBarBufferingTime = class VgScrubBarBufferingTime {\n    constructor(ref, API) {\n        this.API = API;\n        this.subscriptions = [];\n        this.elem = ref.nativeElement;\n    }\n    ngOnInit() {\n        if (this.API.isPlayerReady) {\n            this.onPlayerReady();\n        }\n        else {\n            this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n        }\n    }\n    onPlayerReady() {\n        this.target = this.API.getMediaById(this.vgFor);\n    }\n    getBufferTime() {\n        let bufferTime = '0%';\n        if (this.target && this.target.buffer && this.target.buffered.length) {\n            if (this.target.time.total === 0) {\n                bufferTime = '0%';\n            }\n            else {\n                bufferTime = ((this.target.buffer.end / this.target.time.total) * 100) + '%';\n            }\n        }\n        return bufferTime;\n    }\n    ngOnDestroy() {\n        this.subscriptions.forEach(s => s.unsubscribe());\n    }\n};\nVgScrubBarBufferingTime.ctorParameters = () => [\n    { type: ElementRef },\n    { type: VgAPI }\n];\n__decorate([\n    Input()\n], VgScrubBarBufferingTime.prototype, \"vgFor\", void 0);\nVgScrubBarBufferingTime = __decorate([\n    Component({\n        selector: 'vg-scrub-bar-buffering-time',\n        encapsulation: ViewEncapsulation.None,\n        template: `<div class=\"background\" [style.width]=\"getBufferTime()\"></div>`,\n        styles: [`\n        vg-scrub-bar-buffering-time {\n            display: flex;\n            width: 100%;\n            height: 5px;\n            pointer-events: none;\n            position: absolute;\n        }\n        vg-scrub-bar-buffering-time .background {\n            background-color: rgba(255, 255, 255, 0.3);\n        }\n        vg-controls vg-scrub-bar-buffering-time {\n            position: absolute;\n            top: calc(50% - 3px);\n        }\n        vg-controls vg-scrub-bar-buffering-time .background {\n            -webkit-border-radius: 2px;\n            -moz-border-radius: 2px;\n            border-radius: 2px;\n        }\n    `]\n    })\n], VgScrubBarBufferingTime);\n\n// tslint:disable:no-conflicting-lifecycle\n// tslint:disable:component-class-suffix\n// tslint:disable:no-string-literal\nlet VgScrubBarCuePoints = class VgScrubBarCuePoints {\n    constructor(ref, API) {\n        this.API = API;\n        this.onLoadedMetadataCalled = false;\n        this.cuePoints = [];\n        this.subscriptions = [];\n        this.totalCues = 0;\n        this.elem = ref.nativeElement;\n    }\n    ngOnInit() {\n        if (this.API.isPlayerReady) {\n            this.onPlayerReady();\n        }\n        else {\n            this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n        }\n    }\n    onPlayerReady() {\n        this.target = this.API.getMediaById(this.vgFor);\n        const onTimeUpdate = this.target.subscriptions.loadedMetadata;\n        this.subscriptions.push(onTimeUpdate.subscribe(this.onLoadedMetadata.bind(this)));\n        if (this.onLoadedMetadataCalled) {\n            this.onLoadedMetadata();\n        }\n    }\n    onLoadedMetadata() {\n        if (this.vgCuePoints) {\n            // We need to transform the TextTrackCueList to Array or it doesn't work on IE11/Edge.\n            // See: https://github.com/videogular/videogular2/issues/369\n            this.cuePoints = [];\n            for (let i = 0, l = this.vgCuePoints.length; i < l; i++) {\n                const end = (this.vgCuePoints[i].endTime >= 0) ? this.vgCuePoints[i].endTime : this.vgCuePoints[i].startTime + 1;\n                const cuePointDuration = (end - this.vgCuePoints[i].startTime) * 1000;\n                let position = '0';\n                let percentWidth = '0';\n                if (typeof cuePointDuration === 'number' && this.target.time.total) {\n                    percentWidth = ((cuePointDuration * 100) / this.target.time.total) + '%';\n                    position = (this.vgCuePoints[i].startTime * 100 / (Math.round(this.target.time.total / 1000))) + '%';\n                }\n                this.vgCuePoints[i].$$style = {\n                    width: percentWidth,\n                    left: position\n                };\n                this.cuePoints.push(this.vgCuePoints[i]);\n            }\n        }\n    }\n    updateCuePoints() {\n        if (!this.target) {\n            this.onLoadedMetadataCalled = true;\n            return;\n        }\n        this.onLoadedMetadata();\n    }\n    ngOnChanges(changes) {\n        if (changes['vgCuePoints'].currentValue) {\n            this.updateCuePoints();\n        }\n    }\n    ngDoCheck() {\n        if (this.vgCuePoints) {\n            const changes = this.totalCues !== this.vgCuePoints.length;\n            if (changes) {\n                this.totalCues = this.vgCuePoints.length;\n                this.updateCuePoints();\n            }\n        }\n    }\n    ngOnDestroy() {\n        this.subscriptions.forEach(s => s.unsubscribe());\n    }\n};\nVgScrubBarCuePoints.ctorParameters = () => [\n    { type: ElementRef },\n    { type: VgAPI }\n];\n__decorate([\n    Input()\n], VgScrubBarCuePoints.prototype, \"vgCuePoints\", void 0);\n__decorate([\n    Input()\n], VgScrubBarCuePoints.prototype, \"vgFor\", void 0);\nVgScrubBarCuePoints = __decorate([\n    Component({\n        selector: 'vg-scrub-bar-cue-points',\n        encapsulation: ViewEncapsulation.None,\n        template: `\n        <div class=\"cue-point-container\">\n            <span *ngFor=\"let cp of cuePoints\" [style.width]=\"cp.$$style?.width\" [style.left]=\"cp.$$style?.left\"\n                  class=\"cue-point\"></span>\n        </div>\n    `,\n        styles: [`\n        vg-scrub-bar-cue-points {\n            display: flex;\n            width: 100%;\n            height: 5px;\n            pointer-events: none;\n            position: absolute;\n        }\n        vg-scrub-bar-cue-points .cue-point-container .cue-point {\n            position: absolute;\n            height: 5px;\n            background-color: rgba(255, 204, 0, 0.7);\n        }\n        vg-controls vg-scrub-bar-cue-points {\n            position: absolute;\n            top: calc(50% - 3px);\n        }\n    `]\n    })\n], VgScrubBarCuePoints);\n\n// tslint:disable:component-class-suffix\nlet VgScrubBarCurrentTime = class VgScrubBarCurrentTime {\n    constructor(ref, API) {\n        this.API = API;\n        this.vgSlider = false;\n        this.subscriptions = [];\n        this.elem = ref.nativeElement;\n    }\n    ngOnInit() {\n        if (this.API.isPlayerReady) {\n            this.onPlayerReady();\n        }\n        else {\n            this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n        }\n    }\n    onPlayerReady() {\n        this.target = this.API.getMediaById(this.vgFor);\n    }\n    getPercentage() {\n        return this.target ? ((this.target.time.current * 100) / this.target.time.total) + '%' : '0%';\n    }\n    ngOnDestroy() {\n        this.subscriptions.forEach(s => s.unsubscribe());\n    }\n};\nVgScrubBarCurrentTime.ctorParameters = () => [\n    { type: ElementRef },\n    { type: VgAPI }\n];\n__decorate([\n    Input()\n], VgScrubBarCurrentTime.prototype, \"vgFor\", void 0);\n__decorate([\n    Input()\n], VgScrubBarCurrentTime.prototype, \"vgSlider\", void 0);\nVgScrubBarCurrentTime = __decorate([\n    Component({\n        selector: 'vg-scrub-bar-current-time',\n        encapsulation: ViewEncapsulation.None,\n        template: `<div class=\"background\" [style.width]=\"getPercentage()\"></div><span class=\"slider\" *ngIf=\"vgSlider\"></span>`,\n        styles: [`\n        vg-scrub-bar-current-time {\n            display: flex;\n            width: 100%;\n            height: 5px;\n            pointer-events: none;\n            position: absolute;\n        }\n        vg-scrub-bar-current-time .background {\n            background-color: white;\n        }\n        vg-controls vg-scrub-bar-current-time {\n            position: absolute;\n            top: calc(50% - 3px);\n            -webkit-border-radius: 2px;\n            -moz-border-radius: 2px;\n            border-radius: 2px;\n        }\n        vg-controls vg-scrub-bar-current-time .background {\n            border: 1px solid white;\n            -webkit-border-radius: 2px;\n            -moz-border-radius: 2px;\n            border-radius: 2px;\n        }\n\n        vg-scrub-bar-current-time .slider{\n            background: white;\n            height: 15px;\n            width: 15px;\n            border-radius: 50%;\n            box-shadow: 0px 0px 10px black;\n            margin-top: -5px;\n            margin-left: -10px;\n        }\n    `]\n    })\n], VgScrubBarCurrentTime);\n\n// Workaround until we can use UTC with Angular Date Pipe\nlet VgUtcPipe = class VgUtcPipe {\n    transform(value, format) {\n        const date = new Date(value);\n        let result = format;\n        let ss = date.getUTCSeconds();\n        let mm = date.getUTCMinutes();\n        let hh = date.getUTCHours();\n        if (ss < 10) {\n            ss = '0' + ss;\n        }\n        if (mm < 10) {\n            mm = '0' + mm;\n        }\n        if (hh < 10) {\n            hh = '0' + hh;\n        }\n        result = result.replace(/ss/g, ss);\n        result = result.replace(/mm/g, mm);\n        result = result.replace(/hh/g, hh);\n        return result;\n    }\n};\nVgUtcPipe = __decorate([\n    Pipe({ name: 'vgUtc' })\n], VgUtcPipe);\n// tslint:disable:component-class-suffix\nlet VgTimeDisplay = class VgTimeDisplay {\n    constructor(ref, API) {\n        this.API = API;\n        this.vgProperty = 'current';\n        this.vgFormat = 'mm:ss';\n        this.subscriptions = [];\n        this.elem = ref.nativeElement;\n    }\n    ngOnInit() {\n        if (this.API.isPlayerReady) {\n            this.onPlayerReady();\n        }\n        else {\n            this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n        }\n    }\n    onPlayerReady() {\n        this.target = this.API.getMediaById(this.vgFor);\n    }\n    getTime() {\n        let t = 0;\n        if (this.target) {\n            t = Math.round(this.target.time[this.vgProperty]);\n            t = isNaN(t) || this.target.isLive ? 0 : t;\n        }\n        return t;\n    }\n    ngOnDestroy() {\n        this.subscriptions.forEach(s => s.unsubscribe());\n    }\n};\nVgTimeDisplay.ctorParameters = () => [\n    { type: ElementRef },\n    { type: VgAPI }\n];\n__decorate([\n    Input()\n], VgTimeDisplay.prototype, \"vgFor\", void 0);\n__decorate([\n    Input()\n], VgTimeDisplay.prototype, \"vgProperty\", void 0);\n__decorate([\n    Input()\n], VgTimeDisplay.prototype, \"vgFormat\", void 0);\nVgTimeDisplay = __decorate([\n    Component({\n        selector: 'vg-time-display',\n        encapsulation: ViewEncapsulation.None,\n        template: `\n        <span *ngIf=\"target?.isLive\">LIVE</span>\n        <span *ngIf=\"!target?.isLive\">{{ getTime() | vgUtc:vgFormat }}</span>\n        <ng-content></ng-content>\n    `,\n        styles: [`\n        vg-time-display {\n            -webkit-touch-callout: none;\n            -webkit-user-select: none;\n            -moz-user-select: none;\n            -ms-user-select: none;\n            user-select: none;\n            display: flex;\n            justify-content: center;\n            height: 50px;\n            width: 60px;\n            cursor: pointer;\n            color: white;\n            line-height: 50px;\n            pointer-events: none;\n            font-family: Helvetica Neue, Helvetica, Arial, sans-serif;\n        }\n    `]\n    })\n], VgTimeDisplay);\n\n// tslint:disable:component-class-suffix\nlet VgTrackSelector = class VgTrackSelector {\n    constructor(ref, API) {\n        this.API = API;\n        this.subscriptions = [];\n        this.elem = ref.nativeElement;\n    }\n    ngOnInit() {\n        if (this.API.isPlayerReady) {\n            this.onPlayerReady();\n        }\n        else {\n            this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n        }\n    }\n    onPlayerReady() {\n        this.target = this.API.getMediaById(this.vgFor);\n        const subs = Array.from(this.API.getMasterMedia().elem.children)\n            .filter((item) => item.tagName === 'TRACK')\n            .filter((item) => item.kind === 'subtitles')\n            .map((item) => ({\n            label: item.label,\n            selected: item.default === true,\n            id: item.srclang\n        }));\n        this.tracks = [\n            ...subs,\n            {\n                id: null,\n                label: 'Off',\n                selected: subs.every((item) => item.selected === false)\n            }\n        ];\n        const track = this.tracks.filter((item) => item.selected === true)[0];\n        this.trackSelected = track.id;\n        this.ariaValue = track.label;\n    }\n    selectTrack(trackId) {\n        this.trackSelected = (trackId === 'null') ? null : trackId;\n        this.ariaValue = 'No track selected';\n        Array.from(this.API.getMasterMedia().elem.textTracks)\n            .forEach((item) => {\n            if (item.language === trackId) {\n                this.ariaValue = item.label;\n                item.mode = 'showing';\n            }\n            else {\n                item.mode = 'hidden';\n            }\n        });\n    }\n    ngOnDestroy() {\n        this.subscriptions.forEach(s => s.unsubscribe());\n    }\n};\nVgTrackSelector.ctorParameters = () => [\n    { type: ElementRef },\n    { type: VgAPI }\n];\n__decorate([\n    Input()\n], VgTrackSelector.prototype, \"vgFor\", void 0);\nVgTrackSelector = __decorate([\n    Component({\n        selector: 'vg-track-selector',\n        encapsulation: ViewEncapsulation.None,\n        template: `\n        <div class=\"container\">\n            <div class=\"track-selected\"\n                [class.vg-icon-closed_caption]=\"!trackSelected\">\n                {{ trackSelected || '' }}\n            </div>\n\n            <select class=\"trackSelector\"\n                    (change)=\"selectTrack($event.target.value)\"\n                    tabindex=\"0\"\n                    aria-label=\"track selector\"\n                    [attr.aria-valuetext]=\"ariaValue\">\n                <option\n                    *ngFor=\"let track of tracks\"\n                    [value]=\"track.id\"\n                    [selected]=\"track.selected === true\">\n                    {{ track.label }}\n                </option>\n            </select>\n        </div>\n    `,\n        styles: [`\n        vg-track-selector {\n            -webkit-touch-callout: none;\n            -webkit-user-select: none;\n            -moz-user-select: none;\n            -ms-user-select: none;\n            user-select: none;\n            display: flex;\n            justify-content: center;\n            width: 50px;\n            height: 50px;\n            cursor: pointer;\n            color: white;\n            line-height: 50px;\n        }\n        vg-track-selector .container {\n            position: relative;\n            display: flex;\n            flex-grow: 1;\n            align-items: center;\n\n            padding: 0;\n            margin: 5px;\n        }\n        vg-track-selector select.trackSelector {\n            width: 50px;\n            padding: 5px 8px;\n            border: none;\n            background: none;\n            -webkit-appearance: none;\n            -moz-appearance: none;\n            appearance: none;\n            color: transparent;\n            font-size: 16px;\n        }\n        vg-track-selector select.trackSelector::-ms-expand {\n            display: none;\n        }\n        vg-track-selector select.trackSelector option {\n            color: #000;\n        }\n        vg-track-selector .track-selected {\n            position: absolute;\n            width: 100%;\n            height: 50px;\n            top: -6px;\n            text-align: center;\n            text-transform: uppercase;\n            font-family: Helvetica Neue, Helvetica, Arial, sans-serif;\n            padding-top: 2px;\n            pointer-events: none;\n        }\n        vg-track-selector .vg-icon-closed_caption:before {\n            width: 100%;\n        }\n    `]\n    })\n], VgTrackSelector);\n\n// tslint:disable:no-output-on-prefix\n// tslint:disable:component-class-suffix\n// tslint:disable:no-string-literal\nlet VgQualitySelector = class VgQualitySelector {\n    constructor(ref, API) {\n        this.API = API;\n        this.onBitrateChange = new EventEmitter();\n        this.subscriptions = [];\n        this.elem = ref.nativeElement;\n    }\n    ngOnInit() {\n    }\n    ngOnChanges(changes) {\n        if (changes['bitrates'].currentValue && changes['bitrates'].currentValue.length) {\n            this.bitrates.forEach(item => item.label = (item.label || Math.round(item.bitrate / 1000)).toString());\n        }\n    }\n    selectBitrate(index) {\n        this.bitrateSelected = this.bitrates[index];\n        this.onBitrateChange.emit(this.bitrates[index]);\n    }\n    ngOnDestroy() {\n        this.subscriptions.forEach(s => s.unsubscribe());\n    }\n};\nVgQualitySelector.ctorParameters = () => [\n    { type: ElementRef },\n    { type: VgAPI }\n];\n__decorate([\n    Input()\n], VgQualitySelector.prototype, \"bitrates\", void 0);\n__decorate([\n    Output()\n], VgQualitySelector.prototype, \"onBitrateChange\", void 0);\nVgQualitySelector = __decorate([\n    Component({\n        selector: 'vg-quality-selector',\n        encapsulation: ViewEncapsulation.None,\n        template: `\n        <div class=\"container\">\n            <div class=\"quality-selected\"\n                 [class.vg-icon-hd]=\"!bitrateSelected\">\n                {{ bitrateSelected?.label }}\n            </div>\n\n            <select class=\"quality-selector\"\n                    (change)=\"selectBitrate($event.target.value)\"\n                    tabindex=\"0\"\n                    aria-label=\"quality selector\"\n                    [attr.aria-valuetext]=\"ariaValue\">\n                <option\n                    *ngFor=\"let bitrate of bitrates\"\n                    [value]=\"bitrate.qualityIndex.toString()\"\n                    [selected]=\"bitrate.qualityIndex === bitrateSelected?.qualityIndex\">\n                    {{ bitrate.label }}\n                </option>\n            </select>\n        </div>\n    `,\n        styles: [`\n        vg-quality-selector {\n            -webkit-touch-callout: none;\n            -webkit-user-select: none;\n            -moz-user-select: none;\n            -ms-user-select: none;\n            user-select: none;\n            display: flex;\n            justify-content: center;\n            width: 50px;\n            height: 50px;\n            cursor: pointer;\n            color: white;\n            line-height: 50px;\n        }\n        vg-quality-selector .container {\n            position: relative;\n            display: flex;\n            flex-grow: 1;\n            align-items: center;\n\n            padding: 0;\n            margin: 5px;\n        }\n        vg-quality-selector select.quality-selector {\n            width: 50px;\n            padding: 5px 8px;\n            border: none;\n            background: none;\n            -webkit-appearance: none;\n            -moz-appearance: none;\n            appearance: none;\n            color: transparent;\n            font-size: 16px;\n        }\n        vg-quality-selector select.quality-selector::-ms-expand {\n            display: none;\n        }\n        vg-quality-selector select.quality-selector option {\n            color: #000;\n        }\n        vg-quality-selector .quality-selected {\n            position: absolute;\n            width: 100%;\n            height: 50px;\n            top: -6px;\n            text-align: center;\n            text-transform: uppercase;\n            font-family: Helvetica Neue, Helvetica, Arial, sans-serif;\n            padding-top: 2px;\n            pointer-events: none;\n        }\n        vg-quality-selector .vg-icon-closed_caption:before {\n            width: 100%;\n        }\n    `]\n    })\n], VgQualitySelector);\n\nlet VgControlsModule = class VgControlsModule {\n};\nVgControlsModule = __decorate([\n    NgModule({\n        imports: [CommonModule],\n        declarations: [\n            VgControls,\n            VgFullscreen,\n            VgMute,\n            VgVolume,\n            VgPlayPause,\n            VgPlaybackButton,\n            VgScrubBar,\n            VgScrubBarBufferingTime,\n            VgScrubBarCuePoints,\n            VgScrubBarCurrentTime,\n            VgTimeDisplay,\n            VgUtcPipe,\n            VgTrackSelector,\n            VgQualitySelector\n        ],\n        exports: [\n            VgControls,\n            VgFullscreen,\n            VgMute,\n            VgVolume,\n            VgPlayPause,\n            VgPlaybackButton,\n            VgScrubBar,\n            VgScrubBarBufferingTime,\n            VgScrubBarCuePoints,\n            VgScrubBarCurrentTime,\n            VgTimeDisplay,\n            VgUtcPipe,\n            VgTrackSelector,\n            VgQualitySelector\n        ],\n        providers: [VgControlsHidden]\n    })\n], VgControlsModule);\n\nlet VgEvents = class VgEvents {\n};\nVgEvents.VG_ABORT = 'abort';\nVgEvents.VG_CAN_PLAY = 'canplay';\nVgEvents.VG_CAN_PLAY_THROUGH = 'canplaythrough';\nVgEvents.VG_DURATION_CHANGE = 'durationchange';\nVgEvents.VG_EMPTIED = 'emptied';\nVgEvents.VG_ENCRYPTED = 'encrypted';\nVgEvents.VG_ENDED = 'ended';\nVgEvents.VG_ERROR = 'error';\nVgEvents.VG_LOADED_DATA = 'loadeddata';\nVgEvents.VG_LOADED_METADATA = 'loadedmetadata';\nVgEvents.VG_LOAD_START = 'loadstart';\nVgEvents.VG_PAUSE = 'pause';\nVgEvents.VG_PLAY = 'play';\nVgEvents.VG_PLAYING = 'playing';\nVgEvents.VG_PROGRESS = 'progress';\nVgEvents.VG_RATE_CHANGE = 'ratechange';\nVgEvents.VG_SEEK = 'seek';\nVgEvents.VG_SEEKED = 'seeked';\nVgEvents.VG_SEEKING = 'seeking';\nVgEvents.VG_STALLED = 'stalled';\nVgEvents.VG_SUSPEND = 'suspend';\nVgEvents.VG_TIME_UPDATE = 'timeupdate';\nVgEvents.VG_VOLUME_CHANGE = 'volumechange';\nVgEvents.VG_WAITING = 'waiting';\nVgEvents.VG_LOAD = 'load';\nVgEvents.VG_ENTER = 'enter';\nVgEvents.VG_EXIT = 'exit';\nVgEvents.VG_START_ADS = 'startads';\nVgEvents.VG_END_ADS = 'endads';\nVgEvents = __decorate([\n    Injectable()\n], VgEvents);\n\nlet VgMedia = \n// tslint:disable-next-line:directive-class-suffix\nclass VgMedia {\n    constructor(api, ref) {\n        this.api = api;\n        this.ref = ref;\n        this.state = VgStates.VG_PAUSED;\n        this.time = { current: 0, total: 0, left: 0 };\n        this.buffer = { end: 0 };\n        this.canPlay = false;\n        this.canPlayThrough = false;\n        this.isMetadataLoaded = false;\n        this.isWaiting = false;\n        this.isCompleted = false;\n        this.isLive = false;\n        this.isBufferDetected = false;\n        this.checkInterval = 200;\n        this.currentPlayPos = 0;\n        this.lastPlayPos = 0;\n        this.playAtferSync = false;\n        this.bufferDetected = new Subject();\n    }\n    ngOnInit() {\n        if (this.vgMedia.nodeName) {\n            // It's a native element\n            this.elem = this.vgMedia;\n        }\n        else {\n            // It's an Angular Class\n            this.elem = this.vgMedia.elem;\n        }\n        // Just in case we're creating this vgMedia dynamically register again into API\n        this.api.registerMedia(this);\n        this.subscriptions = {\n            // Native events\n            abort: fromEvent(this.elem, VgEvents.VG_ABORT),\n            canPlay: fromEvent(this.elem, VgEvents.VG_CAN_PLAY),\n            canPlayThrough: fromEvent(this.elem, VgEvents.VG_CAN_PLAY_THROUGH),\n            durationChange: fromEvent(this.elem, VgEvents.VG_DURATION_CHANGE),\n            emptied: fromEvent(this.elem, VgEvents.VG_EMPTIED),\n            encrypted: fromEvent(this.elem, VgEvents.VG_ENCRYPTED),\n            ended: fromEvent(this.elem, VgEvents.VG_ENDED),\n            error: fromEvent(this.elem, VgEvents.VG_ERROR),\n            loadedData: fromEvent(this.elem, VgEvents.VG_LOADED_DATA),\n            loadedMetadata: fromEvent(this.elem, VgEvents.VG_LOADED_METADATA),\n            loadStart: fromEvent(this.elem, VgEvents.VG_LOAD_START),\n            pause: fromEvent(this.elem, VgEvents.VG_PAUSE),\n            play: fromEvent(this.elem, VgEvents.VG_PLAY),\n            playing: fromEvent(this.elem, VgEvents.VG_PLAYING),\n            progress: fromEvent(this.elem, VgEvents.VG_PROGRESS),\n            rateChange: fromEvent(this.elem, VgEvents.VG_RATE_CHANGE),\n            seeked: fromEvent(this.elem, VgEvents.VG_SEEKED),\n            seeking: fromEvent(this.elem, VgEvents.VG_SEEKING),\n            stalled: fromEvent(this.elem, VgEvents.VG_STALLED),\n            suspend: fromEvent(this.elem, VgEvents.VG_SUSPEND),\n            timeUpdate: fromEvent(this.elem, VgEvents.VG_TIME_UPDATE),\n            volumeChange: fromEvent(this.elem, VgEvents.VG_VOLUME_CHANGE),\n            waiting: fromEvent(this.elem, VgEvents.VG_WAITING),\n            // Advertisement only events\n            startAds: fromEvent(this.elem, VgEvents.VG_START_ADS),\n            endAds: fromEvent(this.elem, VgEvents.VG_END_ADS),\n            // See changes on <source> child elements to reload the video file\n            mutation: new Observable((observer) => {\n                const domObs = new MutationObserver((mutations) => {\n                    observer.next(mutations);\n                });\n                domObs.observe(this.elem, { childList: true, attributes: true });\n                return () => {\n                    domObs.disconnect();\n                };\n            }),\n            // Custom buffering detection\n            bufferDetected: this.bufferDetected\n        };\n        this.mutationObs = this.subscriptions.mutation.subscribe(this.onMutation.bind(this));\n        this.canPlayObs = this.subscriptions.canPlay.subscribe(this.onCanPlay.bind(this));\n        this.canPlayThroughObs = this.subscriptions.canPlayThrough.subscribe(this.onCanPlayThrough.bind(this));\n        this.loadedMetadataObs = this.subscriptions.loadedMetadata.subscribe(this.onLoadMetadata.bind(this));\n        this.waitingObs = this.subscriptions.waiting.subscribe(this.onWait.bind(this));\n        this.progressObs = this.subscriptions.progress.subscribe(this.onProgress.bind(this));\n        this.endedObs = this.subscriptions.ended.subscribe(this.onComplete.bind(this));\n        this.playingObs = this.subscriptions.playing.subscribe(this.onStartPlaying.bind(this));\n        this.playObs = this.subscriptions.play.subscribe(this.onPlay.bind(this));\n        this.pauseObs = this.subscriptions.pause.subscribe(this.onPause.bind(this));\n        this.timeUpdateObs = this.subscriptions.timeUpdate.subscribe(this.onTimeUpdate.bind(this));\n        this.volumeChangeObs = this.subscriptions.volumeChange.subscribe(this.onVolumeChange.bind(this));\n        this.errorObs = this.subscriptions.error.subscribe(this.onError.bind(this));\n        if (this.vgMaster) {\n            this.api.playerReadyEvent.subscribe(() => {\n                this.prepareSync();\n            });\n        }\n    }\n    prepareSync() {\n        const canPlayAll = [];\n        for (const media in this.api.medias) {\n            if (this.api.medias[media]) {\n                canPlayAll.push(this.api.medias[media].subscriptions.canPlay);\n            }\n        }\n        this.canPlayAllSubscription = combineLatest(canPlayAll).pipe(map((...params) => {\n            const checkReadyState = (event) => {\n                return event.target.readyState === 4;\n            };\n            const allReady = params.some(checkReadyState);\n            if (allReady && !this.syncSubscription) {\n                this.startSync();\n                this.syncSubscription.unsubscribe();\n            }\n        })).subscribe();\n    }\n    startSync() {\n        this.syncSubscription = timer(0, 1000).subscribe(() => {\n            for (const media in this.api.medias) {\n                if (this.api.medias[media] !== this) {\n                    const diff = this.api.medias[media].currentTime - this.currentTime;\n                    if (diff < -0.3 || diff > 0.3) {\n                        this.playAtferSync = (this.state === VgStates.VG_PLAYING);\n                        this.pause();\n                        this.api.medias[media].pause();\n                        this.api.medias[media].currentTime = this.currentTime;\n                    }\n                    else {\n                        if (this.playAtferSync) {\n                            this.play();\n                            this.api.medias[media].play();\n                            this.playAtferSync = false;\n                        }\n                    }\n                }\n            }\n        });\n    }\n    onMutation(mutations) {\n        // Detect changes only for source elements or src attribute\n        for (let i = 0, l = mutations.length; i < l; i++) {\n            const mut = mutations[i];\n            if (mut.type === 'attributes' && mut.attributeName === 'src') {\n                // Only load src file if it's not a blob (for DASH / HLS sources)\n                // tslint:disable-next-line:no-string-literal\n                if (mut.target['src'] && mut.target['src'].length > 0 && mut.target['src'].indexOf('blob:') < 0) {\n                    this.loadMedia();\n                    break;\n                }\n            }\n            else if (mut.type === 'childList' && mut.removedNodes.length && mut.removedNodes[0].nodeName.toLowerCase() === 'source') {\n                this.loadMedia();\n                break;\n            }\n        }\n    }\n    loadMedia() {\n        this.vgMedia.pause();\n        this.vgMedia.currentTime = 0;\n        // Start buffering until we can play the media file\n        this.stopBufferCheck();\n        this.isBufferDetected = true;\n        this.bufferDetected.next(this.isBufferDetected);\n        // TODO: This is ugly, we should find something cleaner. For some reason a TimerObservable doesn't works.\n        setTimeout(() => this.vgMedia.load(), 10);\n    }\n    play() {\n        // short-circuit if already playing\n        if (this.playPromise || (this.state !== VgStates.VG_PAUSED && this.state !== VgStates.VG_ENDED)) {\n            return;\n        }\n        this.playPromise = this.vgMedia.play();\n        // browser has async play promise\n        if (this.playPromise && this.playPromise.then && this.playPromise.catch) {\n            this.playPromise\n                .then(() => {\n                this.playPromise = null;\n            })\n                .catch(() => {\n                this.playPromise = null;\n                // deliberately empty for the sake of eating console noise\n            });\n        }\n        return this.playPromise;\n    }\n    pause() {\n        // browser has async play promise\n        if (this.playPromise) {\n            this.playPromise\n                .then(() => {\n                this.vgMedia.pause();\n            });\n        }\n        else {\n            this.vgMedia.pause();\n        }\n    }\n    get id() {\n        // We should return undefined if vgMedia still doesn't exist\n        // tslint:disable-next-line:no-unnecessary-initializer\n        let result = undefined;\n        if (this.vgMedia) {\n            result = this.vgMedia.id;\n        }\n        return result;\n    }\n    get duration() {\n        return this.vgMedia.duration;\n    }\n    set currentTime(seconds) {\n        this.vgMedia.currentTime = seconds;\n        // this.elem.dispatchEvent(new CustomEvent(VgEvents.VG_SEEK));\n    }\n    get currentTime() {\n        return this.vgMedia.currentTime;\n    }\n    set volume(volume) {\n        this.vgMedia.volume = volume;\n    }\n    get volume() {\n        return this.vgMedia.volume;\n    }\n    set playbackRate(rate) {\n        this.vgMedia.playbackRate = rate;\n    }\n    get playbackRate() {\n        return this.vgMedia.playbackRate;\n    }\n    get buffered() {\n        return this.vgMedia.buffered;\n    }\n    get textTracks() {\n        return this.vgMedia.textTracks;\n    }\n    // @ts-ignore\n    onCanPlay(event) {\n        this.isBufferDetected = false;\n        this.bufferDetected.next(this.isBufferDetected);\n        this.canPlay = true;\n        this.ref.detectChanges();\n    }\n    // @ts-ignore\n    onCanPlayThrough(event) {\n        this.isBufferDetected = false;\n        this.bufferDetected.next(this.isBufferDetected);\n        this.canPlayThrough = true;\n        this.ref.detectChanges();\n    }\n    // @ts-ignore\n    onLoadMetadata(event) {\n        this.isMetadataLoaded = true;\n        this.time = {\n            current: 0,\n            left: 0,\n            total: this.duration * 1000\n        };\n        this.state = VgStates.VG_PAUSED;\n        // Live streaming check\n        const t = Math.round(this.time.total);\n        this.isLive = (t === Infinity);\n        this.ref.detectChanges();\n    }\n    // @ts-ignore\n    onWait(event) {\n        this.isWaiting = true;\n        this.ref.detectChanges();\n    }\n    // @ts-ignore\n    onComplete(event) {\n        this.isCompleted = true;\n        this.state = VgStates.VG_ENDED;\n        this.ref.detectChanges();\n    }\n    // @ts-ignore\n    onStartPlaying(event) {\n        this.state = VgStates.VG_PLAYING;\n        this.ref.detectChanges();\n    }\n    // @ts-ignore\n    onPlay(event) {\n        this.state = VgStates.VG_PLAYING;\n        if (this.vgMaster) {\n            if (!this.syncSubscription || this.syncSubscription.closed) {\n                this.startSync();\n            }\n        }\n        this.startBufferCheck();\n        this.ref.detectChanges();\n    }\n    // @ts-ignore\n    onPause(event) {\n        this.state = VgStates.VG_PAUSED;\n        if (this.vgMaster) {\n            if (!this.playAtferSync) {\n                this.syncSubscription.unsubscribe();\n            }\n        }\n        this.stopBufferCheck();\n        this.ref.detectChanges();\n    }\n    // @ts-ignore\n    onTimeUpdate(event) {\n        const end = this.buffered.length - 1;\n        this.time = {\n            current: this.currentTime * 1000,\n            total: this.time.total,\n            left: (this.duration - this.currentTime) * 1000\n        };\n        if (end >= 0) {\n            this.buffer = { end: this.buffered.end(end) * 1000 };\n        }\n        this.ref.detectChanges();\n    }\n    // @ts-ignore\n    onProgress(event) {\n        const end = this.buffered.length - 1;\n        if (end >= 0) {\n            this.buffer = { end: this.buffered.end(end) * 1000 };\n        }\n        this.ref.detectChanges();\n    }\n    // @ts-ignore\n    onVolumeChange(event) {\n        // TODO: Save to localstorage the current volume\n        this.ref.detectChanges();\n    }\n    // @ts-ignore\n    onError(event) {\n        // TODO: Handle error messages\n        this.ref.detectChanges();\n    }\n    // http://stackoverflow.com/a/23828241/779529\n    bufferCheck() {\n        const offset = 1 / this.checkInterval;\n        this.currentPlayPos = this.currentTime;\n        if (!this.isBufferDetected && this.currentPlayPos < (this.lastPlayPos + offset)) {\n            this.isBufferDetected = true;\n        }\n        if (this.isBufferDetected && this.currentPlayPos > (this.lastPlayPos + offset)) {\n            this.isBufferDetected = false;\n        }\n        // Prevent calls to bufferCheck after ngOnDestroy have been called\n        if (!this.bufferDetected.closed) {\n            this.bufferDetected.next(this.isBufferDetected);\n        }\n        this.lastPlayPos = this.currentPlayPos;\n    }\n    startBufferCheck() {\n        this.checkBufferSubscription = timer(0, this.checkInterval).subscribe(() => {\n            this.bufferCheck();\n        });\n    }\n    stopBufferCheck() {\n        if (this.checkBufferSubscription) {\n            this.checkBufferSubscription.unsubscribe();\n        }\n        this.isBufferDetected = false;\n        this.bufferDetected.next(this.isBufferDetected);\n    }\n    seekTime(value, byPercent = false) {\n        let second;\n        const duration = this.duration;\n        if (byPercent) {\n            second = value * duration / 100;\n        }\n        else {\n            second = value;\n        }\n        this.currentTime = second;\n    }\n    addTextTrack(type, label, language, mode) {\n        const newTrack = this.vgMedia.addTextTrack(type, label, language);\n        if (mode) {\n            newTrack.mode = mode;\n        }\n        return newTrack;\n    }\n    ngOnDestroy() {\n        this.vgMedia.src = '';\n        this.mutationObs.unsubscribe();\n        this.canPlayObs.unsubscribe();\n        this.canPlayThroughObs.unsubscribe();\n        this.loadedMetadataObs.unsubscribe();\n        this.waitingObs.unsubscribe();\n        this.progressObs.unsubscribe();\n        this.endedObs.unsubscribe();\n        this.playingObs.unsubscribe();\n        this.playObs.unsubscribe();\n        this.pauseObs.unsubscribe();\n        this.timeUpdateObs.unsubscribe();\n        this.volumeChangeObs.unsubscribe();\n        this.errorObs.unsubscribe();\n        if (this.checkBufferSubscription) {\n            this.checkBufferSubscription.unsubscribe();\n        }\n        if (this.syncSubscription) {\n            this.syncSubscription.unsubscribe();\n        }\n        this.bufferDetected.complete();\n        this.bufferDetected.unsubscribe();\n        this.api.unregisterMedia(this);\n    }\n};\nVgMedia.ctorParameters = () => [\n    { type: VgAPI },\n    { type: ChangeDetectorRef }\n];\n__decorate([\n    Input()\n], VgMedia.prototype, \"vgMedia\", void 0);\n__decorate([\n    Input()\n], VgMedia.prototype, \"vgMaster\", void 0);\nVgMedia = __decorate([\n    Directive({\n        selector: '[vgMedia]'\n    })\n    // tslint:disable-next-line:directive-class-suffix\n], VgMedia);\n\nlet VgCuePoints = \n// tslint:disable-next-line:directive-class-suffix\nclass VgCuePoints {\n    constructor(ref) {\n        this.ref = ref;\n        // tslint:disable:no-output-on-prefix\n        this.onEnterCuePoint = new EventEmitter();\n        this.onUpdateCuePoint = new EventEmitter();\n        this.onExitCuePoint = new EventEmitter();\n        this.onCompleteCuePoint = new EventEmitter();\n        this.subscriptions = [];\n        this.cuesSubscriptions = [];\n        this.totalCues = 0;\n    }\n    ngOnInit() {\n        this.onLoad$ = fromEvent(this.ref.nativeElement, VgEvents.VG_LOAD);\n        this.subscriptions.push(this.onLoad$.subscribe(this.onLoad.bind(this)));\n    }\n    onLoad(event) {\n        if (event.target && event.target.track) {\n            const cues = event.target.track.cues;\n            this.ref.nativeElement.cues = cues;\n            this.updateCuePoints(cues);\n        }\n        else if (event.target && event.target.textTracks && event.target.textTracks.length) {\n            const cues = event.target.textTracks[0].cues;\n            this.ref.nativeElement.cues = cues;\n            this.updateCuePoints(cues);\n        }\n    }\n    updateCuePoints(cues) {\n        this.cuesSubscriptions.forEach(s => s.unsubscribe());\n        for (let i = 0, l = cues.length; i < l; i++) {\n            this.onEnter$ = fromEvent(cues[i], VgEvents.VG_ENTER);\n            this.cuesSubscriptions.push(this.onEnter$.subscribe(this.onEnter.bind(this)));\n            this.onExit$ = fromEvent(cues[i], VgEvents.VG_EXIT);\n            this.cuesSubscriptions.push(this.onExit$.subscribe(this.onExit.bind(this)));\n        }\n    }\n    onEnter(event) {\n        this.onEnterCuePoint.emit(event.target);\n    }\n    onExit(event) {\n        this.onExitCuePoint.emit(event.target);\n    }\n    ngDoCheck() {\n        if (this.ref.nativeElement.track && this.ref.nativeElement.track.cues) {\n            const changes = this.totalCues !== this.ref.nativeElement.track.cues.length;\n            if (changes) {\n                this.totalCues = this.ref.nativeElement.track.cues.length;\n                this.ref.nativeElement.cues = this.ref.nativeElement.track.cues;\n                this.updateCuePoints(this.ref.nativeElement.track.cues);\n            }\n        }\n    }\n    ngOnDestroy() {\n        this.subscriptions.forEach(s => s.unsubscribe());\n    }\n};\nVgCuePoints.ctorParameters = () => [\n    { type: ElementRef }\n];\n__decorate([\n    Output()\n], VgCuePoints.prototype, \"onEnterCuePoint\", void 0);\n__decorate([\n    Output()\n], VgCuePoints.prototype, \"onUpdateCuePoint\", void 0);\n__decorate([\n    Output()\n], VgCuePoints.prototype, \"onExitCuePoint\", void 0);\n__decorate([\n    Output()\n], VgCuePoints.prototype, \"onCompleteCuePoint\", void 0);\nVgCuePoints = __decorate([\n    Directive({\n        selector: '[vgCuePoints]'\n    })\n    // tslint:disable-next-line:directive-class-suffix\n], VgCuePoints);\n\nlet VgPlayer = \n// tslint:disable:component-class-suffix\n// tslint:disable:no-output-on-prefix\nclass VgPlayer {\n    constructor(ref, api, fsAPI, controlsHidden) {\n        this.api = api;\n        this.fsAPI = fsAPI;\n        this.controlsHidden = controlsHidden;\n        this.isFullscreen = false;\n        this.isNativeFullscreen = false;\n        this.areControlsHidden = false;\n        this.onPlayerReady = new EventEmitter();\n        this.onMediaReady = new EventEmitter();\n        this.subscriptions = [];\n        this.elem = ref.nativeElement;\n        this.api.registerElement(this.elem);\n    }\n    ngAfterContentInit() {\n        this.medias.toArray().forEach((media) => {\n            this.api.registerMedia(media);\n        });\n        this.fsAPI.init(this.elem, this.medias);\n        this.subscriptions.push(this.fsAPI.onChangeFullscreen.subscribe(this.onChangeFullscreen.bind(this)));\n        this.subscriptions.push(this.controlsHidden.isHidden.subscribe(this.onHideControls.bind(this)));\n        this.api.onPlayerReady(this.fsAPI);\n        this.onPlayerReady.emit(this.api);\n    }\n    onChangeFullscreen(fsState) {\n        if (!this.fsAPI.nativeFullscreen) {\n            this.isFullscreen = fsState;\n            this.zIndex = fsState ? VgUtils.getZIndex().toString() : 'auto';\n        }\n        else {\n            this.isNativeFullscreen = fsState;\n        }\n    }\n    onHideControls(hidden) {\n        this.areControlsHidden = hidden;\n    }\n    ngOnDestroy() {\n        this.subscriptions.forEach(s => s.unsubscribe());\n    }\n};\nVgPlayer.ctorParameters = () => [\n    { type: ElementRef },\n    { type: VgAPI },\n    { type: VgFullscreenAPI },\n    { type: VgControlsHidden }\n];\n__decorate([\n    HostBinding('class.fullscreen')\n], VgPlayer.prototype, \"isFullscreen\", void 0);\n__decorate([\n    HostBinding('class.native-fullscreen')\n], VgPlayer.prototype, \"isNativeFullscreen\", void 0);\n__decorate([\n    HostBinding('class.controls-hidden')\n], VgPlayer.prototype, \"areControlsHidden\", void 0);\n__decorate([\n    HostBinding('style.z-index')\n], VgPlayer.prototype, \"zIndex\", void 0);\n__decorate([\n    Output()\n], VgPlayer.prototype, \"onPlayerReady\", void 0);\n__decorate([\n    Output()\n], VgPlayer.prototype, \"onMediaReady\", void 0);\n__decorate([\n    ContentChildren(VgMedia)\n], VgPlayer.prototype, \"medias\", void 0);\nVgPlayer = __decorate([\n    Component({\n        selector: 'vg-player',\n        encapsulation: ViewEncapsulation.None,\n        template: `<ng-content></ng-content>`,\n        providers: [VgAPI, VgFullscreenAPI, VgControlsHidden],\n        styles: [`\n        vg-player {\n            font-family: 'videogular';\n            position: relative;\n            display: flex;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n            background-color: black;\n        }\n        vg-player.fullscreen {\n            position: fixed;\n            left: 0;\n            top: 0;\n        }\n        vg-player.native-fullscreen.controls-hidden {\n            cursor: none;\n        }\n    `]\n    })\n    // tslint:disable:component-class-suffix\n    // tslint:disable:no-output-on-prefix\n], VgPlayer);\n\nclass VgMediaElement {\n    get audioTracks() { return null; }\n    // @ts-ignore\n    addTextTrack(kind, label, language) {\n        return null;\n    }\n    // @ts-ignore\n    canPlayType(type) {\n        return null;\n    }\n    load() {\n    }\n    msClearEffects() {\n    }\n    msGetAsCastingSource() {\n        return null;\n    }\n    // @ts-ignore\n    msInsertAudioEffect(activatableClassId, effectRequired, config) {\n    }\n    // @ts-ignore\n    msSetMediaKeys(mediaKeys) {\n    }\n    // @ts-ignore\n    msSetMediaProtectionManager(mediaProtectionManager) {\n    }\n    pause() {\n    }\n    play() {\n        return null;\n    }\n    // @ts-ignore\n    setMediaKeys(mediaKeys) {\n        return null;\n    }\n    // @ts-ignore\n    addEventListener(type, listener, useCapture) {\n    }\n}\n\nlet VgCoreModule = class VgCoreModule {\n};\nVgCoreModule = __decorate([\n    NgModule({\n        declarations: [VgMedia, VgCuePoints, VgPlayer],\n        exports: [VgMedia, VgCuePoints, VgPlayer],\n        providers: [VgAPI, VgFullscreenAPI, VgUtils, VgControlsHidden, VgStates, VgEvents]\n    })\n], VgCoreModule);\n\n// tslint:disable:no-output-on-prefix\n// tslint:disable:ban-types\n// tslint:disable:component-class-suffix\nlet VgImaAds = class VgImaAds {\n    constructor(ref, API, fsAPI) {\n        this.API = API;\n        this.fsAPI = fsAPI;\n        this.onAdStart = new EventEmitter();\n        this.onAdStop = new EventEmitter();\n        this.onSkipAd = new EventEmitter();\n        this.isFullscreen = false;\n        this.subscriptions = [];\n        this.displayState = 'none';\n        this.elem = ref.nativeElement;\n        this.onContentEnded = this.onContentEnded.bind(this);\n    }\n    ngOnInit() {\n        if (this.API.isPlayerReady) {\n            this.onPlayerReady();\n        }\n        else {\n            this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n        }\n    }\n    onPlayerReady() {\n        if (typeof google === 'undefined') {\n            this.onMissingGoogleImaLoader();\n            return;\n        }\n        this.target = this.API.getMediaById(this.vgFor);\n        this.initializations();\n        this.subscriptions.push(this.target.subscriptions.ended.subscribe(this.onContentEnded.bind(this)));\n        this.subscriptions.push(this.target.subscriptions.play.subscribe(this.onUpdateState.bind(this)));\n        this.subscriptions.push(this.fsAPI.onChangeFullscreen.subscribe(this.onChangeFullscreen.bind(this)));\n        this.ima.adsLoader.addEventListener(google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, this.onAdsManagerLoaded.bind(this), false);\n        this.ima.adsLoader.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, this.onAdError.bind(this), false);\n        this.loadAds();\n    }\n    initializations() {\n        this.ima = new Ima(this.elem);\n        if (this.vgSkipButton) {\n            this.skipButton = document.querySelector(this.vgSkipButton);\n            this.skipButton.style.display = 'none';\n            this.skipButton.addEventListener('click', this.onClickSkip.bind(this));\n            this.elem.insertBefore(this.skipButton, this.elem.firstChild);\n        }\n        window.addEventListener('resize', () => {\n            const w = this.API.videogularElement.offsetWidth;\n            const h = this.API.videogularElement.offsetHeight;\n            if (this.ima.adsManager) {\n                if (this.isFullscreen) {\n                    this.ima.adsManager.resize(w, h, google.ima.ViewMode.FULLSCREEN);\n                }\n                else {\n                    this.ima.adsManager.resize(w, h, google.ima.ViewMode.NORMAL);\n                }\n            }\n        });\n    }\n    loadAds() {\n        if (this.vgCompanion) {\n            googletag.cmd.push(() => {\n                const adUnitPath = '/' + this.vgNetwork + '/' + this.vgUnitPath;\n                const slot = googletag.defineSlot(adUnitPath, this.vgCompanionSize, this.vgCompanion);\n                if (slot) {\n                    slot.addService(googletag.companionAds());\n                    slot.addService(googletag.pubads());\n                    googletag\n                        .companionAds()\n                        .setRefreshUnfilledSlots(true);\n                    googletag\n                        .pubads()\n                        .enableVideoAds();\n                    googletag.enableServices();\n                }\n            });\n        }\n    }\n    onUpdateState(event) {\n        switch (event.type) {\n            case VgEvents.VG_PLAY:\n                if (!this.ima.adsLoaded) {\n                    this.API.pause();\n                    this.ima.adDisplayContainer.initialize();\n                    this.requestAds(this.vgAdTagUrl);\n                    this.ima.adsLoaded = true;\n                }\n                break;\n        }\n    }\n    requestAds(adTagUrl) {\n        // Show only to get computed style in pixels\n        this.show();\n        const adsRequest = new google.ima.AdsRequest();\n        const computedStyle = window.getComputedStyle(this.elem);\n        adsRequest.adTagUrl = adTagUrl;\n        adsRequest.linearAdSlotWidth = parseInt(computedStyle.width, 10);\n        adsRequest.linearAdSlotHeight = parseInt(computedStyle.height, 10);\n        adsRequest.nonLinearAdSlotWidth = parseInt(computedStyle.width, 10);\n        adsRequest.nonLinearAdSlotHeight = parseInt(computedStyle.height, 10);\n        this.ima.adsLoader.requestAds(adsRequest);\n    }\n    onAdsManagerLoaded(evt) {\n        this.show();\n        this.ima.adsManager = evt.getAdsManager(this.target);\n        this.processAdsManager(this.ima.adsManager);\n    }\n    // @ts-ignore\n    processAdsManager(adsManager) {\n        const w = this.API.videogularElement.offsetWidth;\n        const h = this.API.videogularElement.offsetHeight;\n        // Attach the pause/resume events.\n        this.ima.adsManager.addEventListener(google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED, this.onContentPauseRequested.bind(this), false);\n        this.ima.adsManager.addEventListener(google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED, this.onContentResumeRequested.bind(this), false);\n        this.ima.adsManager.addEventListener(google.ima.AdEvent.Type.SKIPPABLE_STATE_CHANGED, this.onSkippableStateChanged.bind(this), false);\n        this.ima.adsManager.addEventListener(google.ima.AdEvent.Type.ALL_ADS_COMPLETED, this.onAllAdsComplete.bind(this), false);\n        this.ima.adsManager.addEventListener(google.ima.AdEvent.Type.COMPLETE, this.onAdComplete.bind(this), false);\n        this.ima.adsManager.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, this.onAdError.bind(this), false);\n        this.ima.adsManager.init(w, h, google.ima.ViewMode.NORMAL);\n        this.ima.adsManager.start();\n    }\n    onSkippableStateChanged() {\n        const isSkippable = this.ima.adsManager.getAdSkippableState();\n        if (isSkippable) {\n            this.skipButton.style.display = 'block';\n        }\n        else {\n            this.skipButton.style.display = 'none';\n        }\n    }\n    onClickSkip() {\n        this.ima.adsManager.skip();\n        this.onSkipAd.emit(true);\n    }\n    onContentPauseRequested() {\n        this.show();\n        this.API.pause();\n        this.onAdStop.emit(true);\n    }\n    onContentResumeRequested() {\n        this.API.play();\n        this.onAdStart.emit(true);\n        this.hide();\n    }\n    // @ts-ignore\n    onAdError(evt) {\n        if (this.ima.adsManager) {\n            this.ima.adsManager.destroy();\n        }\n        this.hide();\n        this.API.play();\n        this.onAdStop.emit(true);\n    }\n    onAllAdsComplete() {\n        this.hide();\n        // The last ad was a post-roll\n        if (this.ima.adsManager.getCuePoints().join().indexOf('-1') >= 0) {\n            this.API.pause(); // it was stop() in Videogular v1\n            this.onAdStop.emit(true);\n        }\n    }\n    onAdComplete() {\n        // TODO: Update view with current ad count\n        this.ima.currentAd++;\n        this.onAdStop.emit(true);\n    }\n    show() {\n        window.dispatchEvent(new CustomEvent(VgEvents.VG_START_ADS));\n        this.displayState = 'block';\n    }\n    hide() {\n        window.dispatchEvent(new CustomEvent(VgEvents.VG_END_ADS));\n        this.displayState = 'none';\n    }\n    onContentEnded() {\n        this.ima.adsLoader.contentComplete();\n        this.onAdStop.emit(true);\n    }\n    onChangeFullscreen(fsState) {\n        if (!this.fsAPI.nativeFullscreen) {\n            this.isFullscreen = fsState;\n        }\n    }\n    onMissingGoogleImaLoader() {\n        this.hide();\n        this.API.play();\n    }\n    ngOnDestroy() {\n        this.subscriptions.forEach(s => s.unsubscribe());\n    }\n};\nVgImaAds.ctorParameters = () => [\n    { type: ElementRef },\n    { type: VgAPI },\n    { type: VgFullscreenAPI }\n];\n__decorate([\n    Input()\n], VgImaAds.prototype, \"vgFor\", void 0);\n__decorate([\n    Input()\n], VgImaAds.prototype, \"vgNetwork\", void 0);\n__decorate([\n    Input()\n], VgImaAds.prototype, \"vgUnitPath\", void 0);\n__decorate([\n    Input()\n], VgImaAds.prototype, \"vgCompanion\", void 0);\n__decorate([\n    Input()\n], VgImaAds.prototype, \"vgCompanionSize\", void 0);\n__decorate([\n    Input()\n], VgImaAds.prototype, \"vgAdTagUrl\", void 0);\n__decorate([\n    Input()\n], VgImaAds.prototype, \"vgSkipButton\", void 0);\n__decorate([\n    Output()\n], VgImaAds.prototype, \"onAdStart\", void 0);\n__decorate([\n    Output()\n], VgImaAds.prototype, \"onAdStop\", void 0);\n__decorate([\n    Output()\n], VgImaAds.prototype, \"onSkipAd\", void 0);\n__decorate([\n    HostBinding('style.display')\n], VgImaAds.prototype, \"displayState\", void 0);\nVgImaAds = __decorate([\n    Component({\n        selector: 'vg-ima-ads',\n        encapsulation: ViewEncapsulation.None,\n        template: `<div class=\"vg-ima-ads\"></div>`,\n        styles: [`\n        vg-ima-ads {\n            position: absolute;\n            width: 100%;\n            height: 100%;\n            z-index: 300;\n        }\n        vg-ima-ads .vg-ima-ads {\n            position: absolute;\n            width: 100%;\n            height: 100%;\n            pointer-events: none;\n        }\n    `]\n    })\n], VgImaAds);\nclass Ima {\n    constructor(imaAdsElement) {\n        this.adDisplayContainer = new google.ima.AdDisplayContainer(imaAdsElement);\n        this.adsLoader = new google.ima.AdsLoader(this.adDisplayContainer);\n        this.adsManager = null;\n        this.adsLoaded = false;\n        this.currentAd = 0;\n    }\n}\n\nlet VgImaAdsModule = class VgImaAdsModule {\n};\nVgImaAdsModule = __decorate([\n    NgModule({\n        imports: [CommonModule],\n        declarations: [\n            VgImaAds\n        ],\n        exports: [\n            VgImaAds\n        ]\n    })\n], VgImaAdsModule);\n\nlet VgOverlayPlay = \n// tslint:disable:component-class-suffix\nclass VgOverlayPlay {\n    constructor(ref, API, fsAPI, controlsHidden) {\n        this.API = API;\n        this.fsAPI = fsAPI;\n        this.controlsHidden = controlsHidden;\n        this.isNativeFullscreen = false;\n        this.areControlsHidden = false;\n        this.subscriptions = [];\n        this.isBuffering = false;\n        this.elem = ref.nativeElement;\n    }\n    ngOnInit() {\n        if (this.API.isPlayerReady) {\n            this.onPlayerReady();\n        }\n        else {\n            this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n        }\n    }\n    onPlayerReady() {\n        this.target = this.API.getMediaById(this.vgFor);\n        this.subscriptions.push(this.fsAPI.onChangeFullscreen.subscribe(this.onChangeFullscreen.bind(this)));\n        this.subscriptions.push(this.controlsHidden.isHidden.subscribe(this.onHideControls.bind(this)));\n        this.subscriptions.push(this.target.subscriptions.bufferDetected.subscribe(isBuffering => this.onUpdateBuffer(isBuffering)));\n    }\n    onUpdateBuffer(isBuffering) {\n        this.isBuffering = isBuffering;\n    }\n    onChangeFullscreen(fsState) {\n        if (this.fsAPI.nativeFullscreen) {\n            this.isNativeFullscreen = fsState;\n        }\n    }\n    onHideControls(hidden) {\n        this.areControlsHidden = hidden;\n    }\n    onClick() {\n        const state = this.getState();\n        switch (state) {\n            case VgStates.VG_PLAYING:\n                this.target.pause();\n                break;\n            case VgStates.VG_PAUSED:\n            case VgStates.VG_ENDED:\n                this.target.play();\n                break;\n        }\n    }\n    getState() {\n        let state = VgStates.VG_PAUSED;\n        if (this.target) {\n            if (this.target.state instanceof Array) {\n                for (let i = 0, l = this.target.state.length; i < l; i++) {\n                    if (this.target.state[i] === VgStates.VG_PLAYING) {\n                        state = VgStates.VG_PLAYING;\n                        break;\n                    }\n                }\n            }\n            else {\n                state = this.target.state;\n            }\n        }\n        return state;\n    }\n    ngOnDestroy() {\n        this.subscriptions.forEach(s => s.unsubscribe());\n    }\n};\nVgOverlayPlay.ctorParameters = () => [\n    { type: ElementRef },\n    { type: VgAPI },\n    { type: VgFullscreenAPI },\n    { type: VgControlsHidden }\n];\n__decorate([\n    Input()\n], VgOverlayPlay.prototype, \"vgFor\", void 0);\n__decorate([\n    HostBinding('class.is-buffering')\n], VgOverlayPlay.prototype, \"isBuffering\", void 0);\n__decorate([\n    HostListener('click')\n], VgOverlayPlay.prototype, \"onClick\", null);\nVgOverlayPlay = __decorate([\n    Component({\n        selector: 'vg-overlay-play',\n        encapsulation: ViewEncapsulation.None,\n        template: `<div class=\"vg-overlay-play\"\n                    [class.native-fullscreen]=\"isNativeFullscreen\"\n                    [class.controls-hidden]=\"areControlsHidden\">\n                   <div class=\"overlay-play-container\"\n                        [class.vg-icon-play_arrow]=\"getState() !== 'playing'\">\n                   </div>\n               </div>`,\n        styles: [`\n        vg-overlay-play {\n            z-index: 200;\n        }\n        vg-overlay-play.is-buffering {\n            display: none;\n        }\n        vg-overlay-play .vg-overlay-play {\n            transition: all 0.5s;\n            cursor: pointer;\n            position: absolute;\n            display: block;\n            color: white;\n            width: 100%;\n            height: 100%;\n            font-size: 80px;\n            filter: alpha(opacity=60);\n            opacity: 0.6;\n        }\n        vg-overlay-play .vg-overlay-play.native-fullscreen.controls-hidden {\n            cursor: none;\n        }\n        vg-overlay-play .vg-overlay-play .overlay-play-container.vg-icon-play_arrow {\n            pointer-events: none;\n            width: 100%;\n            height: 100%;\n            position: absolute;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            font-size: 80px;\n        }\n        vg-overlay-play .vg-overlay-play:hover {\n            filter: alpha(opacity=100);\n            opacity: 1;\n        }\n        vg-overlay-play .vg-overlay-play:hover .overlay-play-container.vg-icon-play_arrow:before {\n            transform: scale(1.2);\n        }\n    `]\n    })\n    // tslint:disable:component-class-suffix\n], VgOverlayPlay);\n\nlet VgOverlayPlayModule = class VgOverlayPlayModule {\n};\nVgOverlayPlayModule = __decorate([\n    NgModule({\n        imports: [CommonModule],\n        declarations: [\n            VgOverlayPlay\n        ],\n        exports: [\n            VgOverlayPlay\n        ]\n    })\n], VgOverlayPlayModule);\n\nlet VgDASH = \n// tslint:disable:directive-class-suffix\n// tslint:disable:no-output-on-prefix\n// tslint:disable:no-string-literal\nclass VgDASH {\n    constructor(ref, API) {\n        this.ref = ref;\n        this.API = API;\n        this.onGetBitrates = new EventEmitter();\n        this.subscriptions = [];\n    }\n    ngOnInit() {\n        if (this.API.isPlayerReady) {\n            this.onPlayerReady();\n        }\n        else {\n            this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n        }\n    }\n    onPlayerReady() {\n        this.vgFor = this.ref.nativeElement.getAttribute('vgFor');\n        this.target = this.API.getMediaById(this.vgFor);\n        this.createPlayer();\n    }\n    ngOnChanges(changes) {\n        if (changes['vgDash'] && changes['vgDash'].currentValue) {\n            this.createPlayer();\n        }\n        else {\n            this.destroyPlayer();\n        }\n    }\n    createPlayer() {\n        if (this.dash) {\n            this.destroyPlayer();\n        }\n        // It's a DASH source\n        if (this.vgDash && ((this.vgDash.indexOf('.mpd') > -1) ||\n            (this.vgDash.indexOf('mpd-time-csf') > -1))) {\n            let drmOptions;\n            if (this.vgDRMLicenseServer) {\n                drmOptions = this.vgDRMLicenseServer;\n                if (this.vgDRMToken) {\n                    for (const drmServer in drmOptions) {\n                        if (drmServer.hasOwnProperty(drmServer)) {\n                            drmOptions[drmServer].httpRequestHeaders = { Authorization: this.vgDRMToken };\n                        }\n                    }\n                }\n            }\n            this.dash = dashjs.MediaPlayer().create();\n            this.dash.getDebug().setLogToBrowserConsole(false);\n            this.dash.initialize(this.ref.nativeElement);\n            this.dash.setAutoPlay(false);\n            this.dash.on(dashjs.MediaPlayer.events.STREAM_INITIALIZED, () => {\n                const audioList = this.dash.getBitrateInfoListFor('audio');\n                const videoList = this.dash.getBitrateInfoListFor('video');\n                if (audioList.length > 1) {\n                    audioList.forEach(item => item.qualityIndex = ++item.qualityIndex);\n                    audioList.unshift({\n                        qualityIndex: 0,\n                        width: 0,\n                        height: 0,\n                        bitrate: 0,\n                        mediaType: 'video',\n                        label: 'AUTO'\n                    });\n                    this.onGetBitrates.emit(audioList);\n                }\n                if (videoList.length > 1) {\n                    videoList.forEach(item => item.qualityIndex = ++item.qualityIndex);\n                    videoList.unshift({\n                        qualityIndex: 0,\n                        width: 0,\n                        height: 0,\n                        bitrate: 0,\n                        mediaType: 'video',\n                        label: 'AUTO'\n                    });\n                    this.onGetBitrates.emit(videoList);\n                }\n            });\n            if (drmOptions) {\n                this.dash.setProtectionData(drmOptions);\n            }\n            this.dash.attachSource(this.vgDash);\n        }\n        else {\n            if (this.target) {\n                this.target.pause();\n                this.target.seekTime(0);\n                this.ref.nativeElement.src = this.vgDash;\n            }\n        }\n    }\n    setBitrate(bitrate) {\n        if (this.dash) {\n            if (bitrate.qualityIndex > 0) {\n                if (this.dash.getAutoSwitchQualityFor(bitrate.mediaType)) {\n                    this.dash.setAutoSwitchQualityFor(bitrate.mediaType, false);\n                }\n                const nextIndex = bitrate.qualityIndex - 1;\n                this.dash.setQualityFor(bitrate.mediaType, nextIndex);\n            }\n            else {\n                this.dash.setAutoSwitchQualityFor(bitrate.mediaType, true);\n            }\n        }\n    }\n    destroyPlayer() {\n        if (this.dash) {\n            this.dash.reset();\n            this.dash = null;\n        }\n    }\n    ngOnDestroy() {\n        this.subscriptions.forEach(s => s.unsubscribe());\n        this.destroyPlayer();\n    }\n};\nVgDASH.ctorParameters = () => [\n    { type: ElementRef },\n    { type: VgAPI }\n];\n__decorate([\n    Input()\n], VgDASH.prototype, \"vgDash\", void 0);\n__decorate([\n    Input()\n], VgDASH.prototype, \"vgDRMToken\", void 0);\n__decorate([\n    Input()\n], VgDASH.prototype, \"vgDRMLicenseServer\", void 0);\n__decorate([\n    Output()\n], VgDASH.prototype, \"onGetBitrates\", void 0);\nVgDASH = __decorate([\n    Directive({\n        selector: '[vgDash]',\n        exportAs: 'vgDash'\n    })\n    // tslint:disable:directive-class-suffix\n    // tslint:disable:no-output-on-prefix\n    // tslint:disable:no-string-literal\n], VgDASH);\n\nlet VgHLS = \n// tslint:disable:no-string-literal\n// tslint:disable:directive-class-suffix\n// tslint:disable:no-output-on-prefix\nclass VgHLS {\n    constructor(ref, API) {\n        this.ref = ref;\n        this.API = API;\n        this.vgHlsHeaders = {};\n        this.onGetBitrates = new EventEmitter();\n        this.subscriptions = [];\n    }\n    ngOnInit() {\n        if (this.API.isPlayerReady) {\n            this.onPlayerReady();\n        }\n        else {\n            this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n        }\n    }\n    onPlayerReady() {\n        this.crossorigin = this.ref.nativeElement.getAttribute('crossorigin');\n        this.preload = this.ref.nativeElement.getAttribute('preload') !== 'none';\n        this.vgFor = this.ref.nativeElement.getAttribute('vgFor');\n        if (this.vgFor) {\n            this.target = this.API.getMediaById(this.vgFor);\n        }\n        else {\n            this.target = this.API.getDefaultMedia();\n        }\n        this.config = {\n            autoStartLoad: this.preload\n        };\n        // @ts-ignore\n        this.config.xhrSetup = (xhr, url) => {\n            // Send cookies\n            if (this.crossorigin === 'use-credentials') {\n                xhr.withCredentials = true;\n            }\n            for (const key of Object.keys(this.vgHlsHeaders)) {\n                xhr.setRequestHeader(key, this.vgHlsHeaders[key]);\n            }\n        };\n        this.createPlayer();\n        if (!this.preload) {\n            this.subscriptions.push(this.API.subscriptions.play.subscribe(() => {\n                if (this.hls) {\n                    this.hls.startLoad(0);\n                }\n            }));\n        }\n    }\n    ngOnChanges(changes) {\n        if (changes['vgHls'] && changes['vgHls'].currentValue) {\n            this.createPlayer();\n        }\n        else if (changes['vgHlsHeaders'] && changes['vgHlsHeaders'].currentValue) {\n            // Do nothing. We don't want to create a or destroy a player if the headers change.\n        }\n        else {\n            this.destroyPlayer();\n        }\n    }\n    createPlayer() {\n        if (this.hls) {\n            this.destroyPlayer();\n        }\n        // It's a HLS source\n        if (this.vgHls && this.vgHls.indexOf('m3u8') > -1 && Hls.isSupported() && this.API.isPlayerReady) {\n            const video = this.ref.nativeElement;\n            this.hls = new Hls(this.config);\n            // @ts-ignore\n            this.hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {\n                const videoList = [];\n                videoList.push({\n                    qualityIndex: 0,\n                    width: 0,\n                    height: 0,\n                    bitrate: 0,\n                    mediaType: 'video',\n                    label: 'AUTO'\n                });\n                data.levels.forEach((item, index) => {\n                    videoList.push({\n                        qualityIndex: ++index,\n                        width: item.width,\n                        height: item.height,\n                        bitrate: item.bitrate,\n                        mediaType: 'video',\n                        label: item.name\n                    });\n                });\n                this.onGetBitrates.emit(videoList);\n            });\n            // @ts-ignore\n            this.hls.on(Hls.Events.LEVEL_LOADED, (event, data) => {\n                this.target.isLive = data.details.live;\n            });\n            this.hls.loadSource(this.vgHls);\n            this.hls.attachMedia(video);\n        }\n        else {\n            if (this.target && !!this.target.pause) {\n                this.target.pause();\n                this.target.seekTime(0);\n                this.ref.nativeElement.src = this.vgHls;\n            }\n        }\n    }\n    setBitrate(bitrate) {\n        if (this.hls) {\n            this.hls.nextLevel = bitrate.qualityIndex - 1;\n        }\n    }\n    destroyPlayer() {\n        if (this.hls) {\n            this.hls.destroy();\n            this.hls = null;\n        }\n    }\n    ngOnDestroy() {\n        this.subscriptions.forEach(s => s.unsubscribe());\n        this.destroyPlayer();\n        delete this.hls;\n    }\n};\nVgHLS.ctorParameters = () => [\n    { type: ElementRef },\n    { type: VgAPI }\n];\n__decorate([\n    Input()\n], VgHLS.prototype, \"vgHls\", void 0);\n__decorate([\n    Input()\n], VgHLS.prototype, \"vgHlsHeaders\", void 0);\n__decorate([\n    Output()\n], VgHLS.prototype, \"onGetBitrates\", void 0);\nVgHLS = __decorate([\n    Directive({\n        selector: '[vgHls]',\n        exportAs: 'vgHls'\n    })\n    // tslint:disable:no-string-literal\n    // tslint:disable:directive-class-suffix\n    // tslint:disable:no-output-on-prefix\n], VgHLS);\n\nlet VgStreamingModule = class VgStreamingModule {\n};\nVgStreamingModule = __decorate([\n    NgModule({\n        imports: [CommonModule],\n        declarations: [\n            VgDASH, VgHLS\n        ],\n        exports: [\n            VgDASH, VgHLS\n        ]\n    })\n], VgStreamingModule);\n\n/*\n * Public API Surface of ngx-videogular\n */\n// Required for Ivy Build of Library\n// export * from './lib/buffering/vg-buffering';\n// export * from './lib/controls/vg-controls';\n// export * from './lib/controls/vg-fullscreen/vg-fullscreen';\n// export * from './lib/controls/vg-mute/vg-mute';\n// export * from './lib/controls/vg-play-pause/vg-play-pause';\n// export * from './lib/controls/vg-playback-button/vg-playback-button';\n// export * from './lib/controls/vg-volume/vg-volume';\n// export * from './lib/controls/vg-quality-selector/vg-quality-selector';\n// export * from './lib/controls/vg-scrub-bar/vg-scrub-bar';\n// export * from './lib/controls/vg-scrub-bar/vg-scrub-bar-buffering-time/vg-scrub-bar-buffering-time';\n// export * from './lib/controls/vg-scrub-bar/vg-scrub-bar-cue-points/vg-scrub-bar-cue-points';\n// export * from './lib/controls/vg-scrub-bar/vg-scrub-bar-current-time/vg-scrub-bar-current-time';\n// export * from './lib/controls/vg-time-display/vg-time-display';\n// export * from './lib/controls/vg-track-selector/vg-track-selector';\n// export * from './lib/core/vg-player/vg-player';\n// export * from './lib/core/vg-media/vg-media';\n// export * from './lib/core/vg-cue-points/vg-cue-points';\n// export * from './lib/ima-ads/vg-ima-ads';\n// export * from './lib/overlay-play/vg-overlay-play';\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { VgAPI, VgBufferingModule, VgControlsHidden, VgControlsModule, VgCoreModule, VgDASH, VgEvents, VgFullscreenAPI, VgHLS, VgImaAdsModule, VgMediaElement, VgOverlayPlayModule, VgStates, VgStreamingModule, VgUtils, VgBuffering as ɵa, VgControls as ɵb, VgFullscreen as ɵc, VgMute as ɵd, VgVolume as ɵe, VgPlayPause as ɵf, VgPlaybackButton as ɵg, VgScrubBar as ɵh, VgScrubBarBufferingTime as ɵi, VgScrubBarCuePoints as ɵj, VgScrubBarCurrentTime as ɵk, VgUtcPipe as ɵl, VgTimeDisplay as ɵm, VgTrackSelector as ɵn, VgQualitySelector as ɵo, VgMedia as ɵp, VgCuePoints as ɵq, VgPlayer as ɵr, VgImaAds as ɵs, VgOverlayPlay as ɵt };\n"]}