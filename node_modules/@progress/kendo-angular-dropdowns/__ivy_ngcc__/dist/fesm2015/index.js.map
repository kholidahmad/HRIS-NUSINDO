{"version":3,"file":"index.js","sources":["D:/project/projek_angular/hris_rni/node_modules/@progress/kendo-angular-dropdowns/dist/fesm2015/index.js"],"sourcesContent":["/**-----------------------------------------------------------------------------------------\n* Copyright Â© 2020 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport { EventEmitter, Component, Renderer2, Input, Output, ViewChild, HostBinding, Directive, TemplateRef, Injectable, ElementRef, ChangeDetectorRef, NgZone, ViewChildren, forwardRef, isDevMode, ContentChild, ViewContainerRef, InjectionToken, Optional, Inject, KeyValueDiffers, HostListener, NgModule } from '@angular/core';\nimport { isDocumentAvailable, isChanged, KendoInput, ResizeSensorModule } from '@progress/kendo-angular-common';\nimport { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';\nimport { LocalizationService, L10N_PREFIX, ComponentMessages } from '@progress/kendo-angular-l10n';\nimport { merge, fromEvent, Subject, Subscription, of, interval } from 'rxjs';\nimport { map, auditTime, tap, filter, partition, throttleTime, catchError, distinctUntilChanged, skipWhile, concatMap, take, takeUntil } from 'rxjs/operators';\nimport { PopupService, PopupModule } from '@progress/kendo-angular-popup';\nexport { PopupComponent } from '@progress/kendo-angular-popup';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @hidden\n */\nvar Keys;\n(function (Keys) {\n    Keys[Keys[\"backspace\"] = 8] = \"backspace\";\n    Keys[Keys[\"tab\"] = 9] = \"tab\";\n    Keys[Keys[\"enter\"] = 13] = \"enter\";\n    Keys[Keys[\"shift\"] = 16] = \"shift\";\n    Keys[Keys[\"ctrl\"] = 17] = \"ctrl\";\n    Keys[Keys[\"alt\"] = 18] = \"alt\";\n    Keys[Keys[\"pause/break\"] = 19] = \"pause/break\";\n    Keys[Keys[\"caps lock\"] = 20] = \"caps lock\";\n    Keys[Keys[\"esc\"] = 27] = \"esc\";\n    Keys[Keys[\"space\"] = 32] = \"space\";\n    Keys[Keys[\"page up\"] = 33] = \"page up\";\n    Keys[Keys[\"page down\"] = 34] = \"page down\";\n    Keys[Keys[\"end\"] = 35] = \"end\";\n    Keys[Keys[\"home\"] = 36] = \"home\";\n    Keys[Keys[\"left\"] = 37] = \"left\";\n    Keys[Keys[\"up\"] = 38] = \"up\";\n    Keys[Keys[\"right\"] = 39] = \"right\";\n    Keys[Keys[\"down\"] = 40] = \"down\";\n    Keys[Keys[\"insert\"] = 45] = \"insert\";\n    Keys[Keys[\"delete\"] = 46] = \"delete\";\n    Keys[Keys[\"command\"] = 91] = \"command\";\n    Keys[Keys[\"left command\"] = 91] = \"left command\";\n    Keys[Keys[\"right command\"] = 93] = \"right command\";\n    Keys[Keys[\"numpad *\"] = 106] = \"numpad *\";\n    Keys[Keys[\"numpad +\"] = 107] = \"numpad +\";\n    Keys[Keys[\"numpad -\"] = 109] = \"numpad -\";\n    Keys[Keys[\"numpad .\"] = 110] = \"numpad .\";\n    Keys[Keys[\"numpad /\"] = 111] = \"numpad /\";\n    Keys[Keys[\"num lock\"] = 144] = \"num lock\";\n    Keys[Keys[\"scroll lock\"] = 145] = \"scroll lock\";\n    Keys[Keys[\"my computer\"] = 182] = \"my computer\";\n    Keys[Keys[\"my calculator\"] = 183] = \"my calculator\";\n    Keys[Keys[\";\"] = 186] = \";\";\n    Keys[Keys[\"=\"] = 187] = \"=\";\n    Keys[Keys[\",\"] = 188] = \",\";\n    Keys[Keys[\"-\"] = 189] = \"-\";\n    Keys[Keys[\".\"] = 190] = \".\";\n    Keys[Keys[\"/\"] = 191] = \"/\";\n    Keys[Keys[\"`\"] = 192] = \"`\";\n    Keys[Keys[\"[\"] = 219] = \"[\";\n    Keys[Keys[\"\\\\\"] = 220] = \"\\\\\";\n    Keys[Keys[\"]\"] = 221] = \"]\";\n    Keys[Keys[\"'\"] = 222] = \"'\";\n})(Keys || (Keys = {}));\n\n/* tslint:disable:no-null-keyword */\n/* tslint:disable:no-bitwise */\n/* tslint:disable:align */\n/**\n * @hidden\n */\nconst isPresent = (value) => value !== null && value !== undefined;\n/**\n * @hidden\n */\nconst isNumber = (value) => !isNaN(value);\n/**\n * @hidden\n */\nconst guid = () => {\n    let id = \"\";\n    let i;\n    let random;\n    for (i = 0; i < 32; i++) {\n        random = Math.random() * 16 | 0;\n        if (i === 8 || i === 12 || i === 16 || i === 20) {\n            id += \"-\";\n        }\n        id += (i === 12 ? 4 : (i === 16 ? (random & 3 | 8) : random)).toString(16);\n    }\n    return id;\n};\n/**\n * @hidden\n */\nconst combineStr = (begin, end) => {\n    return begin.concat(end.substr(end.toLowerCase().indexOf(begin.toLowerCase()) + begin.length));\n};\n/**\n * @hidden\n */\nconst isWindowAvailable = () => typeof window !== 'undefined';\n/**\n * @hidden\n */\nconst isArray = (value) => Array.isArray(value);\n/**\n * @hidden\n */\nconst isObject = (value) => isPresent(value) && typeof value === 'object';\n/**\n * @hidden\n */\nconst isEmptyString = (value) => typeof value === 'string' && value.length === 0;\n/**\n * @hidden\n */\nconst resolveValuesInArray = (values, data = [], valueField) => values\n    .map(value => {\n    return data.find(item => item[valueField] === value);\n})\n    .filter(value => value !== undefined);\n/**\n * @hidden\n */\nconst validateComplexValues = (values, valueField) => isArray(values) && values.filter(item => {\n    return isObject(item) && item[valueField];\n});\n/**\n * @hidden\n */\nconst resolveAllValues = (value, data, valueField) => {\n    const customValues = validateComplexValues(value, valueField) || [];\n    const resolvedValues = resolveValuesInArray(value, data, valueField) || [];\n    return resolvedValues.concat(customValues);\n};\n/**\n * @hidden\n */\nconst isObjectArray = (values) => {\n    return isArray(values) && values.every(item => isObject(item));\n};\n/**\n * @hidden\n */\nconst selectedIndices = (values, data, valueField) => {\n    const extractedValues = data.map(item => {\n        return isPresent(item) && isPresent(item[valueField]) ? item[valueField] : item;\n    });\n    return values.reduce((arr, item) => {\n        const value = isPresent(item) && isPresent(item[valueField]) ? item[valueField] : item;\n        const index = extractedValues.indexOf(value);\n        if (index !== -1) {\n            arr.push(index);\n        }\n        return arr;\n    }, []);\n};\n/**\n * @hidden\n */\nconst getter = (dataItem, field, usePrimitive = false) => {\n    if (isPresent(dataItem)) {\n        if (usePrimitive) {\n            return field && isPresent(dataItem[field]) ? dataItem[field] : dataItem;\n        }\n        else {\n            return field ? dataItem[field] : dataItem;\n        }\n    }\n};\n/**\n * @hidden\n */\nconst sameCharsOnly = (word, character) => {\n    for (let idx = 0; idx < word.length; idx++) {\n        if (word.charAt(idx) !== character) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * @hidden\n */\nconst shuffleData = (data, splitIndex, defaultItem) => {\n    let result = data;\n    if (defaultItem) {\n        result = [defaultItem].concat(result);\n    }\n    return result.slice(splitIndex).concat(result.slice(0, splitIndex));\n};\n/**\n * @hidden\n */\nconst matchText = (text, word, ignoreCase) => {\n    if (!isPresent(text)) {\n        return false;\n    }\n    let temp = String(text);\n    if (ignoreCase) {\n        temp = temp.toLowerCase();\n    }\n    return temp.indexOf(word) === 0;\n};\n\n/* tslint:disable:member-ordering */\n/**\n * @hidden\n */\nclass SearchBarComponent {\n    constructor(localization, renderer) {\n        this.localization = localization;\n        this.valueChange = new EventEmitter();\n        this.onBlur = new EventEmitter();\n        this.onFocus = new EventEmitter();\n        this.onClick = new EventEmitter();\n        this.onNavigate = new EventEmitter();\n        this.searchBarClass = true;\n        this._userInput = \"\";\n        this._previousValue = \"\";\n        this._placeholder = \"\";\n        this.direction = localization.rtl ? 'rtl' : 'ltr';\n        this.renderer = renderer;\n    }\n    get userInput() {\n        return this._userInput;\n    }\n    set userInput(userInput) {\n        this._userInput = userInput || \"\";\n    }\n    get value() {\n        return this.input.nativeElement.value;\n    }\n    set placeholder(text) {\n        this._placeholder = text || '';\n        this.setInputSize();\n    }\n    get placeholder() {\n        return this._placeholder;\n    }\n    ngOnInit() {\n        this.localizationChangeSubscription = this.localization\n            .changes.subscribe(({ rtl }) => this.direction = rtl ? 'rtl' : 'ltr');\n    }\n    ngOnChanges(changes) {\n        let previousUserInput;\n        if (this.input && (changes.userInput || changes.suggestedText)) {\n            if (changes.userInput && changes.userInput.previousValue) {\n                if (this._previousValue === changes.userInput.previousValue) {\n                    previousUserInput = this._previousValue;\n                }\n                else {\n                    previousUserInput = changes.userInput.currentValue || \"\";\n                }\n            }\n            else {\n                previousUserInput = this._previousValue;\n            }\n            const caretIndex = this.input.nativeElement.selectionStart;\n            const caretAtEnd = previousUserInput.length === caretIndex;\n            this.writeInputValue(this.suggestedText ? combineStr(this.userInput, this.suggestedText) : this.userInput);\n            if (this.suggestedText) {\n                this.setInputSelection(this.userInput.length, this.suggestedText.length);\n            }\n            else if (caretAtEnd) {\n                this.setInputSelection(this.userInput.length, this.userInput.length);\n            }\n            else {\n                this.setInputSelection(caretIndex, caretIndex);\n            }\n            this._previousValue = this.userInput;\n        }\n    }\n    ngOnDestroy() {\n        if (this.localizationChangeSubscription) {\n            this.localizationChangeSubscription.unsubscribe();\n        }\n    }\n    writeInputValue(text) {\n        if (isDocumentAvailable()) {\n            this.renderer.setProperty(this.input.nativeElement, 'value', text);\n        }\n    }\n    setInputSelection(start, end) {\n        if (isDocumentAvailable() && this.input.nativeElement === document.activeElement) {\n            try {\n                this.input.nativeElement.setSelectionRange(start, end);\n            }\n            catch (e) {\n                //Make sure that the element is in the DOM before you invoke its methods\n            }\n        }\n    }\n    handleInput(event) {\n        const value = event.target.value;\n        if (value !== this.userInput) {\n            this._previousValue = value;\n            this.valueChange.emit(value);\n        }\n    }\n    handleFocus(event) {\n        this.onFocus.emit(event);\n    }\n    handleBlur(event) {\n        this.onBlur.emit(event);\n    }\n    handleKeydown(event) {\n        const keyCode = event.keyCode;\n        const keys = [Keys.up, Keys.down, Keys.left, Keys.right, Keys.enter,\n            Keys.esc, Keys.delete, Keys.backspace, Keys.home, Keys.end];\n        if (keys.indexOf(keyCode) > -1) {\n            this.onNavigate.emit(event);\n        }\n    }\n    focus() {\n        if (isDocumentAvailable()) {\n            this.input.nativeElement.focus();\n        }\n    }\n    blur() {\n        if (isDocumentAvailable()) {\n            this.input.nativeElement.blur();\n        }\n    }\n    setInputSize() {\n        const lengthOf = x => x ? x.length : 0;\n        const input = this.input.nativeElement;\n        const placeholderLength = lengthOf(this.placeholder);\n        const textLength = lengthOf(this.value);\n        const size = Math.max(placeholderLength, textLength, 1);\n        this.renderer.setAttribute(input, 'size', size.toString());\n    }\n}\nSearchBarComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-searchbar',\n                template: `\n        <input #input\n            autocomplete=\"off\"\n            [id]=\"id\"\n            [disabled]=\"disabled\"\n            [readonly]=\"readonly\"\n            [placeholder]=\"placeholder\"\n            [class]=\"'k-input'\"\n            (input)=\"handleInput($event)\"\n            (focus)=\"handleFocus($event)\"\n            (blur)=\"handleBlur($event)\"\n            (keydown)=\"handleKeydown($event)\"\n            [attr.tabIndex]=\"tabIndex\"\n            [attr.dir]=\"direction\"\n            [attr.role]=\"role\"\n            [attr.aria-disabled]=\"disabled\"\n            [attr.aria-readonly]=\"readonly\"\n            aria-haspopup=\"listbox\"\n            [attr.aria-expanded]=\"popupOpen\"\n            [attr.aria-owns]=\"listId\"\n            [attr.aria-describedby]=\"tagListId\"\n            [attr.aria-activedescendant]=\"activeDescendant\"\n            [attr.aria-label]=\"noDataLabel\"\n        />\n   `\n            },] },\n];\n/** @nocollapse */\nSearchBarComponent.ctorParameters = () => [\n    { type: LocalizationService },\n    { type: Renderer2 }\n];\nSearchBarComponent.propDecorators = {\n    id: [{ type: Input }],\n    listId: [{ type: Input }],\n    tagListId: [{ type: Input }],\n    activeDescendant: [{ type: Input }],\n    noDataLabel: [{ type: Input }],\n    disabled: [{ type: Input }],\n    readonly: [{ type: Input }],\n    tabIndex: [{ type: Input }],\n    popupOpen: [{ type: Input }],\n    role: [{ type: Input }],\n    userInput: [{ type: Input }],\n    suggestedText: [{ type: Input }],\n    valueChange: [{ type: Output }],\n    onBlur: [{ type: Output }],\n    onFocus: [{ type: Output }],\n    onClick: [{ type: Output }],\n    onNavigate: [{ type: Output }],\n    input: [{ type: ViewChild, args: [\"input\", { static: true },] }],\n    searchBarClass: [{ type: HostBinding, args: ['class.k-searchbar',] }],\n    placeholder: [{ type: Input }]\n};\n\n/* tslint:disable:max-line-length */\n/**\n * Renders the list item content. To define the item template, nest an `<ng-template>` tag\n * with the `kendo<ComponentName>ItemTemplate` directive inside the component tag. The template context is\n * set to the current component. To get a reference to the current data item, use the `let-dataItem` directive.\n *\n * - [Using `ItemTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-item-template)\n * - [Using `ItemTemplate` with the ComboBox]({% slug templates_combobox %}#toc-item-template)\n * - [Using `ItemTemplate` with the DropDownList]({% slug templates_ddl %}#toc-item-template)\n * - [Using `ItemTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-item-template)\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-combobox [data]=\"listItems\">\n *    <ng-template kendoComboBoxItemTemplate let-dataItem>\n *      <span>{{dataItem}} option</span>\n *    </ng-template>\n *  </kendo-combobox>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\nclass ItemTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nItemTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoDropDownListItemTemplate],[kendoComboBoxItemTemplate],[kendoAutoCompleteItemTemplate],[kendoMultiSelectItemTemplate]'\n            },] },\n];\n/** @nocollapse */\nItemTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef }\n];\n\n/* tslint:disable:max-line-length */\n/**\n * Renders the header content of the list. To define the header template, nest an `<ng-template>` tag\n * with the `kendo<ComponentName>HeaderTemplate` directive inside the component tag.\n *\n * - [Using `HeaderTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-header-template)\n * - [Using `HeaderTemplate` with the ComboBox]({% slug templates_combobox %}#toc-header-template)\n * - [Using `HeaderTemplate` with the DropDownList]({% slug templates_ddl %}#toc-header-template)\n * - [Using `HeaderTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-header-template)\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-combobox [data]=\"listItems\">\n *    <ng-template kendoComboBoxHeaderTemplate>\n *      <h4>Header template</h4>\n *    </ng-template>\n *  </kendo-combobox>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\nclass HeaderTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nHeaderTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoDropDownListHeaderTemplate],[kendoComboBoxHeaderTemplate],[kendoAutoCompleteHeaderTemplate],[kendoMultiSelectHeaderTemplate]'\n            },] },\n];\n/** @nocollapse */\nHeaderTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef }\n];\n\n/* tslint:disable:max-line-length */\n/**\n * Renders the footer content of the list. To define the footer template, nest an `<ng-template>` tag\n * with the `kendo<ComponentName>FooterTemplate` directive inside the component tag.\n *\n * - [Using `FooterTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-footer-template)\n * - [Using `FooterTemplate` with the ComboBox]({% slug templates_combobox %}#toc-footer-template)\n * - [Using `FooterTemplate` with the DropDownList]({% slug templates_ddl %}#toc-footer-template)\n * - [Using `FooterTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-footer-template)\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-combobox [data]=\"listItems\">\n *    <ng-template kendoComboBoxFooterTemplate>\n *      <h4>Footer template</h4>\n *    </ng-template>\n *  </kendo-combobox>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\nclass FooterTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nFooterTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoDropDownListFooterTemplate],[kendoComboBoxFooterTemplate],[kendoAutoCompleteFooterTemplate],[kendoMultiSelectFooterTemplate]'\n            },] },\n];\n/** @nocollapse */\nFooterTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef }\n];\n\n/* tslint:disable:max-line-length */\n/**\n * Renders the group header content. To define the group template, nest an `<ng-template>` tag\n * with the `kendo<ComponentName>GroupTemplate` directive inside the component tag. The template context is\n * set to the current component. To get a reference to the current data item, use the `let-groupName` directive.\n *\n * - [Using `GroupTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-group-template)\n * - [Using `GroupTemplate` with the ComboBox]({% slug templates_combobox %}#toc-group-template)\n * - [Using `GroupTemplate` with the DropDownList]({% slug templates_ddl %}#toc-group-template)\n * - [Using `GroupTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-group-template)\n *\n * @example\n * ```ts\n * import { groupBy } from '@progress/kendo-data-query';\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-combobox [data]=\"groupedData\" [textField]=\"'name'\" [valueField]=\"'name'\">\n *    <ng-template kendoComboBoxGroupTemplate let-groupName>\n *      <span>Food type: {{groupName}} option</span>\n *    </ng-template>\n *  </kendo-combobox>\n * `\n * })\n * class AppComponent {\n *   public data = [\n *       { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *       { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *       { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n *   ];\n *   public groupedData = groupBy(this.data, [{field: \"subcategory\"}]);\n * }\n * ```\n */\nclass GroupTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nGroupTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoDropDownListGroupTemplate],[kendoComboBoxGroupTemplate],[kendoAutoCompleteGroupTemplate],[kendoMultiSelectGroupTemplate]'\n            },] },\n];\n/** @nocollapse */\nGroupTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef }\n];\n\n/* tslint:disable:max-line-length */\n/**\n * Renders the fixed group header content. To define the fixed group template, nest an `<ng-template>` tag\n * with the `kendo<ComponentName>FixedGroupTemplate` directive inside the component tag. The template context is\n * set to the current component. To get a reference to the current data item, use the `let-groupName` directive.\n *\n * - [Using `FixedGroupTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-fixed-group-template)\n * - [Using `FixedGroupTemplate` with the ComboBox]({% slug templates_combobox %}#toc-fixed-group-template)\n * - [Using `FixedGroupTemplate` with the DropDownList]({% slug templates_ddl %}#toc-fixed-group-template)\n * - [Using `FixedGroupTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-fixed-group-template)\n *\n * @example\n * ```ts\n * import { groupBy } from '@progress/kendo-data-query';\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-combobox [data]=\"groupedData\" [textField]=\"'name'\" [valueField]=\"'name'\">\n *    <ng-template kendoComboBoxFixedGroupTemplate let-groupName>\n *      <span>Food type: {{groupName}} option</span>\n *    </ng-template>\n *  </kendo-combobox>\n * `\n * })\n * class AppComponent {\n *   public data = [\n *       { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *       { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *       { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n *   ];\n *   public groupedData = groupBy(this.data, [{field: \"subcategory\"}]);\n * }\n * ```\n */\nclass FixedGroupTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nFixedGroupTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoDropDownListFixedGroupTemplate],[kendoComboBoxFixedGroupTemplate],[kendoAutoCompleteFixedGroupTemplate],[kendoMultiSelectFixedGroupTemplate]'\n            },] },\n];\n/** @nocollapse */\nFixedGroupTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef }\n];\n\n/**\n * @hidden\n */\nclass SelectionService {\n    constructor() {\n        this.onSelect = new EventEmitter();\n        this.onChange = new EventEmitter();\n        this.onFocus = new EventEmitter();\n        this.total = 0;\n        this.selectedIndices = [];\n    }\n    getTotal() {\n        return this.total;\n    }\n    isSelected(index) {\n        return isPresent(this.selectedIndices.find(current => current === index));\n    }\n    isFocused(index) {\n        return index === this.focused;\n    }\n    focus(index) {\n        if (this.isFocused(index)) {\n            return;\n        }\n        this.focused = index;\n        this.onFocus.emit(index);\n    }\n    select(index) {\n        if (this.isSelected(index)) {\n            return;\n        }\n        this.selectedIndices = [index];\n        this.focused = index;\n        this.onSelect.emit({\n            indices: [index],\n            newSelection: isPresent(index)\n        });\n    }\n    add(index) {\n        if (this.isSelected(index)) {\n            return;\n        }\n        this.selectedIndices.push(index);\n        this.focused = index;\n        this.onChange.emit({\n            added: index,\n            indices: this.selectedIndices.slice()\n        });\n    }\n    unselect(index) {\n        if (!this.isSelected(index)) {\n            return;\n        }\n        const position = this.selectedIndices.indexOf(index);\n        this.selectedIndices.splice(position, 1);\n        this.focused = index;\n        this.onChange.emit({\n            indices: this.selectedIndices.slice(),\n            removed: index\n        });\n    }\n    change(index) {\n        const newSelection = isPresent(index) && !this.isSelected(index);\n        this.selectedIndices = [index];\n        this.focused = index;\n        this.onChange.emit({\n            indices: [index],\n            newSelection: newSelection\n        });\n    }\n    resetSelection(index) {\n        this.selectedIndices = index instanceof Array ? index : [index];\n        this.focused = this.selectedIndices[this.selectedIndices.length - 1];\n    }\n    get selected() {\n        return this.selectedIndices.slice();\n    }\n    get focused() {\n        return this.focusedIndex;\n    }\n    set focused(index) {\n        if (this.focusedIndex !== index) {\n            this.focusedIndex = index;\n            this.onFocus.emit(index);\n        }\n    }\n}\nSelectionService.decorators = [\n    { type: Injectable },\n];\n\n/**\n * @hidden\n */\nvar NavigationAction;\n(function (NavigationAction) {\n    NavigationAction[NavigationAction[\"Undefined\"] = 0] = \"Undefined\";\n    NavigationAction[NavigationAction[\"Open\"] = 1] = \"Open\";\n    NavigationAction[NavigationAction[\"Close\"] = 2] = \"Close\";\n    NavigationAction[NavigationAction[\"Enter\"] = 3] = \"Enter\";\n    NavigationAction[NavigationAction[\"Tab\"] = 4] = \"Tab\";\n    NavigationAction[NavigationAction[\"Esc\"] = 5] = \"Esc\";\n    NavigationAction[NavigationAction[\"Delete\"] = 6] = \"Delete\";\n    NavigationAction[NavigationAction[\"Backspace\"] = 7] = \"Backspace\";\n    NavigationAction[NavigationAction[\"Home\"] = 8] = \"Home\";\n    NavigationAction[NavigationAction[\"End\"] = 9] = \"End\";\n    NavigationAction[NavigationAction[\"Up\"] = 10] = \"Up\";\n    NavigationAction[NavigationAction[\"Down\"] = 11] = \"Down\";\n    NavigationAction[NavigationAction[\"Left\"] = 12] = \"Left\";\n    NavigationAction[NavigationAction[\"Right\"] = 13] = \"Right\";\n})(NavigationAction || (NavigationAction = {}));\n\n/**\n * @hidden\n */\nclass DataService {\n    constructor() {\n        this.grouped = false;\n        this.groupIndices = [];\n    }\n    set data(data) {\n        this._data = data;\n        this.grouped = this.isGrouped(data);\n        if (this.grouped) {\n            this.groupIndices = this.getGroupIndices(data);\n            this._flatData = this.flatten(data);\n        }\n    }\n    get data() {\n        if (this.grouped) {\n            return this._flatData;\n        }\n        return this._data;\n    }\n    /**\n     * @hidden\n     * Used to get the actual items count, i.e. excluding the header items in case of grouping.\n     */\n    get itemsCount() {\n        if (!isPresent(this.data) || this.data.length === 0) {\n            return 0;\n        }\n        const items = this.grouped ? this._flatData.filter(item => !item.header) : this.data;\n        return items.length;\n    }\n    /**\n     * @hidden\n     * Used to determine if the component received grouped data.\n     */\n    isGrouped(data) {\n        return (isPresent(data) && data.length !== 0) && isPresent(data[0]) && data[0].items !== undefined;\n    }\n    /**\n     * @hidden\n     * Used to calculate the last item index of each group.\n     */\n    getGroupIndices(data) {\n        let groupIndices = [];\n        for (let i = 0; i <= data.length - 1; i++) {\n            groupIndices[i] = (groupIndices[i - 1] || 0) + data[i].items.length;\n        }\n        return groupIndices;\n    }\n    /**\n     * @hidden\n     * Used to get a flat array containing all items matching certain criteria.\n     */\n    filter(predicate) {\n        let result = [];\n        if (this.isGrouped(this.data)) {\n            for (let i = 0; i <= this.groupIndices.length - 1; i++) {\n                const matches = this.data[i].items.filter(predicate);\n                if (matches) {\n                    result = result.concat(matches);\n                }\n            }\n        }\n        else {\n            result = this.data.filter(predicate);\n        }\n        return result;\n    }\n    /**\n     * @hidden\n     * Used to get the index of a given data item.\n     */\n    indexOf(item, startFrom = 0) {\n        let predicate = (element) => {\n            return element === item;\n        };\n        if (this.grouped) {\n            predicate = (element) => {\n                return element.value === item;\n            };\n        }\n        return this.findIndex(predicate, startFrom);\n    }\n    /**\n     * @hidden\n     * Used to get the index of a data item based on an expression.\n     */\n    findIndex(predicate, startFrom = 0) {\n        let index = -1;\n        if (this.grouped) {\n            const data = this._flatData.filter(item => !item.header && item.offsetIndex >= startFrom);\n            index = data.findIndex(predicate);\n            index = data[index] ? data[index].offsetIndex : -1;\n        }\n        else {\n            const data = this.data.slice(startFrom);\n            const itemIndex = data.findIndex(predicate);\n            index = itemIndex !== -1 ? itemIndex + startFrom : -1;\n        }\n        return index;\n    }\n    /**\n     * @hidden\n     * Used to get the closest group header prior to an item index.\n     */\n    closestGroup(index) {\n        for (let i = index; i >= 0; i--) {\n            if (this._flatData[i].header) {\n                return this._flatData[i];\n            }\n        }\n    }\n    /**\n     * @hidden\n     * Used to get the first item matching the criteria.\n     */\n    find(predicate) {\n        const index = this.findIndex(predicate);\n        return this.itemAt(index);\n    }\n    /**\n     * @hidden\n     * Used to get the true index in a flattened data array.\n     */\n    flatIndex(index) {\n        if (this.itemsCount === 0) {\n            return -1;\n        }\n        if (this.grouped) {\n            const match = this._flatData.find((item) => !item.header && item.offsetIndex === index);\n            if (match) {\n                return match.index;\n            }\n        }\n        else {\n            return index;\n        }\n        return -1;\n    }\n    /**\n     * @hidden\n     * Used to get the item at the provided index.\n     */\n    itemAt(index) {\n        let dataItem;\n        if (this.itemsCount === 0) {\n            return dataItem;\n        }\n        if (this.grouped) {\n            const match = this._flatData.find((item) => !item.header && item.offsetIndex === index);\n            if (match) {\n                dataItem = match.value;\n            }\n        }\n        else {\n            dataItem = this.data[index];\n        }\n        return dataItem;\n    }\n    /**\n     * @hidden\n     * Used to get the group at the provided index.\n     */\n    groupAt(index) {\n        if (this.itemsCount === 0 || !this.isGrouped) {\n            return;\n        }\n        return this._flatData.find((item) => item.header && item.index === index);\n    }\n    /**\n     * @hidden\n     * Used to get the field by which the data is grouped.\n     */\n    groupField() {\n        if (this.itemsCount === 0 || !this.isGrouped) {\n            return;\n        }\n        return this._data[0].field;\n    }\n    /**\n     * @hidden\n     * Used to get the group to which a dataItem belongs.\n     */\n    itemGroup(item) {\n        if (!item || this.itemsCount === 0 || !this.isGrouped) {\n            return;\n        }\n        const fieldName = this.groupField();\n        if (fieldName) {\n            return item[fieldName];\n        }\n    }\n    flatten(data, group = undefined, offset = 0, groupIndex = 0) {\n        let flat = [];\n        if (isPresent(group)) {\n            flat.push({\n                header: true,\n                index: groupIndex + offset,\n                offsetIndex: groupIndex,\n                value: group\n            });\n        }\n        for (let i = 0; i < data.length; i++) {\n            let result = [];\n            if (data[i].items) {\n                result = this.flatten(data[i].items, data[i].value, offset, i);\n                offset = offset + data[i].items.length;\n            }\n            else {\n                result.push({\n                    header: false,\n                    index: groupIndex + offset + i + 1,\n                    offsetIndex: offset + i,\n                    value: data[i]\n                });\n            }\n            flat = flat.concat(result);\n        }\n        return flat;\n    }\n}\nDataService.decorators = [\n    { type: Injectable },\n];\n\n/**\n * @hidden\n */\nclass DisabledItemsService {\n    constructor(dataService) {\n        this.dataService = dataService;\n        this.itemDisabled = null;\n    }\n    isIndexDisabled(index) {\n        if (this.itemDisabled) {\n            const item = this.dataService.itemAt(index);\n            if (isPresent(item)) {\n                return this.itemDisabled({ dataItem: item, index });\n            }\n            else if (isPresent(this.defaultItem)) {\n                return this.itemDisabled({ dataItem: this.defaultItem, index: -1 });\n            }\n        }\n    }\n    isItemDisabled(item) {\n        if (this.itemDisabled) {\n            const index = this.dataService.indexOf(item);\n            if (index !== -1) {\n                return this.itemDisabled({ dataItem: item, index });\n            }\n            else if (isPresent(this.defaultItem)) {\n                return this.itemDisabled({ dataItem: this.defaultItem, index: -1 });\n            }\n        }\n    }\n}\nDisabledItemsService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nDisabledItemsService.ctorParameters = () => [\n    { type: DataService }\n];\n\nconst MIN_INDEX = 0;\n/**\n * @hidden\n */\nclass NavigationEvent {\n    /**\n     * The index of the item to which the user navigated.\n     */\n    constructor(index, originalEvent) {\n        this.index = index;\n        this.originalEvent = originalEvent;\n    }\n}\n/**\n * @hidden\n */\nclass NavigationService {\n    constructor(disabledItemsService, selectionService) {\n        this.disabledItemsService = disabledItemsService;\n        this.selectionService = selectionService;\n        this.open = new EventEmitter();\n        this.close = new EventEmitter();\n        this.enter = new EventEmitter();\n        this.tab = new EventEmitter();\n        this.esc = new EventEmitter();\n        this.up = new EventEmitter();\n        this.right = new EventEmitter();\n        this.down = new EventEmitter();\n        this.left = new EventEmitter();\n        this.delete = new EventEmitter();\n        this.backspace = new EventEmitter();\n        this.home = new EventEmitter();\n        this.end = new EventEmitter();\n    }\n    process(args) {\n        const keyCode = args.originalEvent.keyCode;\n        const altKey = args.originalEvent.altKey;\n        let index;\n        let action = NavigationAction.Undefined;\n        if (altKey && keyCode === Keys.down) {\n            action = NavigationAction.Open;\n        }\n        else if (altKey && keyCode === Keys.up) {\n            action = NavigationAction.Close;\n        }\n        else if (keyCode === Keys.enter) {\n            action = NavigationAction.Enter;\n        }\n        else if (keyCode === Keys.esc) {\n            action = NavigationAction.Esc;\n        }\n        else if (keyCode === Keys.tab) {\n            action = NavigationAction.Tab;\n        }\n        else if (keyCode === Keys.up) {\n            index = this.next({ current: args.current, start: args.min, end: args.max, step: -1 });\n            action = NavigationAction.Up;\n        }\n        else if (keyCode === Keys.left) {\n            index = this.next({ current: args.current, start: args.min, end: args.max, step: -1 });\n            action = NavigationAction.Left;\n        }\n        else if (keyCode === Keys.down) {\n            index = this.next({ current: args.current, start: args.min, end: args.max, step: 1 });\n            action = NavigationAction.Down;\n        }\n        else if (keyCode === Keys.right) {\n            index = this.next({ current: args.current, start: args.min, end: args.max, step: 1 });\n            action = NavigationAction.Right;\n        }\n        else if (keyCode === Keys.home) {\n            index = this.isDisabled(MIN_INDEX) ? args.current : MIN_INDEX;\n            action = NavigationAction.Home;\n        }\n        else if (keyCode === Keys.end) {\n            index = this.isDisabled(args.max) ? args.current : args.max;\n            action = NavigationAction.End;\n        }\n        else if (keyCode === Keys.delete) {\n            action = NavigationAction.Delete;\n        }\n        else if (keyCode === Keys.backspace) {\n            action = NavigationAction.Backspace;\n        }\n        const eventData = new NavigationEvent(index, args.originalEvent);\n        if (action !== NavigationAction.Undefined) {\n            this[NavigationAction[action].toLowerCase()].emit(eventData);\n        }\n        return action;\n    }\n    next(args) {\n        const { current, start, end, step } = args;\n        const nextIndex = !isPresent(current) ? start : this.clampIndex(current + step, start, end);\n        const firstFocusableIndex = this.firstFocusableIndex(nextIndex, start, end, step);\n        if (isPresent(firstFocusableIndex)) {\n            return firstFocusableIndex;\n        }\n        if (this.selectionService.isSelected(current) && current >= start) {\n            return current;\n        }\n        const inversedStep = -1 * step;\n        return this.firstFocusableIndex(nextIndex, start, end, inversedStep);\n    }\n    clampIndex(index, min, max) {\n        if (!isPresent(index) || index < min) {\n            return min;\n        }\n        if (index > max) {\n            return max;\n        }\n        return index;\n    }\n    firstFocusableIndex(startIndex, min, max, step) {\n        while (min <= startIndex && startIndex <= max) {\n            if (!this.isDisabled(startIndex)) {\n                return startIndex;\n            }\n            startIndex += step;\n        }\n        return undefined;\n    }\n    isDisabled(index) {\n        if (this.disabledItemsService) {\n            return this.disabledItemsService.isIndexDisabled(index);\n        }\n    }\n}\nNavigationService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nNavigationService.ctorParameters = () => [\n    { type: DisabledItemsService },\n    { type: SelectionService }\n];\n\n/* tslint:disable:max-line-length */\n/**\n * Renders content when no data is available. To define the no-data template, nest a `<ng-template>` tag\n * with the `kendo<ComponentName>NoDataTemplate` directive inside the component tag.\n *\n * - [Using `NoDataTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-no-data-template)\n * - [Using `NoDataTemplate` with the ComboBox]({% slug templates_combobox %}#toc-no-data-template)\n * - [Using `NoDataTemplate` with the DropDownList]({% slug templates_ddl %}#toc-no-data-template)\n * - [Using `NoDataTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-no-data-template)\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-combobox [data]=\"listItems\">\n *    <ng-template kendoComboBoxNoDataTemplate>\n *      <h4>No data!</h4>\n *    </ng-template>\n *  </kendo-combobox>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<string> = [];\n * }\n * ```\n */\nclass NoDataTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nNoDataTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoDropDownListNoDataTemplate],[kendoComboBoxNoDataTemplate],[kendoAutoCompleteNoDataTemplate],[kendoMultiSelectNoDataTemplate]'\n            },] },\n];\n/** @nocollapse */\nNoDataTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef }\n];\n\n/**\n * @hidden\n */\nclass PreventableEvent {\n    constructor() {\n        this.prevented = false;\n    }\n    /**\n     * Prevents the default action for a specified event.\n     * In this way, the source component suppresses the built-in behavior that follows the event.\n     */\n    preventDefault() {\n        this.prevented = true;\n    }\n    /**\n     * If the event is prevented by any of its subscribers, returns `true`.\n     *\n     * @returns `true` if the default action was prevented. Otherwise, returns `false`.\n     */\n    isDefaultPrevented() {\n        return this.prevented;\n    }\n}\n\n/**\n * Defines the mandatory properties of the `kendoDropDownFilter` directive\n * so that `kendoDropDownFilter` can be used with any of the DropDowns components\n * which implement the `FilterableDropDownComponentBase` class.\n *\n * @hidden\n */\nclass FilterableDropDownComponentBase {\n}\n\n/**\n * @hidden\n */\nclass ListItemDirective {\n    constructor(element) {\n        this.element = element;\n    }\n}\nListItemDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '\"li[role=option], li[role=group]\"' // tslint:disable-line\n            },] },\n];\n/** @nocollapse */\nListItemDirective.ctorParameters = () => [\n    { type: ElementRef }\n];\n\n/**\n * @hidden\n */\nclass ListComponent {\n    /* tslint:disable:member-ordering */\n    constructor(dataService, wrapper, selectionService, disabledItemsService, cdr, zone, renderer) {\n        this.dataService = dataService;\n        this.wrapper = wrapper;\n        this.selectionService = selectionService;\n        this.disabledItemsService = disabledItemsService;\n        this.cdr = cdr;\n        this.zone = zone;\n        this.renderer = renderer;\n        this.selected = [];\n        this.focused = -1;\n        this.show = true;\n        this.multipleSelection = false;\n        this.onClick = new EventEmitter();\n        this.pageChange = new EventEmitter();\n        this.startFrom = 0;\n        this.lastLoaded = 0;\n        this.lastScrollTop = 0;\n        this.scrollToFocused = false;\n        this.selectSubscription = merge(this.selectionService.onSelect.pipe(map((args) => args.indices[0])), this.selectionService.onFocus).subscribe(this.scrollToItem.bind(this));\n    }\n    set data(data) {\n        this._data = data[0] && data[0].header ? data.slice(0) : data;\n    }\n    get data() {\n        return this._data;\n    }\n    set items(items) {\n        this._items = items;\n    }\n    get items() {\n        return this._items;\n    }\n    get pageSize() {\n        if (this.virtual.pageSize) {\n            return this.virtual.pageSize;\n        }\n        let size = Math.round(this.height / this.virtual.itemHeight);\n        return size;\n    }\n    get scrollHeight() {\n        return (this.dataService.grouped ? this.virtual.total - 1 : this.virtual.total) * this.virtual.itemHeight;\n    }\n    ngOnChanges(changes) {\n        if (isChanged('data', changes, false)) {\n            if (this.lastLoaded <= 0) {\n                this.lastLoaded = this.data.length - 1;\n                this.scrollToFocused = !changes.data.isFirstChange();\n            }\n        }\n    }\n    ngAfterViewInit() {\n        this.zone.runOutsideAngular(() => {\n            this.scrollSubscription = fromEvent(this.content.nativeElement, \"scroll\").pipe(auditTime(100), tap(this.prefetchData.bind(this)), tap(this.findCurrentGroup.bind(this))).subscribe(() => {\n                this.lastScrollTop = this.content.nativeElement.scrollTop;\n            });\n        });\n    }\n    ngAfterViewChecked() {\n        if (this.virtual) {\n            this.positionItems();\n        }\n        if (this.items && this.scrollToFocused) {\n            this.scrollToFocused = false;\n            const scrollTarget = this.items.length && this.selectionService.focused === -1 ? 0 : this.selectionService.focused;\n            this.scrollToItem(scrollTarget);\n        }\n        if (this.dataService.grouped) {\n            this.findCurrentGroup();\n        }\n    }\n    ngOnDestroy() {\n        this.selectSubscription.unsubscribe();\n        if (this.scrollSubscription) {\n            this.scrollSubscription.unsubscribe();\n        }\n    }\n    firstVisibleItem() {\n        const content = this.content.nativeElement;\n        const contentParent = content.offsetParent;\n        const offsetY = (contentParent ? contentParent.offsetTop : 0) + content.offsetTop + 1;\n        const offsetX = (contentParent ? contentParent.offsetLeft : 0) + content.offsetLeft + 1;\n        const item = document.elementFromPoint(offsetX, offsetY);\n        return item;\n    }\n    findCurrentGroup() {\n        if (!this.dataService.grouped) {\n            this.currentGroup = undefined;\n            return;\n        }\n        const item = this.firstVisibleItem();\n        if (item) {\n            let index;\n            if (item.getAttribute(\"role\") === \"group\") {\n                index = parseInt(item.getAttribute(\"group-index\"), 10);\n                this.currentGroup = this.dataService.groupAt(index).value;\n            }\n            else {\n                index = parseInt(item.getAttribute(\"index\"), 10);\n                this.currentGroup = this.dataService.itemGroup(this.dataService.itemAt(index));\n            }\n        }\n        else {\n            this.currentGroup = undefined;\n        }\n        this.cdr.detectChanges();\n    }\n    prefetchData() {\n        if (!this.virtual) {\n            return;\n        }\n        const visibleItems = Math.trunc(this.content.nativeElement.clientHeight / this.virtual.itemHeight);\n        const offsetY = this.content.nativeElement.scrollTop;\n        const start = Math.trunc(offsetY / this.virtual.itemHeight);\n        const down = offsetY > this.lastScrollTop;\n        const nextPage = (start + visibleItems >= this.lastLoaded) && this.lastLoaded < this.virtual.total - 1;\n        const leftOver = this.pageSize - (this.lastLoaded - this.startFrom);\n        const prevPage = this.lastLoaded - this.pageSize + visibleItems >= start - leftOver;\n        if (down && nextPage) {\n            this.changePage(start);\n        }\n        if (!down && prevPage) {\n            this.changePage(start - this.pageSize + visibleItems + 1);\n        }\n    }\n    changePage(start) {\n        this.zone.run(() => {\n            let end = this.pageSize + start;\n            if (end > this.virtual.total) {\n                start--;\n                end = this.virtual.total;\n            }\n            if (start < 0) {\n                start = 0;\n            }\n            this.startFrom = start;\n            this.lastLoaded = end;\n            this.pageChange.emit({ skip: start, take: this.pageSize });\n        });\n    }\n    index(groupIndex, itemIndex) {\n        return groupIndex > 0 ? (this.dataService.groupIndices[groupIndex - 1] + itemIndex) : itemIndex;\n    }\n    getText(dataItem) {\n        return getter(dataItem, this.textField);\n    }\n    getValue(dataItem) {\n        return getter(dataItem, this.valueField);\n    }\n    isDisabled(index) {\n        return this.disabledItemsService.isIndexDisabled(index);\n    }\n    scrollToItem(index) {\n        if (this.virtual && index > -1) {\n            let flatIndex = index;\n            if (this.dataService.grouped) {\n                flatIndex = this.dataService.flatIndex(index);\n            }\n            this.scrollToIndex(flatIndex);\n            return;\n        }\n        const items = this.items.toArray();\n        if (isPresent(items[index]) && index !== -1) {\n            this.scroll(items[index].element);\n        }\n    }\n    scrollToIndex(index) {\n        let content = this.content.nativeElement;\n        let contentScrollTop = content.scrollTop;\n        const itemOffsetTop = index * this.virtual.itemHeight;\n        const itemOffsetHeight = this.virtual.itemHeight;\n        const contentOffsetHeight = content.clientHeight;\n        const bottomDistance = itemOffsetTop + itemOffsetHeight;\n        if (contentScrollTop > itemOffsetTop) {\n            contentScrollTop = itemOffsetTop;\n        }\n        else if (bottomDistance > (contentScrollTop + contentOffsetHeight)) {\n            contentScrollTop = (bottomDistance - contentOffsetHeight);\n        }\n        content.scrollTop = contentScrollTop;\n    }\n    scroll(item) {\n        if (!item) {\n            return;\n        }\n        const nativeElement = item.nativeElement;\n        let content = this.content.nativeElement, itemOffsetTop = nativeElement.offsetTop, itemOffsetHeight = nativeElement.offsetHeight, contentScrollTop = content.scrollTop, contentOffsetHeight = content.clientHeight, bottomDistance = itemOffsetTop + itemOffsetHeight;\n        if (contentScrollTop > itemOffsetTop) {\n            contentScrollTop = itemOffsetTop;\n        }\n        else if (bottomDistance > (contentScrollTop + contentOffsetHeight)) {\n            contentScrollTop = (bottomDistance - contentOffsetHeight);\n        }\n        content.scrollTop = contentScrollTop;\n    }\n    positionItems() {\n        this.items.forEach((item, index) => {\n            const offsetY = (index + this.startFrom) * this.virtual.itemHeight;\n            this.renderer.setStyle(item.element.nativeElement, \"transform\", `translateY(${offsetY}px`);\n        });\n    }\n}\nListComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-list',\n                template: `\n    <div *ngIf=\"dataService.grouped\"\n        class='k-outer-group-header k-first'\n        [ngClass]=\"{'k-virtual-item': virtual}\"\n        [ngStyle]=\"{\n            'height.px': virtual?.itemHeight,\n            'minHeight.px' : virtual?.itemHeight,\n            'boxSizing' : virtual ? 'border-box' : 'inherit'}\"\n        >\n        <ng-template *ngIf=\"fixedGroupTemplate\"\n            [templateContext]=\"{\n                templateRef: fixedGroupTemplate.templateRef,\n                $implicit: currentGroup\n            }\">\n        </ng-template>\n        <ng-template [ngIf]=\"!fixedGroupTemplate\"><strong>{{ currentGroup }}</strong> </ng-template>\n    </div>\n    <div #content\n         [ngClass]=\"{ 'k-virtual-content': virtual, 'k-list-scroller': !virtual }\"\n         [style.maxHeight.px]=\"height\"\n         unselectable=\"on\">\n    <ul #list\n        role=\"listbox\"\n        class=\"k-list k-reset\"\n        [ngClass]=\"{ 'k-virtual-list': virtual }\"\n        [attr.id]=\"id\"\n        [attr.aria-hidden]=\"!show\">\n         <ng-template *ngIf=\"!dataService.grouped && show\" ngFor let-dataItem let-itemIndex=\"index\" [ngForOf]=\"data\">\n            <li\n                role=\"option\"\n                kendoDropDownsSelectable\n                [height]=\"virtual?.itemHeight\"\n                [index]=\"itemIndex + startFrom\"\n                [multipleSelection]=\"multipleSelection\"\n                [attr.id]=\"optionPrefix + '-' + getValue(dataItem)\"\n                [attr.tabIndex]=\"-1\"\n                class=\"k-item\"\n                [ngClass]=\"{ 'k-virtual-item': virtual, 'k-state-disabled': isDisabled(itemIndex) }\">\n                <ng-template *ngIf=\"template\"\n                    [templateContext]=\"{\n                        templateRef: template.templateRef,\n                        $implicit: dataItem\n                    }\">\n                </ng-template>\n                <ng-template [ngIf]=\"!template\">{{ getText(dataItem) }}</ng-template>\n            </li>\n         </ng-template>\n         <ng-template *ngIf=\"dataService.grouped\" ngFor let-dataItem let-itemIndex=\"index\" [ngForOf]=\"data\">\n            <li\n                *ngIf=\"dataItem.header && dataItem.index > 0\"\n                role=\"group\"\n                class='k-outer-group-header'\n                [ngClass]=\"{ 'k-virtual-item': virtual }\"\n                [ngStyle]=\"{\n                    'height.px': virtual?.itemHeight,\n                    'minHeight.px' : virtual?.itemHeight,\n                    'boxSizing' : virtual ? 'border-box' : 'inherit'}\"\n                [attr.group-index]=\"dataItem.index\"\n                [attr.id]=\"optionPrefix + '-' + getValue(dataItem.value)\"\n                [attr.tabIndex]=\"-1\">\n                    <ng-template *ngIf=\"groupTemplate\"\n                          [templateContext]=\"{\n                            templateRef: groupTemplate.templateRef,\n                            $implicit: dataItem.value\n                    }\">\n                    </ng-template>\n                    <ng-template [ngIf]=\"!groupTemplate\"><strong> {{ dataItem.value }}</strong> </ng-template>\n              </li>\n            <li\n                *ngIf=\"!dataItem.header\"\n                role=\"option\"\n                kendoDropDownsSelectable\n                [height]=\"virtual?.itemHeight\"\n                [index]=\"dataItem.offsetIndex\"\n                [multipleSelection]=\"multipleSelection\"\n                [attr.absolute-index]=\"dataItem.index\"\n                [attr.id]=\"optionPrefix + '-' + getValue(dataItem.value)\"\n                [attr.tabIndex]=\"-1\"\n                class=\"k-item\"\n                [ngClass]=\"{ 'k-virtual-item': virtual, 'k-state-disabled': isDisabled(dataItem.offsetIndex) }\">\n                <ng-template *ngIf=\"template\"\n                    [templateContext]=\"{\n                        templateRef: template.templateRef,\n                        $implicit: dataItem.value\n                    }\">\n                </ng-template>\n                <ng-template [ngIf]=\"!template\">{{ getText(dataItem.value) }}</ng-template>\n            </li>\n        </ng-template>\n    </ul>\n    <div *ngIf=\"virtual\" class=\"k-height-container\" role=\"presentation\">\n        <div [style.height.px]=\"scrollHeight\"></div>\n    </div>\n    </div>\n  `\n            },] },\n];\n/** @nocollapse */\nListComponent.ctorParameters = () => [\n    { type: DataService },\n    { type: ElementRef },\n    { type: SelectionService },\n    { type: DisabledItemsService },\n    { type: ChangeDetectorRef },\n    { type: NgZone },\n    { type: Renderer2 }\n];\nListComponent.propDecorators = {\n    selected: [{ type: Input }],\n    focused: [{ type: Input }],\n    textField: [{ type: Input }],\n    valueField: [{ type: Input }],\n    height: [{ type: Input }],\n    template: [{ type: Input }],\n    groupTemplate: [{ type: Input }],\n    fixedGroupTemplate: [{ type: Input }],\n    show: [{ type: Input }],\n    id: [{ type: Input }],\n    optionPrefix: [{ type: Input }],\n    multipleSelection: [{ type: Input }],\n    virtual: [{ type: Input }],\n    data: [{ type: Input }],\n    onClick: [{ type: Output }],\n    pageChange: [{ type: Output }],\n    items: [{ type: ViewChildren, args: [ListItemDirective,] }],\n    content: [{ type: ViewChild, args: ['content',] }],\n    list: [{ type: ViewChild, args: ['list',] }]\n};\n\n/**\n * @hidden\n */\nconst DEFAULTS = {\n    pageSize: 50,\n    itemHeight: 28\n};\n/**\n * @hidden\n */\nconst normalizeVirtualizationSettings = (settings) => {\n    if (settings === true) {\n        return DEFAULTS;\n    }\n    if (!settings) {\n        return null;\n    }\n    return Object.assign({ pageSize: DEFAULTS.pageSize }, settings);\n};\n\n/* tslint:disable:no-null-keyword */\nconst NO_VALUE = \"\";\n/**\n * @hidden\n */\nconst AUTOCOMPLETE_VALUE_ACCESSOR = {\n    multi: true,\n    provide: NG_VALUE_ACCESSOR,\n    // tslint:disable-next-line:no-use-before-declare\n    useExisting: forwardRef(() => AutoCompleteComponent)\n};\n/**\n * Represents the [Kendo UI AutoComplete component for Angular]({% slug overview_autocomplete %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-autocomplete\n *      [data]=\"listItems\"\n *      [placeholder]=\"placeholder\"\n *  >\n * `\n * })\n * class AppComponent {\n *   public placeholder: string = 'Type \"it\" for suggestions';\n *   public listItems: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\nclass AutoCompleteComponent {\n    constructor(localization, dataService, popupService, selectionService, navigationService, disabledItemsService, _zone, cdr, renderer, wrapper) {\n        this.localization = localization;\n        this.dataService = dataService;\n        this.popupService = popupService;\n        this.selectionService = selectionService;\n        this.navigationService = navigationService;\n        this.disabledItemsService = disabledItemsService;\n        this._zone = _zone;\n        this.cdr = cdr;\n        this.renderer = renderer;\n        /**\n         * Defines whether the first match from the suggestions list will be automatically focused.\n         * By default, `highlightFirst` is set to `true`.\n         */\n        this.highlightFirst = true;\n        /**\n         * @hidden\n         */\n        this.focusableId = `k-${guid()}`;\n        /**\n         * The hint which is displayed when the component is empty.\n         */\n        this.placeholder = \"\";\n        /**\n         * Sets the height of the suggestions list. By default, `listHeight` is 200px.\n         *\n         * > The `listHeight` property affects only the list of suggestions and not the whole popup container.\n         * > To set the height of the popup container, use `popupSettings.height`.\n         */\n        this.listHeight = 200;\n        /**\n         * @hidden\n         *\n         * If set to `true`, renders a button on hovering over the component.\n         * Clicking this button resets the value of the component to `undefined` and triggers the `change` event.\n         */\n        this.clearButton = true;\n        /**\n         * Sets the disabled state of the component.\n         */\n        this.disabled = false;\n        /**\n         * Sets the read-only state of the component.\n         */\n        this.readonly = false;\n        /**\n         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n         */\n        this.tabindex = 0;\n        /**\n         * Enables the [filtering]({% slug filtering_autocomplete %}) functionality.\n         * If set to `true`, the component emits the `filterChange` event.\n         */\n        this.filterable = false;\n        /**\n         * Fires each time the value is changed&mdash;\n         * when the component is blurred or the value is cleared through the **Clear** button\n         * ([see example]({% slug overview_autocomplete %}#toc-events)).\n         * When the value of the component is programmatically changed to `ngModel` or `formControl`\n         * through its API or form binding, the `valueChange` event is not triggered because it\n         * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * Fires each time the user types in the input field.\n         * You can filter the source based on the passed filtration value\n         * ([see example]({% slug overview_autocomplete %}#toc-events)).\n         */\n        this.filterChange = new EventEmitter();\n        /**\n         * Fires each time the popup is about to open.\n         * This event is preventable. If you cancel it, the popup will remain closed.\n         */\n        this.open = new EventEmitter();\n        /**\n         * Fires each time the popup is about to close.\n         * This event is preventable. If you cancel it, the popup will remain open.\n         */\n        this.close = new EventEmitter();\n        /**\n         * Fires each time the user focuses the AutoComplete.\n         */\n        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the AutoComplete gets blurred.\n         */\n        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename\n        this.widgetClasses = true;\n        this.listBoxId = guid();\n        this.optionPrefix = guid();\n        this.onChangeCallback = (_value) => { };\n        this.onTouchedCallback = (_) => { };\n        this.popupMouseDownHandler = (event) => event.preventDefault();\n        this._popupSettings = { animate: true };\n        this._open = false;\n        this._value = \"\";\n        this._previousValue = NO_VALUE;\n        this._filtering = false;\n        this.valueChangeSubject = new Subject();\n        this._isFocused = false;\n        this.direction = localization.rtl ? 'rtl' : 'ltr';\n        this.wrapper = wrapper.nativeElement;\n        this.data = [];\n        this.subscribeEvents();\n        this.selectionService.resetSelection([-1]);\n    }\n    get width() {\n        let wrapperOffsetWidth = 0;\n        if (isDocumentAvailable()) {\n            wrapperOffsetWidth = this.wrapper.offsetWidth;\n        }\n        const width = this.popupSettings.width || wrapperOffsetWidth;\n        const minWidth = isNaN(wrapperOffsetWidth) ? wrapperOffsetWidth : `${wrapperOffsetWidth}px`;\n        const maxWidth = isNaN(width) ? width : `${width}px`;\n        return { min: minWidth, max: maxWidth };\n    }\n    get height() {\n        const popupHeight = this.popupSettings.height;\n        return isPresent(popupHeight) ? `${popupHeight}px` : 'auto';\n    }\n    get listContainerClasses() {\n        const containerClasses = ['k-list-container', 'k-reset'];\n        if (this.popupSettings.popupClass) {\n            containerClasses.push(this.popupSettings.popupClass);\n        }\n        return containerClasses;\n    }\n    get suggestion() {\n        if (!this.text || !this.suggestedText) {\n            this.suggestedText = undefined;\n            return;\n        }\n        const hasMatch = this.suggestedText.toLowerCase().startsWith(this.text.toLowerCase());\n        const shouldSuggest = this.suggest && !this.backspacePressed;\n        if (shouldSuggest && hasMatch) {\n            return this.suggestedText;\n        }\n    }\n    get appendTo() {\n        const { appendTo } = this.popupSettings;\n        if (!appendTo || appendTo === 'root') {\n            return undefined;\n        }\n        return appendTo === 'component' ? this.container : appendTo;\n    }\n    /**\n     * Toggles the visibility of the popup.\n     * If you use the `toggle` method to open or close the popup, the `open` and `close` events will not be fired.\n     *\n     * @param open - The state of the popup.\n     */\n    toggle(open) {\n        Promise.resolve(null).then(() => {\n            this._toggle(open);\n        });\n    }\n    /**\n     * Returns the current open state of the popup.\n     */\n    get isOpen() {\n        return this._open;\n    }\n    /**\n     * @hidden\n     */\n    togglePopup(open) {\n        const isDisabled = this.disabled || this.readonly;\n        const sameState = this.isOpen === open;\n        if (isDisabled || sameState) {\n            return;\n        }\n        const isDefaultPrevented = this.triggerPopupEvents(open);\n        if (!isDefaultPrevented) {\n            this._toggle(open);\n        }\n    }\n    get activeDescendant() {\n        if (!this.isOpen || !isPresent(this.selectionService.focused) || this.selectionService.focused === -1) {\n            return null;\n        }\n        const dataItem = this.dataService.itemAt(this.selectionService.focused);\n        return this.optionPrefix + \"-\" + getter(dataItem, this.valueField);\n    }\n    get noDataLabel() {\n        if (this.data.length === 0) {\n            return this.noDataText;\n        }\n    }\n    get clearTitle() {\n        return this.localization.get('clearTitle');\n    }\n    /**\n     * Sets the data of the AutoComplete.\n     *\n     * > The data has to be provided in an array-like list.\n     */\n    set data(data) {\n        this.dataService.data = data || [];\n        if (this.virtual) {\n            this.virtual.skip = 0;\n        }\n        this.setState(this.value);\n        if (this.filterable) {\n            this.selectionService.focused = this.isOpen && this.data.length && this.highlightFirst ? this.firstFocusableIndex(0) : -1;\n        }\n        if (this.suggest && this.dataService.itemsCount > 0) {\n            this.suggestedText = getter(this.dataService.itemAt(0), this.valueField);\n        }\n    }\n    get data() {\n        const virtual = this.virtual;\n        if (virtual) {\n            const start = virtual.skip || 0;\n            const end = start + virtual.pageSize;\n            // Use length instead of itemsCount because of the grouping.\n            virtual.total = this.dataService.data.length;\n            return this.dataService.data.slice(start, end);\n        }\n        return this.dataService.data;\n    }\n    /**\n     * Sets the value of the AutoComplete.\n     */\n    set value(newValue) {\n        this.verifySettings(newValue);\n        this._value = newValue || NO_VALUE;\n        this.cdr.markForCheck();\n    }\n    get value() {\n        return this._value || NO_VALUE;\n    }\n    /**\n     * Configures the popup of the AutoComplete.\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped. The `auto` mode is not supported when virtual scrolling is enabled.\n     * - `height: Number`&mdash;Sets the height of the popup container.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     * - `appendTo: \"root\" | \"component\" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.\n     */\n    set popupSettings(settings) {\n        this._popupSettings = Object.assign({ animate: true }, settings);\n    }\n    get popupSettings() {\n        return this._popupSettings;\n    }\n    /**\n     * Defines a Boolean function that is executed for each data item in the component\n     * ([see examples]({% slug disableditems_autocomplete %})).\n     * Determines whether the item will be disabled.\n     */\n    set itemDisabled(fn) {\n        if (typeof fn !== 'function') {\n            throw new Error(`itemDisabled must be a function, but received ${JSON.stringify(fn)}.`);\n        }\n        this.disabledItemsService.itemDisabled = fn;\n    }\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n        this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n        return this.tabindex;\n    }\n    /**\n     * Enables the [virtualization]({% slug virtualization_autocomplete %}) functionality.\n     */\n    set virtual(settings) {\n        this._virtualSettings = normalizeVirtualizationSettings(settings);\n    }\n    get virtual() {\n        return this._virtualSettings;\n    }\n    get isFocused() {\n        return this._isFocused;\n    }\n    set isFocused(isFocused) {\n        this._isFocused = isFocused;\n    }\n    get isDisabled() {\n        return this.disabled;\n    }\n    get dir() {\n        return this.direction;\n    }\n    ngOnInit() {\n        this.renderer.removeAttribute(this.wrapper, \"tabindex\");\n        this.localizationChangeSubscription = this.localization\n            .changes\n            .subscribe(({ rtl }) => {\n            this.direction = rtl ? 'rtl' : 'ltr';\n            this.setMessages();\n        });\n        this.setMessages();\n    }\n    ngOnDestroy() {\n        this.destroyPopup();\n        this.unsubscribeEvents();\n        clearTimeout(this.messagesTimeout);\n        if (this.localizationChangeSubscription) {\n            this.localizationChangeSubscription.unsubscribe();\n        }\n    }\n    ngOnChanges(changes) {\n        const virtual = this.virtual;\n        const requestInitialData = virtual && changes.data && changes.data.isFirstChange();\n        if (requestInitialData) {\n            this.pageChange({ skip: 0, take: virtual.pageSize });\n        }\n        const STATE_PROPS = /(value|valueField)/g;\n        if (STATE_PROPS.test(Object.keys(changes).join())) {\n            this.setState(this.value);\n        }\n    }\n    /**\n     * Resets the value of the AutoComplete.\n     * If you use the `reset` method to clear the value of the component,\n     * the model will not update automatically and the `selectionChange` and `valueChange` events will not be fired.\n     */\n    reset() {\n        this.setState(NO_VALUE);\n    }\n    /**\n     * @hidden\n     */\n    clearValue(event) {\n        event.stopImmediatePropagation();\n        this.focus();\n        this.change(NO_VALUE);\n        if (this.filterable) {\n            this.filterChange.emit('');\n        }\n        this.selectionService.resetSelection([]);\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n        this.setState(value);\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.onChangeCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.onTouchedCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n    }\n    /**\n     * Focuses the AutoComplete.\n     */\n    focus() {\n        if (!this.disabled) {\n            this.searchbar.focus();\n        }\n    }\n    /**\n     * Blurs the AutoComplete.\n     */\n    blur() {\n        if (!this.disabled) {\n            this.searchbar.blur();\n        }\n    }\n    /**\n     * @hidden\n     */\n    onResize() {\n        if (this._open) {\n            const popupWrapper = this.popupRef.popupElement;\n            const { min, max } = this.width;\n            popupWrapper.style.minWidth = min;\n            popupWrapper.style.width = max;\n        }\n    }\n    emitChange() {\n        if (this.value === this._previousValue) {\n            return;\n        }\n        this._previousValue = this.value;\n        this.onChangeCallback(this.value);\n        this.valueChange.emit(this.value);\n    }\n    verifySettings(newValue) {\n        if (!isDevMode()) {\n            return;\n        }\n        if (isPresent(newValue) && typeof newValue !== \"string\") {\n            throw new Error(\"Expected value of type string. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/autocomplete/#toc-value\");\n        }\n    }\n    search(text, startFrom = 0) {\n        let index;\n        if (text.length && this.dataService.itemsCount) {\n            index = this.dataService.findIndex(this.findIndexPredicate(text), startFrom);\n        }\n        else {\n            index = -1;\n        }\n        if (this.disabledItemsService.isIndexDisabled(index)) {\n            if (index + 1 < this.dataService.itemsCount) {\n                this.search(text, index + 1);\n            }\n            else {\n                this.selectionService.focus(-1);\n            }\n        }\n        else {\n            this.selectionService.focus(index);\n            if (this.suggest) {\n                this.suggestedText = getter(this.dataService.itemAt(index), this.valueField);\n            }\n        }\n    }\n    navigate(index) {\n        if (!this.isOpen) {\n            return;\n        }\n        this.selectionService.focus(index);\n    }\n    /**\n     * @hidden\n     */\n    handleNavigate(event) {\n        const focused = isNaN(this.selectionService.focused) ? this.firstFocusableIndex(0) : this.selectionService.focused;\n        if (this.disabled || this.readonly || isNaN(focused)) {\n            return;\n        }\n        const action = this.navigationService.process({\n            current: focused,\n            max: this.dataService.itemsCount - 1,\n            min: 0,\n            originalEvent: event\n        });\n        if (action !== NavigationAction.Undefined &&\n            action !== NavigationAction.Backspace &&\n            action !== NavigationAction.Delete &&\n            action !== NavigationAction.Home &&\n            action !== NavigationAction.End &&\n            action !== NavigationAction.Left &&\n            action !== NavigationAction.Right &&\n            ((action === NavigationAction.Enter && this.isOpen) || action !== NavigationAction.Enter)) {\n            event.preventDefault();\n        }\n    }\n    handleEnter(event) {\n        const focused = this.selectionService.focused;\n        let value;\n        this._filtering = false;\n        if (this.isOpen) {\n            event.originalEvent.preventDefault();\n        }\n        if (focused >= 0) {\n            value = getter(this.dataService.itemAt(focused), this.valueField);\n        }\n        else {\n            const match = this.suggest && this.suggestedText && this.data.length &&\n                getter(this.dataService.itemAt(0), this.valueField, true).toLowerCase() === this.searchbar.value.toLowerCase();\n            if (this.isOpen && match) {\n                value = this.suggestedText;\n            }\n            else {\n                value = this.searchbar.value;\n            }\n        }\n        this.change(value);\n    }\n    handleEscape() {\n        this.togglePopup(false);\n        this.selectionService.focused = -1;\n        this.suggestedText = null;\n    }\n    /**\n     * @hidden\n     */\n    searchBarChange(text) {\n        const currentTextLength = isPresent(this.text) ? this.text.length : 0;\n        this.backspacePressed = (text.length < currentTextLength) ? true : false;\n        this.text = text;\n        this.togglePopup(text.length > 0);\n        this._filtering = true;\n        if (!this.highlightFirst) {\n            this.selectionService.focused = -1;\n        }\n        if (this.filterable) {\n            this.filterChange.emit(text);\n        }\n        else if (this.highlightFirst) {\n            this.search(text);\n        }\n    }\n    /**\n     * @hidden\n     */\n    handleFocus() {\n        this.isFocused = true;\n        this.onFocus.emit();\n    }\n    /**\n     * @hidden\n     */\n    handleBlur() {\n        this._filtering = false;\n        const focused = this.filterable ? this.selectionService.focused : -1;\n        let dataItem;\n        let text;\n        if (focused !== -1) {\n            dataItem = this.dataService.itemAt(focused);\n            text = getter(dataItem, this.valueField, true) || \"\";\n        }\n        else {\n            text = this.searchbar.value;\n        }\n        const exactMatch = text === this.searchbar.value;\n        const insensitiveMatch = text.toLowerCase() === this.searchbar.value.toLowerCase();\n        if (!exactMatch && insensitiveMatch) {\n            this.selectionService.resetSelection([]);\n        }\n        this.change(this.searchbar.value);\n        this.togglePopup(false);\n        this.isFocused = false;\n        this.onBlur.emit();\n        this.onTouchedCallback();\n    }\n    /**\n     * @hidden\n     */\n    pageChange(event) {\n        const virtual = this.virtual;\n        virtual.skip = event.skip;\n    }\n    setState(newValue) {\n        if (this._filtering) {\n            return;\n        }\n        this.value = newValue;\n        this._previousValue = this.value;\n        this.text = this.value;\n    }\n    change(value) {\n        this.togglePopup(false);\n        this.valueChangeSubject.next(value);\n    }\n    subscribeEvents() {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        this.valueChangeSubscription = this.valueChangeSubject.pipe(filter((candidate) => {\n            return !(this.value === candidate && this.text === candidate);\n        }))\n            .subscribe((value) => {\n            this.value = value;\n            this.text = value;\n            this.emitChange();\n        });\n        this.changeSubscription = this.selectionService.onChange.subscribe(this.handleItemChange.bind(this));\n        this.focusSubscription = this.selectionService.onFocus.subscribe(this.handleItemFocus.bind(this));\n        this.navigationSubscription = merge(this.navigationService.up, this.navigationService.down).subscribe((event) => this.navigate(event.index));\n        this.closeSubscription = this.navigationService.close.subscribe(() => this.togglePopup(false));\n        this.enterSubscription = this.navigationService.enter.subscribe(this.handleEnter.bind(this));\n        this.escSubscription = this.navigationService.esc.subscribe(this.handleEscape.bind(this));\n    }\n    unsubscribeEvents() {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        this.changeSubscription.unsubscribe();\n        this.navigationSubscription.unsubscribe();\n        this.closeSubscription.unsubscribe();\n        this.enterSubscription.unsubscribe();\n        this.escSubscription.unsubscribe();\n        this.valueChangeSubscription.unsubscribe();\n        this.focusSubscription.unsubscribe();\n    }\n    handleItemChange(event) {\n        const index = event.indices.length ? event.indices[0] : undefined;\n        this._filtering = false;\n        this.selectionService.resetSelection([-1]);\n        if (!isPresent(index)) {\n            return;\n        }\n        let text = getter(this.dataService.itemAt(index), this.valueField);\n        this.change(text);\n    }\n    handleItemFocus(_event) {\n        const focused = this.selectionService.focused;\n        const shouldSuggest = Boolean(this.suggest && this.data && this.data.length && focused >= 0);\n        if (shouldSuggest) {\n            this.suggestedText = getter(this.dataService.itemAt(focused), this.valueField);\n        }\n    }\n    createPopup() {\n        if (this.virtual) {\n            this.virtual.skip = 0;\n        }\n        const horizontalAlign = this.direction === \"rtl\" ? \"right\" : \"left\";\n        const anchorPosition = { horizontal: horizontalAlign, vertical: \"bottom\" };\n        const popupPosition = { horizontal: horizontalAlign, vertical: \"top\" };\n        this.popupRef = this.popupService.open({\n            anchor: this.wrapper,\n            animate: this.popupSettings.animate,\n            appendTo: this.appendTo,\n            content: this.popupTemplate,\n            popupClass: this.listContainerClasses,\n            positionMode: 'absolute',\n            popupAlign: popupPosition,\n            anchorAlign: anchorPosition\n        });\n        const popupWrapper = this.popupRef.popupElement;\n        const { min, max } = this.width;\n        popupWrapper.addEventListener('mousedown', this.popupMouseDownHandler);\n        popupWrapper.style.minWidth = min;\n        popupWrapper.style.width = max;\n        popupWrapper.style.height = this.height;\n        popupWrapper.setAttribute(\"dir\", this.direction);\n        this.popupRef.popupOpen.subscribe(() => {\n            this.cdr.detectChanges();\n            this.optionsList.scrollToItem(this.selectionService.focused);\n        });\n        this.popupRef.popupAnchorViewportLeave.subscribe(() => this.togglePopup(false));\n    }\n    destroyPopup() {\n        if (this.popupRef) {\n            this.popupRef.popupElement\n                .removeEventListener('mousedown', this.popupMouseDownHandler);\n            this.popupRef.close();\n            this.popupRef = null;\n        }\n    }\n    _toggle(open) {\n        this._open = (open === undefined) ? !this._open : open;\n        this.destroyPopup();\n        if (this._open) {\n            this.createPopup();\n        }\n    }\n    triggerPopupEvents(open) {\n        const eventArgs = new PreventableEvent();\n        if (open) {\n            this.open.emit(eventArgs);\n        }\n        else {\n            this.close.emit(eventArgs);\n        }\n        return eventArgs.isDefaultPrevented();\n    }\n    firstFocusableIndex(index) {\n        const maxIndex = this.data.length - 1;\n        if (this.disabledItemsService.isIndexDisabled(index)) {\n            return (index < maxIndex) ? this.firstFocusableIndex(index + 1) : undefined;\n        }\n        else {\n            return index;\n        }\n    }\n    findIndexPredicate(text) {\n        if (this.dataService.grouped) {\n            return (item) => {\n                let itemText = getter(item.value, this.valueField);\n                itemText = !isPresent(itemText) ? \"\" : itemText.toString().toLowerCase();\n                return itemText.startsWith(text.toLowerCase());\n            };\n        }\n        else {\n            return (item) => {\n                let itemText = getter(item, this.valueField);\n                itemText = !isPresent(itemText) ? \"\" : itemText.toString().toLowerCase();\n                return itemText.startsWith(text.toLowerCase());\n            };\n        }\n    }\n    setMessages() {\n        this._zone.runOutsideAngular(() => {\n            clearTimeout(this.messagesTimeout);\n            this.messagesTimeout = setTimeout(() => {\n                this.noDataText = this.localization.get('noDataText');\n                this.cdr.detectChanges();\n            });\n        });\n    }\n}\nAutoCompleteComponent.decorators = [\n    { type: Component, args: [{\n                exportAs: 'kendoAutoComplete',\n                providers: [\n                    AUTOCOMPLETE_VALUE_ACCESSOR,\n                    DataService,\n                    SelectionService,\n                    NavigationService,\n                    DisabledItemsService,\n                    LocalizationService,\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.autocomplete'\n                    },\n                    {\n                        provide: FilterableDropDownComponentBase, useExisting: forwardRef(() => AutoCompleteComponent)\n                    },\n                    {\n                        provide: KendoInput, useExisting: forwardRef(() => AutoCompleteComponent)\n                    }\n                ],\n                selector: 'kendo-autocomplete',\n                template: `\n        <ng-container kendoAutoCompleteLocalizedMessages\n            i18n-noDataText=\"kendo.autocomplete.noDataText|The text displayed in the popup when there are no items\"\n            noDataText=\"NO DATA FOUND\"\n\n            i18n-clearTitle=\"kendo.autocomplete.clearTitle|The title of the clear button\"\n            clearTitle=\"clear\"\n        >\n        </ng-container>\n        <kendo-searchbar #searchbar\n            [role]=\"'combobox'\"\n            [id]=\"focusableId\"\n            [listId]=\"listBoxId\"\n            [activeDescendant]=\"activeDescendant\"\n            [noDataLabel]=\"noDataLabel\"\n            [userInput]=\"text\"\n            [suggestedText]=\"suggestion\"\n            [disabled]=\"disabled\"\n            [readonly]=\"readonly\"\n            [tabIndex]=\"tabIndex\"\n            [popupOpen]=\"isOpen\"\n            [placeholder]=\"placeholder\"\n            (onNavigate)=\"handleNavigate($event)\"\n            (valueChange)=\"searchBarChange($event)\"\n            (onBlur)=\"handleBlur()\"\n            (onFocus)=\"handleFocus()\"\n        ></kendo-searchbar>\n        <span *ngIf=\"!loading && !readonly && (clearButton && text?.length)\" class=\"k-icon k-clear-value k-i-close\" [attr.title]=\"clearTitle\" role=\"button\" tabindex=\"-1\" (click)=\"clearValue($event)\" (mousedown)=\"$event.preventDefault()\">\n</span>\n        <span *ngIf=\"loading\" class=\"k-icon k-i-loading\"></span>\n        <ng-template #popupTemplate>\n            <!--header template-->\n            <ng-template *ngIf=\"headerTemplate\"\n                [templateContext]=\"{\n                    templateRef: headerTemplate.templateRef\n                }\">\n            </ng-template>\n            <!--list-->\n            <kendo-list\n                #optionsList\n                [id]=\"listBoxId\"\n                [optionPrefix]=\"optionPrefix\"\n                [data]=\"data\"\n                [textField]=\"valueField\"\n                [valueField]=\"valueField\"\n                [template]=\"template\"\n                [groupTemplate]=\"groupTemplate\"\n                [fixedGroupTemplate]=\"fixedGroupTemplate\"\n                [height]=\"listHeight\"\n                [show]=\"isOpen\"\n                [virtual]=\"virtual\"\n                (pageChange)=\"pageChange($event)\"\n            >\n            </kendo-list>\n            <!--no-data template-->\n            <div class=\"k-nodata\" *ngIf=\"data.length === 0\">\n                <ng-template [ngIf]=\"noDataTemplate\"\n                    [templateContext]=\"{\n                        templateRef: noDataTemplate?.templateRef\n                    }\">\n                </ng-template>\n                <ng-template [ngIf]=\"!noDataTemplate\">\n                    <div>{{ noDataText }}</div>\n                </ng-template>\n            </div>\n            <!--footer template-->\n            <ng-template *ngIf=\"footerTemplate\"\n                [templateContext]=\"{\n                    templateRef: footerTemplate.templateRef\n                }\">\n            </ng-template>\n        </ng-template>\n        <ng-template [ngIf]=\"isOpen\">\n            <kendo-resize-sensor (resize)=\"onResize()\"></kendo-resize-sensor>\n        </ng-template>\n        <ng-container #container></ng-container>\n  `\n            },] },\n];\n/** @nocollapse */\nAutoCompleteComponent.ctorParameters = () => [\n    { type: LocalizationService },\n    { type: DataService },\n    { type: PopupService },\n    { type: SelectionService },\n    { type: NavigationService },\n    { type: DisabledItemsService },\n    { type: NgZone },\n    { type: ChangeDetectorRef },\n    { type: Renderer2 },\n    { type: ElementRef }\n];\nAutoCompleteComponent.propDecorators = {\n    highlightFirst: [{ type: Input }],\n    focusableId: [{ type: Input }],\n    data: [{ type: Input }],\n    value: [{ type: Input }],\n    valueField: [{ type: Input }],\n    placeholder: [{ type: Input }],\n    popupSettings: [{ type: Input }],\n    listHeight: [{ type: Input }],\n    loading: [{ type: Input }],\n    clearButton: [{ type: Input }],\n    suggest: [{ type: Input }],\n    disabled: [{ type: Input }],\n    itemDisabled: [{ type: Input }],\n    readonly: [{ type: Input }],\n    tabindex: [{ type: Input }],\n    tabIndex: [{ type: Input, args: [\"tabIndex\",] }],\n    filterable: [{ type: Input }],\n    virtual: [{ type: Input }],\n    valueChange: [{ type: Output }],\n    filterChange: [{ type: Output }],\n    open: [{ type: Output }],\n    close: [{ type: Output }],\n    onFocus: [{ type: Output, args: ['focus',] }],\n    onBlur: [{ type: Output, args: ['blur',] }],\n    template: [{ type: ContentChild, args: [ItemTemplateDirective,] }],\n    headerTemplate: [{ type: ContentChild, args: [HeaderTemplateDirective,] }],\n    footerTemplate: [{ type: ContentChild, args: [FooterTemplateDirective,] }],\n    noDataTemplate: [{ type: ContentChild, args: [NoDataTemplateDirective,] }],\n    groupTemplate: [{ type: ContentChild, args: [GroupTemplateDirective,] }],\n    fixedGroupTemplate: [{ type: ContentChild, args: [FixedGroupTemplateDirective,] }],\n    container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef },] }],\n    popupTemplate: [{ type: ViewChild, args: ['popupTemplate',] }],\n    searchbar: [{ type: ViewChild, args: [SearchBarComponent,] }],\n    optionsList: [{ type: ViewChild, args: ['optionsList',] }],\n    widgetClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-autocomplete',] }, { type: HostBinding, args: ['class.k-header',] }],\n    isFocused: [{ type: HostBinding, args: ['class.k-state-focused',] }],\n    isDisabled: [{ type: HostBinding, args: ['class.k-state-disabled',] }],\n    dir: [{ type: HostBinding, args: ['attr.dir',] }]\n};\n\n/**\n * @hidden\n */\nconst TOUCH_ENABLED = new InjectionToken('dropdowns-touch-enabled');\n\n/**\n * @hidden\n */\n/* tslint:disable:max-line-length */\n/* tslint:disable:variable-name */\nconst MultiselectMessages = {\n    'array': 'Expected values of array type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselect/#value-selection',\n    'object': 'Expected values of Object type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselect/#value-selection',\n    'primitive': 'Expected values of primitive type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselect/#value-selection',\n    'textAndValue': 'Expected textField and valueField options to be set. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselect/#toc-bind-to-arrays-of-complex-data'\n};\n/**\n * @hidden\n */\n/* tslint:disable:max-line-length */\n/* tslint:disable:variable-name */\nconst ComboBoxMessages = {\n    'object': 'Expected value of type Object. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/combobox/#toc-value-selection',\n    'primitive': 'Expected value of primitive type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/combobox/#toc-value-selection',\n    'textAndValue': 'Expected textField and valueField options to be set. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/combobox/#toc-bind-to-arrays-of-complex-data',\n    'noItemHeight': 'Expected virtual.itemHeight of type number.'\n};\n/**\n * @hidden\n */\n/* tslint:disable:max-line-length */\n/* tslint:disable:variable-name */\nconst DropDownListMessages = {\n    'defaultItem': 'defaultItem and data items must be of same type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/api/DropDownListComponent/#toc-defaultitem',\n    'object': 'Expected value of type Object. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdownlist/#toc-value-selection',\n    'primitive': 'Expected value of primitive type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdownlist/#toc-value-selection',\n    'textAndValue': 'Expected textField and valueField options to be set. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdownlist/#toc-bind-to-arrays-of-complex-data'\n};\n\n/* tslint:disable:no-null-keyword */\n/**\n * @hidden\n */\nconst COMBOBOX_VALUE_ACCESSOR = {\n    multi: true,\n    provide: NG_VALUE_ACCESSOR,\n    // tslint:disable-next-line:no-use-before-declare\n    useExisting: forwardRef(() => ComboBoxComponent)\n};\n/**\n * Represents the [Kendo UI ComboBox component for Angular]({% slug overview_combobox %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-combobox [data]=\"listItems\">\n *  </kendo-combobox>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\nclass ComboBoxComponent {\n    constructor(localization, popupService, selectionService, navigationService, disabledItemsService, dataService, _zone, cdr, renderer, wrapper, touchEnabled) {\n        this.localization = localization;\n        this.popupService = popupService;\n        this.selectionService = selectionService;\n        this.navigationService = navigationService;\n        this.disabledItemsService = disabledItemsService;\n        this.dataService = dataService;\n        this._zone = _zone;\n        this.cdr = cdr;\n        this.renderer = renderer;\n        this.touchEnabled = touchEnabled;\n        this.selected = [];\n        /**\n         * @hidden\n         */\n        this.focusableId = `k-${guid()}`;\n        /**\n         * Specifies whether the ComboBox allows user-defined values that are not present in the dataset\n         * ([more information and examples]({% slug custom_values_combobox %})).\n         * Defaults to `false`.\n         */\n        this.allowCustom = false;\n        /**\n         * A user-defined callback which returns normalized custom values.\n         * Typically used when the data items are different from type `string`.\n         * @param { Any } value - The custom value defined by the user.\n         * @returns { Any }\n         *\n         * @example\n         * ```ts\n         * import { map } from 'rxjs/operators';\n         *\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *   <kendo-combobox\n         *       [allowCustom]=\"true\"\n         *       [data]=\"listItems\"\n         *       [textField]=\"'text'\"\n         *       [valueField]=\"'value'\"\n         *       [valueNormalizer]=\"valueNormalizer\"\n         *       (valueChange)=\"onValueChange($event)\"\n         *   >\n         *   </kendo-combobox>\n         * `\n         * })\n         *\n         * class AppComponent {\n         *   public listItems: Array<{ text: string, value: number }> = [\n         *       { text: \"Small\", value: 1 },\n         *       { text: \"Medium\", value: 2 },\n         *       { text: \"Large\", value: 3 }\n         *   ];\n         *\n         *   public onValueChange(value) {\n         *       console.log(\"valueChange : \", value);\n         *   }\n         *\n         *   public valueNormalizer = (text$: Observable<string>) => text$.pipe(map((text: string) => {\n         *      return { ProductID: null, ProductName: text };\n         *   }));\n         *\n         * }\n         * ```\n         */\n        this.valueNormalizer = (text) => text.pipe(map((userInput) => userInput));\n        /**\n         * The hint that is displayed when the component is empty.\n         *\n         */\n        this.placeholder = \"\";\n        /**\n         * Sets the height of the suggestions list. By default, `listHeight` is 200px.\n         *\n         * > The `listHeight` property affects only the list of suggestions and not the whole popup container.\n         * > To set the height of the popup container, use `popupSettings.height`.\n         */\n        this.listHeight = 200;\n        /**\n         * Enables the auto-completion of the text based on the first data item.\n         */\n        this.suggest = false;\n        /**\n         * If set to `true`, renders a button on hovering over the component.\n         * Clicking this button resets the value of the component to `undefined` and triggers the `change` event.\n         */\n        this.clearButton = true;\n        /**\n         * Sets the disabled state of the component.\n         */\n        this.disabled = false;\n        /**\n         * Sets the read-only state of the component.\n         */\n        this.readonly = false;\n        /**\n         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n         */\n        this.tabindex = 0;\n        /**\n         * Enables the [filtering]({% slug filtering_combobox %}) functionality.\n         * If set to `true`, the component emits the `filterChange` event.\n         */\n        this.filterable = false;\n        /**\n         * Fires each time the value is changed&mdash;\n         * when the component is blurred or the value is cleared through the **Clear** button\n         * ([see example]({% slug overview_combobox %}#toc-events)).\n         * When the value of the component is programmatically changed to `ngModel` or `formControl`\n         * through its API or form binding, the `valueChange` event is not triggered because it\n         * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * Fires each time an item selection is changed\n         * ([see example]({% slug overview_combobox %}#toc-events)).\n         */\n        this.selectionChange = new EventEmitter();\n        /**\n         * Fires each time the user types in the input field.\n         * You can filter the source based on the passed filtration value\n         * ([see example]({% slug overview_combobox %}#toc-events)).\n         */\n        this.filterChange = new EventEmitter();\n        /**\n         * Fires each time the popup is about to open.\n         * This event is preventable. If you cancel it, the popup will remain closed.\n         */\n        this.open = new EventEmitter();\n        /**\n         * Fires each time the popup is about to close.\n         * This event is preventable. If you cancel it, the popup will remain open.\n         */\n        this.close = new EventEmitter();\n        /**\n         * Fires each time the user focuses the ComboBox.\n         */\n        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the ComboBox gets blurred.\n         */\n        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename\n        this.widgetClasses = true;\n        this.isFocused = false;\n        this.listBoxId = guid();\n        this.optionPrefix = guid();\n        this.onChangeCallback = (_) => { };\n        this.onTouchedCallback = (_) => { };\n        this._filtering = false;\n        this._text = \"\";\n        this._open = false;\n        this._popupSettings = { animate: true };\n        this.popupMouseDownHandler = (event) => event.preventDefault();\n        this.customValueSubject = new Subject();\n        this.valueSubject = new Subject();\n        this.clearValueSubject = new Subject();\n        this.selectionSubject = new Subject();\n        this.subs = new Subscription();\n        this.direction = localization.rtl ? 'rtl' : 'ltr';\n        this.wrapper = wrapper.nativeElement;\n        this.data = [];\n    }\n    get width() {\n        let wrapperOffsetWidth = 0;\n        if (isDocumentAvailable()) {\n            wrapperOffsetWidth = this.wrapper.offsetWidth;\n        }\n        const width = this.popupSettings.width || wrapperOffsetWidth;\n        const minWidth = isNaN(wrapperOffsetWidth) ? wrapperOffsetWidth : `${wrapperOffsetWidth}px`;\n        const maxWidth = isNaN(width) ? width : `${width}px`;\n        return { min: minWidth, max: maxWidth };\n    }\n    get height() {\n        const popupHeight = this.popupSettings.height;\n        return isPresent(popupHeight) ? `${popupHeight}px` : 'auto';\n    }\n    set text(text) {\n        this._text = isPresent(text) ? text.toString() : \"\";\n    }\n    get text() {\n        return this._text;\n    }\n    /**\n     * @hidden\n     */\n    togglePopup(open) {\n        const isDisabled = this.disabled || this.readonly;\n        const sameState = this.isOpen === open;\n        if (isDisabled || sameState) {\n            return;\n        }\n        const isDefaultPrevented = this.triggerPopupEvents(open);\n        if (!isDefaultPrevented) {\n            this._toggle(open);\n        }\n    }\n    get activeDescendant() {\n        if (!this.isOpen || !isPresent(this.selectionService.focused) || this.selectionService.focused === -1) {\n            return null;\n        }\n        const dataItem = this.dataService.itemAt(this.selectionService.focused);\n        return this.optionPrefix + \"-\" + (dataItem ? getter(dataItem, this.valueField) : \"\");\n    }\n    get noDataLabel() {\n        if (this.data.length === 0) {\n            return this.noDataText;\n        }\n    }\n    get clearTitle() {\n        return this.localization.get('clearTitle');\n    }\n    get appendTo() {\n        const { appendTo } = this.popupSettings;\n        if (!appendTo || appendTo === 'root') {\n            return undefined;\n        }\n        return appendTo === 'component' ? this.container : appendTo;\n    }\n    /**\n     * Sets the data of the ComboBox.\n     *\n     * > The data has to be provided in an array-like list.\n     */\n    set data(data) {\n        this.dataService.data = data || [];\n        if (this.virtual) {\n            this.virtual.skip = 0;\n        }\n        this.setState();\n        if (this._filtering) {\n            const queryAndDataPresent = this.text.length > 0 && this.dataService.itemsCount > 0;\n            const index = queryAndDataPresent ? this.firstFocusableIndex(0) : -1;\n            this.selectionService.focused = index;\n        }\n        if (this.suggest && this.dataService.itemsCount && this.text) {\n            this.suggestedText = getter(this.dataService.itemAt(0), this.textField);\n        }\n    }\n    get data() {\n        const virtual = this.virtual;\n        if (virtual) {\n            const start = virtual.skip || 0;\n            const end = start + virtual.pageSize;\n            // Use length instead of itemsCount because of the grouping.\n            virtual.total = this.dataService.data.length;\n            return this.dataService.data.slice(start, end);\n        }\n        return this.dataService.data;\n    }\n    /**\n     * Sets the value of the ComboBox.\n     * It can either be of the primitive (string, numbers) or of the complex (objects) type.\n     * To define the type, use the `valuePrimitive` option.\n     *\n     * > All selected values which are not present in the dataset are considered custom values.\n     * > When the `Enter` key is pressed or the component loses focus, custom values get dismissed unless `allowCustom` is set to `true`.\n     */\n    set value(newValue) {\n        this.verifySettings(newValue);\n        this._value = newValue;\n        this.cdr.markForCheck();\n    }\n    get value() {\n        return this._value;\n    }\n    /**\n     * Configures the popup of the ComboBox.\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped. The `auto` mode is not supported when virtual scrolling is enabled.\n     * - `height: Number`&mdash;Sets the height of the popup container.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     * - `appendTo: \"root\" | \"component\" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.\n     */\n    set popupSettings(settings) {\n        this._popupSettings = Object.assign({ animate: true }, settings);\n    }\n    get popupSettings() {\n        return this._popupSettings;\n    }\n    /**\n     * Defines a Boolean function that is executed for each data item in the component\n     * ([see examples]({% slug disableditems_combobox %})). Determines whether the item will be disabled.\n     */\n    set itemDisabled(fn) {\n        if (typeof fn !== 'function') {\n            throw new Error(`itemDisabled must be a function, but received ${JSON.stringify(fn)}.`);\n        }\n        this.disabledItemsService.itemDisabled = fn;\n    }\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n        this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n        return this.tabindex;\n    }\n    /**\n     * Enables the [virtualization]({% slug virtualization_combobox %}) functionality.\n     */\n    set virtual(settings) {\n        this._virtualSettings = normalizeVirtualizationSettings(settings);\n    }\n    get virtual() {\n        return this._virtualSettings;\n    }\n    get clearable() {\n        return this.clearButton;\n    }\n    get dir() {\n        return this.direction;\n    }\n    ngOnInit() {\n        this.renderer.removeAttribute(this.wrapper, \"tabindex\");\n        this.attachStreams();\n        this.createSelectionStream();\n        this.createValueStream();\n        this.setMessages();\n    }\n    createValueStream() {\n        const valueStream = this.valueSubject.pipe(filter((candidate) => {\n            const valueFrom = this.prop(this.valueField, this.valuePrimitive);\n            const textFrom = this.prop(this.textField, this.valuePrimitive);\n            const current = valueFrom(this.value);\n            const newValue = valueFrom(candidate);\n            let newText = textFrom(candidate);\n            if (!isPresent(this.value) && !isPresent(newValue)) {\n                return false;\n            }\n            if (isPresent(newText)) {\n                newText = newText.toString();\n            }\n            if (current === newValue && this.text === newText) {\n                return false;\n            }\n            else {\n                return true;\n            }\n        }), map((candidate) => {\n            const valueFrom = this.prop(this.valueField, this.valuePrimitive);\n            const textFrom = this.prop(this.textField, this.valuePrimitive);\n            const newValue = valueFrom(candidate);\n            const newText = textFrom(candidate);\n            return {\n                dataItem: candidate,\n                text: newText,\n                value: this.valuePrimitive ? newValue : candidate\n            };\n        }));\n        const customValueStreams = partition(() => this.allowCustom)(this.customValueSubject.pipe(throttleTime(300)));\n        const allowCustomValueStream = customValueStreams[0].pipe(tap(() => {\n            this.loading = true;\n            this.disabled = true;\n            this.cdr.detectChanges();\n        }), filter(() => {\n            const valueFrom = this.prop(this.valueField, this.valuePrimitive);\n            const hasChange = this.text !== valueFrom(this.value);\n            this.loading = hasChange;\n            this.disabled = hasChange;\n            return hasChange;\n        }), this.valueNormalizer, map((normalizedValue) => {\n            return {\n                custom: true,\n                dataItem: normalizedValue,\n                text: this.text,\n                value: normalizedValue\n            };\n        }));\n        const disableCustomValueStream = customValueStreams[1].pipe(map(() => {\n            return {\n                custom: true,\n                dataItem: undefined,\n                text: undefined,\n                value: undefined\n            };\n        }));\n        const clearValueStream = this.clearValueSubject.pipe(map(() => ({\n            dataItem: undefined,\n            text: undefined,\n            value: undefined\n        })));\n        if (this.valueSubscription) {\n            this.valueSubscription.unsubscribe();\n        }\n        const merged = merge(valueStream, allowCustomValueStream, disableCustomValueStream, clearValueStream);\n        this.valueSubscription = merged.pipe(catchError(() => {\n            this.dataItem = undefined;\n            this.value = undefined;\n            this.text = undefined;\n            this.loading = false;\n            this.disabled = false;\n            this.emitSelectionChange(undefined);\n            this.emitValueChange();\n            this.createValueStream();\n            return of(null);\n        }))\n            .subscribe((state) => {\n            this.dataItem = state.dataItem;\n            this.value = state.value;\n            const textCleared = (isPresent(this.text) && this.text.length) && !isPresent(state.text);\n            this.text = state.text;\n            this.loading = false;\n            this.disabled = false;\n            if (this.filterable && !isPresent(state.value) && textCleared) {\n                this.filterChange.emit(\"\");\n            }\n            if (state.custom) {\n                this.selectionService.focused = -1;\n            }\n            this.emitSelectionChange(state.custom ? undefined : this.dataItem);\n            this.emitValueChange();\n        });\n    }\n    attachStreams() {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        this.subs.add(this.localization\n            .changes.subscribe(({ rtl }) => {\n            this.direction = rtl ? 'rtl' : 'ltr';\n            this.setMessages();\n        }));\n        this.subs.add(merge(this.navigationService.up, this.navigationService.down, this.navigationService.home, this.navigationService.end)\n            .pipe(filter((event) => isPresent(event.index)))\n            .subscribe((event) => this.navigate(event.index)));\n        this.subs.add(this.navigationService.open.subscribe(this.handleNavigationOpen.bind(this)));\n        this.subs.add(this.navigationService.close.subscribe(() => this.togglePopup(false)));\n        this.subs.add(this.navigationService.esc.subscribe(this.handleEscape.bind(this)));\n        this.subs.add(this.navigationService.enter.pipe(tap((event) => {\n            if (this.isOpen) {\n                event.originalEvent.preventDefault();\n            }\n        }))\n            .subscribe(this.handleEnter.bind(this)));\n        this.subs.add(merge(this.selectionService.onChange, this.selectionService.onSelect.pipe(filter(_ => !this.isOpen)))\n            .pipe(tap(_ => {\n            this._filtering = false;\n            this.togglePopup(false);\n        }), map((event) => this.dataService.itemAt(event.indices[0])))\n            .subscribe(dataItem => {\n            this.change(dataItem);\n        }));\n        this.subs.add(this.selectionService.onSelect.pipe(filter(_ => this.isOpen), tap(_ => this._filtering = false), map((event) => this.dataService.itemAt(event.indices[0])))\n            .subscribe(dataItem => {\n            this.updateState({ dataItem });\n            this.emitSelectionChange(dataItem);\n        }));\n    }\n    ngOnDestroy() {\n        this.destroyPopup();\n        clearTimeout(this.messagesTimeout);\n        this.subs.unsubscribe();\n        [this.valueSubscription, this.selectionSubscription].forEach(sub => isPresent(sub) && sub.unsubscribe());\n    }\n    ngOnChanges(changes) {\n        const virtual = this.virtual;\n        const requestInitialData = virtual && changes.data && changes.data.isFirstChange();\n        if (requestInitialData) {\n            this.pageChange({ skip: 0, take: virtual.pageSize });\n        }\n        if (this.valuePrimitive === undefined) {\n            this.valuePrimitive = this.valueField ? false : true;\n        }\n        this.verifySettings(this.value);\n        if (isChanged(\"valueNormalizer\", changes)) {\n            this.createValueStream();\n        }\n        if (isChanged(\"value\", changes)) {\n            this.createSelectionStream();\n        }\n        if (this.valuePrimitive === undefined) {\n            this.valuePrimitive = this.valueField ? false : true;\n        }\n        const STATE_PROPS = /(value|textField|valueField|valuePrimitive)/g;\n        if (STATE_PROPS.test(Object.keys(changes).join())) {\n            this.setState();\n        }\n    }\n    /**\n     * Focuses the ComboBox.\n     */\n    focus() {\n        if (!this.disabled) {\n            this.searchbar.focus();\n        }\n    }\n    /**\n     * Blurs the ComboBox.\n     */\n    blur() {\n        if (!this.disabled) {\n            this.searchbar.blur();\n        }\n    }\n    /**\n     * Toggles the visibility of the popup. If you use the `toggle` method to open or close the popup,\n     * the `open` and `close` events will not be fired.\n     *\n     * @param open - The state of the popup.\n     */\n    toggle(open) {\n        Promise.resolve(null).then(() => {\n            this._toggle(open);\n            this.cdr.markForCheck();\n        });\n    }\n    /**\n     * Returns the current open state of the popup.\n     */\n    get isOpen() {\n        return this._open;\n    }\n    /**\n     * Resets the value of the ComboBox.\n     * If you use the `reset` method to clear the value of the component,\n     * the model will not update automatically and the `selectionChange` and `valueChange` events will not be fired.\n     */\n    reset() {\n        this.value = undefined;\n        this.clearState();\n        this.resetSelection();\n        this.createSelectionStream();\n    }\n    /**\n     * @hidden\n     *\n     * Used by the TextBoxContainer to determine if the floating label\n     * should be rendered in the input when the component is not focused.\n     */\n    isEmpty() {\n        const textEmpty = !isPresent(this.text) || isEmptyString(this.text);\n        const valueEmpty = !isPresent(this.value) || isEmptyString(this.value);\n        return textEmpty && valueEmpty;\n    }\n    /**\n     * @hidden\n     */\n    clearValue(event) {\n        event.stopImmediatePropagation();\n        this.focus();\n        this._filtering = true;\n        this._previousDataItem = undefined;\n        this.selectionService.resetSelection([]);\n        this.clearValueSubject.next();\n        this._filtering = false;\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n        this.text = \"\";\n        this.value = value === null ? undefined : value;\n        this.setState();\n        this.createSelectionStream();\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.onChangeCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.onTouchedCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n    get buttonClasses() {\n        return this.loading ? 'k-i-loading' : this.iconClass || 'k-i-arrow-s';\n    }\n    /**\n     * @hidden\n     */\n    onResize() {\n        if (this.isOpen) {\n            const popupWrapper = this.popupRef.popupElement;\n            const { min, max } = this.width;\n            popupWrapper.style.minWidth = min;\n            popupWrapper.style.width = max;\n        }\n    }\n    verifySettings(newValue) {\n        const valueOrText = !isPresent(this.valueField) !== !isPresent(this.textField);\n        if (!isDevMode()) {\n            return;\n        }\n        if (this.valuePrimitive === true && isPresent(newValue) && typeof newValue === \"object\") {\n            throw new Error(ComboBoxMessages.primitive);\n        }\n        if (this.valuePrimitive === false && isPresent(newValue) && typeof newValue !== \"object\") {\n            throw new Error(ComboBoxMessages.object);\n        }\n        if (valueOrText) {\n            throw new Error(ComboBoxMessages.textAndValue);\n        }\n        if (this.virtual && isNaN(this.virtual.itemHeight)) {\n            throw new Error(ComboBoxMessages.noItemHeight);\n        }\n    }\n    setState() {\n        // Filtering in process, do nothing.\n        if (this._filtering) {\n            return;\n        }\n        const value = this.value;\n        const valueField = this.valueField;\n        const primitive = this.valuePrimitive;\n        const resolved = this.findDataItem({ primitive, valueField, value });\n        if (isPresent(resolved.dataItem)) {\n            this.updateState({ dataItem: resolved.dataItem, confirm: true });\n            this.resetSelection(resolved.index);\n        }\n        else if (isPresent(value) && this.allowCustom) {\n            this.updateState({ dataItem: value });\n            this.resetSelection(-1);\n        }\n        else if (this._previousDataItem && this.value) {\n            this.updateState({ dataItem: this._previousDataItem });\n            this.resetSelection();\n        }\n        else {\n            this.clearState();\n            this.resetSelection(-1);\n        }\n    }\n    updateState({ dataItem, confirm = false }) {\n        this.dataItem = dataItem;\n        this.text = this.prop(this.textField, this.valuePrimitive)(dataItem);\n        if (confirm) {\n            this._previousDataItem = dataItem;\n        }\n    }\n    clearState() {\n        this.text = undefined;\n        this.dataItem = undefined;\n    }\n    resetSelection(index) {\n        const clear = !isPresent(index) || index < 0;\n        this.selectionService.resetSelection(clear ? [] : [index]);\n        this.selectionService.focused = index;\n    }\n    firstFocusableIndex(index) {\n        const maxIndex = this.data.length - 1;\n        if (this.disabledItemsService.isIndexDisabled(index)) {\n            return (index < maxIndex) ? this.firstFocusableIndex(index + 1) : undefined;\n        }\n        else {\n            return index;\n        }\n    }\n    findIndexPredicate(text) {\n        if (this.dataService.grouped) {\n            return (item) => {\n                let itemText = this.prop(this.textField, this.valuePrimitive)(item.value);\n                itemText = !isPresent(itemText) ? \"\" : itemText.toString().toLowerCase();\n                return itemText.startsWith(text.toLowerCase());\n            };\n        }\n        else {\n            return (item) => {\n                let itemText = this.prop(this.textField, this.valuePrimitive)(item);\n                itemText = !isPresent(itemText) ? \"\" : itemText.toString().toLowerCase();\n                return itemText.startsWith(text.toLowerCase());\n            };\n        }\n    }\n    prop(field, usePrimitive) {\n        return (dataItem) => {\n            if (isPresent(dataItem)) {\n                if (usePrimitive) {\n                    return field && isObject(dataItem) ? dataItem[field] : dataItem;\n                }\n                else {\n                    return dataItem[field];\n                }\n            }\n            return null;\n        };\n    }\n    findDataItem({ primitive, valueField, value }) {\n        const result = {\n            dataItem: null,\n            index: -1\n        };\n        const prop = this.prop(valueField, primitive);\n        let comparer;\n        if (this.dataService.grouped) {\n            comparer = (element) => {\n                return prop(element.value) === prop(value);\n            };\n        }\n        else {\n            comparer = (element) => {\n                return prop(element) === prop(value);\n            };\n        }\n        const index = this.dataService.findIndex(comparer);\n        result.dataItem = this.dataService.itemAt(index);\n        result.index = index;\n        return result;\n    }\n    search(text, startFrom = 0) {\n        let index;\n        if (text.length && this.dataService.itemsCount) {\n            index = this.dataService.findIndex(this.findIndexPredicate(text), startFrom);\n        }\n        else {\n            index = -1;\n        }\n        if (this.disabledItemsService.isIndexDisabled(index)) {\n            if (index + 1 < this.dataService.itemsCount) {\n                this.search(text, index + 1);\n            }\n            else {\n                this.selectionService.focus(-1);\n            }\n        }\n        else {\n            this.selectionService.focus(index);\n            if (this.suggest) {\n                this.suggestedText = getter(this.dataService.itemAt(index), this.textField);\n            }\n        }\n    }\n    /**\n     * @hidden\n     */\n    getSuggestion() {\n        const hasSelected = !!this.selectionService.selected.length;\n        const shouldSuggest = this.suggest && !this.backspacePressed && this.suggestedText && this.text;\n        if (!hasSelected && shouldSuggest && this.suggestedText.toLowerCase().startsWith(this.text.toLowerCase())) {\n            return this.suggestedText;\n        }\n        else {\n            this.suggestedText = undefined;\n        }\n    }\n    navigate(index) {\n        if (this.dataService.itemsCount === 0) {\n            return;\n        }\n        this.text = this.prop(this.textField, this.valuePrimitive)(this.dataService.itemAt(index));\n        this.selectionService.select(index);\n    }\n    /**\n     * @hidden\n     */\n    handleNavigate(event) {\n        const hasSelected = isPresent(this.selectionService.selected[0]);\n        const focused = isNaN(this.selectionService.focused) ? this.firstFocusableIndex(0) : this.selectionService.focused;\n        let offset = 0;\n        if (this.disabled || this.readonly) {\n            return;\n        }\n        if (event.keyCode === Keys.home || event.keyCode === Keys.end) {\n            return;\n        }\n        if (!hasSelected) {\n            if (event.keyCode === Keys.down) {\n                offset = -1;\n            }\n            else if (event.keyCode === Keys.up) {\n                offset = 1;\n            }\n        }\n        const action = this.navigationService.process({\n            current: offset + focused,\n            max: this.dataService.itemsCount - 1,\n            min: 0,\n            originalEvent: event\n        });\n        if (action !== NavigationAction.Undefined &&\n            action !== NavigationAction.Left &&\n            action !== NavigationAction.Right &&\n            action !== NavigationAction.Backspace &&\n            action !== NavigationAction.Delete &&\n            ((action === NavigationAction.Enter && this.isOpen) || action !== NavigationAction.Enter)) {\n            event.preventDefault();\n        }\n    }\n    handleEnter() {\n        const text = this.text;\n        const focused = this.selectionService.focused;\n        const hasFocused = isPresent(focused) && focused !== -1;\n        const previousText = getter(this._previousDataItem, this.textField) || \"\";\n        const focusedItemText = getter(this.dataService.itemAt(focused), this.textField);\n        const textHasChanged = text !== previousText;\n        this.togglePopup(false);\n        this._filtering = false;\n        if (this.allowCustom && textHasChanged) {\n            if (text === focusedItemText || this.useSuggestion()) {\n                this.selectionService.change(focused);\n            }\n            else {\n                this.change(text, true);\n            }\n        }\n        if (!this.allowCustom) {\n            if (hasFocused) {\n                this.selectionService.change(focused);\n            }\n            else if (textHasChanged) {\n                this.change(text, true);\n            }\n        }\n    }\n    /**\n     * @hidden\n     */\n    handleBlur() {\n        this._filtering = false;\n        const currentText = this.searchbar.value; // The value is updated, but the Angular `change` event is not emitted yet and `this.text` is not updated. Fails on suggested text.\n        if (!currentText && !isPresent(this._previousDataItem) && !isPresent(this.dataItem)) {\n            this.togglePopup(false);\n            this.isFocused = false;\n            this.onBlur.emit();\n            this.onTouchedCallback();\n            return;\n        }\n        const focused = this.selectionService.focused;\n        let itemText;\n        const isItemFocused = focused !== -1 && focused !== undefined;\n        if (isItemFocused) {\n            itemText = getter(this.dataService.itemAt(focused), this.textField);\n            itemText = !isPresent(itemText) ? \"\" : itemText.toString().toLowerCase();\n        }\n        if (itemText === currentText.toLowerCase()) {\n            this.selectionService.change(focused);\n        }\n        else {\n            this.change(currentText, true);\n        }\n        this.togglePopup(false);\n        this.isFocused = false;\n        this.onBlur.emit();\n        this.onTouchedCallback();\n    }\n    /**\n     * @hidden\n     */\n    handleEscape() {\n        this.togglePopup(false);\n        // clear the focus only if the focused item is not selected\n        const hasSelected = this.selectionService.selected.length > 0;\n        if (!hasSelected) {\n            this.suggestedText = null;\n            this.selectionService.focused = -1;\n        }\n    }\n    /**\n     * @hidden\n     */\n    handleNavigationOpen() {\n        this.restoreItemFocus();\n        this.togglePopup(true);\n    }\n    /**\n     * @hidden\n     */\n    searchBarChange(text) {\n        const currentTextLength = this.text ? this.text.length : 0;\n        this.backspacePressed = (text.length < currentTextLength) ? true : false;\n        this.text = text;\n        // Reset the selection prior to filter. If a match is present, it will be resolved. If a match is not present, it is not needed.\n        this.selectionService.resetSelection([]);\n        this.togglePopup(true);\n        this._filtering = true;\n        if (this.filterable) {\n            this.filterChange.emit(text);\n        }\n        else {\n            this.search(text);\n        }\n    }\n    /**\n     * @hidden\n     */\n    handleFocus() {\n        this.isFocused = true;\n        this.onFocus.emit();\n    }\n    /**\n     * @hidden\n     */\n    pageChange(event) {\n        const virtual = this.virtual;\n        virtual.skip = event.skip;\n    }\n    change(candidate, isCustom = false) {\n        if (isCustom) {\n            this.customValueSubject.next(candidate);\n        }\n        else {\n            this.valueSubject.next(candidate);\n        }\n    }\n    emitSelectionChange(dataItem) {\n        this.selectionSubject.next(dataItem);\n    }\n    emitValueChange() {\n        this.onChangeCallback(this.value);\n        this.valueChange.emit(this.value);\n        this._previousDataItem = this.dataItem;\n    }\n    /**\n     * @hidden\n     */\n    selectClick() {\n        if (!this.touchEnabled) {\n            this.searchbar.focus();\n        }\n        if (!this.isOpen) {\n            this.restoreItemFocus();\n        }\n        this.togglePopup(!this.isOpen);\n    }\n    get listContainerClasses() {\n        const containerClasses = ['k-list-container', 'k-reset'];\n        if (this.popupSettings.popupClass) {\n            containerClasses.push(this.popupSettings.popupClass);\n        }\n        return containerClasses;\n    }\n    /**\n     * Focuses the first match when there's text in the input field, but no focused item.\n     */\n    restoreItemFocus() {\n        const hasFocus = isPresent(this.selectionService.focused) && this.selectionService.focused > -1;\n        if (!hasFocus && this.text && this.dataService.itemsCount) {\n            if (this.filterable) {\n                this.selectionService.focused = this.firstFocusableIndex(0);\n            }\n            else {\n                this.search(this.text);\n            }\n        }\n    }\n    useSuggestion() {\n        if (!(this.suggest && isPresent(this.searchbar.value))) {\n            return false;\n        }\n        const focusedDataItem = this.dataService.itemAt(this.selectionService.focused);\n        const focusedItemText = this.prop(this.textField, this.valuePrimitive)(focusedDataItem);\n        if (!isPresent(focusedItemText)) {\n            return false;\n        }\n        return this.searchbar.value.toLowerCase() === focusedItemText.toLowerCase();\n    }\n    destroyPopup() {\n        if (this.popupRef) {\n            this.popupRef.popupElement\n                .removeEventListener('mousedown', this.popupMouseDownHandler);\n            this.popupRef.close();\n            this.popupRef = null;\n        }\n    }\n    createPopup() {\n        if (this.virtual) {\n            this.virtual.skip = 0;\n        }\n        const horizontalAlign = this.direction === \"rtl\" ? \"right\" : \"left\";\n        const anchorPosition = { horizontal: horizontalAlign, vertical: \"bottom\" };\n        const popupPosition = { horizontal: horizontalAlign, vertical: \"top\" };\n        this.popupRef = this.popupService.open({\n            anchor: this.wrapper,\n            animate: this.popupSettings.animate,\n            appendTo: this.appendTo,\n            content: this.popupTemplate,\n            popupClass: this.listContainerClasses,\n            positionMode: 'absolute',\n            anchorAlign: anchorPosition,\n            popupAlign: popupPosition\n        });\n        const popupWrapper = this.popupRef.popupElement;\n        const { min, max } = this.width;\n        popupWrapper.addEventListener('mousedown', this.popupMouseDownHandler);\n        popupWrapper.style.minWidth = min;\n        popupWrapper.style.width = max;\n        popupWrapper.style.height = this.height;\n        popupWrapper.setAttribute(\"dir\", this.direction);\n        this.popupRef.popupOpen.subscribe(() => {\n            this.cdr.detectChanges();\n            this.optionsList.scrollToItem(this.selectionService.focused);\n        });\n        this.popupRef.popupAnchorViewportLeave.subscribe(() => this.togglePopup(false));\n    }\n    _toggle(open) {\n        this._open = (open === undefined) ? !this._open : open;\n        this.destroyPopup();\n        if (this._open) {\n            this.createPopup();\n        }\n    }\n    triggerPopupEvents(open) {\n        const eventArgs = new PreventableEvent();\n        if (open) {\n            this.open.emit(eventArgs);\n        }\n        else {\n            this.close.emit(eventArgs);\n        }\n        return eventArgs.isDefaultPrevented();\n    }\n    setMessages() {\n        this._zone.runOutsideAngular(() => {\n            clearTimeout(this.messagesTimeout);\n            this.messagesTimeout = setTimeout(() => {\n                this.noDataText = this.localization.get('noDataText');\n                this.cdr.detectChanges();\n            });\n        });\n    }\n    createSelectionStream() {\n        if (isPresent(this.selectionSubscription)) {\n            this.selectionSubscription.unsubscribe();\n        }\n        this.selectionSubscription = this.selectionSubject\n            .pipe(distinctUntilChanged())\n            .subscribe(dataItem => this.selectionChange.emit(dataItem));\n    }\n}\nComboBoxComponent.decorators = [\n    { type: Component, args: [{\n                exportAs: 'kendoComboBox',\n                providers: [\n                    COMBOBOX_VALUE_ACCESSOR,\n                    DataService,\n                    SelectionService,\n                    NavigationService,\n                    DisabledItemsService,\n                    LocalizationService,\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.combobox'\n                    },\n                    {\n                        provide: FilterableDropDownComponentBase, useExisting: forwardRef(() => ComboBoxComponent)\n                    },\n                    {\n                        provide: KendoInput, useExisting: forwardRef(() => ComboBoxComponent)\n                    }\n                ],\n                selector: 'kendo-combobox',\n                template: `\n        <ng-container kendoComboBoxLocalizedMessages\n            i18n-noDataText=\"kendo.combobox.noDataText|The text displayed in the popup when there are no items\"\n            noDataText=\"NO DATA FOUND\"\n\n            i18n-clearTitle=\"kendo.combobox.clearTitle|The title of the clear button\"\n            clearTitle=\"clear\"\n        >\n        </ng-container>\n        <span #wrapper unselectable=\"on\"\n            class=\"k-dropdown-wrap\"\n            [ngClass]=\"{ 'k-state-default': !disabled, 'k-state-disabled': disabled, 'k-state-focused': isFocused }\"\n        >\n          <kendo-searchbar #searchbar\n              [role]=\"'combobox'\"\n              [id]=\"focusableId\"\n              [listId]=\"listBoxId\"\n              [activeDescendant]=\"activeDescendant\"\n              [noDataLabel]=\"noDataLabel\"\n              [userInput]=\"text\"\n              [suggestedText]=\"getSuggestion()\"\n              [disabled]=\"disabled\"\n              [readonly]=\"readonly\"\n              [tabIndex]=\"tabIndex\"\n              [popupOpen]=\"isOpen\"\n              [placeholder]=\"placeholder\"\n              (onNavigate)=\"handleNavigate($event)\"\n              (valueChange)=\"searchBarChange($event)\"\n              (onBlur)=\"handleBlur()\"\n              (onFocus)=\"handleFocus()\"\n          ></kendo-searchbar>\n          <span *ngIf=\"!loading && !readonly && (clearButton && text?.length)\" class=\"k-icon k-clear-value k-i-close\" [attr.title]=\"clearTitle\" role=\"button\" tabindex=\"-1\" (click)=\"clearValue($event)\" (mousedown)=\"$event.preventDefault()\"></span>\n          <span unselectable=\"on\"\n              class=\"k-select\"\n              (click)=\"selectClick()\"\n              (mousedown)=\"$event.preventDefault()\" >\n              <span class=\"k-icon\" [ngClass]=\"buttonClasses\">\n               </span>\n          </span>\n          <ng-template #popupTemplate>\n              <!--header template-->\n              <ng-template *ngIf=\"headerTemplate\"\n                  [templateContext]=\"{\n                      templateRef: headerTemplate.templateRef\n                  }\">\n              </ng-template>\n              <!--list-->\n              <kendo-list\n                  #optionsList\n                  [id]=\"listBoxId\"\n                  [optionPrefix]=\"optionPrefix\"\n                  [data]=\"data\"\n                  [textField]=\"textField\"\n                  [valueField]=\"valueField\"\n                  [template]=\"template\"\n                  [groupTemplate]=\"groupTemplate\"\n                  [fixedGroupTemplate]=\"fixedGroupTemplate\"\n                  [height]=\"listHeight\"\n                  [show]=\"isOpen\"\n                  [virtual]=\"virtual\"\n                  (pageChange)=\"pageChange($event)\"\n              >\n              </kendo-list>\n              <!--no-data template-->\n              <div class=\"k-nodata\" *ngIf=\"data.length === 0\">\n                  <ng-template [ngIf]=\"noDataTemplate\"\n                      [templateContext]=\"{\n                          templateRef: noDataTemplate ? noDataTemplate.templateRef : undefined\n                      }\">\n                  </ng-template>\n                  <ng-template [ngIf]=\"!noDataTemplate\">\n                      <div>{{ noDataText }}</div>\n                  </ng-template>\n              </div>\n              <!--footer template-->\n              <ng-template *ngIf=\"footerTemplate\"\n                  [templateContext]=\"{\n                      templateRef: footerTemplate.templateRef\n                  }\">\n              </ng-template>\n          </ng-template>\n        </span>\n        <ng-template [ngIf]=\"isOpen\">\n            <kendo-resize-sensor (resize)=\"onResize()\"></kendo-resize-sensor>\n        </ng-template>\n        <ng-container #container></ng-container>\n  `\n            },] },\n];\n/** @nocollapse */\nComboBoxComponent.ctorParameters = () => [\n    { type: LocalizationService },\n    { type: PopupService },\n    { type: SelectionService },\n    { type: NavigationService },\n    { type: DisabledItemsService },\n    { type: DataService },\n    { type: NgZone },\n    { type: ChangeDetectorRef },\n    { type: Renderer2 },\n    { type: ElementRef },\n    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [TOUCH_ENABLED,] }] }\n];\nComboBoxComponent.propDecorators = {\n    focusableId: [{ type: Input }],\n    allowCustom: [{ type: Input }],\n    data: [{ type: Input }],\n    value: [{ type: Input }],\n    textField: [{ type: Input }],\n    valueField: [{ type: Input }],\n    valuePrimitive: [{ type: Input }],\n    valueNormalizer: [{ type: Input }],\n    placeholder: [{ type: Input }],\n    popupSettings: [{ type: Input }],\n    listHeight: [{ type: Input }],\n    iconClass: [{ type: Input }],\n    loading: [{ type: Input }],\n    suggest: [{ type: Input }],\n    clearButton: [{ type: Input }],\n    disabled: [{ type: Input }],\n    itemDisabled: [{ type: Input }],\n    readonly: [{ type: Input }],\n    tabindex: [{ type: Input }],\n    tabIndex: [{ type: Input, args: [\"tabIndex\",] }],\n    filterable: [{ type: Input }],\n    virtual: [{ type: Input }],\n    valueChange: [{ type: Output }],\n    selectionChange: [{ type: Output }],\n    filterChange: [{ type: Output }],\n    open: [{ type: Output }],\n    close: [{ type: Output }],\n    onFocus: [{ type: Output, args: ['focus',] }],\n    onBlur: [{ type: Output, args: ['blur',] }],\n    template: [{ type: ContentChild, args: [ItemTemplateDirective,] }],\n    headerTemplate: [{ type: ContentChild, args: [HeaderTemplateDirective,] }],\n    footerTemplate: [{ type: ContentChild, args: [FooterTemplateDirective,] }],\n    noDataTemplate: [{ type: ContentChild, args: [NoDataTemplateDirective,] }],\n    groupTemplate: [{ type: ContentChild, args: [GroupTemplateDirective,] }],\n    fixedGroupTemplate: [{ type: ContentChild, args: [FixedGroupTemplateDirective,] }],\n    container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef },] }],\n    popupTemplate: [{ type: ViewChild, args: ['popupTemplate',] }],\n    searchbar: [{ type: ViewChild, args: [SearchBarComponent,] }],\n    optionsList: [{ type: ViewChild, args: ['optionsList',] }],\n    widgetClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-combobox',] }, { type: HostBinding, args: ['class.k-header',] }],\n    clearable: [{ type: HostBinding, args: ['class.k-combobox-clearable',] }],\n    dir: [{ type: HostBinding, args: ['attr.dir',] }]\n};\n\n/* tslint:disable:max-line-length */\n/**\n * Renders the selected value of the DropDownList\n * ([see example]({% slug templates_ddl %}#toc-value-template)).\n * The template context is set to the current component.\n * To get a reference to the current data item, use the `let-dataItem` directive.\n *\n * > The `ValueTemplate` directive can only be used with the DropDownList component.\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-dropdownlist [data]=\"listItems\">\n *    <ng-template kendoDropDownListValueTemplate let-dataItem>\n *      <span>{{dataItem}} option</span>\n *    </ng-template>\n *  </kendo-dropdownlist>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\nclass ValueTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nValueTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoDropDownListValueTemplate]'\n            },] },\n];\n/** @nocollapse */\nValueTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef }\n];\n\n/* tslint:disable:max-line-length */\n/**\n * @hidden\n */\nconst DROPDOWNLIST_VALUE_ACCESSOR = {\n    multi: true,\n    provide: NG_VALUE_ACCESSOR,\n    // tslint:disable-next-line:no-use-before-declare\n    useExisting: forwardRef(() => DropDownListComponent)\n};\n/**\n * Represents the [Kendo UI DropDownList component for Angular]({% slug overview_ddl %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-dropdownlist [data]=\"listItems\">\n *  </kendo-dropdownlist>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\nclass DropDownListComponent {\n    constructor(localization, popupService, selectionService, navigationService, disabledItemsService, dataService, _zone, renderer, hostElement, cdr, touchEnabled) {\n        this.localization = localization;\n        this.popupService = popupService;\n        this.selectionService = selectionService;\n        this.navigationService = navigationService;\n        this.disabledItemsService = disabledItemsService;\n        this.dataService = dataService;\n        this._zone = _zone;\n        this.renderer = renderer;\n        this.hostElement = hostElement;\n        this.cdr = cdr;\n        this.touchEnabled = touchEnabled;\n        /**\n         * @hidden\n         */\n        this.focusableId = `k-${guid()}`;\n        /**\n         * Sets the height of the options list. By default, `listHeight` is 200px.\n         *\n         * > The `listHeight` property affects only the list of options and not the whole popup container.\n         * > To set the height of the popup container, use `popupSettings.height`.\n         */\n        this.listHeight = 200;\n        /**\n         * Sets the disabled state of the component.\n         */\n        this.disabled = false;\n        /**\n         * Sets the read-only state of the component.\n         */\n        this.readonly = false;\n        /**\n         * Enables the [filtering]({% slug filtering_ddl %}) functionality of the DropDownList.\n         */\n        this.filterable = false;\n        /**\n         * Enables a case-insensitive search. When filtration is disabled, use this option.\n         */\n        this.ignoreCase = true;\n        /**\n         * Sets the delay before an item search is performed. When filtration is disabled, use this option.\n         */\n        this.delay = 500;\n        /**\n         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n         */\n        this.tabindex = 0;\n        /**\n         * Fires each time the value is changed ([see example]({% slug overview_ddl %}#toc-events)).\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * Fires each time the user types in the input field\n         * ([see example]({% slug overview_ddl %}#toc-events)).\n         * You can filter the source based on the passed filtration value.\n         * When the value of the component is programmatically changed to `ngModel` or `formControl`\n         * through its API or form binding, the `valueChange` event is not triggered because it\n         * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.\n         */\n        this.filterChange = new EventEmitter();\n        /**\n         * Fires each time the item selection is changed\n         * ([see example]({% slug overview_ddl %}#toc-events)).\n         */\n        this.selectionChange = new EventEmitter();\n        /**\n         * Fires each time the popup is about to open\n         * ([see example]({% slug openstate_ddl %}#toc-preventing-opening-and-closing)).\n         * This event is preventable. If you cancel it, the popup will remain closed.\n         */\n        this.open = new EventEmitter();\n        /**\n         * Fires each time the popup is about to close\n         * ([see example]({% slug openstate_ddl %}#toc-preventing-opening-and-closing)).\n         * This event is preventable. If you cancel it, the popup will remain open.\n         */\n        this.close = new EventEmitter();\n        /**\n         * Fires each time the user focuses the DropDownList.\n         */\n        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the DropDownList gets blurred.\n         */\n        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename\n        this.widgetClasses = true;\n        this.groupIndices = [];\n        this.listBoxId = guid();\n        this.optionPrefix = guid();\n        this.valueLabelId = guid();\n        this.filterText = \"\";\n        this.isFocused = false;\n        this.onTouchedCallback = (_) => { };\n        this.onChangeCallback = (_) => { };\n        this.word = \"\";\n        this.last = \"\";\n        this.filterFocused = new EventEmitter();\n        this.filterBlurred = new EventEmitter();\n        this.wrapperFocused = new EventEmitter();\n        this.wrapperBlurred = new EventEmitter();\n        this.selectionSubscription = new Subscription();\n        this._open = false;\n        this._popupSettings = { animate: true };\n        this.direction = localization.rtl ? 'rtl' : 'ltr';\n        this.data = [];\n        this.subscribeEvents();\n        this.hostElement = hostElement.nativeElement;\n        this.popupMouseDownHandler = this.onMouseDown.bind(this);\n    }\n    get width() {\n        const wrapperWidth = isDocumentAvailable() ? this.wrapper.nativeElement.offsetWidth : 0;\n        const width = this.popupSettings.width || wrapperWidth;\n        const minWidth = isNaN(wrapperWidth) ? wrapperWidth : `${wrapperWidth}px`;\n        const maxWidth = isNaN(width) ? width : `${width}px`;\n        return { min: minWidth, max: maxWidth };\n    }\n    get height() {\n        const popupHeight = this.popupSettings.height;\n        return isPresent(popupHeight) ? `${popupHeight}px` : 'auto';\n    }\n    get widgetTabIndex() {\n        if (this.disabled) {\n            return undefined;\n        }\n        const providedTabIndex = Number(this.tabIndex);\n        const defaultTabIndex = 0;\n        return !isNaN(providedTabIndex) ? providedTabIndex : defaultTabIndex;\n    }\n    get ariaExpanded() {\n        return this.isOpen;\n    }\n    get ariaOwns() {\n        if (!this.isOpen) {\n            return;\n        }\n        return this.listBoxId;\n    }\n    get ariaActivedescendant() {\n        if (!isPresent(this.dataItem)) {\n            return;\n        }\n        return this.optionPrefix + \"-\" + getter(this.dataItem, this.valueField);\n    }\n    get noDataLabel() {\n        if (this.dataService.itemsCount === 0) {\n            return this.noDataText;\n        }\n    }\n    get appendTo() {\n        const { appendTo } = this.popupSettings;\n        if (!appendTo || appendTo === 'root') {\n            return undefined;\n        }\n        return appendTo === 'component' ? this.container : appendTo;\n    }\n    /**\n     * Sets the data of the DropDownList.\n     *\n     * > The data has to be provided in an array-like list.\n     */\n    set data(data) {\n        this.dataService.data = data || [];\n        if (this.virtual) {\n            this.virtual.skip = 0;\n        }\n        this.setState();\n    }\n    get data() {\n        const virtual = this.virtual;\n        if (virtual) {\n            const start = virtual.skip || 0;\n            const end = start + virtual.pageSize;\n            // Use length instead of itemsCount because of the grouping.\n            virtual.total = this.dataService.data.length;\n            return this.dataService.data.slice(start, end);\n        }\n        return this.dataService.data;\n    }\n    /**\n     * Sets the value of the DropDownList.\n     * It can either be of the primitive (string, numbers) or of the complex (objects) type.\n     * To define the type, use the `valuePrimitive` option.\n     *\n     * > All selected values which are not present in the source are ignored.\n     */\n    set value(newValue) {\n        this._value = newValue;\n        this.cdr.markForCheck();\n    }\n    get value() {\n        return this._value;\n    }\n    /**\n     * Configures the popup of the DropDownList.\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped. The `auto` mode is not supported when virtual scrolling is enabled.\n     * - `height: Number`&mdash;Sets the height of the popup container.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     * - `appendTo: \"root\" | \"component\" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.\n     */\n    set popupSettings(settings) {\n        this._popupSettings = Object.assign({ animate: true }, settings);\n    }\n    get popupSettings() {\n        return this._popupSettings;\n    }\n    /**\n     * Defines a Boolean function that is executed for each data item in the component\n     * ([see examples]({% slug disableditems_ddl %})). Determines whether the item will be disabled.\n     */\n    set itemDisabled(fn) {\n        if (typeof fn !== 'function') {\n            throw new Error(`itemDisabled must be a function, but received ${JSON.stringify(fn)}.`);\n        }\n        this.disabledItemsService.itemDisabled = fn;\n    }\n    /**\n     * Enables the [virtualization]({% slug virtualization_ddl %}) functionality.\n     */\n    set virtual(settings) {\n        this._virtualSettings = normalizeVirtualizationSettings(settings);\n    }\n    get virtual() {\n        return this._virtualSettings;\n    }\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n        this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n        return this.tabindex;\n    }\n    /**\n     * @hidden\n     */\n    blurComponent() {\n        this.wrapperBlurred.emit();\n    }\n    /**\n     * @hidden\n     */\n    blurFilterInput() {\n        this.filterBlurred.emit();\n    }\n    /**\n     * @hidden\n     */\n    focusComponent() {\n        this.wrapperFocused.emit();\n        if (!this.isFocused) {\n            this.isFocused = true;\n            this.onFocus.emit();\n        }\n    }\n    /**\n     * @hidden\n     */\n    keydown(event) {\n        const firstIndex = isPresent(this.defaultItem) ? -1 : 0;\n        let focused = isNaN(this.selectionService.focused) ? this.firstFocusableIndex(firstIndex) : this.selectionService.focused;\n        let offset = 0;\n        if (this.disabled || this.readonly) {\n            return;\n        }\n        const isHomeEnd = event.keyCode === Keys.home || event.keyCode === Keys.end;\n        const isFilterFocused = this.filterable && this.isFocused && this.isOpen;\n        if (isFilterFocused && isHomeEnd) {\n            return;\n        }\n        const hasSelected = isPresent(this.selectionService.selected[0]);\n        const focusedItemNotSelected = isPresent(this.selectionService.focused) && !this.selectionService.isSelected(this.selectionService.focused);\n        if (!hasSelected || focusedItemNotSelected) {\n            if (event.keyCode === Keys.down || event.keyCode === Keys.right) {\n                offset = -1;\n            }\n            else if (event.keyCode === Keys.up || event.keyCode === Keys.left) {\n                offset = 1;\n            }\n        }\n        const eventData = event;\n        const action = this.navigationService.process({\n            current: focused + offset,\n            max: this.dataService.itemsCount - 1,\n            min: this.defaultItem ? -1 : 0,\n            originalEvent: eventData\n        });\n        const leftRightKeys = (action === NavigationAction.Left) || (action === NavigationAction.Right);\n        if (action !== NavigationAction.Undefined &&\n            action !== NavigationAction.Tab &&\n            action !== NavigationAction.Backspace &&\n            action !== NavigationAction.Delete &&\n            !(leftRightKeys && this.filterable) &&\n            action !== NavigationAction.Enter //enter when popup is opened is handled before `handleEnter`\n        ) {\n            eventData.preventDefault();\n        }\n    }\n    /**\n     * @hidden\n     */\n    keypress(event) {\n        if (this.disabled || this.readonly || this.filterable) {\n            return;\n        }\n        this.onKeyPress(event);\n    }\n    /**\n     * @hidden\n     */\n    click() {\n        this.focus();\n        this.togglePopup(!this.isOpen);\n    }\n    /**\n     * @hidden\n     */\n    onResize() {\n        if (this._open) {\n            const popupWrapper = this.popupRef.popupElement;\n            const { min, max } = this.width;\n            popupWrapper.style.minWidth = min;\n            popupWrapper.style.width = max;\n        }\n    }\n    get dir() {\n        return this.direction;\n    }\n    ngOnInit() {\n        this.renderer.removeAttribute(this.hostElement, \"tabindex\");\n        this.localizationChangesSubscription = this.localization\n            .changes.subscribe(({ rtl }) => {\n            this.direction = rtl ? 'rtl' : 'ltr';\n            this.setMessages();\n        });\n        this.setMessages();\n    }\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the component is empty.\n     */\n    isEmpty() {\n        const value = this.value;\n        return !(value === 0 || value === false || value || this.defaultItem);\n    }\n    /**\n     * @hidden\n     */\n    onFilterFocus() {\n        this.filterFocused.emit();\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n        this.destroyPopup();\n        this.unsubscribeEvents();\n        clearTimeout(this.messagesTimeout);\n        if (this.localizationChangesSubscription) {\n            this.localizationChangesSubscription.unsubscribe();\n        }\n    }\n    /**\n     * @hidden\n     */\n    ngOnChanges(_changes) {\n        const virtual = this.virtual;\n        const requestInitialData = virtual && _changes.data && _changes.data.isFirstChange();\n        if (requestInitialData) {\n            this.pageChange({ skip: 0, take: virtual.pageSize });\n        }\n        if (this.valuePrimitive === undefined) {\n            this.valuePrimitive = this.valueField ? false : true;\n        }\n        if (_changes.hasOwnProperty(\"value\")) {\n            this.verifySettings(_changes.value.currentValue);\n            if (!isPresent(this.value)) {\n                this._previousDataItem = undefined;\n            }\n        }\n        if (_changes.hasOwnProperty(\"defaultItem\")) {\n            this.disabledItemsService.defaultItem = this.defaultItem;\n        }\n        const STATE_PROPS = /(value|textField|valueField|valuePrimitive|defaultItem|itemDisabled)/g;\n        if (STATE_PROPS.test(Object.keys(_changes).join())) {\n            this.setState();\n        }\n    }\n    /**\n     * Focuses the DropDownList.\n     */\n    focus() {\n        if (!this.disabled) {\n            this.wrapper.nativeElement.focus();\n        }\n    }\n    /**\n     * Blurs the DropDownList.\n     */\n    blur() {\n        if (!this.disabled) {\n            this.wrapper.nativeElement.blur();\n        }\n    }\n    /**\n     * Toggles the visibility of the popup\n     * ([see example]({% slug openstate_ddl %}#toc-setting-the-initially-opened-component)).\n     * If you use the `toggle` method to open or close the popup, the `open` and `close` events will not be fired.\n     *\n     * @param open - The state of the popup.\n     */\n    toggle(open) {\n        // The Promise is required to open the popup on load.\n        // Otherwise, the \"Expression has changed...\" type error will be thrown.\n        Promise.resolve(null).then(() => {\n            this._toggle(open);\n        });\n    }\n    _toggle(open) {\n        this._open = (open === undefined) ? !this._open : open;\n        this.destroyPopup();\n        if (this._open) {\n            this.createPopup();\n        }\n    }\n    triggerPopupEvents(open) {\n        const eventArgs = new PreventableEvent();\n        if (open) {\n            this.open.emit(eventArgs);\n        }\n        else {\n            this.close.emit(eventArgs);\n        }\n        return eventArgs.isDefaultPrevented();\n    }\n    /**\n     * @hidden\n     */\n    togglePopup(open) {\n        const isDisabled = this.disabled || this.readonly;\n        const sameState = this.isOpen === open;\n        if (isDisabled || sameState) {\n            return;\n        }\n        const isDefaultPrevented = this.triggerPopupEvents(open);\n        if (!isDefaultPrevented) {\n            if (!open && this.filterable && this.isFocused) {\n                this.focus();\n            }\n            this._toggle(open);\n        }\n    }\n    /**\n     * Returns the current open state of the popup.\n     */\n    get isOpen() {\n        return this._open;\n    }\n    /**\n     * Resets the value of the DropDownList.\n     * If you use the `reset` method to clear the value of the component,\n     * the model will not update automatically and the `selectionChange` and `valueChange` events will not be fired.\n     */\n    reset() {\n        this._previousDataItem = undefined;\n        this.value = undefined;\n        this.setState();\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n        this.verifySettings(value);\n        this.value = value === null ? undefined : value;\n        if (!isPresent(value)) {\n            this._previousDataItem = undefined;\n        }\n        this.setState();\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.onChangeCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.onTouchedCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n    get buttonClasses() {\n        return this.loading ? 'k-i-loading' : this.iconClass || 'k-i-arrow-s';\n    }\n    /**\n     * @hidden\n     */\n    get listContainerClasses() {\n        const containerClasses = ['k-list-container', 'k-reset'];\n        if (this.popupSettings.popupClass) {\n            containerClasses.push(this.popupSettings.popupClass);\n        }\n        return containerClasses;\n    }\n    /**\n     * @hidden\n     */\n    get isDisabledDefaultItem() {\n        return this.disabledItemsService.isItemDisabled(this.defaultItem);\n    }\n    /**\n     * @hidden\n     */\n    getText() {\n        return this.text;\n    }\n    /**\n     * @hidden\n     */\n    getDefaultItemText() {\n        return getter(this.defaultItem, this.textField);\n    }\n    createPopup() {\n        if (this.virtual) {\n            this.virtual.skip = 0;\n        }\n        const horizontalAlign = this.direction === \"rtl\" ? \"right\" : \"left\";\n        const anchorPosition = { horizontal: horizontalAlign, vertical: \"bottom\" };\n        const popupPosition = { horizontal: horizontalAlign, vertical: \"top\" };\n        this.popupRef = this.popupService.open({\n            anchor: this.wrapper,\n            anchorAlign: anchorPosition,\n            animate: this.popupSettings.animate,\n            appendTo: this.appendTo,\n            content: this.popupTemplate,\n            popupAlign: popupPosition,\n            popupClass: this.listContainerClasses,\n            positionMode: 'absolute'\n        });\n        const popupWrapper = this.popupRef.popupElement;\n        const { min, max } = this.width;\n        popupWrapper.addEventListener('mousedown', this.popupMouseDownHandler);\n        popupWrapper.style.minWidth = min;\n        popupWrapper.style.width = max;\n        popupWrapper.style.height = this.height;\n        popupWrapper.setAttribute(\"dir\", this.direction);\n        this.popupRef.popupOpen.subscribe(() => {\n            this.cdr.detectChanges();\n            this.optionsList.scrollToItem(this.selectionService.focused);\n        });\n        if (!this.filterable) {\n            this.popupRef.popupAnchorViewportLeave.subscribe(() => this.togglePopup(false));\n        }\n    }\n    destroyPopup() {\n        if (this.popupRef) {\n            this.popupRef.popupElement\n                .removeEventListener('mousedown', this.popupMouseDownHandler);\n            this.popupRef.close();\n            this.popupRef = null;\n        }\n    }\n    updateState({ dataItem, confirm = false }) {\n        this.dataItem = dataItem;\n        this.text = this.prop(this.textField, this.valuePrimitive)(dataItem);\n        if (confirm) {\n            this._previousDataItem = dataItem;\n        }\n    }\n    clearState() {\n        this.text = undefined;\n        this.dataItem = undefined;\n    }\n    resetSelection(index) {\n        const clear = !isPresent(index);\n        this.selectionService.resetSelection(clear ? [] : [index]);\n        this.selectionService.focused = clear ? this.firstFocusableIndex(0) : index;\n    }\n    onSelectionChange({ dataItem }) {\n        this.updateState({ dataItem });\n        this.selectionChange.emit(dataItem);\n        /* forces firefox/nvda, forefox/jaws, ie/jaws to read the new value when\n         the popup is closed and the value is changed with the arrow keys (up/down) */\n        this.valueLabelId = guid();\n    }\n    subscribeEvents() {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        // Item selection when the popup is open.\n        this.selectionSubscription.add(this.selectionService.onSelect.pipe(filter(_ => this.isOpen), map(this.itemFromEvent.bind(this)))\n            .subscribe(this.onSelectionChange.bind(this)));\n        // Item selection when the popup is closed | clicked | enter, and so on.\n        this.selectionSubscription.add(merge(this.selectionService.onSelect.pipe(filter(_ => !this.isOpen)), this.selectionService.onChange).pipe(map(this.itemFromEvent.bind(this)), tap(_ => this.togglePopup(false)))\n            .subscribe(({ dataItem, value: newValue, newSelection }) => {\n            if (newSelection) {\n                this.onSelectionChange({ dataItem });\n            }\n            const shouldUsePrevious = !isPresent(dataItem) && this._previousDataItem;\n            const shouldUseNewValue = newValue !== this.prop(this.valueField, this.valuePrimitive)(this.value);\n            if (shouldUsePrevious) {\n                this.updateState({ dataItem: this._previousDataItem });\n                this.resetSelection();\n            }\n            else if (shouldUseNewValue) {\n                this.value = this.valuePrimitive ? newValue : dataItem;\n                this._previousDataItem = dataItem;\n                this.emitChange(this.value);\n            }\n            this.clearFilter();\n        }));\n        this.navigationSubscription = merge(this.navigationService.up, this.navigationService.down, this.navigationService.left.pipe(skipWhile(() => this.filterable)), this.navigationService.right.pipe(skipWhile(() => this.filterable)), this.navigationService.home, this.navigationService.end)\n            .pipe(filter((event) => !isNaN(event.index)))\n            .subscribe((event) => this.selectionService.select(event.index));\n        this.openSubscription = this.navigationService.open.subscribe(() => this.togglePopup(true));\n        this.closeSubscription = this.navigationService.close.subscribe(() => {\n            this.togglePopup(false);\n            this.focus();\n        });\n        this.enterSubscription = this.navigationService.enter\n            .pipe(tap((event) => event.originalEvent.preventDefault()))\n            .subscribe(this.handleEnter.bind(this));\n        this.escSubscription = this.navigationService.esc\n            .subscribe(this.handleEscape.bind(this));\n        this.filterBlurredSubscription = this.filterBlurred.pipe(concatMap(() => interval(10).pipe(take(1), takeUntil(this.wrapperFocused))))\n            .subscribe(() => {\n            this.wrapperBlurred.emit();\n        });\n        this._zone.runOutsideAngular(() => {\n            this.componentBlurredSubscription =\n                merge(this.wrapperBlurred.pipe(concatMap(() => interval(10).pipe(take(1), takeUntil(this.filterFocused)))), this.navigationService.tab).pipe(tap(event => event instanceof NavigationEvent && this.focus()), filter(() => this.isFocused))\n                    .subscribe(() => this._zone.run(() => {\n                    this.componentBlur();\n                }));\n        });\n    }\n    unsubscribeEvents() {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        this.navigationSubscription.unsubscribe();\n        this.openSubscription.unsubscribe();\n        this.closeSubscription.unsubscribe();\n        this.enterSubscription.unsubscribe();\n        this.escSubscription.unsubscribe();\n        this.componentBlurredSubscription.unsubscribe();\n        this.filterBlurredSubscription.unsubscribe();\n        if (this.selectionSubscription) {\n            this.selectionSubscription.unsubscribe();\n        }\n    }\n    itemFromEvent(event) {\n        const index = event.indices[0];\n        let dataItem = this.dataService.itemAt(index);\n        dataItem = isPresent(dataItem) ? dataItem : this.currentOrDefault(index);\n        const value = this.prop(this.valueField, this.valuePrimitive)(dataItem);\n        const newSelection = event.newSelection;\n        return {\n            dataItem,\n            index,\n            newSelection,\n            value\n        };\n    }\n    currentOrDefault(selectedIndex) {\n        const defaultItemIndex = -1;\n        if (isPresent(this.dataItem) && selectedIndex !== defaultItemIndex) {\n            return this.dataItem;\n        }\n        else {\n            return this.defaultItem;\n        }\n    }\n    firstFocusableIndex(index) {\n        const maxIndex = this.dataService.itemsCount - 1;\n        if (this.disabledItemsService.isIndexDisabled(index)) {\n            return (index < maxIndex) ? this.firstFocusableIndex(index + 1) : undefined;\n        }\n        else {\n            return index;\n        }\n    }\n    handleEnter() {\n        if (this.isOpen) {\n            this.selectionService.change(this.selectionService.focused);\n            this.focus();\n        }\n        else {\n            this.togglePopup(true);\n        }\n    }\n    handleEscape() {\n        this.selectionService.change(this.selectionService.selected[0]);\n        this.focus();\n    }\n    clearFilter() {\n        if (!(this.filterable && this.filterText)) {\n            return;\n        }\n        this.filterText = \"\";\n        this.cdr.markForCheck();\n        this.filterChange.emit(this.filterText);\n    }\n    verifySettings(newValue) {\n        const valueOrText = !isPresent(this.valueField) !== !isPresent(this.textField);\n        if (!isDevMode()) {\n            return;\n        }\n        if (this.defaultItem && this.valueField && typeof this.defaultItem !== \"object\") {\n            throw new Error(DropDownListMessages.defaultItem);\n        }\n        if (this.valuePrimitive === true && isPresent(newValue) && typeof newValue === \"object\") {\n            throw new Error(DropDownListMessages.primitive);\n        }\n        if (this.valuePrimitive === false && isPresent(newValue) && typeof newValue !== \"object\") {\n            throw new Error(DropDownListMessages.object);\n        }\n        if (valueOrText) {\n            throw new Error(DropDownListMessages.textAndValue);\n        }\n    }\n    componentBlur() {\n        this.isFocused = false;\n        this.selectionService.change(this.selectionService.selected[0]);\n        this.onBlur.emit();\n        this.onTouchedCallback();\n    }\n    /**\n     * @hidden\n     */\n    onMouseDown(event) {\n        const tagName = event.target.tagName.toLowerCase();\n        if (tagName !== \"input\") {\n            event.preventDefault();\n        }\n    }\n    onKeyPress(event) {\n        if (event.which === 0 || event.keyCode === Keys.enter) {\n            return;\n        }\n        let character = String.fromCharCode(event.charCode || event.keyCode);\n        if (this.ignoreCase) {\n            character = character.toLowerCase();\n        }\n        if (character === \" \") {\n            event.preventDefault();\n        }\n        this.word += character;\n        this.last = character;\n        this.search();\n    }\n    search() {\n        clearTimeout(this.typingTimeout);\n        if (!this.filterable) {\n            this.typingTimeout = setTimeout(() => { this.word = \"\"; }, this.delay);\n            this.selectNext();\n        }\n    }\n    selectNext() {\n        let data = this.dataService\n            .filter((item) => isPresent(item) && !item.header && !this.disabledItemsService.isItemDisabled(item))\n            .map((item) => {\n            if (this.dataService.grouped) {\n                return { item: item.value, itemIndex: item.offsetIndex };\n            }\n            return { item: item, itemIndex: this.dataService.indexOf(item) };\n        });\n        const isInLoop = sameCharsOnly(this.word, this.last);\n        let dataLength = data.length;\n        let hasSelected = !isNaN(this.selectionService.selected[0]);\n        let startIndex = !hasSelected ? 0 : this.selectionService.selected[0];\n        let text, index, defaultItem;\n        if (this.defaultItem && !this.disabledItemsService.isItemDisabled(this.defaultItem)) {\n            defaultItem = { item: this.defaultItem, itemIndex: -1 };\n            dataLength += 1;\n            startIndex += 1;\n        }\n        startIndex += isInLoop && hasSelected ? 1 : 0;\n        data = shuffleData(data, startIndex, defaultItem);\n        index = 0;\n        for (; index < dataLength; index++) {\n            text = getter(data[index].item, this.textField);\n            const loopMatch = Boolean(isInLoop && matchText(text, this.last, this.ignoreCase));\n            const nextMatch = Boolean(matchText(text, this.word, this.ignoreCase));\n            if (loopMatch || nextMatch) {\n                index = data[index].itemIndex;\n                break;\n            }\n        }\n        if (index !== dataLength) {\n            this.navigate(index);\n        }\n    }\n    emitChange(value) {\n        this.onChangeCallback(value);\n        this.valueChange.emit(value);\n    }\n    navigate(index) {\n        this.selectionService.select(index);\n    }\n    prop(field, usePrimitive) {\n        return (dataItem) => {\n            if (isPresent(dataItem)) {\n                if (usePrimitive) {\n                    return field && isObject(dataItem) ? dataItem[field] : dataItem;\n                }\n                else {\n                    return dataItem[field];\n                }\n            }\n            return null;\n        };\n    }\n    findDataItem({ primitive, valueField, value }) {\n        const result = {\n            dataItem: null,\n            index: -1\n        };\n        const prop = this.prop(valueField, primitive);\n        let comparer;\n        if (this.dataService.grouped) {\n            comparer = (element) => {\n                return prop(element.value) === prop(value);\n            };\n        }\n        else {\n            comparer = (element) => {\n                return prop(element) === prop(value);\n            };\n        }\n        const index = this.dataService.findIndex(comparer);\n        result.dataItem = this.dataService.itemAt(index);\n        result.index = index;\n        return result;\n    }\n    setState() {\n        const value = this.value;\n        const valueField = this.valueField;\n        const textField = this.textField;\n        const primitive = this.valuePrimitive;\n        if (this.defaultItem) {\n            const defaultValue = this.prop(valueField, primitive)(this.defaultItem);\n            const currentValue = this.prop(valueField, primitive)(value);\n            if (!isPresent(value) || (currentValue === defaultValue)) {\n                this.updateState({ dataItem: this.defaultItem, confirm: true });\n                this.resetSelection(-1);\n                if (this.filterable && this.filterText && this.dataService.itemsCount) {\n                    this.selectionService.focused = this.firstFocusableIndex(0);\n                }\n                return;\n            }\n        }\n        const resolved = this.findDataItem({ primitive, valueField, value });\n        // The data and value are of same shape,\n        // for example, value: 'foo', data: ['foo', 'bar']\n        // or value: { value: 1, text: 'foo' }, data: [{ value: 1, text: 'foo' }].\n        const ofSameType = !(primitive && textField);\n        if (resolved.dataItem) {\n            this.updateState({ dataItem: resolved.dataItem, confirm: true });\n            this.resetSelection(resolved.index);\n        }\n        else if (isPresent(value) && ofSameType) {\n            this.updateState({ dataItem: value });\n            this.resetSelection();\n        }\n        else if (this._previousDataItem) {\n            this.updateState({ dataItem: this._previousDataItem });\n            this.resetSelection();\n        }\n        else {\n            this.clearState();\n            this.resetSelection();\n        }\n    }\n    /**\n     * @hidden\n     */\n    handleFilter(event) {\n        this.filterChange.emit(event.target.value);\n    }\n    /**\n     * @hidden\n     */\n    pageChange(event) {\n        const virtual = this.virtual;\n        virtual.skip = event.skip;\n    }\n    setMessages() {\n        this._zone.runOutsideAngular(() => {\n            clearTimeout(this.messagesTimeout);\n            this.messagesTimeout = setTimeout(() => {\n                this.noDataText = this.localization.get('noDataText');\n                this.cdr.detectChanges();\n            });\n        });\n    }\n}\nDropDownListComponent.decorators = [\n    { type: Component, args: [{\n                exportAs: 'kendoDropDownList',\n                providers: [\n                    DROPDOWNLIST_VALUE_ACCESSOR,\n                    DataService,\n                    SelectionService,\n                    NavigationService,\n                    DisabledItemsService,\n                    LocalizationService,\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.dropdownlist'\n                    },\n                    {\n                        provide: FilterableDropDownComponentBase, useExisting: forwardRef(() => DropDownListComponent)\n                    },\n                    {\n                        provide: KendoInput, useExisting: forwardRef(() => DropDownListComponent)\n                    }\n                ],\n                selector: 'kendo-dropdownlist',\n                template: `\n        <ng-container kendoDropDownListLocalizedMessages\n            i18n-noDataText=\"kendo.dropdownlist.noDataText|The text displayed in the popup when there are no items\"\n            noDataText=\"NO DATA FOUND\"\n        >\n        </ng-container>\n        <span #wrapper unselectable=\"on\"\n          role=\"listbox\"\n          [id]=\"focusableId\"\n          [ngClass]=\"{\n            'k-dropdown-wrap': true,\n            'k-state-default': !this.disabled,\n            'k-state-disabled': this.disabled,\n            'k-state-focused': this.isFocused\n          }\"\n          [attr.dir]=\"direction\"\n          [attr.readonly]=\"readonly\"\n          [attr.tabindex]=\"widgetTabIndex\"\n          [attr.aria-disabled]=\"disabled\"\n          [attr.aria-readonly]=\"readonly\"\n          aria-haspopup=\"listbox\"\n          [attr.aria-expanded]=\"ariaExpanded\"\n          [attr.aria-owns]=\"ariaOwns\"\n          [attr.aria-activedescendant]=\"ariaActivedescendant\"\n          [attr.aria-describedby]=\"valueLabelId\"\n          [attr.aria-label]=\"noDataLabel\"\n          (focus)=\"focusComponent()\"\n          (blur)=\"blurComponent()\"\n          (keydown)=\"keydown($event)\"\n          (keypress)=\"keypress($event)\"\n          (click)=\"click()\"\n        >\n            <span class=\"k-input\" unselectable=\"on\" [id]=\"valueLabelId\">\n               <ng-template *ngIf=\"valueTemplate\"\n                   [templateContext]=\"{\n                       templateRef: valueTemplate.templateRef,\n                       $implicit: dataItem\n                   }\">\n               </ng-template>\n               <ng-template [ngIf]=\"!valueTemplate\">{{ getText() }}</ng-template>\n           </span>\n           <span class=\"k-select\" unselectable=\"on\">\n               <span class=\"k-icon\"\n                    [ngClass]=\"buttonClasses\">\n                </span>\n           </span>\n           <ng-template #popupTemplate>\n               <!--filterable-->\n\n               <ng-template [ngIf]=\"filterable\">\n                   <span class=\"k-list-filter\" (click)=\"$event.stopImmediatePropagation()\">\n                       <input\n                           [attr.aria-owns]=\"ariaOwns\"\n                           [attr.aria-activedescendant]=\"ariaActivedescendant\"\n                           [attr.aria-label]=\"noDataLabel\"\n                           tabindex=\"-1\"\n                           [filterInput]=\"isFocused && !touchEnabled\"\n                           [dir]=\"direction\"\n                           [(ngModel)]=\"filterText\"\n                           class=\"k-textbox\"\n                           (keydown)=\"keydown($event)\"\n                           (input)=\"handleFilter($event)\"\n                           (focus)=\"onFilterFocus()\"\n                           (blur)=\"blurFilterInput()\" />\n                       <span class=\"k-icon k-i-search\" unselectable=\"on\"></span>\n                   </span>\n               </ng-template>\n               <!--default item-->\n               <ng-template [ngIf]=\"defaultItem && !itemTemplate\">\n                   <div class=\"k-list-optionlabel\" [ngClass]=\"{ 'k-state-disabled': isDisabledDefaultItem }\" kendoDropDownsSelectable [index]=\"-1\">\n                       {{ getDefaultItemText() }}\n                   </div>\n               </ng-template>\n               <ng-template [ngIf]=\"defaultItem && itemTemplate\">\n                   <div class=\"k-list-optionlabel\" [ngClass]=\"{ 'k-state-disabled': isDisabledDefaultItem }\" kendoDropDownsSelectable [index]=\"-1\">\n                       <ng-template\n                           [templateContext]=\"{\n                               templateRef: itemTemplate.templateRef,\n                               $implicit: defaultItem\n                           }\">\n                       </ng-template>\n                   </div>\n               </ng-template>\n               <!--header template-->\n               <ng-template *ngIf=\"headerTemplate\"\n                   [templateContext]=\"{\n                       templateRef: headerTemplate.templateRef\n                   }\">\n               </ng-template>\n               <!--list-->\n               <kendo-list\n                   #optionsList\n                   [id]=\"listBoxId\"\n                   [optionPrefix]=\"optionPrefix\"\n                   [data]=\"data\"\n                   [textField]=\"textField\"\n                   [valueField]=\"valueField\"\n                   [template]=\"itemTemplate\"\n                   [groupTemplate]=\"groupTemplate\"\n                   [fixedGroupTemplate]=\"fixedGroupTemplate\"\n                   [height]=\"listHeight\"\n                   [show]=\"isOpen\"\n                   [virtual]=\"virtual\"\n                   (pageChange)=\"pageChange($event)\"\n                   >\n               </kendo-list>\n               <!--no-data template-->\n               <div class=\"k-nodata\" *ngIf=\"data.length === 0\">\n                   <ng-template [ngIf]=\"noDataTemplate\"\n                       [templateContext]=\"{\n                           templateRef: noDataTemplate ? noDataTemplate.templateRef : undefined\n                       }\">\n                   </ng-template>\n                   <ng-template [ngIf]=\"!noDataTemplate\">\n                       <div>{{ noDataText }}</div>\n                   </ng-template>\n               </div>\n               <!--footer template-->\n               <ng-template *ngIf=\"footerTemplate\"\n                   [templateContext]=\"{\n                       templateRef: footerTemplate.templateRef\n                   }\">\n               </ng-template>\n            </ng-template>\n        </span>\n        <ng-template [ngIf]=\"isOpen\">\n            <kendo-resize-sensor (resize)=\"onResize()\"></kendo-resize-sensor>\n        </ng-template>\n        <ng-container #container></ng-container>\n  `\n            },] },\n];\n/** @nocollapse */\nDropDownListComponent.ctorParameters = () => [\n    { type: LocalizationService },\n    { type: PopupService },\n    { type: SelectionService },\n    { type: NavigationService },\n    { type: DisabledItemsService },\n    { type: DataService },\n    { type: NgZone },\n    { type: Renderer2 },\n    { type: ElementRef },\n    { type: ChangeDetectorRef },\n    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [TOUCH_ENABLED,] }] }\n];\nDropDownListComponent.propDecorators = {\n    focusableId: [{ type: Input }],\n    iconClass: [{ type: Input }],\n    loading: [{ type: Input }],\n    data: [{ type: Input }],\n    value: [{ type: Input }],\n    textField: [{ type: Input }],\n    valueField: [{ type: Input }],\n    popupSettings: [{ type: Input }],\n    listHeight: [{ type: Input }],\n    defaultItem: [{ type: Input }],\n    disabled: [{ type: Input }],\n    itemDisabled: [{ type: Input }],\n    readonly: [{ type: Input }],\n    filterable: [{ type: Input }],\n    virtual: [{ type: Input }],\n    ignoreCase: [{ type: Input }],\n    delay: [{ type: Input }],\n    valuePrimitive: [{ type: Input }],\n    tabindex: [{ type: Input }],\n    tabIndex: [{ type: Input, args: [\"tabIndex\",] }],\n    valueChange: [{ type: Output }],\n    filterChange: [{ type: Output }],\n    selectionChange: [{ type: Output }],\n    open: [{ type: Output }],\n    close: [{ type: Output }],\n    onFocus: [{ type: Output, args: ['focus',] }],\n    onBlur: [{ type: Output, args: ['blur',] }],\n    itemTemplate: [{ type: ContentChild, args: [ItemTemplateDirective,] }],\n    groupTemplate: [{ type: ContentChild, args: [GroupTemplateDirective,] }],\n    fixedGroupTemplate: [{ type: ContentChild, args: [FixedGroupTemplateDirective,] }],\n    valueTemplate: [{ type: ContentChild, args: [ValueTemplateDirective,] }],\n    headerTemplate: [{ type: ContentChild, args: [HeaderTemplateDirective,] }],\n    footerTemplate: [{ type: ContentChild, args: [FooterTemplateDirective,] }],\n    noDataTemplate: [{ type: ContentChild, args: [NoDataTemplateDirective,] }],\n    container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef },] }],\n    popupTemplate: [{ type: ViewChild, args: ['popupTemplate',] }],\n    wrapper: [{ type: ViewChild, args: ['wrapper',] }],\n    optionsList: [{ type: ViewChild, args: ['optionsList',] }],\n    widgetClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-dropdown',] }, { type: HostBinding, args: ['class.k-header',] }],\n    dir: [{ type: HostBinding, args: ['attr.dir',] }]\n};\n\n/* tslint:disable:max-line-length */\n/**\n * Renders the content of the custom list item in the MultiSelect\n * ([see example]({% slug templates_multiselect %}#toc-customizing-the-item-content)).\n * The template context is set to the current component.\n * To get a reference to the current text that is typed by the\n * user, use the `let-customItem` directive.\n *\n * > The `CustomItemTemplate` directive can only be used with the MultiSelect component.\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-multiselect [data]=\"listItems\" [allowCustom]=\"true\">\n *    <ng-template kendoMultiSelectCustomItemTemplate let-customItem>\n *      <span>New Item: {{customItem}}</span>\n *    </ng-template>\n *  </kendo-multiselect>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n *\n */\nclass CustomItemTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nCustomItemTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoMultiSelectCustomItemTemplate]'\n            },] },\n];\n/** @nocollapse */\nCustomItemTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef }\n];\n\n/* tslint:disable:max-line-length */\n/**\n * Renders the selected tag value of the MultiSelect\n * ([see example]({% slug templates_multiselect %}#toc-tag-template)).\n * The template context is set to the current component.\n * To get a reference to the current data item, use the `let-dataItem` directive.\n *\n * > The `TagTemplate` directive can only be used with the MultiSelect component.\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-multiselect [data]=\"items\">\n *    <ng-template kendoMultiSelectTagTemplate let-dataItem>\n *      <span>{{dataItem}} option</span>\n *    </ng-template>\n *  </kendo-multiselect>\n * `\n * })\n * class AppComponent {\n *   public items: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\nclass TagTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nTagTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoMultiSelectTagTemplate]'\n            },] },\n];\n/** @nocollapse */\nTagTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef }\n];\n\n/* tslint:disable:max-line-length */\n/**\n * Renders the grouped tag values in the MultiSelect\n * ([see example]({% slug summarytagmode_multiselect %})).\n * The template context is set to the current component.\n * To get a reference to the current grouped\n * data items collection, use the `let-dataItems` directive.\n *\n * > The `GroupTagTemplate` directive can only be used with the MultiSelect component.\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-multiselect kendoMultiSelectSummaryTag [data]=\"items\">\n *    <ng-template kendoMultiSelectGroupTagTemplate let-dataItems>\n *      <span>{{dataItems.length}} item(s) selected</span>\n *    </ng-template>\n *  </kendo-multiselect>\n * `\n * })\n * class AppComponent {\n *   public items: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\nclass GroupTagTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nGroupTagTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoMultiSelectGroupTagTemplate]'\n            },] },\n];\n/** @nocollapse */\nGroupTagTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef }\n];\n\n/**\n * Arguments for the `removeTag` event. The `removeTag` event fires when a tag is about\n * to the removed. If you cancel the event, the removal is prevented.\n */\nclass RemoveTagEvent extends PreventableEvent {\n    /**\n     * Constructs the event arguments for the `remove` event.\n     * @param dataItem - The data item or an array of data items that will be removed.\n     */\n    constructor(dataItem) {\n        super();\n        this.dataItem = dataItem;\n    }\n}\n\n/* tslint:disable:max-line-length */\nconst MULTISELECT_VALUE_ACCESSOR = {\n    multi: true,\n    provide: NG_VALUE_ACCESSOR,\n    // tslint:disable-next-line:no-use-before-declare\n    useExisting: forwardRef(() => MultiSelectComponent)\n};\n/**\n * Represents the [Kendo UI MultiSelect component for Angular]({% slug overview_multiselect %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-multiselect [data]=\"listItems\">\n *  </kendo-multiselect>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\nclass MultiSelectComponent {\n    constructor(localization, popupService, dataService, selectionService, navigationService, disabledItemsService, cdr, differs, renderer, hostElement, _zone, touchEnabled) {\n        this.localization = localization;\n        this.popupService = popupService;\n        this.dataService = dataService;\n        this.selectionService = selectionService;\n        this.navigationService = navigationService;\n        this.disabledItemsService = disabledItemsService;\n        this.cdr = cdr;\n        this.differs = differs;\n        this.renderer = renderer;\n        this.hostElement = hostElement;\n        this._zone = _zone;\n        this.touchEnabled = touchEnabled;\n        this.listBoxId = guid();\n        this.tagListId = guid();\n        this.tagPrefix = \"tag-\" + guid();\n        this.optionPrefix = \"option-\" + guid();\n        this.focusedTagIndex = undefined;\n        /**\n         * @hidden\n         */\n        this.focusableId = `k-${guid()}`;\n        /**\n         * Determines whether to close the options list of the MultiSelect after the item selection is finished\n         * ([see example]({% slug openstate_multiselect %}#toc-keeping-the-options-list-open-while-on-focus)).\n         * @default true\n         */\n        this.autoClose = true;\n        /**\n         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n         */\n        this.tabindex = 0;\n        /**\n         * Sets the disabled state of the component.\n         */\n        this.disabled = false;\n        /**\n         * Sets the read-only state of the component.\n         */\n        this.readonly = false;\n        /**\n         * Enables the [filtering]({% slug filtering_multiselect %}) functionality of the MultiSelect.\n         */\n        this.filterable = false;\n        /**\n         * Sets the height of the suggestions list. By default, `listHeight` is 200px.\n         *\n         * > The `listHeight` property affects only the list of suggestions and not the whole popup container.\n         * > To set the height of the popup container, use `popupSettings.height`.\n         */\n        this.listHeight = 200;\n        /**\n         * If set to `true`, renders a button on hovering over the component.\n         * Clicking this button resets the value of the component to an empty array and triggers the `change` event.\n         */\n        this.clearButton = true;\n        /**\n         * A user-defined callback function which receives an array of selected data items and maps them to an array of tags.\n         *\n         * @param { Any[] } dataItems - The selected data items from the list.\n         * @returns { Any[] } - The tags that will be rendered by the component.\n         */\n        this.tagMapper = (tags) => tags || [];\n        /**\n         * Specifies whether the MultiSelect allows user-defined values that are not present in the dataset\n         * ([more information and examples]({% slug custom_values_multiselect %})).\n         * Defaults to `false`.\n         */\n        this.allowCustom = false;\n        /**\n         * A user-defined callback function which returns normalized custom values.\n         * Typically used when the data items are different from type `string`.\n         *\n         * @param { Any } value - The custom value that is defined by the user.\n         * @returns { Any }\n         *\n         * @example\n         * ```ts\n         * import { map } from 'rxjs/operators';\n         *\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *   <kendo-multiselect\n         *       [allowCustom]=\"true\"\n         *       [data]=\"listItems\"\n         *       [textField]=\"'text'\"\n         *       [valueField]=\"'value'\"\n         *       [valueNormalizer]=\"valueNormalizer\"\n         *       (valueChange)=\"onValueChange($event)\"\n         *   >\n         *   </kendo-multiselect>\n         * `\n         * })\n         *\n         * class AppComponent {\n         *   public listItems: Array<{ text: string, value: number }> = [\n         *       { text: \"Small\", value: 1 },\n         *       { text: \"Medium\", value: 2 },\n         *       { text: \"Large\", value: 3 }\n         *   ];\n         *\n         *   public onValueChange(value) {\n         *       console.log(\"valueChange : \", value);\n         *   }\n         *\n         *   public valueNormalizer = (text$: Observable<string>) => text$.pipe(map((text: string) => {\n         *      return {\n         *         value: Math.floor(Math.random() * (1000 - 100) + 1000), //generate unique valueField\n         *         text: text };\n         *   }));\n         *\n         * }\n         * ```\n         */\n        this.valueNormalizer = (text) => text.pipe(map((userInput) => {\n            const comparer = (item) => typeof item === 'string' && userInput.toLowerCase() === item.toLowerCase();\n            const matchingValue = this.value.find(comparer);\n            if (matchingValue) {\n                return matchingValue;\n            }\n            const matchingItem = this.dataService.find(comparer);\n            return matchingItem ? matchingItem : userInput;\n        }));\n        /**\n         * Fires each time the user types in the input field.\n         * You can filter the source based on the passed filtration value.\n         */\n        this.filterChange = new EventEmitter();\n        /**\n         * Fires each time the value is changed&mdash;\n         * when the component is blurred or the value is cleared through the **Clear** button\n         * ([see example]({% slug overview_multiselect %}#toc-events)).\n         * When the value of the component is programmatically changed to `ngModel` or `formControl`\n         * through its API or form binding, the `valueChange` event is not triggered because it\n         * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * Fires each time the popup is about to open\n         * ([see example]({% slug openstate_multiselect %}#toc-preventing-opening-and-closing)).\n         * This event is preventable. If you cancel it, the popup will remain closed.\n         */\n        this.open = new EventEmitter();\n        /**\n         * Fires each time the popup is about to close\n         * ([see example]({% slug openstate_multiselect %}#toc-preventing-opening-and-closing)).\n         * This event is preventable. If you cancel it, the popup will remain open.\n         */\n        this.close = new EventEmitter();\n        /**\n         * Fires each time the user focuses the MultiSelect.\n         */\n        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the MultiSelect gets blurred.\n         */\n        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time a tag is about to be removed.\n         * This event is preventable. If you cancel it, the tag will not be removed.\n         */\n        this.removeTag = new EventEmitter();\n        this.widgetClasses = true;\n        this.onChangeCallback = (_) => { };\n        this.onTouchedCallback = (_) => { };\n        this._placeholder = '';\n        this._open = false;\n        this._value = [];\n        this._popupSettings = { animate: true };\n        this.isFocused = false;\n        this.selectedDataItems = [];\n        this.customValueSubject = new Subject();\n        this.observableSubscriptions = new Subscription();\n        this.hostElement = hostElement.nativeElement;\n        this.popupMouseDownHandler = this.onMouseDown.bind(this);\n        this.data = [];\n        this.direction = this.localization.rtl ? 'rtl' : 'ltr';\n        this.subscribeEvents();\n    }\n    /**\n     * Focuses the MultiSelect.\n     */\n    focus() {\n        if (!this.disabled) {\n            this.searchbar.focus();\n        }\n    }\n    /**\n     * @hidden\n     */\n    onSearchBarFocus() {\n        if (!this.isFocused) {\n            this.isFocused = true;\n            this.onFocus.emit();\n        }\n    }\n    /**\n     * Blurs the MultiSelect.\n     */\n    blur() {\n        if (!this.disabled) {\n            this.searchbar.blur();\n        }\n    }\n    /**\n     * @hidden\n     */\n    onSearchBarBlur() {\n        if (this.isFocused) {\n            this.closePopup();\n            this.isFocused = false;\n            if (!this.allowCustom) {\n                this.clearFilter();\n            }\n            this.onBlur.emit();\n            this.onTouchedCallback();\n        }\n    }\n    /**\n     * @hidden\n     */\n    wrapperMousedown(event) {\n        const inputElement = this.searchbar.input.nativeElement;\n        if (event.button === 0) {\n            if (this.isFocused && this.isOpen && event.target === inputElement) {\n                return;\n            }\n            if (!this.touchEnabled || (this.touchEnabled && event.target.tagName !== 'SPAN')) {\n                this.searchbar.focus();\n            }\n            this.togglePopup(!this.isOpen);\n            event.preventDefault();\n        }\n    }\n    /**\n     * @hidden\n     */\n    onMouseDown(event) {\n        event.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n    onResize() {\n        if (this._open) {\n            const popupWrapper = this.popupRef.popupElement;\n            const { min, max } = this.width;\n            popupWrapper.style.minWidth = min;\n            popupWrapper.style.width = max;\n        }\n    }\n    get appendTo() {\n        const { appendTo } = this.popupSettings;\n        if (!appendTo || appendTo === 'root') {\n            return undefined;\n        }\n        return appendTo === 'component' ? this.container : appendTo;\n    }\n    /**\n     * Sets the data of the MultiSelect.\n     *\n     * > The data has to be provided in an array-like list of items.\n     */\n    set data(data) {\n        this.dataService.data = data || [];\n        if (this.virtual) {\n            this.virtual.skip = 0;\n        }\n        this.setState(this.value);\n    }\n    get data() {\n        const virtual = this.virtual;\n        if (virtual) {\n            const start = virtual.skip || 0;\n            const end = start + virtual.pageSize;\n            //Use length instead of itemsCount because of grouping\n            virtual.total = this.dataService.data.length;\n            return this.dataService.data.slice(start, end);\n        }\n        return this.dataService.data;\n    }\n    /**\n     * Sets the value of the MultiSelect. It can be either of the primitive (string, numbers) or of the complex (objects) type.\n     * To define the type, use the `valuePrimitive` option.\n     *\n     * > All selected values which are not present in the source are ignored.\n     */\n    set value(values) {\n        this._value = values ? values : [];\n        if (!this.differ && this.value) {\n            this.differ = this.differs.find(this.value).create();\n        }\n    }\n    get value() {\n        return this._value;\n    }\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n        this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n        return this.tabindex;\n    }\n    /**\n     * The hint which is displayed when the component is empty.\n     * When the values are selected, it disappears.\n     */\n    set placeholder(text) {\n        this._placeholder = text || '';\n    }\n    get placeholder() {\n        return this.selectedDataItems.length ? '' : this._placeholder;\n    }\n    /**\n     * Defines a Boolean function that is executed for each data item in the component\n     * ([see examples]({% slug disableditems_multiselect %})). Determines whether the item will be disabled.\n     */\n    set itemDisabled(fn) {\n        if (typeof fn !== 'function') {\n            throw new Error(`itemDisabled must be a function, but received ${JSON.stringify(fn)}.`);\n        }\n        this.disabledItemsService.itemDisabled = fn;\n    }\n    /**\n     * Enables the [virtualization]({% slug virtualization_multiselect %}) functionality.\n     */\n    set virtual(settings) {\n        this._virtualSettings = normalizeVirtualizationSettings(settings);\n    }\n    get virtual() {\n        return this._virtualSettings;\n    }\n    /**\n     * Configures the popup of the MultiSelect.\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped. The `auto` mode is not supported when virtual scrolling is enabled.\n     * - `height: Number`&mdash;Sets the height of the popup container.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     * - `appendTo: \"root\" | \"component\" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.\n     */\n    set popupSettings(settings) {\n        this._popupSettings = Object.assign({ animate: true }, settings);\n    }\n    get popupSettings() {\n        return this._popupSettings;\n    }\n    get dir() {\n        return this.direction;\n    }\n    get focusedClass() {\n        return this.isFocused;\n    }\n    get disabledClass() {\n        return this.disabled;\n    }\n    get listContainerClasses() {\n        const containerClasses = ['k-list-container', 'k-reset'];\n        if (this.popupSettings.popupClass) {\n            containerClasses.push(this.popupSettings.popupClass);\n        }\n        return containerClasses;\n    }\n    get width() {\n        let wrapperOffsetWidth = 0;\n        if (isDocumentAvailable()) {\n            wrapperOffsetWidth = this.wrapper.nativeElement.offsetWidth;\n        }\n        const width = this.popupSettings.width || wrapperOffsetWidth;\n        const minWidth = isNaN(wrapperOffsetWidth) ? wrapperOffsetWidth : `${wrapperOffsetWidth}px`;\n        const maxWidth = isNaN(width) ? width : `${width}px`;\n        return { min: minWidth, max: maxWidth };\n    }\n    get height() {\n        const popupHeight = this.popupSettings.height;\n        return isPresent(popupHeight) ? `${popupHeight}px` : 'auto';\n    }\n    get activeDescendant() {\n        const focusedTagIndex = this.focusedTagIndex;\n        const focusedListIndex = this.selectionService.focused;\n        let prefix;\n        let item;\n        if (isPresent(focusedTagIndex) && !this.isOpen) {\n            item = this.tags[focusedTagIndex];\n            prefix = this.tagPrefix;\n        }\n        else if (isPresent(focusedListIndex) && focusedListIndex !== -1 && this.isOpen) {\n            item = this.dataService.itemAt(focusedListIndex);\n            prefix = this.optionPrefix;\n        }\n        else {\n            return null;\n        }\n        return prefix + \"-\" + this.prop(this.valueField, this.valuePrimitive)(item);\n    }\n    get noDataLabel() {\n        if (this.dataService.itemsCount === 0) {\n            return this.noDataText;\n        }\n    }\n    get clearTitle() {\n        return this.localization.get('clearTitle');\n    }\n    /**\n     * @hidden\n     */\n    verifySettings() {\n        const valueOrText = !isPresent(this.valueField) !== !isPresent(this.textField);\n        if (!isDevMode() || this.value.length === 0) {\n            return;\n        }\n        if (!isArray(this.value)) {\n            throw new Error(MultiselectMessages.array);\n        }\n        if (this.valuePrimitive === true && isObjectArray(this.value)) {\n            throw new Error(MultiselectMessages.primitive);\n        }\n        if (this.valuePrimitive === false && !isObjectArray(this.value)) {\n            throw new Error(MultiselectMessages.object);\n        }\n        if (valueOrText) {\n            throw new Error(MultiselectMessages.textAndValue);\n        }\n    }\n    /**\n     * @hidden\n     */\n    change(event) {\n        const isCustomItem = (isPresent(event.added) || isPresent(event.removed)) && (event.added === -1 || event.removed === -1);\n        if (isCustomItem) {\n            this.addCustomValue(this.text);\n            return; // The change is emited asynchronosly.\n        }\n        // Existing items.\n        if (isPresent(event.added)) {\n            const dataItem = this.dataService.itemAt(event.added);\n            const newItem = (this.valuePrimitive && isPresent(dataItem) && isPresent(dataItem[this.valueField])) ? dataItem[this.valueField] : dataItem;\n            this.value = [...this.value, newItem];\n            this.cdr.markForCheck();\n        }\n        if (isPresent(event.removed)) {\n            const dataItem = this.dataService.itemAt(event.removed);\n            const prop = this.prop(this.valueField, this.valuePrimitive);\n            const filter$$1 = (item) => prop(item) !== prop(dataItem);\n            this.value = this.value.filter(filter$$1);\n            this.selectedDataItems = this.selectedDataItems.filter(filter$$1);\n            this.tags = this.tagMapper(this.selectedDataItems.slice());\n            this.cdr.detectChanges();\n        }\n        this.emitValueChange();\n    }\n    /**\n     * @hidden\n     */\n    setState(value) {\n        const objectArray = isObjectArray(value);\n        let data = this.dataService.data;\n        if (this.dataService.grouped) {\n            data = data.filter(item => !item.header).map(item => item.value);\n        }\n        const selection = selectedIndices(this.value, data, this.valueField);\n        this.selectionService.resetSelection(selection);\n        if (this.isOpen && this.selectionService.focused === undefined) {\n            this.selectionService.focused = this.dataService.itemsCount ? this.firstFocusableIndex(0) : this.allowCustom ? -1 : undefined;\n        }\n        if (!this.text) {\n            if (!(isPresent(value) && value.length)) {\n                this.selectedDataItems = [];\n            }\n            if (this.valuePrimitive && !this.valueField) {\n                this.selectedDataItems = value.slice();\n            }\n            if (objectArray || this.valuePrimitive && this.valueField) {\n                this.selectedDataItems = resolveAllValues(value, data, this.valueField);\n            }\n            if (this.selectedDataItems.length < value.length) {\n                const prop = this.prop(this.valueField, this.valuePrimitive);\n                const dataItems = value\n                    .map(current => {\n                    const dataItem = this.selectedDataItems.find(item => prop(item) === prop(current));\n                    return isPresent(dataItem) ? dataItem : this.resolveDataItemFromTags(current);\n                })\n                    .filter(dataItem => isPresent(dataItem));\n                this.selectedDataItems = dataItems;\n            }\n        }\n        this.tags = this.tagMapper(this.selectedDataItems.slice(0));\n        this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n    handleFilter(text) {\n        this.text = text;\n        if (text && !this.isOpen) {\n            this.openPopup();\n        }\n        if (this.filterable) {\n            this.filterChange.emit(text);\n        }\n        else {\n            this.searchTextAndFocus(text);\n        }\n        this.searchbar.setInputSize();\n    }\n    /**\n     * @hidden\n     */\n    pageChange(event) {\n        const virtual = this.virtual;\n        virtual.skip = event.skip;\n    }\n    /**\n     * @hidden\n     */\n    clearFilter() {\n        if (this.filterable && this.text) {\n            this.filterChange.emit(\"\");\n        }\n        this.text = \"\";\n        /* Clearing the value from the input as the setInputSize calculation will be incorrect otherwise.\n         Calling cdr.detectChanges to clear the input value as a result of property binding\n         causes JAWS to read outdated tag values in IE upon tag selection for some reason. */\n        this.searchbar.input.nativeElement.value = \"\";\n        this.searchbar.setInputSize();\n    }\n    /**\n     * @hidden\n     */\n    handleNavigate(event) {\n        const navigateInput = this.text && event.keyCode !== Keys.down && event.keyCode !== Keys.up;\n        const selectValue = this.text && event.keyCode === Keys.enter || event.keyCode === Keys.esc;\n        const deleteTag = !this.text && event.keyCode === Keys.backspace && this.tags.length > 0;\n        if (deleteTag) {\n            this.handleBackspace();\n            return;\n        }\n        if (this.disabled || navigateInput && !selectValue) {\n            return;\n        }\n        const eventData = event;\n        const focused = isNaN(this.selectionService.focused) ? -1 : this.selectionService.focused;\n        const action = this.navigationService.process({\n            current: focused,\n            max: this.dataService.itemsCount - 1,\n            min: this.allowCustom && this.text ? -1 : 0,\n            open: this.isOpen,\n            originalEvent: eventData\n        });\n        if (action !== NavigationAction.Undefined &&\n            ((action === NavigationAction.Enter && this.isOpen) || action !== NavigationAction.Enter)) {\n            event.preventDefault();\n        }\n    }\n    /**\n     * @hidden\n     */\n    handleRemoveTag(tagData) {\n        const eventArgs = new RemoveTagEvent(tagData);\n        if (this.disabled || this.readonly) {\n            return;\n        }\n        this.focus();\n        this.removeTag.emit(eventArgs);\n        if (eventArgs.isDefaultPrevented()) {\n            return;\n        }\n        if (tagData instanceof Array) {\n            this.removeGroupTag(tagData);\n        }\n        else {\n            this.removeSingleTag(tagData);\n        }\n        this.cdr.detectChanges();\n    }\n    /**\n     * @hidden\n     */\n    clearAll(event) {\n        event.stopImmediatePropagation();\n        this.clearFilter();\n        this.reset();\n        this.emitValueChange();\n    }\n    /**\n     * @hidden\n     */\n    addCustomValue(text) {\n        this.customValueSubject.next(text);\n    }\n    ngAfterContentChecked() {\n        this.verifySettings();\n    }\n    ngDoCheck() {\n        if (this.differ) {\n            const valueChanges = this.differ.diff(this.value);\n            if (valueChanges && !this.valueChangeDetected) {\n                this.selectedDataItems = this.getSelectedDataItems(valueChanges);\n                this.tags = this.tagMapper(this.selectedDataItems.slice(0));\n                if (!(this.tags && this.dataService.data)) {\n                    return;\n                }\n                const isValueCustom = (value) => this.dataService.indexOf(value) === -1;\n                const isValueSelected = (value) => this.selectionService.isSelected(this.dataService.indexOf(value));\n                const reselectionRequired = this.selectedDataItems.some(value => !(isValueCustom(value) || isValueSelected(value)));\n                if (reselectionRequired) {\n                    this.setState(this.value);\n                }\n            }\n        }\n        this.valueChangeDetected = false;\n    }\n    ngOnInit() {\n        this.renderer.removeAttribute(this.hostElement, \"tabindex\");\n        this.createCustomValueStream();\n        this.localizationChangeSubscription = this.localization\n            .changes.subscribe(({ rtl }) => {\n            this.direction = rtl ? 'rtl' : 'ltr';\n            this.setMessages();\n        });\n        this.setMessages();\n    }\n    ngOnChanges(changes) {\n        const virtual = this.virtual;\n        const requestInitialData = virtual && changes.data && changes.data.isFirstChange();\n        if (requestInitialData) {\n            this.pageChange({ skip: 0, take: virtual.pageSize });\n        }\n        if (this.valuePrimitive === undefined) {\n            this.valuePrimitive = !this.valueField;\n        }\n        if (isChanged(\"valueNormalizer\", changes)) {\n            this.createCustomValueStream();\n        }\n        const STATE_PROPS = /(data|textField|valueField|valuePrimitive|value)/g;\n        if (changes.hasOwnProperty(\"value\")) {\n            this.valueChangeDetected = true;\n        }\n        if (STATE_PROPS.test(Object.keys(changes).join())) {\n            this.setState(this.value);\n        }\n    }\n    ngAfterViewInit() {\n        this.searchbar.setInputSize();\n    }\n    ngOnDestroy() {\n        this._toggle(false);\n        this.unsubscribeEvents();\n        clearTimeout(this.messagesTimeout);\n        if (this.localizationChangeSubscription) {\n            this.localizationChangeSubscription.unsubscribe();\n        }\n    }\n    /**\n     * Toggles the visibility of the popup\n     * ([see example]({% slug openstate_multiselect %}#toc-setting-the-initially-opened-component)).\n     * If you use the `toggle` method to open or close the popup, the respective `open` and `close` events will not be fired.\n     *\n     * @param open - The state of the popup.\n     */\n    toggle(open) {\n        // The Promise is required for opening the popup on load.\n        // Otherwise, the \"Expression has changed...\" type error will be thrown.\n        Promise.resolve(null).then(() => {\n            this._toggle((open === undefined) ? !this._open : open);\n            this.cdr.markForCheck();\n        });\n    }\n    /**\n     * Returns the current open state of the popup.\n     */\n    get isOpen() {\n        return this._open;\n    }\n    /**\n     * Resets the value of the MultiSelect.\n     * If you use the `reset` method to clear the value of the component,\n     * the model will not update automatically and the `selectionChange` and `valueChange` events will not be fired.\n     */\n    reset() {\n        this.text = \"\";\n        this.value = [];\n        this.selectedDataItems = [];\n        this.setState([]);\n        this.cdr.markForCheck();\n    }\n    // NG MODEL BINDINGS\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n        this.value = value || [];\n        this.setState(this.value);\n        this.verifySettings();\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.onChangeCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.onTouchedCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n    onTagMapperChange() {\n        this.tags = this.tagMapper(this.selectedDataItems.slice(0));\n        this.cdr.markForCheck();\n    }\n    prop(field, usePrimitive) {\n        return (dataItem) => {\n            if (isPresent(dataItem)) {\n                if (usePrimitive) {\n                    return field && isObject(dataItem) ? dataItem[field] : dataItem;\n                }\n                else {\n                    return dataItem[field];\n                }\n            }\n            return null;\n        };\n    }\n    subscribeEvents() {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        const isOpen = () => this.isOpen;\n        const isClosed = () => !this.isOpen;\n        const isTagFocused = () => !this.isOpen && this.focusedTagIndex !== undefined;\n        [\n            this.selectionService.onChange.subscribe(this.handleItemChange.bind(this)),\n            this.navigationService.esc.subscribe(this.closePopup.bind(this)),\n            this.navigationService.enter.pipe(filter(isOpen)).subscribe(this.handleEnter.bind(this)),\n            this.navigationService.open.subscribe(this.openPopup.bind(this)),\n            this.navigationService.close.subscribe(this.handleClose.bind(this)),\n            this.navigationService.up.pipe(filter(isOpen)).subscribe((event) => this.handleUp(event.index)),\n            this.navigationService.home.pipe(filter(() => isClosed)).subscribe(this.handleHome.bind(this)),\n            this.navigationService.end.pipe(filter(() => isClosed)).subscribe(this.handleEnd.bind(this)),\n            this.navigationService.backspace.pipe(filter(isTagFocused)).subscribe(this.handleBackspace.bind(this)),\n            this.navigationService.delete.pipe(filter(isTagFocused)).subscribe(this.handleDelete.bind(this)),\n            this.navigationService.left.subscribe(this.handleLeftKey.bind(this)),\n            this.navigationService.right.subscribe(this.handleRightKey.bind(this)),\n            this.navigationService.down.subscribe((event) => this.handleDownKey(event.index))\n        ].forEach(s => this.observableSubscriptions.add(s));\n    }\n    unsubscribeEvents() {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        this.observableSubscriptions.unsubscribe();\n        if (this.customValueSubscription) {\n            this.customValueSubscription.unsubscribe();\n        }\n    }\n    removeGroupTag(dataItems) {\n        const prop = this.prop(this.valueField, this.valuePrimitive);\n        let data = this.dataService.data;\n        if (this.dataService.grouped) {\n            data = data.filter(item => !item.header).map(item => item.value);\n        }\n        const dataItemValues = new Set(dataItems.map(item => prop(item)));\n        this.value = this.value.filter(value => !dataItemValues.has(prop(value)));\n        this.selectedDataItems = this.selectedDataItems.filter(value => !dataItemValues.has(prop(value)));\n        const selection = selectedIndices(this.value, data, this.valueField);\n        this.selectionService.resetSelection(selection);\n        this.tags = this.tagMapper(this.selectedDataItems.slice(0));\n        this.cdr.markForCheck();\n        this.emitValueChange();\n    }\n    removeSingleTag(dataItem) {\n        const prop = this.prop(this.valueField, this.valuePrimitive);\n        let data = this.dataService.data;\n        if (this.dataService.grouped) {\n            data = data.filter(item => !item.header).map(item => item.value);\n        }\n        const index = selectedIndices([dataItem], data, this.valueField)[0];\n        if (isNumber(index)) {\n            this.selectionService.unselect(index);\n            this.togglePopup(false);\n        }\n        else { // the deleted item is not present in the source\n            const filter$$1 = item => prop(item) !== prop(dataItem);\n            this.value = this.value.filter(filter$$1);\n            this.selectedDataItems = this.selectedDataItems.filter(filter$$1);\n            this.tags = this.tagMapper(this.selectedDataItems.slice(0));\n            this.cdr.markForCheck();\n            this.emitValueChange();\n        }\n    }\n    createCustomValueStream() {\n        if (this.customValueSubscription) {\n            this.customValueSubscription.unsubscribe();\n        }\n        this.customValueSubscription = this.customValueSubject.pipe(tap(() => {\n            this.loading = true;\n            this.disabled = true;\n            this.cdr.detectChanges();\n        }), this.valueNormalizer, catchError(() => {\n            this.loading = false;\n            this.disabled = false;\n            this.clearFilter();\n            if (this.autoClose) {\n                this.togglePopup(false);\n                this.nextTick(() => {\n                    this.searchbar.focus();\n                });\n            }\n            this.createCustomValueStream();\n            return of(null);\n        }))\n            .subscribe((normalizedValue) => {\n            this.loading = false;\n            this.disabled = false;\n            this.clearFilter();\n            if (isPresent(normalizedValue)) { //if valueNormalizer returns `null` or `undefined` custom value is discarded\n                const newValue = this.valuePrimitive ? getter(normalizedValue, this.valueField) : normalizedValue;\n                const itemIndex = this.dataService.indexOf(newValue);\n                const customItem = itemIndex === -1;\n                if (this.value.indexOf(newValue) === -1) {\n                    if (!customItem) {\n                        this.selectionService.add(itemIndex);\n                    }\n                    else {\n                        this.value = [...this.value, newValue];\n                    }\n                    this.selectedDataItems = [...this.selectedDataItems, normalizedValue];\n                }\n                else {\n                    if (!customItem && this.selectionService.isSelected(itemIndex)) {\n                        this.selectionService.unselect(itemIndex);\n                    }\n                    else {\n                        this.value.splice(this.value.indexOf(newValue), 1);\n                        this.selectedDataItems = this.selectedDataItems.filter(item => getter(item, this.valueField) !== newValue);\n                    }\n                }\n                this.tags = this.tagMapper(this.selectedDataItems.slice(0));\n                this.emitValueChange();\n            }\n            if (this.autoClose) {\n                this.togglePopup(false);\n                this.nextTick(() => {\n                    this.searchbar.focus();\n                });\n            }\n        });\n    }\n    handleItemChange(event) {\n        this.change(event);\n        if (this.autoClose) {\n            this.togglePopup(false);\n        }\n        if (isPresent(event.added) && event.added !== -1) {\n            this.clearFilter();\n        }\n    }\n    handleEnter(event) {\n        const service = this.selectionService;\n        const focusedIndex = this.selectionService.focused;\n        if (this.isOpen) {\n            event.originalEvent.preventDefault();\n        }\n        if (focusedIndex === -1) {\n            if (this.allowCustom && this.text) {\n                this.addCustomValue(this.text);\n            }\n            return; // Clear filter & close are done at customValueSubscription due to race conditions.\n        }\n        if (service.isSelected(focusedIndex)) {\n            service.unselect(focusedIndex);\n        }\n        else {\n            service.add(focusedIndex);\n        }\n        this.clearFilter();\n        if (this.autoClose) {\n            this.togglePopup(false);\n        }\n    }\n    handleClose() {\n        this.closePopup();\n        this.searchbar.focus();\n    }\n    handleEnd() {\n        this.focusedTagIndex = this.tags.length - 1;\n    }\n    handleHome() {\n        this.focusedTagIndex = 0;\n    }\n    handleUp(index) {\n        this.selectionService.focused = index;\n    }\n    handleBackspace() {\n        if (this.focusedTagIndex !== undefined) {\n            this.handleDelete();\n        }\n        else {\n            this.handleRemoveTag(this.tags[this.tags.length - 1]);\n            this.searchbar.focus();\n        }\n    }\n    handleDelete() {\n        this.handleRemoveTag(this.tags[this.focusedTagIndex]);\n        if (this.focusedTagIndex === this.tags.length) {\n            this.focusedTagIndex = undefined;\n        }\n    }\n    handleLeftKey() {\n        if (this.direction === 'rtl') {\n            if (this.focusedTagIndex === 0) {\n                this.focusedTagIndex = undefined;\n            }\n            if (this.focusedTagIndex === undefined) {\n                return;\n            }\n        }\n        if (this.focusedTagIndex === undefined || this.focusedTagIndex < 0) {\n            this.focusedTagIndex = this.tags.length - 1;\n        }\n        else if (this.focusedTagIndex !== 0) {\n            this.focusedTagIndex--;\n        }\n    }\n    handleDownKey(index) {\n        if (this.isOpen) {\n            this.selectionService.focused = index || this.firstFocusableIndex(0);\n        }\n        else {\n            this.openPopup();\n        }\n    }\n    handleRightKey() {\n        const last = this.tags.length - 1;\n        if (this.direction === 'rtl') {\n            if (this.focusedTagIndex === undefined) {\n                this.focusedTagIndex = 0;\n                return;\n            }\n            if (this.focusedTagIndex === last) {\n                return;\n            }\n        }\n        if (this.focusedTagIndex === last) {\n            this.focusedTagIndex = undefined;\n        }\n        else if (this.focusedTagIndex < last) {\n            this.focusedTagIndex++;\n        }\n    }\n    findIndex(text, startsFrom = 0) {\n        let itemText;\n        text = text.toLowerCase();\n        let index = this.dataService.findIndex(item => {\n            if (this.dataService.grouped) {\n                itemText = this.prop(this.textField, this.valuePrimitive)(item.value);\n            }\n            else {\n                itemText = this.prop(this.textField, this.valuePrimitive)(item);\n            }\n            itemText = !isPresent(itemText) ? \"\" : itemText.toString().toLowerCase();\n            return text && itemText.startsWith(text);\n        }, startsFrom);\n        if (this.disabledItemsService.isIndexDisabled(index)) {\n            return (index + 1 > this.dataService.itemsCount) ? -1 : this.findIndex(text, index + 1);\n        }\n        else {\n            return index;\n        }\n    }\n    searchTextAndFocus(text) {\n        const index = this.findIndex(text);\n        this.selectionService.focused = index;\n    }\n    closePopup() {\n        this.togglePopup(false);\n        this.focusedTagIndex = undefined;\n    }\n    openPopup() {\n        this.togglePopup(true);\n        this.focusedTagIndex = undefined;\n    }\n    togglePopup(open) {\n        const isDisabled = this.disabled || this.readonly;\n        const sameState = this.isOpen === open;\n        if (isDisabled || sameState) {\n            return;\n        }\n        const isDefaultPrevented = this.triggerPopupEvents(open);\n        if (!isDefaultPrevented) {\n            this._toggle(open);\n        }\n    }\n    triggerPopupEvents(open) {\n        const eventArgs = new PreventableEvent();\n        if (open) {\n            this.open.emit(eventArgs);\n        }\n        else {\n            this.close.emit(eventArgs);\n        }\n        return eventArgs.isDefaultPrevented();\n    }\n    _toggle(open) {\n        this._open = (open === undefined) ? !this._open : open;\n        this.destroyPopup();\n        if (this._open) {\n            this.createPopup();\n        }\n    }\n    destroyPopup() {\n        if (this.popupRef) {\n            this.popupRef.popupElement\n                .removeEventListener('mousedown', this.popupMouseDownHandler);\n            this.popupRef.close();\n            this.popupRef = null;\n        }\n    }\n    createPopup() {\n        if (this.virtual) {\n            this.virtual.skip = 0;\n        }\n        const horizontalAlign = this.direction === \"rtl\" ? \"right\" : \"left\";\n        const anchorPosition = { horizontal: horizontalAlign, vertical: \"bottom\" };\n        const popupPosition = { horizontal: horizontalAlign, vertical: \"top\" };\n        this.popupRef = this.popupService.open({\n            anchor: this.wrapper,\n            anchorAlign: anchorPosition,\n            animate: this.popupSettings.animate,\n            appendTo: this.appendTo,\n            content: this.popupTemplate,\n            popupAlign: popupPosition,\n            popupClass: this.listContainerClasses,\n            positionMode: 'absolute'\n        });\n        const popupWrapper = this.popupRef.popupElement;\n        const { min, max } = this.width;\n        popupWrapper.addEventListener('mousedown', this.popupMouseDownHandler);\n        popupWrapper.style.minWidth = min;\n        popupWrapper.style.width = max;\n        popupWrapper.style.height = this.height;\n        popupWrapper.setAttribute(\"dir\", this.direction);\n        this.popupRef.popupOpen.subscribe(() => {\n            this.cdr.detectChanges();\n            this.optionsList.scrollToItem(this.selectionService.focused);\n        });\n        this.popupRef.popupAnchorViewportLeave.subscribe(() => {\n            this.togglePopup(false);\n        });\n    }\n    emitValueChange() {\n        this.onChangeCallback(this.value);\n        this.valueChange.emit(this.value);\n    }\n    getSelectedDataItems(valueChanges) {\n        if (!this.dataService.itemsCount && this.valuePrimitive && this.valueField) {\n            return [];\n        }\n        const isBoundToComplexData = isObjectArray(this.data);\n        const prop = this.prop(this.valueField, this.valuePrimitive);\n        let currentValue;\n        let index;\n        let selectedDataItems = [];\n        valueChanges.forEachItem((value) => {\n            currentValue = value.currentValue;\n            if (this.dataService.grouped) {\n                index = this.dataService.findIndex((item) => {\n                    return prop(item.value) === prop(currentValue);\n                });\n            }\n            else {\n                index = this.dataService.findIndex((item) => {\n                    return prop(item) === prop(currentValue);\n                });\n            }\n            if (index !== -1) {\n                selectedDataItems.push(this.dataService.itemAt(index));\n            }\n            else if (isPresent(value) && !(isBoundToComplexData && this.valuePrimitive)) { //value is not present in the data\n                selectedDataItems.push(currentValue);\n            }\n            else { // value is primitive, dataItem is an object, dataItem is not present in the current data set\n                const item = this.resolveDataItemFromTags(currentValue);\n                if (isPresent(item)) {\n                    selectedDataItems.push(item);\n                }\n            }\n        });\n        return selectedDataItems;\n    }\n    resolveDataItemFromTags(value) {\n        if (!(this.tags && this.tags.length && isPresent(value))) {\n            return undefined;\n        }\n        // Flattening the tags array in case of a summary tag occurrence.\n        const tags = this.tags.reduce((acc, tag) => {\n            const items = isArray(tag) ? tag : [tag];\n            acc.push(...items);\n            return acc;\n        }, []);\n        const prop = this.prop(this.valueField, this.valuePrimitive);\n        return tags.find(tag => prop(tag) === prop(value));\n    }\n    firstFocusableIndex(index) {\n        const maxIndex = this.dataService.itemsCount;\n        if (this.disabledItemsService.isIndexDisabled(index)) {\n            const nextIndex = index + 1;\n            return (nextIndex < maxIndex) ? this.firstFocusableIndex(nextIndex) : undefined;\n        }\n        else {\n            return index;\n        }\n    }\n    nextTick(f) {\n        this._zone.runOutsideAngular(() => {\n            // Use `setTimeout` instead of a resolved promise\n            // because the latter does not wait long enough.\n            setTimeout(() => this._zone.run(f));\n        });\n    }\n    setMessages() {\n        this._zone.runOutsideAngular(() => {\n            clearTimeout(this.messagesTimeout);\n            this.messagesTimeout = setTimeout(() => {\n                this.noDataText = this.localization.get('noDataText');\n                this.cdr.detectChanges();\n            });\n        });\n    }\n}\nMultiSelectComponent.decorators = [\n    { type: Component, args: [{\n                exportAs: 'kendoMultiSelect',\n                providers: [\n                    MULTISELECT_VALUE_ACCESSOR,\n                    DataService,\n                    SelectionService,\n                    NavigationService,\n                    DisabledItemsService,\n                    LocalizationService,\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.multiselect'\n                    },\n                    {\n                        provide: FilterableDropDownComponentBase, useExisting: forwardRef(() => MultiSelectComponent)\n                    },\n                    {\n                        provide: KendoInput, useExisting: forwardRef(() => MultiSelectComponent)\n                    }\n                ],\n                selector: 'kendo-multiselect',\n                template: `\n        <ng-container kendoMultiSelectLocalizedMessages\n            i18n-noDataText=\"kendo.multiselect.noDataText|The text displayed in the popup when there are no items\"\n            noDataText=\"NO DATA FOUND\"\n\n            i18n-clearTitle=\"kendo.combobox.clearTitle|The title of the clear button\"\n            clearTitle=\"clear\"\n        >\n        </ng-container>\n        <div class=\"k-multiselect-wrap k-floatwrap\"\n            #wrapper\n            (mousedown)=\"wrapperMousedown($event)\"\n        >\n            <kendo-taglist\n                [id]=\"tagListId\"\n                [tags]=\"tags\"\n                [textField]=\"textField\"\n                [valueField]=\"valueField\"\n                [focused]=\"focusedTagIndex\"\n                [disabled]=\"disabled\"\n                [template]=\"tagTemplate\"\n                [groupTemplate]=\"groupTagTemplate\"\n                [tagPrefix]=\"tagPrefix\"\n                (removeTag)=\"handleRemoveTag($event)\"\n            >\n            </kendo-taglist>\n            <kendo-searchbar\n                #searchbar\n                [id]=\"focusableId\"\n                [role]=\"'listbox'\"\n                [tagListId]=\"tagListId\"\n                [activeDescendant]=\"activeDescendant\"\n                [noDataLabel]=\"noDataLabel\"\n                [userInput]=\"text\"\n                [disabled]=\"disabled\"\n                [readonly]=\"readonly\"\n                [tabIndex]=\"tabIndex\"\n                [popupOpen]=\"isOpen\"\n                [placeholder]=\"placeholder\"\n                (onNavigate)=\"handleNavigate($event)\"\n                (valueChange)=\"handleFilter($event)\"\n                (onBlur)=\"onSearchBarBlur()\"\n                (onFocus)=\"onSearchBarFocus()\"\n            >\n            </kendo-searchbar>\n            <span *ngIf=\"!loading && !readonly && clearButton && (tags?.length || text?.length)\" class=\"k-icon k-clear-value k-i-close\" [attr.title]=\"clearTitle\" role=\"button\" tabindex=\"-1\" (mousedown)=\"clearAll($event)\"></span>\n            <span *ngIf=\"loading\" class=\"k-icon k-i-loading\"></span>\n        </div>\n        <ng-template #popupTemplate>\n            <!--header template-->\n            <ng-template *ngIf=\"headerTemplate\"\n                [templateContext]=\"{\n                    templateRef: headerTemplate.templateRef\n                }\">\n            </ng-template>\n            <!--custom item template-->\n            <div class=\"k-list\" *ngIf=\"allowCustom && text\">\n                <div class=\"k-item k-custom-item\" kendoDropDownsSelectable [multipleSelection]=\"true\" [index]=\"-1\">\n                    <ng-template *ngIf=\"customItemTemplate;else default_custom_item_template\"\n                        [templateContext]=\"{\n                            templateRef: customItemTemplate.templateRef,\n                            $implicit: text\n                        }\">\n                    </ng-template>\n                    <ng-template #default_custom_item_template>{{ text }}</ng-template>\n                    <span class=\"k-icon k-i-plus\" style=\"float: right\"></span>\n                </div>\n            </div>\n            <!--list-->\n            <kendo-list\n                #optionsList\n                [id]=\"listBoxId\"\n                [optionPrefix]=\"optionPrefix\"\n                [data]=\"data\"\n                [textField]=\"textField\"\n                [valueField]=\"valueField\"\n                [height]=\"listHeight\"\n                [template]=\"template\"\n                [groupTemplate]=\"groupTemplate\"\n                [fixedGroupTemplate]=\"fixedGroupTemplate\"\n                [show]=\"isOpen\"\n                [multipleSelection]=\"true\"\n                [virtual]=\"virtual\"\n                (pageChange)=\"pageChange($event)\"\n                >\n            </kendo-list>\n            <!--no data template-->\n            <div class=\"k-nodata\" *ngIf=\"data.length === 0\">\n                <ng-template [ngIf]=\"noDataTemplate\"\n                    [templateContext]=\"{\n                        templateRef: noDataTemplate ? noDataTemplate.templateRef : undefined\n                    }\">\n                </ng-template>\n                <ng-template [ngIf]=\"!noDataTemplate\">\n                    <div>{{ noDataText }}</div>\n                </ng-template>\n            </div>\n            <!--footer template-->\n            <ng-template *ngIf=\"footerTemplate\"\n                [templateContext]=\"{\n                    templateRef: footerTemplate.templateRef\n                }\">\n            </ng-template>\n        </ng-template>\n        <ng-template [ngIf]=\"isOpen\">\n            <kendo-resize-sensor (resize)=\"onResize()\"></kendo-resize-sensor>\n        </ng-template>\n        <ng-container #container></ng-container>\n  `\n            },] },\n];\n/** @nocollapse */\nMultiSelectComponent.ctorParameters = () => [\n    { type: LocalizationService },\n    { type: PopupService },\n    { type: DataService },\n    { type: SelectionService },\n    { type: NavigationService },\n    { type: DisabledItemsService },\n    { type: ChangeDetectorRef },\n    { type: KeyValueDiffers },\n    { type: Renderer2 },\n    { type: ElementRef },\n    { type: NgZone },\n    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [TOUCH_ENABLED,] }] }\n];\nMultiSelectComponent.propDecorators = {\n    focusableId: [{ type: Input }],\n    autoClose: [{ type: Input }],\n    loading: [{ type: Input }],\n    data: [{ type: Input }],\n    value: [{ type: Input }],\n    valueField: [{ type: Input }],\n    textField: [{ type: Input }],\n    tabindex: [{ type: Input }],\n    tabIndex: [{ type: Input, args: [\"tabIndex\",] }],\n    placeholder: [{ type: Input }],\n    disabled: [{ type: Input }],\n    itemDisabled: [{ type: Input }],\n    readonly: [{ type: Input }],\n    filterable: [{ type: Input }],\n    virtual: [{ type: Input }],\n    popupSettings: [{ type: Input }],\n    listHeight: [{ type: Input }],\n    valuePrimitive: [{ type: Input }],\n    clearButton: [{ type: Input }],\n    tagMapper: [{ type: Input }],\n    allowCustom: [{ type: Input }],\n    valueNormalizer: [{ type: Input }],\n    filterChange: [{ type: Output }],\n    valueChange: [{ type: Output }],\n    open: [{ type: Output }],\n    close: [{ type: Output }],\n    onFocus: [{ type: Output, args: ['focus',] }],\n    onBlur: [{ type: Output, args: ['blur',] }],\n    removeTag: [{ type: Output }],\n    container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef },] }],\n    searchbar: [{ type: ViewChild, args: [SearchBarComponent,] }],\n    popupTemplate: [{ type: ViewChild, args: ['popupTemplate',] }],\n    wrapper: [{ type: ViewChild, args: ['wrapper',] }],\n    optionsList: [{ type: ViewChild, args: ['optionsList',] }],\n    template: [{ type: ContentChild, args: [ItemTemplateDirective,] }],\n    customItemTemplate: [{ type: ContentChild, args: [CustomItemTemplateDirective,] }],\n    groupTemplate: [{ type: ContentChild, args: [GroupTemplateDirective,] }],\n    fixedGroupTemplate: [{ type: ContentChild, args: [FixedGroupTemplateDirective,] }],\n    headerTemplate: [{ type: ContentChild, args: [HeaderTemplateDirective,] }],\n    footerTemplate: [{ type: ContentChild, args: [FooterTemplateDirective,] }],\n    tagTemplate: [{ type: ContentChild, args: [TagTemplateDirective,] }],\n    groupTagTemplate: [{ type: ContentChild, args: [GroupTagTemplateDirective,] }],\n    noDataTemplate: [{ type: ContentChild, args: [NoDataTemplateDirective,] }],\n    widgetClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-multiselect',] }, { type: HostBinding, args: ['class.k-header',] }],\n    dir: [{ type: HostBinding, args: ['attr.dir',] }],\n    focusedClass: [{ type: HostBinding, args: ['class.k-state-focused',] }],\n    disabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }]\n};\n\n/* tslint:disable:max-line-length */\n/**\n * @hidden\n */\nclass TagListComponent {\n    constructor() {\n        this.removeTag = new EventEmitter();\n    }\n    tagProp(tag, prop) {\n        return prop && isObject(tag) ? tag[prop] : tag;\n    }\n    deleteTag(event, tag) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        if (!this.disabled && event.which === 1) {\n            this.removeTag.emit(tag);\n        }\n    }\n    itemId(tag) {\n        if (tag) { //because of custom values\n            return this.tagPrefix + \"-\" + this.tagProp(tag, this.valueField);\n        }\n    }\n    isGroupTag(tag) {\n        return tag instanceof Array;\n    }\n}\nTagListComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-taglist',\n                template: `\n        <ul [attr.id]=\"id\" class=\"k-reset\">\n            <li role=\"option\" *ngFor=\"let tag of tags; let i = index;\" aria-selected=\"true\" [attr.aria-setsize]=\"tags?.length\"\n                class=\"k-button\" [ngClass]=\"{ 'k-state-focused': i === focused }\" [attr.id]=\"itemId(tag)\"\n            >\n                <ng-template *ngIf=\"isGroupTag(tag); then groupTag else singleTag\"></ng-template>\n                    <ng-template #groupTag>\n                        <span>\n                            <ng-template *ngIf=\"groupTemplate\"\n                                [templateContext]=\"{\n                                templateRef: groupTemplate.templateRef,\n                                $implicit: tag\n                            }\">\n                            </ng-template>\n                            <ng-template [ngIf]=\"!groupTemplate\">{{ tag.length }} {{ tag.length === 1 ? 'item' : 'items' }} selected</ng-template>\n                        </span>\n                    </ng-template>\n                    <ng-template #singleTag>\n                        <span>\n                        <ng-template *ngIf=\"template\"\n                                [templateContext]=\"{\n                                templateRef: template.templateRef,\n                                $implicit: tag\n                            }\">\n                            </ng-template>\n                            <ng-template [ngIf]=\"!template\">{{ tagProp(tag, textField) }}</ng-template>\n                        </span>\n                    </ng-template>\n\n                <span aria-label=\"delete\" [attr.aria-hidden]=\"i !== focused\" class=\"k-select\">\n                    <span class=\"k-icon k-i-close\" (mousedown)=\"deleteTag($event, tag)\">\n                    </span>\n                </span>\n            </li>\n        </ul>\n  `\n            },] },\n];\nTagListComponent.propDecorators = {\n    tags: [{ type: Input }],\n    textField: [{ type: Input }],\n    valueField: [{ type: Input }],\n    focused: [{ type: Input }],\n    template: [{ type: Input }],\n    groupTemplate: [{ type: Input }],\n    disabled: [{ type: Input }],\n    tagPrefix: [{ type: Input }],\n    id: [{ type: Input }],\n    removeTag: [{ type: Output }]\n};\n\n/**\n * @hidden\n */\nclass TemplateContextDirective {\n    constructor(viewContainerRef) {\n        this.viewContainerRef = viewContainerRef;\n    }\n    set templateContext(context) {\n        if (this.insertedViewRef) {\n            this.viewContainerRef.remove(this.viewContainerRef.indexOf(this.insertedViewRef));\n            this.insertedViewRef = undefined;\n        }\n        if (context.templateRef) {\n            this.insertedViewRef = this.viewContainerRef.createEmbeddedView(context.templateRef, context);\n        }\n    }\n}\nTemplateContextDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[templateContext]' // tslint:disable-line\n            },] },\n];\n/** @nocollapse */\nTemplateContextDirective.ctorParameters = () => [\n    { type: ViewContainerRef }\n];\nTemplateContextDirective.propDecorators = {\n    templateContext: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nclass SelectableDirective {\n    constructor(selectionService) {\n        // @HostBinding('attr.offset-index')\n        // @Input() public offsetIndex: number;\n        this.multipleSelection = false;\n        this.selectionService = selectionService;\n    }\n    get focusedClassName() {\n        return this.selectionService.isFocused(this.index);\n    }\n    get selectedClassName() {\n        return this.selectionService.isSelected(this.index);\n    }\n    onClick(event) {\n        event.stopPropagation();\n        if (this.multipleSelection) {\n            if (this.selectionService.isSelected(this.index)) {\n                this.selectionService.unselect(this.index);\n            }\n            else {\n                this.selectionService.add(this.index);\n            }\n        }\n        else {\n            this.selectionService.change(this.index);\n        }\n    }\n}\nSelectableDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoDropDownsSelectable]'\n            },] },\n];\n/** @nocollapse */\nSelectableDirective.ctorParameters = () => [\n    { type: SelectionService }\n];\nSelectableDirective.propDecorators = {\n    index: [{ type: HostBinding, args: ['attr.index',] }, { type: Input }],\n    height: [{ type: HostBinding, args: ['style.height.px',] }, { type: HostBinding, args: ['style.minHeight.px',] }, { type: Input }],\n    multipleSelection: [{ type: Input }],\n    focusedClassName: [{ type: HostBinding, args: ['class.k-state-focused',] }],\n    selectedClassName: [{ type: HostBinding, args: ['class.k-state-selected',] }],\n    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]\n};\n\n/**\n * A directive which configures the MultiSelect to show one single summary tag for all selected data items.\n * When a number is provided, the summary tag is displayed after the given amount of data items are selected\n * ([more information and examples]({% slug summarytagmode_multiselect %})).\n *\n * @example\n * ```ts-no-run\n * <kendo-multiselect kendoMultiSelectSummaryTag [data]=\"data\"></kendo-multiselect>\n * ```\n *\n * @example\n * ```ts-no-run\n * <kendo-multiselect [kendoMultiSelectSummaryTag]=\"2\" [data]=\"data\"></kendo-multiselect>\n * ```\n */\nclass SummaryTagDirective {\n    constructor(multiSelectComponent) {\n        this.multiSelectComponent = multiSelectComponent;\n        /**\n         * A numeric value that indicates the number of selected data items after which the summary tag will appear.\n         */\n        this.showAfter = 0; // tslint:disable-line:no-input-rename\n        this.createTagMapper();\n    }\n    ngOnChanges(changes) {\n        if (isPresent(changes.showAfter)) {\n            this.createTagMapper();\n            this.multiSelectComponent.onTagMapperChange();\n        }\n    }\n    createTagMapper() {\n        this.multiSelectComponent.tagMapper = (tags) => {\n            if (tags.length > this.showAfter) {\n                let result;\n                result = tags.slice(0, this.showAfter);\n                result.push(tags.slice(this.showAfter, tags.length));\n                return result;\n            }\n            else {\n                return tags;\n            }\n        };\n    }\n}\nSummaryTagDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoMultiSelectSummaryTag]'\n            },] },\n];\n/** @nocollapse */\nSummaryTagDirective.ctorParameters = () => [\n    { type: MultiSelectComponent }\n];\nSummaryTagDirective.propDecorators = {\n    showAfter: [{ type: Input, args: ['kendoMultiSelectSummaryTag',] }]\n};\n\n// tslint:disable:no-input-rename\n/**\n * Implements an event handler for the `filterChange` event of a DropDowns component\n * which performs simple data filtering.\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-autocomplete\n *      [data]=\"data\"\n *      kendoDropDownFilter\n *      placeholder=\"e.g. Andorra\">\n *  </kendo-autocomplete>\n * `\n * })\n * class AppComponent {\n *     public data: Array<string> = [\"Albania\", \"Andorra\", \"Armenia\", \"Austria\", \"Azerbaijan\"];\n * }\n * ```\n */\nclass FilterDirective {\n    constructor(component) {\n        this.component = component;\n    }\n    ngOnChanges() {\n        this.data = this.data || [];\n        this.filterSettings = this.filterSettings || {\n            caseSensitive: false,\n            operator: 'startsWith'\n        };\n    }\n    ngOnInit() {\n        this.component.filterable = true;\n        this.filterChangeSubscription = this.component.filterChange\n            .subscribe(query => this.component.data = this.getFilteredData(query));\n    }\n    ngOnDestroy() {\n        this.filterChangeSubscription.unsubscribe();\n    }\n    getFilteredData(query) {\n        const field = this.component.textField || this.component.valueField;\n        return this.data.filter(item => this.checkItem(getter(item, field), query));\n    }\n    checkItem(target, query) {\n        target = this.normalizeValue(target);\n        query = this.normalizeValue(query);\n        return this.filterSettings.operator === 'contains' ? target.indexOf(query) !== -1 : target.indexOf(query) === 0;\n    }\n    normalizeValue(value) {\n        const normalizedValue = isPresent(value) ? value.toString() : '';\n        return this.filterSettings.caseSensitive ? normalizedValue : normalizedValue.toLowerCase();\n    }\n}\nFilterDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoDropDownFilter]'\n            },] },\n];\n/** @nocollapse */\nFilterDirective.ctorParameters = () => [\n    { type: FilterableDropDownComponentBase }\n];\nFilterDirective.propDecorators = {\n    data: [{ type: Input }],\n    filterSettings: [{ type: Input, args: ['kendoDropDownFilter',] }]\n};\n\n/**\n * @hidden\n */\nclass Messages extends ComponentMessages {\n}\nMessages.propDecorators = {\n    noDataText: [{ type: Input }],\n    clearTitle: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nclass LocalizedMessagesDirective extends Messages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n}\nLocalizedMessagesDirective.decorators = [\n    { type: Directive, args: [{\n                providers: [\n                    {\n                        provide: Messages,\n                        useExisting: forwardRef(() => LocalizedMessagesDirective) // tslint:disable-line:no-forward-ref\n                    }\n                ],\n                selector: `\n    [kendoDropDownListLocalizedMessages],\n    [kendoComboBoxLocalizedMessages],\n    [kendoAutoCompleteLocalizedMessages],\n    [kendoMultiSelectLocalizedMessages]\n  `\n            },] },\n];\n/** @nocollapse */\nLocalizedMessagesDirective.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * Custom component messages override default component messages\n * ([see example]({% slug globalization_grid %}#toc-localization)).\n */\nclass CustomMessagesComponent extends Messages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n    get override() {\n        return true;\n    }\n}\nCustomMessagesComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: Messages,\n                        useExisting: forwardRef(() => CustomMessagesComponent) // tslint:disable-line:no-forward-ref\n                    }\n                ],\n                selector: 'kendo-dropdownlist-messages, kendo-combobox-messages, kendo-autocomplete-messages, kendo-multiselect-messages',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nCustomMessagesComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\nconst SHARED_DIRECTIVES = [\n    HeaderTemplateDirective,\n    FooterTemplateDirective,\n    ItemTemplateDirective,\n    GroupTemplateDirective,\n    FixedGroupTemplateDirective,\n    NoDataTemplateDirective,\n    LocalizedMessagesDirective,\n    CustomMessagesComponent,\n    FilterDirective\n];\n/**\n * @hidden\n *\n * The exported package module.\n *\n * The package exports:\n * - `ItemTemplateDirective`&mdash;The item template directive.\n * - `HeaderTemplateDirective`&mdash;The header template directive.\n * - `FooterTemplateDirective`&mdash;The footer template directive.\n * - `NoDataTemplateDirective`&mdash;The noData template directive.\n */\nclass SharedDirectivesModule {\n}\nSharedDirectivesModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [SHARED_DIRECTIVES],\n                exports: [SHARED_DIRECTIVES]\n            },] },\n];\n\nconst INTERNAL_DIRECTIVES = [\n    ListComponent,\n    ListItemDirective,\n    SelectableDirective,\n    SearchBarComponent,\n    TemplateContextDirective\n];\n/**\n * @hidden\n */\nclass SharedModule {\n}\nSharedModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [INTERNAL_DIRECTIVES],\n                exports: [INTERNAL_DIRECTIVES, CommonModule, FormsModule, PopupModule, ResizeSensorModule, SharedDirectivesModule],\n                imports: [CommonModule, FormsModule, PopupModule, ResizeSensorModule, SharedDirectivesModule]\n            },] },\n];\n\nconst AUTOCOMPLETE_DIRECTIVES = [\n    AutoCompleteComponent\n];\n/**\n * @hidden\n *\n * The exported package module.\n *\n * The package exports:\n * - `AutoCompleteComponent`&mdash;The AutoComplete component class.\n * - `ItemTemplateDirective`&mdash;The item template directive.\n * - `HeaderTemplateDirective`&mdash;The header template directive.\n * - `FooterTemplateDirective`&mdash;The footer template directive.\n */\nclass AutoCompleteModule {\n}\nAutoCompleteModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [AUTOCOMPLETE_DIRECTIVES],\n                exports: [AUTOCOMPLETE_DIRECTIVES, SharedDirectivesModule],\n                imports: [SharedModule]\n            },] },\n];\n\n/* tslint:disable:object-literal-sort-keys */\nconst agentRxs = {\n    wp: /(Windows Phone(?: OS)?)\\s(\\d+)\\.(\\d+(\\.\\d+)?)/,\n    fire: /(Silk)\\/(\\d+)\\.(\\d+(\\.\\d+)?)/,\n    android: /(Android|Android.*(?:Opera|Firefox).*?\\/)\\s*(\\d+)\\.(\\d+(\\.\\d+)?)/,\n    iphone: /(iPhone|iPod).*OS\\s+(\\d+)[\\._]([\\d\\._]+)/,\n    ipad: /(iPad).*OS\\s+(\\d+)[\\._]([\\d_]+)/,\n    meego: /(MeeGo).+NokiaBrowser\\/(\\d+)\\.([\\d\\._]+)/,\n    webos: /(webOS)\\/(\\d+)\\.(\\d+(\\.\\d+)?)/,\n    blackberry: /(BlackBerry|BB10).*?Version\\/(\\d+)\\.(\\d+(\\.\\d+)?)/,\n    playbook: /(PlayBook).*?Tablet\\s*OS\\s*(\\d+)\\.(\\d+(\\.\\d+)?)/,\n    windows: /(MSIE)\\s+(\\d+)\\.(\\d+(\\.\\d+)?)/,\n    tizen: /(tizen).*?Version\\/(\\d+)\\.(\\d+(\\.\\d+)?)/i,\n    sailfish: /(sailfish).*rv:(\\d+)\\.(\\d+(\\.\\d+)?).*firefox/i,\n    ffos: /(Mobile).*rv:(\\d+)\\.(\\d+(\\.\\d+)?).*Firefox/\n};\nconst osRxs = {\n    ios: /^i(phone|pad|pod)$/i,\n    android: /^android|fire$/i,\n    blackberry: /^blackberry|playbook/i,\n    windows: /windows/,\n    wp: /wp/,\n    flat: /sailfish|ffos|tizen/i,\n    meego: /meego/\n};\nconst desktopBrowserRxs = {\n    edge: /(edge)[ \\/]([\\w.]+)/i,\n    webkit: /(chrome)[ \\/]([\\w.]+)/i,\n    safari: /(webkit)[ \\/]([\\w.]+)/i,\n    opera: /(opera)(?:.*version|)[ \\/]([\\w.]+)/i,\n    msie: /(msie\\s|trident.*? rv:)([\\w.]+)/i,\n    mozilla: /(mozilla)(?:.*? rv:([\\w.]+)|)/i\n};\nconst mobileBrowserRxs = {\n    omini: /Opera\\sMini/i,\n    omobile: /Opera\\sMobi/i,\n    firefox: /Firefox|Fennec/i,\n    mobilesafari: /version\\/.*safari/i,\n    ie: /MSIE|Windows\\sPhone/i,\n    chrome: /chrome|crios/i,\n    webkit: /webkit/i\n};\nconst testRx = (agent, rxs, dflt) => {\n    for (let rx in rxs) {\n        if (rxs.hasOwnProperty(rx) && rxs[rx].test(agent)) {\n            return rx;\n        }\n    }\n    return dflt !== undefined ? dflt : agent;\n};\n/**\n * @hidden\n */\nconst detectMobileOS = (ua) => {\n    let minorVersion;\n    let match = [];\n    for (let agent in agentRxs) {\n        if (agentRxs.hasOwnProperty(agent)) {\n            match = ua.match(agentRxs[agent]);\n            if (!match) {\n                continue;\n            }\n            if (agent === 'windows' && 'plugins' in window.navigator) {\n                return null;\n            } // Break if not Metro/Mobile Windows\n            const os = {};\n            os.device = agent;\n            os.browser = testRx(ua, mobileBrowserRxs, 'default');\n            os.name = testRx(agent, osRxs);\n            os[os.name] = true;\n            os.majorVersion = match[2];\n            os.minorVersion = match[3].replace('_', '.');\n            minorVersion = os.minorVersion.replace('.', '').substr(0, 2);\n            os.flatVersion = os.majorVersion + minorVersion +\n                (new Array(3 - (minorVersion.length < 3 ? minorVersion.length : 2)).join('0'));\n            os.cordova = typeof window.PhoneGap !== undefined\n                || typeof window.cordova !== undefined; // Use file protocol to detect appModes.\n            os.appMode = window.navigator.standalone\n                || (/file|local|wmapp/).test(window.location.protocol)\n                || os.cordova; // Use file protocol to detect appModes.\n            return os;\n        }\n    }\n    return null;\n};\n/**\n * @hidden\n */\nconst detectDesktopBrowser = (ua) => {\n    let browserInfo = null;\n    let match = [];\n    for (let agent in desktopBrowserRxs) {\n        if (desktopBrowserRxs.hasOwnProperty(agent)) {\n            match = ua.match(desktopBrowserRxs[agent]);\n            if (match) {\n                browserInfo = {};\n                browserInfo[agent] = true;\n                browserInfo[match[1].toLowerCase().split(' ')[0].split('/')[0]] = true;\n                browserInfo.version = parseInt(document.documentMode || match[2], 10);\n                break;\n            }\n        }\n    }\n    return browserInfo;\n};\nconst userAgent = isWindowAvailable() && window.navigator ? window.navigator.userAgent : null;\n/**\n * @hidden\n */\nconst browser = userAgent ? detectDesktopBrowser(userAgent) : null;\n/**\n * @hidden\n */\nconst mobileOS = userAgent ? detectMobileOS(userAgent) : null;\n/**\n * @hidden\n */\nconst touch = isWindowAvailable() && 'ontouchstart' in window;\n/**\n * @hidden\n */\nconst msPointers = browser && !browser.chrome && window.MSPointerEvent;\n/**\n * @hidden\n */\nconst pointers = browser && !browser.chrome && window.PointerEvent;\n/**\n * @hidden\n */\nconst touchEnabled = mobileOS && (touch || msPointers || pointers);\n\nconst COMBOBOX_DIRECTIVES = [\n    ComboBoxComponent\n];\nconst Éµ0$1 = touchEnabled;\n/**\n * @hidden\n *\n * The exported package module.\n *\n * The package exports:\n * - `ComboBoxComponent`&mdash;The ComboBox component class.\n * - `ItemTemplateDirective`&mdash;The item template directive.\n * - `HeaderTemplateDirective`&mdash;The header template directive.\n * - `FooterTemplateDirective`&mdash;The footer template directive.\n */\nclass ComboBoxModule {\n}\nComboBoxModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [COMBOBOX_DIRECTIVES],\n                exports: [COMBOBOX_DIRECTIVES, SharedDirectivesModule],\n                imports: [SharedModule],\n                providers: [{ provide: TOUCH_ENABLED, useValue: Éµ0$1 }]\n            },] },\n];\n\n/**\n * @hidden\n */\nclass FilterInputDirective {\n    constructor(element, zone) {\n        this.element = element;\n        this.zone = zone;\n    }\n    ngOnChanges() {\n        if (this.focused) {\n            this.nextTick(() => this.element.nativeElement.focus());\n        }\n    }\n    nextTick(fn) {\n        this.zone.runOutsideAngular(() => setTimeout(fn));\n    }\n}\nFilterInputDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[filterInput]' // tslint:disable-line\n            },] },\n];\n/** @nocollapse */\nFilterInputDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: NgZone }\n];\nFilterInputDirective.propDecorators = {\n    focused: [{ type: Input, args: ['filterInput',] }]\n};\n\nconst DROPDOWNLIST_DIRECTIVES = [\n    DropDownListComponent,\n    ValueTemplateDirective,\n    FilterInputDirective\n];\n/**\n * @hidden\n *\n * The exported package module.\n *\n * The package exports:\n * - `DropDownListComponent`&mdash;The DropDownList component class.\n * - `ItemTemplateDirective`&mdash;The item template directive.\n * - `ValueTemplateDirective`&mdash;The value template directive.\n * - `HeaderTemplateDirective`&mdash;The header template directive.\n * - `FooterTemplateDirective`&mdash;The footer template directive.\n */\nclass DropDownListModule {\n}\nDropDownListModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [DROPDOWNLIST_DIRECTIVES],\n                exports: [DROPDOWNLIST_DIRECTIVES, SharedDirectivesModule],\n                imports: [SharedModule]\n            },] },\n];\n\nconst MULTISELECT_DIRECTIVES = [\n    MultiSelectComponent,\n    TagListComponent,\n    TagTemplateDirective,\n    GroupTagTemplateDirective,\n    SummaryTagDirective,\n    CustomItemTemplateDirective\n];\nconst Éµ0$2 = touchEnabled;\n/**\n * @hidden\n *\n * The exported package module.\n *\n * The package exports:\n * - `MultiSelectComponent`&mdash;The MultiSelect component class.\n * - `SummaryTagDirective`&mdash;The MultiSelect summary tag directive.\n * - `ItemTemplateDirective`&mdash;The item template directive.\n * - `CustomItemTemplateDirective`&mdash;The custom item template directive.\n * - `TagTemplateDirective`&mdash;The tag template directive.\n * - `SummaryTagTemplateDirective`&mdash;The summary tag template directive.\n * - `HeaderTemplateDirective`&mdash;The header template directive.\n * - `FooterTemplateDirective`&mdash;The footer template directive.\n * - `NoDataTemplateDirective`&mdash;The no-data template directive.\n */\nclass MultiSelectModule {\n}\nMultiSelectModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [MULTISELECT_DIRECTIVES],\n                exports: [MULTISELECT_DIRECTIVES, SharedDirectivesModule],\n                imports: [SharedModule],\n                providers: [{ provide: TOUCH_ENABLED, useValue: Éµ0$2 }]\n            },] },\n];\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Dropdowns components.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Dropdowns module\n * import { DropDownsModule } from '@progress/kendo-angular-dropdowns';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare the app component\n *     imports:      [BrowserModule, DropDownsModule], // import the Dropdowns module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nclass DropDownsModule {\n}\nDropDownsModule.decorators = [\n    { type: NgModule, args: [{\n                exports: [AutoCompleteModule, ComboBoxModule, DropDownListModule, MultiSelectModule]\n            },] },\n];\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AUTOCOMPLETE_VALUE_ACCESSOR, COMBOBOX_VALUE_ACCESSOR, DataService, DisabledItemsService, DROPDOWNLIST_VALUE_ACCESSOR, FilterInputDirective, FilterableDropDownComponentBase, ListItemDirective, CustomMessagesComponent, LocalizedMessagesDirective, Messages, NavigationService, SearchBarComponent, SelectionService, browser, detectDesktopBrowser, detectMobileOS, mobileOS, msPointers, pointers, touch, touchEnabled, NoDataTemplateDirective, TagTemplateDirective, TOUCH_ENABLED, isWindowAvailable, AutoCompleteComponent, ComboBoxComponent, DropDownListComponent, MultiSelectComponent, TagListComponent, ItemTemplateDirective, GroupTemplateDirective, FixedGroupTemplateDirective, CustomItemTemplateDirective, HeaderTemplateDirective, FooterTemplateDirective, ValueTemplateDirective, TemplateContextDirective, GroupTagTemplateDirective, SelectableDirective, SummaryTagDirective, FilterDirective, DropDownsModule, MultiSelectModule, SharedModule, AutoCompleteModule, ComboBoxModule, DropDownListModule, SharedDirectivesModule, ListComponent, PreventableEvent };\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiUC,4BA8BC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBA2BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkCD,0QAKC;;;;;;;;;;4EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiCD,sRAKC;;;;;;;;;;4EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiCD,sRAKC;;;;;;;;;;4EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwCD,gRAKC;;;;;;;;;;4EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwCD,8SAKC;;;;;;;;;;4EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwFD;;;gDAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAqPD;;;gDAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgCD,2HAGC;;;;;;;qEAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgID,kHAGC;;;;;;;;0GAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiCD,sRAKC;;;;;;;;;;4EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2CD,8IAKC;;;;;;;;;;2EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA+MD,oDAoGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBA+BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2uBD,uFAqGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAqDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6kCD,uFA+GC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBA0DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgCD,iJAKC;;;;;;;;;;4EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA06BD,4LA0JC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAwDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkCD,+JAKC;;;;;;;;;;4EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgCD,0IAKC;;;;;;;;;;4EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiCD,yJAKC;;;;;;;;;;4EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiqCD,kFAqIC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAgEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4BD,4JAyCC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAYA;;;;;;;;;;;;;;;;;;;;CAkBD,sLAKC;;;;;;;;;;;;;;;oBAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgCD,gGAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6CD,sPAKC;;;;;;;;;;;;;;;;oBAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwDD,wPAKC;;;;;;;;;;;;;;;;;;;oBAQA;;;;;;;;4KAMD;;;;;qEAIC;;;;;;;;;;;;;;;;;CAUD,iDAgBC;;;;;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;;;;CAcD,wJAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;CAyBD;;;;;;;;;;;;;;;;;;;;;;;;0BAMC;;;;;;;;;;;;;;;;;CAaD;;;;;;;;;;;;;;;;;;;;0BAOC;;;;;;;;;;;;;;;;;;;;CAiBD;;;;;;;;;;0BAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAqJD;;;;;;;;;;;0BAQC;;;;;;;;;;;;;;;;;;;;CAkBD,sNAKC;;;;;;;;;;;;;;;;;oBAQA;;;;;;;;;;;;;;;;;;;;;;;CAoBD;;;;;;;;;;;;;;0BAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4BD;;;;;;;;;;;;;;;;;;;;;0BAQC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkCD;;;;;;;;;;0BAKC;;;;;;;"}