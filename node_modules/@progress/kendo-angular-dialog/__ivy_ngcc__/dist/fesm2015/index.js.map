{"version":3,"file":"index.js","sources":["D:/project/projek_angular/hris_rni/node_modules/@progress/kendo-angular-dialog/dist/fesm2015/index.js"],"sourcesContent":["/**-----------------------------------------------------------------------------------------\n* Copyright Â© 2020 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport { EventEmitter, TemplateRef, Component, ElementRef, Input, Output, HostBinding, InjectionToken, Inject, Optional, Renderer2, ContentChild, ViewChild, HostListener, Injectable, isDevMode, ComponentFactoryResolver, NgZone, Directive, Host, ViewChildren, ViewContainerRef, forwardRef, NgModule } from '@angular/core';\nimport { trigger, state, style, transition, animate } from '@angular/animations';\nimport { LocalizationService, L10N_PREFIX, MessageService, RTL, ComponentMessages } from '@progress/kendo-angular-l10n';\nimport { Subject, merge, Subscription, of } from 'rxjs';\nimport { take, tap, switchMap, takeUntil, map } from 'rxjs/operators';\nimport { DraggableDirective, isChanged, isDocumentAvailable, DraggableModule } from '@progress/kendo-angular-common';\nimport { offset, scrollPosition, positionWithScroll, getDocumentElement, getWindowViewPort } from '@progress/kendo-popup-common';\nimport { Button } from '@progress/kendo-angular-buttons';\nimport { CommonModule } from '@angular/common';\n\n/**\n * Specifies the action buttons of the Dialog\n * ([see example]({% slug actionbuttons_dialog %})).\n */\nclass DialogActionsComponent {\n    constructor(el) {\n        this.el = el;\n        /**\n         * Specifies the possible layout of the action buttons.\n         */\n        this.layout = 'stretched';\n        /**\n         * Fires when the user clicks an action button.\n         */\n        this.action = new EventEmitter();\n        this.buttonGroupClassName = true;\n    }\n    get className() {\n        return this.layout === 'stretched';\n    }\n    /**\n     * @hidden\n     */\n    actionTemplate() {\n        return this.actions instanceof TemplateRef;\n    }\n    /**\n     * @hidden\n     */\n    onButtonClick(action, _e) {\n        this.action.emit(action);\n    }\n    /**\n     * @hidden\n     */\n    buttonClass(action) {\n        const classes = [\"k-button\"];\n        if (action.primary) {\n            classes.push(\"k-primary\");\n        }\n        return classes.join(\" \");\n    }\n}\nDialogActionsComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-dialog-actions',\n                template: `\n    <ng-content *ngIf=\"!actions\"></ng-content>\n    <ng-container *ngIf=\"!actionTemplate()\">\n      <button type=\"button\"\n        [ngClass]=\"buttonClass(action)\"\n        (click)=\"onButtonClick(action, $event)\"\n        *ngFor=\"let action of actions\">\n        {{ action.text }}\n      </button>\n    </ng-container>\n    <ng-template [ngTemplateOutlet]=\"actions\" *ngIf=\"actionTemplate()\"></ng-template>\n  `\n            },] },\n];\n/** @nocollapse */\nDialogActionsComponent.ctorParameters = () => [\n    { type: ElementRef }\n];\nDialogActionsComponent.propDecorators = {\n    actions: [{ type: Input }],\n    layout: [{ type: Input }],\n    action: [{ type: Output }],\n    buttonGroupClassName: [{ type: HostBinding, args: ['class.k-dialog-buttongroup',] }],\n    className: [{ type: HostBinding, args: ['class.k-dialog-button-layout-stretched',] }]\n};\n\n/**\n * @hidden\n */\nconst DIALOG_LOCALIZATION_SERVICE = new InjectionToken('Dialog LocalizationService');\n\n/**\n * @hidden\n */\nclass TitleBarLocalizationService extends LocalizationService {\n    constructor(prefix, messageService, rtl, dialogLocalization) {\n        super(prefix, messageService, rtl);\n        this.dialogLocalization = dialogLocalization;\n    }\n    get(shortKey) {\n        if (this.dialogLocalization) {\n            return this.dialogLocalization.get(shortKey);\n        }\n        return super.get(shortKey);\n    }\n}\n/** @nocollapse */\nTitleBarLocalizationService.ctorParameters = () => [\n    { type: String, decorators: [{ type: Inject, args: [L10N_PREFIX,] }] },\n    { type: MessageService, decorators: [{ type: Optional }] },\n    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [RTL,] }] },\n    { type: LocalizationService, decorators: [{ type: Optional }, { type: Inject, args: [DIALOG_LOCALIZATION_SERVICE,] }] }\n];\n\n/**\n * Represents the [Kendo UI DialogTitleBar component for Angular]({% slug api_dialog_dialogtitlebarcomponent %}).\n *\n * It is used as part of the Dialog content when the component is created dynamically by using an [Angular service]({% slug service_dialog %}).\n */\nclass DialogTitleBarComponent {\n    constructor(hostElement, localizationService) {\n        this.hostElement = hostElement;\n        this.localizationService = localizationService;\n        /**\n         * @hidden\n         */\n        this.close = new EventEmitter();\n    }\n    get className() {\n        return true;\n    }\n    get closeButtonTitle() {\n        return this.closeTitle || this.localizationService.get('closeTitle');\n    }\n    ngAfterViewChecked() {\n        const element = this.hostElement.nativeElement;\n        element.setAttribute('id', this.id);\n    }\n    /**\n     * @hidden\n     */\n    onCloseClick(e) {\n        e.preventDefault();\n        this.close.emit();\n    }\n}\nDialogTitleBarComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-dialog-titlebar',\n                providers: [\n                    TitleBarLocalizationService,\n                    {\n                        provide: LocalizationService,\n                        useExisting: TitleBarLocalizationService\n                    },\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.dialog'\n                    }\n                ],\n                template: `\n    <ng-container kendoDialogTitleBarLocalizedMessages\n        i18n-closeTitle=\"kendo.dialog.closeTitle|The title of the close button\"\n        closeTitle=\"Close\"\n    >\n    <ng-container>\n    <div class=\"k-window-title k-dialog-title\">\n      <ng-content></ng-content>\n    </div>\n\n    <div class=\"k-window-actions k-dialog-actions\">\n      <a href=\"#\" role=\"button\"\n         [attr.title]=\"closeButtonTitle\"\n         [attr.aria-label]=\"closeButtonTitle\"\n         class=\"k-button k-bare k-button-icon k-window-action k-dialog-action k-dialog-close\"\n         (click)=\"onCloseClick($event)\">\n        <span class=\"k-icon k-i-x\"></span>\n      </a>\n    </div>\n  `\n            },] },\n];\n/** @nocollapse */\nDialogTitleBarComponent.ctorParameters = () => [\n    { type: ElementRef },\n    { type: LocalizationService, decorators: [{ type: Optional }] }\n];\nDialogTitleBarComponent.propDecorators = {\n    close: [{ type: Output }],\n    id: [{ type: Input }],\n    closeTitle: [{ type: Input }],\n    className: [{ type: HostBinding, args: ['class.k-window-titlebar',] }, { type: HostBinding, args: ['class.k-dialog-titlebar',] }]\n};\n\n/**\n * @hidden\n */\nconst isPresent = (value) => value !== null && value !== undefined;\n/**\n * @hidden\n */\nconst isTruthy = (value) => !!value;\nconst toClassList = (classNames) => String(classNames).trim().split(' ');\nconst focusableRegex = /^(?:a|input|select|textarea|button|object)$/i;\n/**\n * @hidden\n */\nvar Keys;\n(function (Keys) {\n    Keys[Keys[\"esc\"] = 27] = \"esc\";\n    Keys[Keys[\"tab\"] = 9] = \"tab\";\n    Keys[Keys[\"enter\"] = 13] = \"enter\";\n    Keys[Keys[\"space\"] = 32] = \"space\";\n    Keys[Keys[\"ctrl\"] = 17] = \"ctrl\";\n    Keys[Keys[\"shift\"] = 16] = \"shift\";\n    Keys[Keys[\"left\"] = 37] = \"left\";\n    Keys[Keys[\"up\"] = 38] = \"up\";\n    Keys[Keys[\"right\"] = 39] = \"right\";\n    Keys[Keys[\"down\"] = 40] = \"down\";\n})(Keys || (Keys = {}));\n/**\n * @hidden\n */\nconst DIALOG_ELEMENTS_HANDLING_ESC_KEY = 'k-dialog-wrapper k-dialog-buttongroup k-dialog-action';\n/**\n * @hidden\n */\nconst DIALOG_ELEMENTS_HANDLING_ARROWS = 'k-dialog-buttongroup';\n/**\n * @hidden\n */\nconst WINDOW_CLASSES = 'k-window';\n/**\n * @hidden\n */\nconst hasClasses = (element, classNames) => {\n    const namesList = toClassList(classNames);\n    return Boolean(toClassList(element.className).find((className) => namesList.indexOf(className) >= 0));\n};\n/**\n * @hidden\n */\nconst isVisible = (element) => {\n    const rect = element.getBoundingClientRect();\n    return !!(rect.width && rect.height) && window.getComputedStyle(element).visibility !== 'hidden';\n};\n/**\n * @hidden\n */\nconst isFocusable = (element, checkVisibility = true) => {\n    if (element.tagName) {\n        const tagName = element.tagName.toLowerCase();\n        const tabIndex = element.getAttribute('tabIndex');\n        const validTabIndex = tabIndex !== null && !isNaN(tabIndex) && tabIndex > -1;\n        let focusable = false;\n        if (focusableRegex.test(tagName)) {\n            focusable = !element.disabled;\n        }\n        else {\n            focusable = validTabIndex;\n        }\n        return focusable && (!checkVisibility || isVisible(element));\n    }\n    return false;\n};\n/**\n * @hidden\n */\nconst focusableSelector = [\n    'a[href]',\n    'area[href]',\n    'input:not([disabled])',\n    'select:not([disabled])',\n    'textarea:not([disabled])',\n    'button:not([disabled])',\n    'iframe',\n    'object',\n    'embed',\n    '*[tabindex]',\n    '*[contenteditable]'\n].join(',');\n/**\n * @hidden\n */\nconst preventDefault = ({ originalEvent: event }) => {\n    event.stopPropagation();\n    event.preventDefault();\n};\n/**\n * @hidden\n */\nconst RESIZE_DIRECTIONS = ['n', 'e', 's', 'w', 'se', 'sw', 'ne', 'nw'];\n/**\n * @hidden\n */\nconst OFFSET_STYLES = ['top', 'left', 'width', 'height'];\n/**\n * @hidden\n */\nconst isNumber = (value) => typeof value === 'number' && isFinite(value);\n/**\n * @hidden\n */\nconst createValueWithUnit = (value) => value + (isNumber(value) ? 'px' : '');\n\n/**\n * Represents the [Kendo UI Dialog component for Angular]({% slug overview_dialog_dialogs %}).\n */\nclass DialogComponent {\n    constructor(_elRef, _renderer, localization) {\n        this._elRef = _elRef;\n        this._renderer = _renderer;\n        /**\n         * Specifies the layout of the action buttons in the Dialog.\n         * This option is only applicable if the action buttons are specified through the `actions` options.\n         *\n         * @default 'stretched'\n         */\n        this.actionsLayout = 'stretched';\n        /**\n         * @hidden\n         */\n        this.titleId = null;\n        /**\n         * Fires when the user clicks an action button of the Dialog.\n         * The event is fired only when the action buttons are specified through the `actions` options.\n         */\n        this.action = new EventEmitter();\n        /**\n         * Fires when the user clicks the **Close** button of the Dialog.\n         */\n        this.close = new EventEmitter();\n        this.tabIndex = 0;\n        this.subscriptions = [];\n        this.direction = localization.rtl ? 'rtl' : 'ltr';\n        this.subscriptions.push(localization.changes.subscribe(({ rtl }) => this.direction = rtl ? 'rtl' : 'ltr'));\n        this.titleId = this.generateTitleId();\n    }\n    get dir() {\n        return this.direction;\n    }\n    /**\n     * @hidden\n     */\n    onComponentKeydown(event) {\n        const target = event.target;\n        const parent = target.parentElement;\n        if (hasClasses(target, DIALOG_ELEMENTS_HANDLING_ESC_KEY) ||\n            hasClasses(parent, DIALOG_ELEMENTS_HANDLING_ESC_KEY)) {\n            if (event.keyCode === Keys.esc) {\n                this.close.emit();\n            }\n        }\n        if (hasClasses(target, 'k-button') &&\n            hasClasses(parent, DIALOG_ELEMENTS_HANDLING_ARROWS) &&\n            (event.keyCode === Keys.left || event.keyCode === Keys.right)) {\n            this.handleActionButtonFocus(parent, event.keyCode);\n        }\n        if (event.keyCode === Keys.tab) {\n            this.keepFocusWithinComponent(target, event);\n        }\n    }\n    ngAfterContentInit() {\n        this.bubble('close', this.titlebarContent);\n        if (this.titlebarContent) {\n            this.titlebarContent.id = this.titleId;\n        }\n    }\n    ngAfterViewInit() {\n        this.handleInitialFocus();\n        this.bubble('close', this.titlebarView);\n        this.bubble('action', this.actionsView);\n        if (this.titlebarView || this.titlebarContent) {\n            //Needed for Dialogs created via service\n            this._renderer.setAttribute(this._elRef.nativeElement.querySelector('.k-dialog'), 'aria-labelledby', this.titleId);\n        }\n    }\n    ngOnInit() {\n        this._renderer.removeAttribute(this._elRef.nativeElement, 'title');\n    }\n    ngOnDestroy() {\n        this.subscriptions.forEach(s => s.unsubscribe());\n        this.subscriptions = [];\n    }\n    /**\n     * Focuses the wrapper of the Dialog component.\n     */\n    focus() {\n        const wrapper = this._elRef.nativeElement;\n        if (isPresent(wrapper)) {\n            wrapper.focus();\n        }\n    }\n    /**\n     * @hidden\n     */\n    handleInitialFocus() {\n        const wrapper = this._elRef.nativeElement;\n        const primaryButton = wrapper.querySelector('.k-primary');\n        if (this.autoFocusedElement) {\n            const initiallyFocusedElement = wrapper.querySelector(this.autoFocusedElement);\n            if (initiallyFocusedElement) {\n                initiallyFocusedElement.focus();\n            }\n        }\n        else if (this.shouldFocusPrimary(primaryButton)) {\n            primaryButton.focus();\n        }\n        else {\n            wrapper.focus();\n        }\n    }\n    /**\n     * @hidden\n     */\n    handleActionButtonFocus(parent, key) {\n        const focusableActionButtons = this.getAllFocusableChildren(parent);\n        for (let i = 0; i < focusableActionButtons.length; i++) {\n            const current = focusableActionButtons[i];\n            if (current === document.activeElement) {\n                if (key === Keys.left && i > 0) {\n                    focusableActionButtons[i - 1].focus();\n                    break;\n                }\n                if (key === Keys.right && i < focusableActionButtons.length - 1) {\n                    focusableActionButtons[i + 1].focus();\n                    break;\n                }\n            }\n        }\n    }\n    /**\n     * @hidden\n     */\n    keepFocusWithinComponent(target, event) {\n        const firstFocusable = this._elRef.nativeElement;\n        const lastFocusable = this.getLastFocusableElement(firstFocusable);\n        const tabBeforeFirstFocusable = (target === firstFocusable) && event.shiftKey;\n        const tabAfterLastFocusable = !event.shiftKey && isPresent(lastFocusable) && (target === lastFocusable);\n        const tabWithNoFocusable = !isPresent(lastFocusable) && !event.shiftKey;\n        if (tabBeforeFirstFocusable || tabWithNoFocusable) {\n            event.preventDefault();\n            firstFocusable.focus();\n        }\n        if (tabAfterLastFocusable) {\n            event.preventDefault();\n            lastFocusable.focus();\n        }\n    }\n    /**\n     * @hidden\n     */\n    shouldFocusPrimary(el) {\n        return isPresent(el) && isFocusable(el);\n    }\n    /**\n     * @hidden\n     */\n    getAllFocusableChildren(parent) {\n        return parent.querySelectorAll(focusableSelector);\n    }\n    /**\n     * @hidden\n     */\n    getLastFocusableElement(parent) {\n        const all = this.getAllFocusableChildren(parent);\n        return (all.length > 0) ? all[all.length - 1] : null;\n    }\n    /**\n     * @hidden\n     */\n    generateTitleId() {\n        return \"kendo-dialog-title-\" + Math.ceil(Math.random() * 1000000).toString();\n    }\n    get wrapperClass() {\n        return true;\n    }\n    get styles() {\n        const styles = {};\n        if (this.width) {\n            styles.width = createValueWithUnit(this.width);\n        }\n        if (this.height) {\n            styles.height = createValueWithUnit(this.height);\n        }\n        if (this.minWidth) {\n            styles.minWidth = createValueWithUnit(this.minWidth);\n        }\n        if (this.maxWidth) {\n            styles.maxWidth = createValueWithUnit(this.maxWidth);\n        }\n        if (this.minHeight) {\n            styles.minHeight = createValueWithUnit(this.minHeight);\n        }\n        if (this.maxHeight) {\n            styles.maxHeight = createValueWithUnit(this.maxHeight);\n        }\n        return styles;\n    }\n    bubble(eventName, component) {\n        if (component) {\n            const emit = e => this[eventName].emit(e);\n            const s = component[eventName].subscribe(emit);\n            this.subscriptions.push(s);\n        }\n    }\n}\nDialogComponent.decorators = [\n    { type: Component, args: [{\n                animations: [\n                    trigger('overlayAppear', [\n                        state('in', style({ opacity: 1 })),\n                        transition('void => *', [\n                            style({ opacity: .1 }),\n                            animate('.3s cubic-bezier(.2, .6, .4, 1)')\n                        ])\n                    ]),\n                    trigger('dialogSlideInAppear', [\n                        state('in', style({ transform: 'translate(0, 0)' })),\n                        transition('void => *', [\n                            style({ transform: 'translate(0, -10%)' }),\n                            animate('.3s cubic-bezier(.2, 1, .2, 1)')\n                        ])\n                    ])\n                ],\n                exportAs: 'kendoDialog',\n                providers: [\n                    LocalizationService,\n                    {\n                        provide: DIALOG_LOCALIZATION_SERVICE,\n                        useExisting: LocalizationService\n                    },\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.dialog'\n                    }\n                ],\n                selector: 'kendo-dialog',\n                template: `\n    <div class=\"k-overlay\" @overlayAppear></div>\n\n    <div\n      class=\"k-widget k-window k-dialog\"\n      role=\"dialog\"\n      [ngStyle]=\"styles\"\n      @dialogSlideInAppear\n    >\n      <kendo-dialog-titlebar *ngIf=\"title\" [closeTitle]=\"closeTitle\" [id]=\"titleId\">{{title}}</kendo-dialog-titlebar>\n      <ng-content select=\"kendo-dialog-titlebar\" *ngIf=\"!title\"></ng-content>\n\n      <div class=\"k-content k-window-content k-dialog-content\">\n        <ng-content *ngIf=\"!contentTemplate\"></ng-content>\n        <ng-template [ngTemplateOutlet]=\"contentTemplate\" *ngIf=\"contentTemplate\"></ng-template>\n      </div>\n\n      <ng-content select=\"kendo-dialog-actions\" *ngIf=\"!actions\"></ng-content>\n      <kendo-dialog-actions *ngIf=\"actions\"\n        [actions]=\"actions\"\n        [layout]=\"actionsLayout\">\n      </kendo-dialog-actions>\n    </div>\n  `\n            },] },\n];\n/** @nocollapse */\nDialogComponent.ctorParameters = () => [\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: LocalizationService }\n];\nDialogComponent.propDecorators = {\n    actions: [{ type: Input }],\n    actionsLayout: [{ type: Input }],\n    autoFocusedElement: [{ type: Input }],\n    title: [{ type: Input }],\n    width: [{ type: Input }],\n    minWidth: [{ type: Input }],\n    maxWidth: [{ type: Input }],\n    height: [{ type: Input }],\n    minHeight: [{ type: Input }],\n    maxHeight: [{ type: Input }],\n    action: [{ type: Output }],\n    close: [{ type: Output }],\n    dir: [{ type: HostBinding, args: ['attr.dir',] }],\n    tabIndex: [{ type: HostBinding, args: ['attr.tabIndex',] }],\n    titlebarContent: [{ type: ContentChild, args: [DialogTitleBarComponent,] }],\n    titlebarView: [{ type: ViewChild, args: [DialogTitleBarComponent,] }],\n    actionsView: [{ type: ViewChild, args: [DialogActionsComponent,] }],\n    onComponentKeydown: [{ type: HostListener, args: ['keydown', ['$event'],] }],\n    wrapperClass: [{ type: HostBinding, args: ['class.k-dialog-wrapper',] }]\n};\n\n/**\n * The base class  which will be extended by a component that is provided as content through `content`\n * ([see example]({% slug service_dialog %}#toc-passing-title-content-and-actions-as-a-single-component)).\n */\nclass DialogContentBase {\n    constructor(dialog) {\n        this.dialog = dialog;\n    }\n    /**\n     * @hidden\n     */\n    ngAfterViewInit() {\n        if (this.dialogTitleBar) {\n            this.dialogTitleBar.close.subscribe(() => {\n                this.dialog.close();\n            });\n        }\n        if (this.dialogActions) {\n            if (this.dialogActions.actions) {\n                this.dialogActions.action.subscribe(action => this.dialog.dialog.instance.action.emit(action));\n            }\n        }\n    }\n}\nDialogContentBase.propDecorators = {\n    dialogTitleBar: [{ type: ViewChild, args: [DialogTitleBarComponent,] }],\n    dialogActions: [{ type: ViewChild, args: [DialogActionsComponent,] }]\n};\n\n/**\n * @hidden\n */\nclass DialogContainerService {\n    set container(container) {\n        DialogContainerService.container = container;\n    }\n    get container() {\n        return DialogContainerService.container;\n    }\n}\nDialogContainerService.container = null;\nDialogContainerService.decorators = [\n    { type: Injectable },\n];\n\n/**\n * The settings for the Dialog actions when the Dialog is opened through `DialogService`\n * ([see example]({% slug api_dialog_dialogservice %}#toc-open)).\n */\nclass DialogAction {\n}\n/**\n * Indicates that the **Close** button is clicked. Used when the results from\n * the Dialogs that are opened through `DialogService` are filtered\n * ([see example]({% slug api_dialog_dialogservice %}#toc-open)).\n */\nclass DialogCloseResult {\n}\n/**\n * The settings that can be used when the Dialog is opened through `DialogService`.\n * ([see example]({% slug api_dialog_dialogservice %}#toc-open)).\n */\nclass DialogSettings {\n}\n/**\n * Holds references to the object instance and published events of the Dialog.\n * Controls the Dialogs that were opened through the `DialogService`\n * ([see example]({% slug api_dialog_dialogservice %}#toc-open)).\n */\nclass DialogRef {\n}\n\n// tslint:disable:max-line-length\nclass DialogInjector {\n    constructor(getDialogRef, parentInjector) {\n        this.getDialogRef = getDialogRef;\n        this.parentInjector = parentInjector;\n    }\n    get(token, notFoundValue) {\n        if (token === DialogRef) {\n            return this.getDialogRef();\n        }\n        return this.parentInjector.get(token, notFoundValue);\n    }\n}\n/**\n * A service for opening Dialog windows dynamically\n * ([see example]({% slug service_dialog %})).\n */\nclass DialogService {\n    constructor(\n    /**\n     * @hidden\n     */\n    resolver, containerService) {\n        this.resolver = resolver;\n        this.containerService = containerService;\n    }\n    /**\n     * Opens a Dialog window. Requires an element in the application that uses the\n     * [`kendoDialogContainer`]({% slug api_dialog_dialogcontainerdirective %}) directive.\n     * Created Dialogs will be mounted in the DOM directly after that element.\n     *\n     * @param {DialogAction} options - The options that define the Dialog.\n     * @returns {DialogRef} - A reference to the Dialog object and the convenience properties.\n     *\n     * @example\n     *\n     * ```ts-no-run\n     * _@Component({\n     *   selector: 'my-app',\n     *   template: `\n     *     <button kendoButton (click)=\"open()\">Harmless button</button>\n     *     <div kendoDialogContainer></div>\n     *   `\n     * })\n     * export class AppComponent {\n     *     constructor( private dialogService: DialogService ) {}\n     *\n     *     public open() {\n     *         var dialog = this.dialogService.open({\n     *           title: \"Please confirm\",\n     *           content: \"Are you sure?\",\n     *           actions: [\n     *             { text: \"No\" },\n     *             { text: \"Yes\", primary: true }\n     *           ]\n     *         });\n     *\n     *         dialog.result.subscribe((result) => {\n     *           if (result instanceof DialogCloseResult) {\n     *             console.log(\"close\");\n     *           } else {\n     *             console.log(\"action\", result);\n     *           }\n     *         });\n     *     }\n     * }\n     * ```\n     *\n     */\n    open(options) {\n        const factory = this.resolver.resolveComponentFactory(DialogComponent);\n        const container = options.appendTo || this.containerService.container;\n        if (!container) {\n            throw new Error(`\nCannot attach dialog to the page.\nAdd an element that uses the kendoDialogContainer directive, or set the 'appendTo' property.\nSee https://www.telerik.com/kendo-angular-ui/components/dialogs/dialog/service/.\n          `);\n        }\n        // create DialogRef to (1) pass as result, (2) provide through injector\n        const dialogRef = {\n            close: () => { },\n            content: null,\n            dialog: null,\n            result: null\n        };\n        return this.initializeDialog(options.content, factory, container, dialogRef, options);\n    }\n    initializeDialog(component, factory, container, dialogRef, options) {\n        const content = this.contentFrom(component, container, dialogRef);\n        const dialog = container.createComponent(factory, undefined, undefined, content.nodes);\n        dialogRef.dialog = dialog;\n        dialog.changeDetectorRef.markForCheck();\n        // copy @Input options to dialog instance\n        this.applyOptions(dialog.instance, options);\n        // create close handler and result stream\n        const apiClose = new Subject();\n        const close = (e) => {\n            apiClose.next(e || new DialogCloseResult());\n            if (content.componentRef) {\n                content.componentRef.destroy();\n            }\n            dialog.destroy();\n        };\n        const result = merge(apiClose, dialog.instance.close, dialog.instance.action).pipe(take(1));\n        result.subscribe(close);\n        dialogRef.close = close;\n        dialogRef.result = result;\n        if (component && isDevMode()) {\n            const hasContentTitle = content.nodes[0] && content.nodes[0].length > 0;\n            const hasContentActions = content.nodes[2] && content.nodes[2].length > 0;\n            const multipleTitles = options.title && hasContentTitle;\n            const multipleActions = options.actions && hasContentActions;\n            if (component.prototype instanceof DialogContentBase) { // content component extends DialogContentBase\n                if (multipleTitles || multipleActions) {\n                    console.warn(`\n                    Multiple Title and/or Actions configurations detected.\n                    When using a component as content, provide the title and actions either in the component's markup\n                    or via the title and actions properties of the DialogSettings object, but not both.\n                    See https://www.telerik.com/kendo-angular-ui/components/dialogs/dialog/service.md#toc-passing-title-content-and-actions-as-a-single-component'`);\n                }\n            }\n            else {\n                if (hasContentTitle || hasContentActions) {\n                    console.warn(`\n                    When Title and/or Actions markup is provided in content component's template,\n                    the component needs to inherit the DialogContentBase class to ensure that close and result events are properly hooked.\n                    See https://www.telerik.com/kendo-angular-ui/components/dialogs/dialog/service.md#toc-passing-title-content-and-actions-as-a-single-component'`);\n                }\n            }\n        }\n        return dialogRef;\n    }\n    applyOptions(instance, options) {\n        instance.title = options.title;\n        instance.actions = options.actions;\n        instance.actionsLayout = options.actionsLayout || 'stretched';\n        instance.width = options.width;\n        instance.minWidth = options.minWidth;\n        instance.maxWidth = options.maxWidth;\n        instance.height = options.height;\n        instance.minHeight = options.minHeight;\n        instance.maxHeight = options.maxHeight;\n        instance.autoFocusedElement = options.autoFocusedElement;\n        instance.closeTitle = options.closeTitle;\n        if (options.content instanceof TemplateRef) {\n            instance.contentTemplate = options.content;\n        }\n    }\n    contentFrom(content, container, dialogRef) {\n        const renderer = container.injector.get(Renderer2);\n        let nodes = [];\n        let titleNodes = [];\n        let actionNodes = [];\n        let componentRef = null;\n        if (typeof content === 'string') {\n            nodes = [renderer.createText(content)];\n        }\n        else if (content && !(content instanceof TemplateRef)) { // Component\n            const injector = new DialogInjector(() => dialogRef, container.injector);\n            const factory = this.resolver.resolveComponentFactory(content);\n            componentRef = container.createComponent(factory, undefined, injector);\n            titleNodes = Array.from(componentRef.location.nativeElement.querySelectorAll('kendo-dialog-titlebar'));\n            nodes = [componentRef.location.nativeElement];\n            actionNodes = Array.from(componentRef.location.nativeElement.querySelectorAll('kendo-dialog-actions'));\n            dialogRef.content = componentRef;\n        }\n        return {\n            componentRef,\n            nodes: [\n                titleNodes,\n                nodes,\n                actionNodes // <ng-content select=\"kendo-dialog-actions\">\n            ]\n        };\n    }\n}\nDialogService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nDialogService.ctorParameters = () => [\n    { type: ComponentFactoryResolver },\n    { type: DialogContainerService, decorators: [{ type: Inject, args: [DialogContainerService,] }] }\n];\n\n/**\n * @hidden\n */\nlet newZIndex = 10002;\n/**\n * @hidden\n */\nconst DEFAULT_OPTIONS = {\n    draggable: true,\n    height: null,\n    left: null,\n    minHeight: 100,\n    minWidth: 120,\n    position: 'absolute',\n    resizable: true,\n    state: 'default',\n    top: null,\n    width: null\n};\n/**\n * @hidden\n */\nconst createMoveStream = (el, ev) => mouseDown => {\n    return el.kendoDrag\n        .pipe(takeUntil(el.kendoRelease.pipe(tap(() => { ev.emit(); }))), map(({ pageX, pageY }) => ({\n        originalX: mouseDown.pageX,\n        originalY: mouseDown.pageY,\n        pageX,\n        pageY\n    })));\n};\n/**\n * @hidden\n */\nclass DragResizeService {\n    constructor(ngZone) {\n        this.ngZone = ngZone;\n        this.close = new EventEmitter();\n        this.focus = new EventEmitter();\n        this.change = new EventEmitter();\n        this.stateChange = new EventEmitter();\n        this.dragStart = new EventEmitter();\n        this.dragEnd = new EventEmitter();\n        this.resizeStart = new EventEmitter();\n        this.resizeEnd = new EventEmitter();\n        this.options = Object.assign({}, DEFAULT_OPTIONS);\n        this.lastAction = null;\n        this.subscriptions = new Subscription();\n        this.dragSubscription = new Subscription();\n    }\n    ngOnDestroy() {\n        if (this.subscriptions) {\n            this.subscriptions.unsubscribe();\n        }\n        if (this.dragSubscription) {\n            this.dragSubscription.unsubscribe();\n        }\n    }\n    init(el) {\n        const state$$1 = this.options.state;\n        let options = this.options;\n        this.window = el;\n        if (state$$1 !== 'default') {\n            this.restoreOptions = Object.assign({}, options);\n        }\n        if (state$$1 === 'minimized') {\n            options.height = 0;\n            options.minHeight = 0;\n        }\n        if (state$$1 === 'maximized') {\n            options.position = 'fixed';\n        }\n    }\n    onDrag(el) {\n        this.subscriptions.add(this.ngZone.runOutsideAngular(() => {\n            let startPosition;\n            let dragStarted;\n            this.dragSubscription = el.kendoPress\n                .pipe(tap((ev) => {\n                if (!ev.isTouch) {\n                    preventDefault(ev);\n                }\n                this.focus.emit();\n                startPosition = this.currentPosition();\n                dragStarted = false;\n            }), switchMap(createMoveStream(el, this.dragEnd)))\n                .subscribe(({ pageX, pageY, originalX, originalY }) => {\n                if (!dragStarted) {\n                    this.ensureWidth();\n                    this.dragStart.emit();\n                    dragStarted = true;\n                }\n                this.handleDrag({\n                    originalX, originalY,\n                    pageX, pageY, startPosition\n                });\n            });\n        }));\n    }\n    handleDrag({ originalX, originalY, pageX, pageY, startPosition }) {\n        this.options.left = startPosition.x + pageX - originalX;\n        this.options.top = startPosition.y + pageY - originalY;\n        if (this.options.state === 'minimized' && isPresent(this.restoreOptions)) {\n            this.restoreOptions.left = this.options.left;\n            this.restoreOptions.top = this.options.top;\n        }\n        this.change.emit({\n            left: startPosition.x + pageX - originalX,\n            top: startPosition.y + pageY - originalY\n        });\n    }\n    onResize(handle, direction) {\n        this.subscriptions.add(this.ngZone.runOutsideAngular(() => {\n            let startOffsetAndPosition;\n            let resizeStarted = false;\n            handle.kendoPress.pipe(tap((ev) => {\n                preventDefault(ev);\n                this.focus.emit();\n                startOffsetAndPosition = this.currentOffsetAndPosition();\n                resizeStarted = false;\n            }), switchMap(createMoveStream(handle, this.resizeEnd)))\n                .subscribe(({ pageX, pageY, originalX, originalY }) => {\n                if (!resizeStarted) {\n                    this.resizeStart.emit(direction);\n                    resizeStarted = true;\n                }\n                let deltaX = pageX - originalX;\n                let deltaY = pageY - originalY;\n                this.handleResize(startOffsetAndPosition, direction, deltaX, deltaY);\n            });\n        }));\n    }\n    handleResize(initial, dir, deltaX, deltaY) {\n        const old = this.options;\n        let ev = {};\n        if (dir.indexOf('e') >= 0) {\n            const newWidth = initial.width + deltaX;\n            if (newWidth !== old.width && newWidth >= old.minWidth) {\n                ev.width = newWidth;\n            }\n        }\n        if (dir.indexOf('n') >= 0) {\n            const newHeight = initial.height - deltaY;\n            const newTop = initial.y + deltaY;\n            if (newHeight !== old.height && newHeight >= old.minHeight && newTop !== old.top) {\n                ev.height = newHeight;\n                ev.top = newTop;\n            }\n        }\n        if (dir.indexOf('s') >= 0) {\n            const newHeight = initial.height + deltaY;\n            if (newHeight !== old.height && newHeight >= old.minHeight) {\n                ev.height = newHeight;\n            }\n        }\n        if (dir.indexOf('w') >= 0) {\n            const newLeft = initial.x + deltaX;\n            const newWidth = initial.width - deltaX;\n            if (newWidth !== old.width && newWidth >= old.minWidth && newLeft !== old.left) {\n                ev.width = newWidth;\n                ev.left = newLeft;\n            }\n        }\n        if (isPresent(ev.width) || isPresent(ev.height)) {\n            OFFSET_STYLES.forEach((style$$1) => {\n                if (isPresent(ev[style$$1])) {\n                    this.options[style$$1] = ev[style$$1];\n                }\n            });\n            this.change.emit(ev);\n        }\n    }\n    restoreAction() {\n        this.lastAction = 'restore';\n        this.defaultState();\n    }\n    defaultState() {\n        if (isPresent(this.restoreOptions)) {\n            this.options = Object.assign({}, this.restoreOptions);\n        }\n        this.options.state = 'default';\n        this.stateChange.emit('default');\n    }\n    storeOptions() {\n        this.restoreOptions = Object.assign({}, this.options);\n    }\n    maximizeAction() {\n        this.lastAction = 'maximize';\n        this.maximizeState();\n    }\n    maximizeState() {\n        this.storeOptions();\n        const wnd = this.windowViewPort;\n        this.options = Object.assign({}, this.options, {\n            height: wnd.height,\n            left: 0,\n            position: 'fixed',\n            state: 'maximized',\n            top: 0,\n            width: wnd.width\n        });\n        this.stateChange.emit('maximized');\n    }\n    minimizeAction() {\n        this.lastAction = 'minimize';\n        this.minimizeState();\n    }\n    minimizeState() {\n        this.storeOptions();\n        this.options = Object.assign({}, this.options, {\n            height: null,\n            minHeight: 0,\n            state: 'minimized'\n        });\n        this.stateChange.emit('minimized');\n    }\n    /**\n     * Handles manual changes of the 'state' property.\n     * Required to distinguish them from action clicks.\n     */\n    applyManualState() {\n        const state$$1 = this.options.state;\n        switch (state$$1) {\n            case 'default':\n                this.clearHeight();\n                this.defaultState();\n                break;\n            case 'maximized':\n                this.clearHeight();\n                this.maximizeState();\n                break;\n            case 'minimized':\n                this.minimizeState();\n                break;\n            default:\n                break;\n        }\n    }\n    closeAction() {\n        this.close.emit();\n    }\n    ensureWidth() {\n        const windowOffset = offset(this.window.nativeElement);\n        if (!isPresent(this.options.width)) {\n            this.options.width = windowOffset.width;\n            this.change.emit({ width: windowOffset.width });\n        }\n    }\n    clearHeight() {\n        if (this.options.height === 0) {\n            delete this.options.height;\n        }\n        if (this.options.minHeight === 0) {\n            delete this.options.minHeight;\n        }\n    }\n    center() {\n        if (this.options.state === 'maximized') {\n            return;\n        }\n        let scroll = scrollPosition(this.window.nativeElement);\n        let wnd = this.windowViewPort;\n        let wrapper = offset(this.window.nativeElement);\n        let ev = {};\n        if (!isPresent(this.options.left)) {\n            this.options.left = scroll.x + Math.max(0, (wnd.width - wrapper.width) / 2);\n            ev.left = this.options.left;\n        }\n        if (!isPresent(this.options.top)) {\n            this.options.top = scroll.y + Math.max(0, (wnd.height - wrapper.height) / 2);\n            ev.top = this.options.top;\n        }\n        this.change.emit(ev);\n    }\n    currentOffsetAndPosition() {\n        const o = this.options;\n        const off = offset(this.window.nativeElement);\n        return Object.assign({}, this.currentPosition(), {\n            height: o.height ? o.height : off.height,\n            width: o.width ? o.width : off.width\n        });\n    }\n    currentPosition() {\n        const o = this.options;\n        if (!o.top || !o.left) {\n            this.setPosition();\n        }\n        return {\n            x: this.options.left,\n            y: this.options.top\n        };\n    }\n    setPosition() {\n        const wrapper = positionWithScroll(this.window.nativeElement, getDocumentElement(this.window.nativeElement));\n        this.options.left = wrapper.left;\n        this.options.top = wrapper.top;\n    }\n    setRestoreOption(style$$1, value) {\n        if (isPresent(this.restoreOptions)) {\n            this.restoreOptions[style$$1] = value;\n        }\n    }\n    get nextPossibleZIndex() {\n        return newZIndex;\n    }\n    get nextZIndex() {\n        return newZIndex++;\n    }\n    get windowViewPort() {\n        return getWindowViewPort(this.window.nativeElement);\n    }\n}\nDragResizeService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nDragResizeService.ctorParameters = () => [\n    { type: NgZone }\n];\n\n/**\n * @hidden\n */\nclass ResizeHandleDirective {\n    constructor(draggable, el, renderer, service) {\n        this.draggable = draggable;\n        this.el = el;\n        this.renderer = renderer;\n        this.service = service;\n        this.subscriptions = new Subscription();\n    }\n    get hostClass() {\n        return true;\n    }\n    ngOnInit() {\n        this.setDisplay();\n        this.renderer.addClass(this.el.nativeElement, 'k-resize-' + this.direction);\n        this.subscriptions.add(of(this.draggable).subscribe(handle => {\n            this.service.onResize(handle, this.direction);\n        }));\n        this.subscriptions.add(this.service.resizeStart.subscribe((dir) => {\n            if (dir !== this.direction) {\n                this.setDisplay('none');\n            }\n        }));\n        this.subscriptions.add(this.service.dragStart.subscribe(() => {\n            this.setDisplay('none');\n        }));\n        this.subscriptions.add(merge(this.service.resizeEnd, this.service.dragEnd).subscribe(() => {\n            this.setDisplay('block');\n        }));\n        this.subscriptions.add(this.service.stateChange.subscribe((state$$1) => {\n            this.setDisplay(state$$1 === 'default' ? 'block' : 'none');\n        }));\n    }\n    ngOnDestroy() {\n        this.subscriptions.unsubscribe();\n    }\n    setDisplay(value = 'block') {\n        this.renderer.setStyle(this.el.nativeElement, 'display', this.service.options.state === 'default' ? value : 'none');\n    }\n}\nResizeHandleDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoWindowResizeHandle]'\n            },] },\n];\n/** @nocollapse */\nResizeHandleDirective.ctorParameters = () => [\n    { type: DraggableDirective, decorators: [{ type: Host }] },\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: DragResizeService }\n];\nResizeHandleDirective.propDecorators = {\n    direction: [{ type: Input }],\n    hostClass: [{ type: HostBinding, args: ['class.k-resize-handle',] }]\n};\n\nclass WindowTitleBarComponent {\n    constructor(el, service, ngZone) {\n        this.el = el;\n        this.ngZone = ngZone;\n        this.service = service;\n    }\n    ngOnInit() {\n        this.dragDirective = new DraggableDirective(this.el, this.ngZone);\n        this.dragDirective.ngOnInit();\n        if (this.isDraggable) {\n            this.subscribeDrag();\n        }\n        this.subscribeStateChange();\n    }\n    ngOnDestroy() {\n        this.dragDirective.ngOnDestroy();\n        this.unsubscribeDrag();\n        this.unsubscribeState();\n    }\n    /**\n     * @hidden\n     */\n    subscribeDrag() {\n        this.unsubscribeDrag();\n        this.dragSubscription = of(this.dragDirective).subscribe(titleBar => {\n            this.service.onDrag(titleBar);\n        });\n    }\n    /**\n     * @hidden\n     */\n    subscribeStateChange() {\n        this.stateSubscription = this.service.stateChange.subscribe((state$$1) => {\n            if (this.service.options.draggable) {\n                if (state$$1 === 'maximized') {\n                    this.unsubscribeDrag();\n                }\n                else {\n                    this.subscribeDrag();\n                }\n            }\n        });\n    }\n    /**\n     * @hidden\n     */\n    unsubscribeDrag() {\n        if (this.dragSubscription) {\n            this.service.dragSubscription.unsubscribe();\n            this.dragSubscription.unsubscribe();\n            this.dragSubscription = null;\n        }\n    }\n    /**\n     * @hidden\n     */\n    unsubscribeState() {\n        if (this.stateSubscription) {\n            this.stateSubscription.unsubscribe();\n            this.stateSubscription = null;\n        }\n    }\n    get className() {\n        return true;\n    }\n    get touchAction() {\n        if (this.isDraggable) {\n            return 'none';\n        }\n    }\n    /**\n     * @hidden\n     */\n    handle(ev) {\n        const target = ev.target;\n        const state$$1 = this.service.options.state;\n        if (!hasClasses(target, 'k-icon') && !isFocusable(target, false) && this.service.options.resizable) {\n            if (state$$1 === 'default') {\n                this.service.maximizeAction();\n            }\n            else if (state$$1 === 'maximized') {\n                this.service.restoreAction();\n            }\n        }\n    }\n    get isDraggable() {\n        const options = this.service.options;\n        return options.draggable && options.state !== 'maximized';\n    }\n}\nWindowTitleBarComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-window-titlebar',\n                template: `\n    <ng-content *ngIf=\"!template\"></ng-content>\n    <ng-template\n      [ngTemplateOutlet]=\"template\"\n      [ngTemplateOutletContext]=\"{'$implicit': service}\" *ngIf=\"template\">\n    </ng-template>\n  `\n            },] },\n];\n/** @nocollapse */\nWindowTitleBarComponent.ctorParameters = () => [\n    { type: ElementRef },\n    { type: DragResizeService },\n    { type: NgZone }\n];\nWindowTitleBarComponent.propDecorators = {\n    template: [{ type: Input }],\n    className: [{ type: HostBinding, args: ['class.k-window-titlebar',] }, { type: HostBinding, args: ['class.k-dialog-titlebar',] }],\n    touchAction: [{ type: HostBinding, args: ['style.touch-action',] }],\n    handle: [{ type: HostListener, args: ['dblclick', ['$event'],] }]\n};\n\n/**\n * @hidden\n */\nclass NavigationService {\n    constructor(window) {\n        this.window = window;\n    }\n    process(ev) {\n        const key = ev.keyCode;\n        switch (key) {\n            case Keys.up:\n            case Keys.down:\n            case Keys.left:\n            case Keys.right: {\n                ev.preventDefault();\n                this.handleArrow(key, ev);\n                break;\n            }\n            case Keys.esc:\n                this.handleEscape();\n                break;\n            default:\n                break;\n        }\n    }\n    handleArrow(key, ev) {\n        const options = this.window.options;\n        if (ev.altKey) {\n            this.handleStateChange(key, options.state);\n            return;\n        }\n        if ((ev.ctrlKey || ev.metaKey) && options.state === 'default') {\n            this.handleResize(key);\n        }\n        else {\n            this.handleDrag(key);\n        }\n    }\n    handleEscape() {\n        this.window.closeAction();\n    }\n    handleDrag(key) {\n        let options = this.window.options;\n        if (!options.draggable) {\n            return;\n        }\n        const offset$$1 = this.window.currentOffsetAndPosition();\n        let restoreOptions = this.window.restoreOptions;\n        let ev = {};\n        let delta = 10;\n        if (key === Keys.left || key === Keys.up) {\n            delta *= -1;\n        }\n        switch (key) {\n            case Keys.left:\n            case Keys.right: {\n                ev.left = offset$$1.x + delta;\n                options.left = ev.left;\n                break;\n            }\n            case Keys.up:\n            case Keys.down: {\n                ev.top = offset$$1.y + delta;\n                options.top = ev.top;\n                break;\n            }\n            default:\n                break;\n        }\n        if (options.state === 'minimized' && isPresent(restoreOptions)) {\n            restoreOptions.left = options.left;\n            restoreOptions.top = options.top;\n        }\n        this.window.change.emit(ev);\n    }\n    handleResize(key) {\n        const options = this.window.options;\n        if (!options.resizable) {\n            return;\n        }\n        const offset$$1 = this.window.currentOffsetAndPosition();\n        let newWidth;\n        let newHeight;\n        let ev = {};\n        let delta = 10;\n        if (key === Keys.left || key === Keys.up) {\n            delta *= -1;\n        }\n        switch (key) {\n            case Keys.left:\n            case Keys.right: {\n                newWidth = offset$$1.width + delta;\n                if (newWidth !== options.width && newWidth >= options.minWidth) {\n                    ev.width = newWidth;\n                }\n                break;\n            }\n            case Keys.up:\n            case Keys.down: {\n                newHeight = offset$$1.height + delta;\n                if (newHeight !== options.height && newHeight >= options.minHeight) {\n                    ev.height = newHeight;\n                }\n                break;\n            }\n            default:\n                break;\n        }\n        if (isPresent(ev.width) || isPresent(ev.height)) {\n            OFFSET_STYLES.forEach((style$$1) => {\n                if (isPresent(ev[style$$1])) {\n                    this.window.options[style$$1] = ev[style$$1];\n                }\n            });\n            this.window.change.emit(ev);\n        }\n    }\n    handleStateChange(key, state$$1) {\n        if ((state$$1 === 'minimized' && key === Keys.up) ||\n            (state$$1 === 'maximized' && key === Keys.down)) {\n            this.window.restoreAction();\n            return;\n        }\n        if (state$$1 === 'default') {\n            if (key === Keys.up) {\n                this.window.maximizeAction();\n            }\n            else if (key === Keys.down) {\n                this.window.minimizeAction();\n            }\n        }\n    }\n}\nNavigationService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nNavigationService.ctorParameters = () => [\n    { type: DragResizeService }\n];\n\n/**\n * Represents the [Kendo UI Window component for Angular]({% slug overview_window_dialogs %}).\n */\nclass WindowComponent {\n    constructor(el, renderer, service, navigation, ngZone, localization) {\n        this.el = el;\n        this.renderer = renderer;\n        this.service = service;\n        this.navigation = navigation;\n        this.ngZone = ngZone;\n        this.localization = localization;\n        /**\n         * Specifies if the content of the component is persisted in the DOM when minimized.\n         * @default false\n         */\n        this.keepContent = false;\n        /**\n         * Fires when the user starts to move the Window.\n         */\n        this.dragStart = new EventEmitter();\n        /**\n         * Fires when the Window was moved by the user.\n         */\n        this.dragEnd = new EventEmitter();\n        /**\n         * Fires when the user starts to resize the Window.\n         */\n        this.resizeStart = new EventEmitter();\n        /**\n         * Fires when the Window was resized by the user.\n         */\n        this.resizeEnd = new EventEmitter();\n        /**\n         * Fires when the user closes the Window.\n         */\n        this.close = new EventEmitter();\n        /**\n         * Fires when the `width` property of the component was updated. The event is triggered only after the resizing\n         * has ended. The event data contains the new width. Allows a two-way binding of the `width` property.\n         */\n        this.widthChange = new EventEmitter();\n        /**\n         * Fires when the `height` property of the component was updated. The event is triggered only after the resizing\n         * has ended. The event data contains the new height. Allows a two-way binding of the `height` property.\n         */\n        this.heightChange = new EventEmitter();\n        /**\n         * Fires when the `top` property of the component was updated. The event is triggered only after the dragging\n         * and resizing have ended. The event data contains the new top offset. Allows a two-way binding of the `top` property.\n         */\n        this.topChange = new EventEmitter();\n        /**\n         * Fires when the `left` property of the component was updated. The event is triggered only after the dragging\n         * and resizing have ended. The event data contains the new left offset. Allows a two-way binding of the `left` property.\n         */\n        this.leftChange = new EventEmitter();\n        /**\n         * Fires when the `state` property of the component was updated. The event data contains the new state. Allows a\n         * two-way binding of the `state` property.\n         */\n        this.stateChange = new EventEmitter();\n        this.tabIndex = 0;\n        this.draged = false;\n        this.resized = false;\n        this.windowSubscription = new Subscription();\n        this.direction = this.localization.rtl ? 'rtl' : 'ltr';\n        this.localizationChangeSubscription = this.localization.changes\n            .subscribe(({ rtl }) => this.direction = rtl ? 'rtl' : 'ltr');\n        this.resizeDirections = RESIZE_DIRECTIONS;\n        this.subscribeEvents();\n    }\n    /**\n     * Specifies whether the user will be able to drag the component.\n     * @default true\n     */\n    set draggable(value) {\n        this.options.draggable = value;\n    }\n    get draggable() {\n        return this.options.draggable;\n    }\n    /**\n     * Specifies whether the user will be able to resize the component.\n     * @default true\n     */\n    set resizable(value) {\n        this.options.resizable = value;\n    }\n    get resizable() {\n        return this.options.resizable;\n    }\n    /**\n     * Specifies the initial state of the component.\n     * If not specified, the value is set to `default`.\n     *\n     * The possible values are:\n     * * `minimized`\n     * * `maximized`\n     * * `default`\n     */\n    set state(value) {\n        this.options.state = value;\n    }\n    get state() {\n        return this.options.state;\n    }\n    /**\n     * Specifies the minimum width of the component.\n     * The `minWidth` property has to be set in pixels.\n     * @default 120\n     */\n    set minWidth(value) {\n        this.setOption('minWidth', value);\n    }\n    get minWidth() {\n        return this.options.minWidth;\n    }\n    /**\n     * Specifies the minimum height of the Window.\n     * The `minHeight` property has to be set in pixels.\n     * @default 100\n     */\n    set minHeight(value) {\n        this.setOption('minHeight', value);\n    }\n    get minHeight() {\n        return this.options.minHeight;\n    }\n    /**\n     * Specifies the width of the Window.\n     * The `width` property has to be set in pixels.\n     */\n    set width(value) {\n        this.setOption('width', value);\n    }\n    get width() {\n        return this.options.width;\n    }\n    /**\n     * Specifies the height of the Window.\n     * The `height` property has to be set in pixels.\n     */\n    set height(value) {\n        this.setOption('height', value);\n    }\n    get height() {\n        return this.options.height;\n    }\n    /**\n     * Specifies the initial top offset of the Window.\n     * The `top` property has to be set in pixels.\n     */\n    set top(value) {\n        this.setOption('top', value);\n    }\n    get top() {\n        return this.options.top;\n    }\n    /**\n     * Specifies the initial left offset of the Window.\n     * Numeric values are treated as pixels.\n     */\n    set left(value) {\n        this.setOption('left', value);\n    }\n    get left() {\n        return this.options.left;\n    }\n    get closeButtonTitle() {\n        if (this.messages && this.messages.closeTitle) {\n            return this.messages.closeTitle;\n        }\n        return this.localization.get('closeTitle');\n    }\n    get restoreButtonTitle() {\n        if (this.messages && this.messages.restoreTitle) {\n            return this.messages.restoreTitle;\n        }\n        return this.localization.get('restoreTitle');\n    }\n    get maximizeButtonTitle() {\n        if (this.messages && this.messages.maximizeTitle) {\n            return this.messages.maximizeTitle;\n        }\n        return this.localization.get('maximizeTitle');\n    }\n    get minimizeButtonTitle() {\n        if (this.messages && this.messages.minimizeTitle) {\n            return this.messages.minimizeTitle;\n        }\n        return this.localization.get('minimizeTitle');\n    }\n    get hostClasses() {\n        return true;\n    }\n    get dir() {\n        return this.direction;\n    }\n    ngAfterViewInit() {\n        this.setNextZIndex();\n        this.handleInitialFocus();\n        this.ngZone.runOutsideAngular(() => Promise.resolve(null).then(() => this.setInitialOffset()));\n    }\n    ngOnInit() {\n        this.renderer.removeAttribute(this.el.nativeElement, 'title');\n        this.service.init(this.el);\n    }\n    ngOnChanges(changes) {\n        OFFSET_STYLES.forEach((style$$1) => {\n            if (isChanged(style$$1, changes)) {\n                this.setStyle(style$$1, this.options[style$$1]);\n            }\n        });\n        if (isChanged('draggable', changes)) {\n            const titleBar = isPresent(this.titleBarContent) ? this.titleBarContent : this.titleBarView;\n            if (isTruthy(changes.draggable.currentValue)) {\n                titleBar.subscribeDrag();\n            }\n            else {\n                titleBar.unsubscribeDrag();\n            }\n        }\n        if (isChanged('state', changes)) {\n            if (isPresent(this.service.lastAction)) {\n                this.service.lastAction = null;\n            }\n            else {\n                this.service.applyManualState();\n                this.updateAllOffset();\n            }\n        }\n    }\n    ngOnDestroy() {\n        if (this.windowSubscription) {\n            this.windowSubscription.unsubscribe();\n        }\n        this.localizationChangeSubscription.unsubscribe();\n    }\n    /**\n     * Focuses the wrapper of the Window component.\n     */\n    focus() {\n        const wrapper = this.el.nativeElement;\n        if (isPresent(wrapper)) {\n            wrapper.focus();\n        }\n    }\n    /**\n     * Brings the current Window component on top of other Window components on the page.\n     */\n    bringToFront() {\n        this.setNextZIndex();\n    }\n    /**\n     * Manually updates the `width` or `height` option of the Window.\n     * The required style will be applied to the Window wrapper element and the\n     * corresponding property of the component instance will be updated.\n     * This method is intended to be used for sizing dynamically created components using the\n     * [`WindowService`]({% slug api_dialog_windowservice %})\n     * @param {WindowDimensionSetting} dimension - The option that will be updated\n     * @param {number} value - The value set in pixels\n     */\n    setDimension(dimension, value) {\n        this.setOption(dimension, value);\n        this.setStyle(dimension, value);\n    }\n    /**\n     * Manually updates the `top` or `left` offset of the Window.\n     * The required style will be applied to the Window wrapper element and the\n     * corresponding property of the component instance will be updated.\n     * This method is intended to be used for positioning dynamically created components using the\n     * [`WindowService`]({% slug api_dialog_windowservice %})\n     * @param {WindowOffsetSetting} offset - The option that will be updated\n     * @param {number} value - The value set in pixels\n     */\n    setOffset(offset$$1, value) {\n        this.setOption(offset$$1, value);\n        this.setStyle(offset$$1, value);\n    }\n    get showDefaultTitleBar() {\n        return !isPresent(this.titleBarContent);\n    }\n    get styleMinWidth() {\n        return this.minWidth + 'px';\n    }\n    get styleMinHeight() {\n        return this.minHeight + 'px';\n    }\n    get stylePosition() {\n        return this.options.position;\n    }\n    get wrapperMaximizedClass() {\n        return this.state === 'maximized';\n    }\n    get wrapperMinimizedClass() {\n        return this.state === 'minimized';\n    }\n    /**\n     * @hidden\n     */\n    onComponentKeydown(event) {\n        if (hasClasses(event.target, WINDOW_CLASSES)) {\n            this.navigation.process(event);\n        }\n    }\n    /**\n     * @hidden\n     */\n    onComponentFocus() {\n        this.renderer.addClass(this.el.nativeElement, 'k-state-focused');\n        this.setNextZIndex();\n    }\n    /**\n     * @hidden\n     */\n    onComponentBlur() {\n        this.renderer.removeClass(this.el.nativeElement, 'k-state-focused');\n    }\n    subscribeEvents() {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        this.windowSubscription.add(this.service.focus.subscribe(() => {\n            this.el.nativeElement.focus();\n        }));\n        this.windowSubscription.add(this.service.dragStart.subscribe(() => {\n            this.draged = true;\n            this.ngZone.run(() => {\n                this.dragStart.emit();\n            });\n        }));\n        this.windowSubscription.add(this.service.dragEnd.subscribe(() => {\n            if (this.draged) {\n                this.draged = false;\n                this.ngZone.run(() => {\n                    this.dragEnd.emit();\n                });\n            }\n        }));\n        this.windowSubscription.add(this.service.close.subscribe(() => {\n            this.close.emit();\n        }));\n        this.windowSubscription.add(this.service.resizeStart.subscribe(() => {\n            this.resized = true;\n            this.ngZone.run(() => {\n                this.resizeStart.emit();\n            });\n        }));\n        this.windowSubscription.add(this.service.resizeEnd.subscribe(() => {\n            if (this.resized) {\n                this.resized = false;\n                this.ngZone.run(() => {\n                    this.resizeEnd.emit();\n                });\n            }\n        }));\n        this.windowSubscription.add(this.service.change.subscribe((ev) => {\n            OFFSET_STYLES.forEach((style$$1) => {\n                if (isPresent(ev[style$$1])) {\n                    this.setStyle(style$$1, ev[style$$1]);\n                    if (this.state !== 'maximized') {\n                        const emitter = this[style$$1 + 'Change'];\n                        if (emitter.observers.length) {\n                            this.ngZone.run(() => {\n                                emitter.emit(ev[style$$1]);\n                            });\n                        }\n                    }\n                }\n            });\n        }));\n        this.windowSubscription.add(this.service.stateChange.subscribe((state$$1) => {\n            if (isPresent(this.service.lastAction)) {\n                this.updateAllOffset();\n                this.stateChange.emit(state$$1);\n            }\n        }));\n    }\n    setNextZIndex() {\n        const currentZIndex = this.el.nativeElement.style['z-index'];\n        const nextPossibleZIndex = this.service.nextPossibleZIndex;\n        if (!currentZIndex || (nextPossibleZIndex - currentZIndex > 1)) {\n            this.renderer.setStyle(this.el.nativeElement, \"z-index\", this.service.nextZIndex);\n        }\n    }\n    setInitialOffset() {\n        if (this.state !== 'maximized') {\n            this.updateAllOffset();\n            if (!isPresent(this.left) || !isPresent(this.top)) {\n                this.service.center();\n            }\n        }\n        else {\n            const viewPort = this.service.windowViewPort;\n            this.setStyle('width', viewPort.width);\n            this.setStyle('height', viewPort.height);\n            this.setStyle('top', 0);\n            this.setStyle('left', 0);\n        }\n    }\n    updateAllOffset() {\n        OFFSET_STYLES.forEach((style$$1) => {\n            if (isPresent(this[style$$1])) {\n                this.setStyle(style$$1, this[style$$1]);\n            }\n            else {\n                this.removeStyle(style$$1);\n            }\n        });\n    }\n    setStyle(style$$1, value) {\n        this.renderer.setStyle(this.el.nativeElement, style$$1, value + 'px');\n    }\n    removeStyle(style$$1) {\n        this.renderer.removeStyle(this.el.nativeElement, style$$1);\n    }\n    get options() {\n        return this.service.options;\n    }\n    setOption(style$$1, value) {\n        if (typeof value !== 'number' && typeof value !== 'string') {\n            return;\n        }\n        const parsedValue = (typeof value === 'number') ? value : parseInt(value, 10);\n        this.options[style$$1] = parsedValue;\n        this.service.setRestoreOption(style$$1, parsedValue);\n    }\n    handleInitialFocus() {\n        const wrapper = this.el.nativeElement;\n        if (this.autoFocusedElement) {\n            const initiallyFocusedElement = wrapper.querySelector(this.autoFocusedElement);\n            if (initiallyFocusedElement) {\n                initiallyFocusedElement.focus();\n            }\n        }\n        else {\n            this.focus();\n        }\n    }\n}\nWindowComponent.decorators = [\n    { type: Component, args: [{\n                exportAs: 'kendoWindow',\n                providers: [\n                    DragResizeService,\n                    NavigationService,\n                    LocalizationService,\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.window'\n                    }\n                ],\n                selector: 'kendo-window',\n                template: `\n        <ng-container kendoWindowLocalizedMessages\n            i18n-closeTitle=\"kendo.window.closeTitle|The title of the close button\"\n            closeTitle=\"Close\"\n\n            i18n-restoreTitle=\"kendo.window.restoreTitle|The title of the restore button\"\n            restoreTitle=\"Restore\"\n\n            i18n-maximizeTitle=\"kendo.window.maximizeTitle|The title of the maximize button\"\n            maximizeTitle=\"Maximize\"\n\n            i18n-minimizeTitle=\"kendo.window.minimizeTitle|The title of the minimize button\"\n            minimizeTitle=\"Minimize\"\n        >\n        <ng-container>\n\n        <kendo-window-titlebar *ngIf=\"showDefaultTitleBar\" [template]=\"titleBarTemplate\">\n            <div class=\"k-window-title\">{{ title }}</div>\n            <div class=\"k-window-actions\">\n                <button kendoWindowMinimizeAction  [attr.title]=\"minimizeButtonTitle\" [attr.aria-label]=\"minimizeButtonTitle\"></button>\n                <button kendoWindowMaximizeAction [attr.title]=\"maximizeButtonTitle\" [attr.aria-label]=\"maximizeButtonTitle\"></button>\n                <button kendoWindowRestoreAction [attr.title]=\"restoreButtonTitle\" [attr.aria-label]=\"restoreButtonTitle\"></button>\n                <button kendoWindowCloseAction [attr.title]=\"closeButtonTitle\" [attr.aria-label]=\"closeButtonTitle\"></button>\n            </div>\n        </kendo-window-titlebar>\n        <ng-content select=\"kendo-window-titlebar\" *ngIf=\"!showDefaultTitleBar\"></ng-content>\n\n        <div *ngIf=\"state !== 'minimized' || keepContent\"\n            [hidden]=\"state === 'minimized' && keepContent\"\n            class=\"k-content k-window-content\"\n        >\n            <ng-content *ngIf=\"!contentTemplate\"></ng-content>\n            <ng-template [ngTemplateOutlet]=\"contentTemplate\" *ngIf=\"contentTemplate\"></ng-template>\n        </div>\n\n        <ng-template [ngIf]='resizable'>\n            <div *ngFor='let dir of resizeDirections'\n                [direction]=\"dir\"\n                kendoWindowResizeHandle\n                kendoDraggable>\n            </div>\n        </ng-template>\n    `\n            },] },\n];\n/** @nocollapse */\nWindowComponent.ctorParameters = () => [\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: DragResizeService },\n    { type: NavigationService },\n    { type: NgZone },\n    { type: LocalizationService }\n];\nWindowComponent.propDecorators = {\n    autoFocusedElement: [{ type: Input }],\n    title: [{ type: Input }],\n    draggable: [{ type: Input }],\n    resizable: [{ type: Input }],\n    keepContent: [{ type: Input }],\n    state: [{ type: Input }],\n    minWidth: [{ type: Input }],\n    minHeight: [{ type: Input }],\n    width: [{ type: Input }],\n    height: [{ type: Input }],\n    top: [{ type: Input }],\n    left: [{ type: Input }],\n    dragStart: [{ type: Output }],\n    dragEnd: [{ type: Output }],\n    resizeStart: [{ type: Output }],\n    resizeEnd: [{ type: Output }],\n    close: [{ type: Output }],\n    widthChange: [{ type: Output }],\n    heightChange: [{ type: Output }],\n    topChange: [{ type: Output }],\n    leftChange: [{ type: Output }],\n    stateChange: [{ type: Output }],\n    tabIndex: [{ type: HostBinding, args: ['attr.tabIndex',] }],\n    hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-window',] }],\n    dir: [{ type: HostBinding, args: ['attr.dir',] }],\n    titleBarView: [{ type: ViewChild, args: [WindowTitleBarComponent,] }],\n    titleBarContent: [{ type: ContentChild, args: [WindowTitleBarComponent,] }],\n    resizeHandles: [{ type: ViewChildren, args: [ResizeHandleDirective,] }],\n    styleMinWidth: [{ type: HostBinding, args: ['style.minWidth',] }],\n    styleMinHeight: [{ type: HostBinding, args: ['style.minHeight',] }],\n    stylePosition: [{ type: HostBinding, args: ['style.position',] }],\n    wrapperMaximizedClass: [{ type: HostBinding, args: ['class.k-window-maximized',] }],\n    wrapperMinimizedClass: [{ type: HostBinding, args: ['class.k-window-minimized',] }],\n    onComponentKeydown: [{ type: HostListener, args: ['keydown', ['$event'],] }],\n    onComponentFocus: [{ type: HostListener, args: ['focus',] }],\n    onComponentBlur: [{ type: HostListener, args: ['blur',] }]\n};\n\nclass WindowMaximizeActionDirective extends Button {\n    constructor(el, renderer, _service, localization, ngZone) {\n        super(el, renderer, null, localization, ngZone);\n        this.buttonType = 'button';\n        this.window = _service;\n        this.look = 'bare';\n        this.icon = 'window-maximize';\n    }\n    /**\n     * @hidden\n     */\n    onClick() {\n        if (!this.isDisabled) {\n            this.window.maximizeAction();\n        }\n    }\n    get visible() {\n        return this.window.options.state === 'default' ? 'inline-flex' : 'none';\n    }\n}\nWindowMaximizeActionDirective.decorators = [\n    { type: Directive, args: [{\n                exportAs: 'kendoWindowMaximizeAction',\n                providers: [\n                    LocalizationService,\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.button'\n                    }\n                ],\n                selector: 'button[kendoWindowMaximizeAction]' // tslint:disable-line\n            },] },\n];\n/** @nocollapse */\nWindowMaximizeActionDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: DragResizeService, decorators: [{ type: Optional }] },\n    { type: LocalizationService },\n    { type: NgZone }\n];\nWindowMaximizeActionDirective.propDecorators = {\n    window: [{ type: Input }],\n    buttonType: [{ type: HostBinding, args: ['attr.type',] }],\n    onClick: [{ type: HostListener, args: ['click',] }],\n    visible: [{ type: HostBinding, args: ['style.display',] }]\n};\n\nclass WindowMinimizeActionDirective extends Button {\n    constructor(el, renderer, _service, localization, ngZone) {\n        super(el, renderer, null, localization, ngZone);\n        this.buttonType = 'button';\n        this.window = _service;\n        this.look = 'bare';\n        this.icon = 'window-minimize';\n    }\n    /**\n     * @hidden\n     */\n    onClick() {\n        if (!this.isDisabled) {\n            this.window.minimizeAction();\n        }\n    }\n    get visible() {\n        return this.window.options.state === 'default' ? 'inline-flex' : 'none';\n    }\n}\nWindowMinimizeActionDirective.decorators = [\n    { type: Directive, args: [{\n                exportAs: 'kendoWindowMinimizeAction',\n                providers: [\n                    LocalizationService,\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.button'\n                    }\n                ],\n                selector: 'button[kendoWindowMinimizeAction]' // tslint:disable-line\n            },] },\n];\n/** @nocollapse */\nWindowMinimizeActionDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: DragResizeService, decorators: [{ type: Optional }] },\n    { type: LocalizationService },\n    { type: NgZone }\n];\nWindowMinimizeActionDirective.propDecorators = {\n    window: [{ type: Input }],\n    buttonType: [{ type: HostBinding, args: ['attr.type',] }],\n    onClick: [{ type: HostListener, args: ['click',] }],\n    visible: [{ type: HostBinding, args: ['style.display',] }]\n};\n\nclass WindowCloseActionDirective extends Button {\n    constructor(el, renderer, _service, localization, ngZone) {\n        super(el, renderer, null, localization, ngZone);\n        this.buttonType = 'button';\n        this.window = _service;\n        this.look = 'bare';\n        this.icon = 'close';\n    }\n    /**\n     * @hidden\n     */\n    onClick() {\n        if (!this.isDisabled) {\n            this.window.closeAction();\n        }\n    }\n}\nWindowCloseActionDirective.decorators = [\n    { type: Directive, args: [{\n                exportAs: 'kendoWindowCloseAction',\n                providers: [\n                    LocalizationService,\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.button'\n                    }\n                ],\n                selector: 'button[kendoWindowCloseAction]' // tslint:disable-line\n            },] },\n];\n/** @nocollapse */\nWindowCloseActionDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: DragResizeService, decorators: [{ type: Optional }] },\n    { type: LocalizationService },\n    { type: NgZone }\n];\nWindowCloseActionDirective.propDecorators = {\n    window: [{ type: Input }],\n    buttonType: [{ type: HostBinding, args: ['attr.type',] }],\n    onClick: [{ type: HostListener, args: ['click',] }]\n};\n\nclass WindowRestoreActionDirective extends Button {\n    constructor(el, renderer, _service, localization, ngZone) {\n        super(el, renderer, null, localization, ngZone);\n        this.buttonType = 'button';\n        this.window = _service;\n        this.look = 'bare';\n        this.icon = 'window-restore';\n    }\n    /**\n     * @hidden\n     */\n    onClick() {\n        if (!this.isDisabled) {\n            this.window.restoreAction();\n        }\n    }\n    get visible() {\n        return this.window.options.state === 'default' ? 'none' : 'inline-flex';\n    }\n}\nWindowRestoreActionDirective.decorators = [\n    { type: Directive, args: [{\n                exportAs: 'kendoWindowRestoreAction',\n                providers: [\n                    LocalizationService,\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.button'\n                    }\n                ],\n                selector: 'button[kendoWindowRestoreAction]' // tslint:disable-line\n            },] },\n];\n/** @nocollapse */\nWindowRestoreActionDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: DragResizeService, decorators: [{ type: Optional }] },\n    { type: LocalizationService },\n    { type: NgZone }\n];\nWindowRestoreActionDirective.propDecorators = {\n    window: [{ type: Input }],\n    buttonType: [{ type: HostBinding, args: ['attr.type',] }],\n    onClick: [{ type: HostListener, args: ['click',] }],\n    visible: [{ type: HostBinding, args: ['style.display',] }]\n};\n\n/**\n * The settings for the Window actions when the Window is opened through `WindowService`\n * ([see example]({% slug api_dialog_windowservice %}#toc-open)).\n */\nclass WindowSettings {\n}\n/**\n * Indicates that the **Close** button of a Window that is opened through `WindowService` is clicked.\n */\nclass WindowCloseResult {\n}\n/**\n * Holds references to the object instance of the Window.\n * Controls the Windows that were opened through `WindowService`\n * ([see example]({% slug api_dialog_windowservice %}#toc-open)).\n */\nclass WindowRef {\n}\n\n/**\n * @hidden\n */\nclass WindowContainerService {\n    set container(container) {\n        WindowContainerService.container = container;\n    }\n    get container() {\n        return WindowContainerService.container;\n    }\n}\nWindowContainerService.container = null;\nWindowContainerService.decorators = [\n    { type: Injectable },\n];\n\nclass WindowInjector {\n    constructor(getWindowRef, parentInjector) {\n        this.getWindowRef = getWindowRef;\n        this.parentInjector = parentInjector;\n    }\n    get(token, notFoundValue) {\n        if (token === WindowRef) {\n            return this.getWindowRef();\n        }\n        return this.parentInjector.get(token, notFoundValue);\n    }\n}\n/**\n * A service for opening Windows dynamically\n * ([see example]({% slug service_window %})).\n */\nclass WindowService {\n    constructor(\n    /**\n     * @hidden\n     */\n    resolver, containerService) {\n        this.resolver = resolver;\n        this.containerService = containerService;\n    }\n    /**\n     * Opens a Window component.\n     *\n     * @param {WindowSettings} settings - The settings that define the Window.\n     * @returns {WindowRef} - A reference to the Window object.\n     *\n     * @example\n     *\n     * ```ts-no-run\n     * _@Component({\n     *   selector: 'my-app',\n     *   template: `\n     *     <button kendoButton (click)=\"open()\">Open window</button>\n     *     <div kendoWindowContainer></div>\n     *   `\n     * })\n     * export class AppComponent {\n     *     constructor( private windowService: WindowService ) {}\n     *\n     *     public open() {\n     *         var window = this.windowService.open({\n     *           title: \"My window\",\n     *           content: \"My content!\"\n     *         });\n     *\n     *         window.result.subscribe((result) => {\n     *           if (result instanceof WindowCloseResult) {\n     *             console.log(\"Window was closed\");\n     *           }\n     *         });\n     *     }\n     * }\n     * ```\n     *\n     */\n    open(settings) {\n        const factory = this.resolver.resolveComponentFactory(WindowComponent);\n        const container = settings.appendTo || this.containerService.container;\n        if (!container) {\n            throw new Error(`Cannot attach window to the page.\n                Add an element that uses the kendoWindowContainer directive, or set the 'appendTo' property.\n                See https://www.telerik.com/kendo-angular-ui/components/dialogs/window/service/\n            `);\n        }\n        const windowRef = {\n            close: () => { },\n            content: null,\n            result: null,\n            window: null\n        };\n        const content = this.contentFrom(settings.content, container, windowRef);\n        const window = container.createComponent(factory, undefined, undefined, content.nodes);\n        windowRef.window = window;\n        this.applyOptions(window.instance, settings);\n        const apiClose = new Subject();\n        const close = (e) => {\n            apiClose.next(e || new WindowCloseResult());\n            if (content.componentRef) {\n                content.componentRef.destroy();\n            }\n            window.destroy();\n        };\n        const result = merge(apiClose, window.instance.close).pipe(take(1));\n        result.subscribe(close);\n        windowRef.close = close;\n        windowRef.result = result;\n        window.changeDetectorRef.markForCheck();\n        return windowRef;\n    }\n    applyOptions(instance, options) {\n        if (isPresent(options.title)) {\n            instance.title = options.title;\n        }\n        if (isPresent(options.keepContent)) {\n            instance.keepContent = options.keepContent;\n        }\n        if (isPresent(options.width)) {\n            instance.width = options.width;\n        }\n        if (isPresent(options.minWidth)) {\n            instance.minWidth = options.minWidth;\n        }\n        if (isPresent(options.height)) {\n            instance.height = options.height;\n        }\n        if (isPresent(options.minHeight)) {\n            instance.minHeight = options.minHeight;\n        }\n        if (isPresent(options.left)) {\n            instance.left = options.left;\n        }\n        if (isPresent(options.top)) {\n            instance.top = options.top;\n        }\n        if (isPresent(options.draggable)) {\n            instance.draggable = options.draggable;\n        }\n        if (isPresent(options.resizable)) {\n            instance.resizable = options.resizable;\n        }\n        if (isPresent(options.messages && options.messages.closeTitle)) {\n            instance.messages.closeTitle = options.messages.closeTitle;\n        }\n        if (isPresent(options.messages && options.messages.restoreTitle)) {\n            instance.messages.restoreTitle = options.messages.restoreTitle;\n        }\n        if (isPresent(options.messages && options.messages.maximizeTitle)) {\n            instance.messages.maximizeTitle = options.messages.maximizeTitle;\n        }\n        if (isPresent(options.messages && options.messages.minimizeTitle)) {\n            instance.messages.minimizeTitle = options.messages.minimizeTitle;\n        }\n        if (isPresent(options.autoFocusedElement)) {\n            instance.autoFocusedElement = options.autoFocusedElement;\n        }\n        if (isPresent(options.state)) {\n            instance.state = options.state;\n            if (options.state === 'minimized') {\n                instance.keepContent = true;\n            }\n        }\n        if (options.content instanceof TemplateRef) {\n            instance.contentTemplate = options.content;\n        }\n        if (options.titleBarContent instanceof TemplateRef) {\n            instance.titleBarTemplate = options.titleBarContent;\n        }\n    }\n    contentFrom(content, container, windowRef) {\n        const renderer = container.injector.get(Renderer2);\n        let nodes = [];\n        let componentRef = null;\n        if (typeof content === 'string') {\n            nodes = [renderer.createText(content)];\n        }\n        else if (content && !(content instanceof TemplateRef)) {\n            const injector = new WindowInjector(() => windowRef, container.injector);\n            const factory = this.resolver.resolveComponentFactory(content);\n            componentRef = container.createComponent(factory, undefined, injector);\n            nodes = [componentRef.location.nativeElement];\n            windowRef.content = componentRef;\n        }\n        return {\n            componentRef,\n            nodes: [\n                [],\n                nodes // Content\n            ]\n        };\n    }\n}\nWindowService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nWindowService.ctorParameters = () => [\n    { type: ComponentFactoryResolver },\n    { type: WindowContainerService, decorators: [{ type: Inject, args: [WindowContainerService,] }] }\n];\n\n/**\n * Provides an insertion point for the Dialogs which are created through the\n * Dialog service ([see example]({% slug api_dialog_dialogservice %}#toc-open)).\n * Created Dialogs will be mounted after that element.\n *\n * @example\n * ```html-no-run\n * <div kendoDialogContainer></div>\n * ```\n */\nclass DialogContainerDirective {\n    constructor(container, service) {\n        service.container = container;\n    }\n}\nDialogContainerDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoDialogContainer]'\n            },] },\n];\n/** @nocollapse */\nDialogContainerDirective.ctorParameters = () => [\n    { type: ViewContainerRef },\n    { type: DialogContainerService }\n];\n\n/**\n * @hidden\n */\nclass Messages extends ComponentMessages {\n}\nMessages.propDecorators = {\n    closeTitle: [{ type: Input }],\n    restoreTitle: [{ type: Input }],\n    maximizeTitle: [{ type: Input }],\n    minimizeTitle: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nclass LocalizedMessagesDirective extends Messages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n}\nLocalizedMessagesDirective.decorators = [\n    { type: Directive, args: [{\n                providers: [\n                    {\n                        provide: Messages,\n                        useExisting: forwardRef(() => LocalizedMessagesDirective)\n                    }\n                ],\n                selector: `\n    [kendoDialogTitleBarLocalizedMessages],\n    [kendoWindowLocalizedMessages]\n  `\n            },] },\n];\n/** @nocollapse */\nLocalizedMessagesDirective.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * Custom component messages override default component messages\n * ([see example]({% slug globalization_dialogs %}#toc-localization)).\n */\nclass CustomMessagesComponent extends Messages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n    get override() {\n        return true;\n    }\n}\nCustomMessagesComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: Messages,\n                        useExisting: forwardRef(() => CustomMessagesComponent) // tslint:disable-line:no-forward-ref\n                    }\n                ],\n                selector: 'kendo-dialog-messages, kendo-window-messages',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nCustomMessagesComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * @hidden\n */\nconst SHARED_DIRECTIVES = [\n    DialogActionsComponent,\n    CustomMessagesComponent,\n    LocalizedMessagesDirective\n];\n/**\n * @hidden\n */\nclass SharedModule {\n}\nSharedModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [SHARED_DIRECTIVES],\n                exports: [SHARED_DIRECTIVES, CommonModule],\n                imports: [CommonModule]\n            },] },\n];\n\n/**\n * @hidden\n */\nconst DIALOG_DIRECTIVES = [\n    DialogComponent,\n    DialogTitleBarComponent\n];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Dialog component that includes all Dialog components and directives.\n * Imports `DialogModule` into the [root module]({{ site.data.urls.angular['ngmodules'] }}#angular-modularity)\n * of your application or into any other sub-module that will use the Dialog component.\n *\n * @example\n * ```ts-no-run\n * import { NgModule } from '@angular/core';\n * import { BrowserModule } from '@angular/platform-browser';\n * import { DialogModule } from '@progress/kendo-angular-dialog';\n * import { AppComponent } from './app.component';\n *\n * _@NgModule({\n *     bootstrap:    [AppComponent],\n *     declarations: [AppComponent],\n *     imports:      [BrowserModule, DialogModule]\n * })\n * export class AppModule {\n * }\n * ```\n */\nclass DialogModule {\n}\nDialogModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [DIALOG_DIRECTIVES, DialogContainerDirective],\n                entryComponents: [DIALOG_DIRECTIVES],\n                exports: [DIALOG_DIRECTIVES, SHARED_DIRECTIVES, DialogContainerDirective],\n                imports: [SharedModule],\n                providers: [DialogContainerService, DialogService]\n            },] },\n];\n\n/**\n * Provides an insertion point for the Windows which are created through the\n * Window service ([see example]({% slug api_dialog_windowservice %}#toc-open)).\n * Created Windows will be mounted after that element.\n *\n * @example\n * ```html-no-run\n * <div kendoWindowContainer></div>\n * ```\n */\nclass WindowContainerDirective {\n    constructor(container, service) {\n        service.container = container;\n    }\n}\nWindowContainerDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoWindowContainer]'\n            },] },\n];\n/** @nocollapse */\nWindowContainerDirective.ctorParameters = () => [\n    { type: ViewContainerRef },\n    { type: WindowContainerService }\n];\n\nconst WINDOW_DIRECTIVES = [\n    ResizeHandleDirective,\n    WindowComponent,\n    WindowTitleBarComponent,\n    WindowCloseActionDirective,\n    WindowMinimizeActionDirective,\n    WindowMaximizeActionDirective,\n    WindowRestoreActionDirective\n];\nconst ENTRY_COMPONENTS = [\n    WindowComponent,\n    WindowTitleBarComponent\n];\nconst exportedModules = [\n    WindowComponent,\n    WindowCloseActionDirective,\n    WindowMinimizeActionDirective,\n    WindowMaximizeActionDirective,\n    WindowRestoreActionDirective,\n    WindowTitleBarComponent\n];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Window component. Imports `WindowModule` into the\n * [root module]({{ site.data.urls.angular['ngmodules'] }}#angular-modularity)\n * of your application or into any other sub-module that will use the Window component.\n *\n * @example\n * ```ts-no-run\n * import { NgModule } from '@angular/core';\n * import { BrowserModule } from '@angular/platform-browser';\n * import { WindowModule } from '@progress/kendo-angular-window';\n * import { AppComponent } from './app.component';\n *\n * _@NgModule({\n *     bootstrap:    [AppComponent],\n *     declarations: [AppComponent],\n *     imports:      [BrowserModule, WindowModule]\n * })\n * export class AppModule {\n * }\n * ```\n */\nclass WindowModule {\n}\nWindowModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [WINDOW_DIRECTIVES, WindowContainerDirective],\n                entryComponents: [ENTRY_COMPONENTS],\n                exports: [exportedModules, SHARED_DIRECTIVES, WindowContainerDirective],\n                imports: [SharedModule, DraggableModule],\n                providers: [WindowContainerService, WindowService]\n            },] },\n];\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Dialogs components.\n *\n * @example\n *\n * ```ts-no-run\n * import { DialogsModule } from '@progress/kendo-angular-dialog';\n *\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { NgModule } from '@angular/core';\n *\n * import { AppComponent } from './app.component';\n *\n * _@NgModule({\n *     declarations: [AppComponent],\n *     imports:      [BrowserModule, DialogsModule],\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nclass DialogsModule {\n}\nDialogsModule.decorators = [\n    { type: NgModule, args: [{\n                exports: [DialogModule, WindowModule]\n            },] },\n];\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DIALOG_DIRECTIVES, DialogContainerDirective, DialogContainerService, CustomMessagesComponent, DIALOG_LOCALIZATION_SERVICE, LocalizedMessagesDirective, Messages, TitleBarLocalizationService, SHARED_DIRECTIVES, SharedModule, DragResizeService, NavigationService, WindowContainerDirective, WindowContainerService, ResizeHandleDirective, DialogComponent, DialogTitleBarComponent, DialogContentBase, DialogActionsComponent, DialogService, DialogCloseResult, DialogRef, DialogSettings, DialogAction, WindowComponent, WindowTitleBarComponent, WindowMaximizeActionDirective, WindowMinimizeActionDirective, WindowCloseActionDirective, WindowRestoreActionDirective, WindowSettings, WindowRef, WindowCloseResult, WindowService, DialogModule, WindowModule, DialogsModule };\n"],"names":[],"mappings":"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"}