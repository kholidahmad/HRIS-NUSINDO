{"version":3,"file":"index.js","sources":["D:/project/projek_angular/hris_rni/node_modules/@progress/kendo-angular-dateinputs/dist/fesm2015/index.js"],"sourcesContent":["/**-----------------------------------------------------------------------------------------\n* Copyright © 2020 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport { Injectable, EventEmitter, Injector, InjectionToken, Component, Inject, ElementRef, Renderer2, NgZone, Input, Output, HostBinding, ChangeDetectionStrategy, ChangeDetectorRef, ViewChild, Directive, TemplateRef, isDevMode, forwardRef, Optional, ContentChild, ViewContainerRef, HostListener, ViewChildren, ContentChildren, IterableDiffers, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR, NG_VALIDATORS, NgControl } from '@angular/forms';\nimport { LocalizationService, L10N_PREFIX, RTL, ComponentMessages } from '@progress/kendo-angular-l10n';\nimport { getDate, isEqual, cloneDate, addDays, addDecades, addCenturies, firstDecadeOfCentury, lastDecadeOfCentury, firstYearOfDecade, createDate, durationInCenturies, addYears, lastYearOfDecade, durationInDecades, addWeeks, addMonths, firstDayOfMonth, lastDayOfMonth, dayOfWeek, durationInMonths, firstMonthOfYear, lastMonthOfYear, durationInYears, weekInYear } from '@progress/kendo-date-math';\nimport { isDocumentAvailable, KendoInput, guid, hasObservers, Keys, EventsModule } from '@progress/kendo-angular-common';\nimport { IntlService, IntlModule } from '@progress/kendo-angular-intl';\nimport { ReplaySubject, Observable, Subject, combineLatest, of, interval, animationFrameScheduler, fromEvent, EMPTY, from, Subscription, BehaviorSubject, merge } from 'rxjs';\nimport { map, scan, takeWhile, tap, filter, debounceTime } from 'rxjs/operators';\nimport { PopupService, PopupModule } from '@progress/kendo-angular-popup';\nimport { CommonModule } from '@angular/common';\nimport { touchEnabled } from '@progress/kendo-common';\n\n/**\n * @hidden\n */\nvar Action;\n(function (Action) {\n    Action[Action[\"Left\"] = 0] = \"Left\";\n    Action[Action[\"Right\"] = 1] = \"Right\";\n    Action[Action[\"Up\"] = 2] = \"Up\";\n    Action[Action[\"Down\"] = 3] = \"Down\";\n    Action[Action[\"PrevView\"] = 4] = \"PrevView\";\n    Action[Action[\"NextView\"] = 5] = \"NextView\";\n    Action[Action[\"FirstInView\"] = 6] = \"FirstInView\";\n    Action[Action[\"LastInView\"] = 7] = \"LastInView\";\n    Action[Action[\"LowerView\"] = 8] = \"LowerView\";\n    Action[Action[\"UpperView\"] = 9] = \"UpperView\";\n})(Action || (Action = {}));\n\n/**\n * @hidden\n */\nconst EMPTY_SELECTIONRANGE = { start: null, end: null };\n\n/**\n * @hidden\n */\nconst MIDNIGHT_DATE = new Date(1980, 0, 1);\n/**\n * @hidden\n */\nconst MIN_DATE = new Date(1900, 0, 1);\n/**\n * @hidden\n */\nconst MAX_DATE = new Date(2099, 11, 31);\n/**\n * @hidden\n */\nconst MIN_TIME = new Date(1980, 0, 1);\n/**\n * @hidden\n */\nconst MAX_TIME = new Date(1980, 0, 1, 23, 59, 59);\n\n/* tslint:disable:no-bitwise max-line-length */\nconst isSet = (value) => value !== null && value !== undefined;\nconst setter = (method) => (date, value) => {\n    const clone = cloneDate(date);\n    clone[method](value);\n    return clone;\n};\n/**\n * @hidden\n */\nconst setTime = (origin, candidate) => {\n    const date = cloneDate(origin);\n    date.setHours(candidate.getHours(), candidate.getMinutes(), candidate.getSeconds(), candidate.getMilliseconds());\n    return date;\n};\nconst normalizeTimes = (candidate, min, max) => ({\n    candidateValue: setTime(MIDNIGHT_DATE, candidate),\n    maxValue: addDays(setTime(MIDNIGHT_DATE, max), min.getHours() < max.getHours() ||\n        (min.getHours() === max.getHours() && min.getMinutes() < max.getMinutes()) ? 0 : 1),\n    minValue: setTime(MIDNIGHT_DATE, min)\n});\n/**\n * @hidden\n */\nconst setHours = setter('setHours');\n/**\n * @hidden\n */\nconst setMinutes = setter('setMinutes');\n/**\n * @hidden\n */\nconst setSeconds = setter('setSeconds');\n/**\n * @hidden\n */\nconst range = (start, end, step = 1) => {\n    const result = [];\n    for (let i = start; i < end; i = i + step) {\n        result.push(i);\n    }\n    return result;\n};\n/**\n * @hidden\n */\nconst isInRange = (candidate, min, max) => (!candidate || !((min && min > candidate) || (max && max < candidate)));\n/**\n * @hidden\n */\nconst isInTimeRange = (candidate, min, max) => {\n    if (!candidate || !min || !max) {\n        return true;\n    }\n    const { candidateValue, minValue, maxValue } = normalizeTimes(candidate, min, max);\n    return minValue <= candidateValue && candidateValue <= maxValue;\n};\n/**\n * @hidden\n */\nconst isValidRange = (min, max) => (!isSet(min) || !isSet(max) || min <= max);\n/**\n * @hidden\n */\nconst dateInRange = (candidate, min, max) => {\n    if (!candidate) {\n        return candidate;\n    }\n    if (min && candidate < min) {\n        return cloneDate(min);\n    }\n    if (max && candidate > max) {\n        return cloneDate(max);\n    }\n    return candidate;\n};\n/**\n * @hidden\n */\nconst timeInRange = (candidate, min, max) => {\n    if (!candidate || !min || !max) {\n        return candidate;\n    }\n    const { candidateValue, minValue, maxValue } = normalizeTimes(candidate, min, max);\n    if (candidateValue < minValue) {\n        return setTime(candidate, min);\n    }\n    if (candidateValue > maxValue) {\n        return setTime(candidate, max);\n    }\n    return candidate;\n};\n/**\n * @hidden\n */\nconst getNow = () => new Date();\n/**\n * @hidden\n */\nconst getToday = () => getDate(new Date());\n/**\n * @hidden\n */\nconst noop = (_) => { }; // tslint:disable-line:no-empty\n/**\n * @hidden\n */\nconst isWindowAvailable = () => {\n    return typeof window !== 'undefined';\n};\n/**\n * @hidden\n */\nconst stringifyClassObject = (classes) => {\n    const pushToAcc = (acc, cls) => classes[cls] ? acc.concat(cls) : acc;\n    return Object.keys(classes).reduce(pushToAcc, []).join(' ');\n};\n/**\n * @hidden\n */\nconst shiftWeekNames = (names, offset) => (names.slice(offset).concat(names.slice(0, offset)));\n/**\n * @hidden\n */\nconst approximateStringMatching = (oldTextOrigin, oldFormat, newTextOrigin, caret) => {\n    // Remove the right part of the cursor.\n    //oldFormat = oldFormat.substring(0, caret + oldText.length - newText.length);\n    const oldIndex = caret + oldTextOrigin.length - newTextOrigin.length;\n    const oldTextSeparator = oldTextOrigin[oldIndex];\n    const oldText = oldTextOrigin.substring(0, caret + oldTextOrigin.length - newTextOrigin.length);\n    const newText = newTextOrigin.substring(0, caret);\n    const diff = [];\n    // Handle typing a single character over the same selection.\n    if (oldText === newText && caret > 0) {\n        diff.push([oldFormat[caret - 1], newText[caret - 1]]);\n        return diff;\n    }\n    if (oldText.indexOf(newText) === 0 && (newText.length === 0 || oldFormat[newText.length - 1] !== oldFormat[newText.length])) {\n        // Handle Delete/Backspace.\n        let deletedSymbol = \"\";\n        //XXX:\n        // Whole text is replaced with a same char\n        // Nasty patch required to keep the selection in the first segment\n        if (newText.length === 1) {\n            diff.push([oldFormat[0], newText[0]]);\n        }\n        for (let i = newText.length; i < oldText.length; i++) {\n            if (oldFormat[i] !== deletedSymbol && oldFormat[i] !== \"_\") {\n                deletedSymbol = oldFormat[i];\n                diff.push([deletedSymbol, \"\"]);\n            }\n        }\n        return diff;\n    }\n    // Handle inserting text (the new text is longer than the previous one).\n    // Handle typing over a literal as well.\n    if (newText.indexOf(oldText) === 0 || oldFormat[caret - 1] === \"_\") {\n        let symbol = oldFormat[0];\n        for (let i = Math.max(0, oldText.length - 1); i < oldFormat.length; i++) {\n            if (oldFormat[i] !== \"_\") {\n                symbol = oldFormat[i];\n                break;\n            }\n        }\n        return [[symbol, newText[caret - 1]]];\n    }\n    // Handle entering a space or a separator, for navigation to the next item.\n    if (newText[newText.length - 1] === \" \" || (newText[newText.length - 1] === oldTextSeparator && oldFormat[oldIndex] === '_')) {\n        return [[oldFormat[caret - 1], \"_\"]];\n    }\n    // Handle typing over a correctly selected part.\n    return [[oldFormat[caret - 1], newText[caret - 1]]];\n};\n/**\n * @hidden\n */\nconst domContainerFactory = (type) => (children, classes = \"\", styles = {}) => {\n    const container = document.createElement(type);\n    container.className = classes;\n    Object.keys(styles).map(key => container.style[key] = styles[key]);\n    if (typeof children === 'string') {\n        container.innerHTML = children || '';\n    }\n    else {\n        (children || []).forEach(child => child && container.appendChild(child));\n    }\n    return container;\n};\n/**\n * @hidden\n */\nconst hasChange = (changes, field) => changes[field] !== undefined;\n/**\n * @hidden\n */\nconst hasExistingValue = (changes, field) => changes[field] && changes[field].currentValue !== undefined && changes[field].currentValue !== null;\n/**\n * @hidden\n */\nconst isInSelectionRange = (value, selectionRange) => {\n    const { start, end } = selectionRange || EMPTY_SELECTIONRANGE;\n    if (!start || !end) {\n        return false;\n    }\n    return start < value && value < end;\n};\n/**\n * @hidden\n */\nconst either = (value1, value2) => value1 || value2;\n/**\n * @hidden\n */\nconst clampRange = (value) => ({ start: value, end: value });\n/**\n * @hidden\n */\nconst isEqualRange = (initial, updated) => {\n    const { start: initialStart, end: initialEnd } = initial || EMPTY_SELECTIONRANGE;\n    const { start: updatedStart, end: updatedEnd } = updated || EMPTY_SELECTIONRANGE;\n    return isEqual(initialStart, updatedStart) && isEqual(initialEnd, updatedEnd);\n};\n/**\n * @hidden\n *\n * Creates a new date based on the date information from the specified date portion\n * and the time information from the time portion.\n * If a parameter is not provided, returns `null`.\n */\nconst mergeDateAndTime = (date, time) => {\n    if (!(date && time)) {\n        return null;\n    }\n    return new Date(date.getFullYear(), date.getMonth(), date.getDate(), time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());\n};\n/**\n * @hidden\n */\nconst lastMillisecondOfDate = (date) => {\n    if (!date) {\n        return null;\n    }\n    return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 23, 59, 59, 999);\n};\n/**\n * @hidden\n *\n * Returns an array with dates ranging between and including the specified start and\n * end dates that are evaluated as disabled.\n */\nconst disabledDatesInRange = (start, end, isDateDisabled) => {\n    if (!(start && end && isDateDisabled) || (start > end)) {\n        return [];\n    }\n    const dates = [];\n    let current = start;\n    while (current <= end) {\n        if (isDateDisabled(current)) {\n            dates.push(current);\n        }\n        current = addDays(current, 1);\n    }\n    return dates;\n};\n\n/* tslint:disable:object-literal-sort-keys */\nconst EMPTY_DATA = [[]];\nconst CELLS_LENGTH = 5;\nconst ROWS_LENGTH = 2;\nconst ACTIONS = {\n    [Action.Left]: (date) => addDecades(date, -1),\n    [Action.Up]: (date) => addDecades(date, -5),\n    [Action.Right]: (date) => addDecades(date, 1),\n    [Action.Down]: (date) => addDecades(date, 5),\n    [Action.PrevView]: (date) => addCenturies(date, -1),\n    [Action.NextView]: (date) => addCenturies(date, 1),\n    [Action.FirstInView]: (date) => firstDecadeOfCentury(date),\n    [Action.LastInView]: (date) => lastDecadeOfCentury(date)\n};\n/**\n * @hidden\n */\nclass CenturyViewService {\n    addToDate(min, skip) {\n        return addCenturies(min, skip);\n    }\n    datesList(start, count) {\n        return range(0, count).map(i => addCenturies(start, i));\n    }\n    data(options) {\n        const { cellUID, focusedDate, isActiveView, max, min, selectedDate, selectionRange = EMPTY_SELECTIONRANGE, viewDate } = options;\n        if (!viewDate) {\n            return EMPTY_DATA;\n        }\n        const cells = range(0, CELLS_LENGTH);\n        const firstDate = firstDecadeOfCentury(viewDate);\n        const lastDate = lastDecadeOfCentury(viewDate);\n        const isSelectedDateInRange = isInRange(selectedDate, min, max);\n        const today = getToday();\n        return range(0, ROWS_LENGTH).map(rowOffset => {\n            const baseDate = addDecades(firstDate, rowOffset * CELLS_LENGTH);\n            return cells.map(cellOffset => {\n                const cellDate = this.normalize(addDecades(baseDate, cellOffset), min, max);\n                if (!this.isInRange(cellDate, min, max)) {\n                    return null;\n                }\n                const isRangeStart = this.isEqual(cellDate, selectionRange.start);\n                const isRangeEnd = this.isEqual(cellDate, selectionRange.end);\n                const isInMiddle = !isRangeStart && !isRangeEnd;\n                const isRangeMid = isInMiddle && isInSelectionRange(cellDate, selectionRange);\n                return {\n                    formattedValue: this.value(cellDate),\n                    id: `${cellUID}${cellDate.getTime()}`,\n                    isFocused: this.isEqual(cellDate, focusedDate),\n                    isSelected: isActiveView && isSelectedDateInRange && this.isEqual(cellDate, selectedDate),\n                    isWeekend: false,\n                    isRangeStart: isRangeStart,\n                    isRangeMid: isRangeMid,\n                    isRangeEnd: isRangeEnd,\n                    isRangeSplitEnd: isRangeMid && this.isEqual(cellDate, lastDate),\n                    isRangeSplitStart: isRangeMid && this.isEqual(cellDate, firstDate),\n                    isToday: this.isEqual(cellDate, today),\n                    title: this.cellTitle(cellDate),\n                    value: cellDate\n                };\n            });\n        });\n    }\n    isEqual(candidate, expected) {\n        if (!candidate || !expected) {\n            return false;\n        }\n        return firstYearOfDecade(candidate).getFullYear() === firstYearOfDecade(expected).getFullYear();\n    }\n    isInArray(date, dates) {\n        if (!dates.length) {\n            return false;\n        }\n        const year = date.getFullYear();\n        return dates[0].getFullYear() <= year && year <= (dates[dates.length - 1].getFullYear() + 99);\n    }\n    isInRange(candidate, min, max) {\n        const year = firstYearOfDecade(candidate).getFullYear();\n        const aboveMin = !min || firstYearOfDecade(min).getFullYear() <= year;\n        const belowMax = !max || year <= firstYearOfDecade(max).getFullYear();\n        return aboveMin && belowMax;\n    }\n    beginningOfPeriod(date) {\n        if (!date) {\n            return date;\n        }\n        const firstYear = firstYearOfDecade(firstDecadeOfCentury(date));\n        return createDate(firstYear.getFullYear(), 0, 1);\n    }\n    isRangeStart(value) {\n        return value.getFullYear() % 1000 === 0;\n    }\n    move(value, action) {\n        const modifier = ACTIONS[action];\n        if (!modifier) {\n            return value;\n        }\n        return modifier(value);\n    }\n    cellTitle(value) {\n        return firstYearOfDecade(value).getFullYear().toString();\n    }\n    navigationTitle(value) {\n        return value ? firstDecadeOfCentury(value).getFullYear().toString() : '';\n    }\n    title(value) {\n        if (!value) {\n            return '';\n        }\n        return `${firstDecadeOfCentury(value).getFullYear()} - ${lastDecadeOfCentury(value).getFullYear()}`;\n    }\n    rowLength(_) {\n        return CELLS_LENGTH;\n    }\n    skip(value, min) {\n        return durationInCenturies(min, value);\n    }\n    total(min, max) {\n        return durationInCenturies(min, max) + 1;\n    }\n    value(current) {\n        return current ? firstYearOfDecade(current).getFullYear().toString() : '';\n    }\n    viewDate(date, max, viewsCount = 1) {\n        const viewsInRange = this.total(date, max);\n        if (viewsInRange < viewsCount) {\n            const centuriesToSubtract = viewsCount - viewsInRange;\n            return addCenturies(date, -1 * centuriesToSubtract);\n        }\n        return date;\n    }\n    normalize(cellDate, min, max) {\n        if (cellDate < min && this.isEqual(cellDate, min)) {\n            return cloneDate(min);\n        }\n        if (cellDate > max && this.isEqual(cellDate, max)) {\n            return cloneDate(max);\n        }\n        return cellDate;\n    }\n}\nCenturyViewService.decorators = [\n    { type: Injectable },\n];\n\n/* tslint:disable:object-literal-sort-keys */\nconst EMPTY_DATA$1 = [[]];\nconst CELLS_LENGTH$1 = 5;\nconst ROWS_LENGTH$1 = 2;\nconst ACTIONS$1 = {\n    [Action.Left]: (date) => addYears(date, -1),\n    [Action.Up]: (date) => addYears(date, -5),\n    [Action.Right]: (date) => addYears(date, 1),\n    [Action.Down]: (date) => addYears(date, 5),\n    [Action.PrevView]: (date) => addDecades(date, -1),\n    [Action.NextView]: (date) => addDecades(date, 1),\n    [Action.FirstInView]: (date) => firstYearOfDecade(date),\n    [Action.LastInView]: (date) => lastYearOfDecade(date)\n};\n/**\n * @hidden\n */\nclass DecadeViewService {\n    addToDate(min, skip) {\n        return addDecades(min, skip);\n    }\n    datesList(start, count) {\n        return range(0, count).map(i => addDecades(start, i));\n    }\n    data(options) {\n        const { cellUID, focusedDate, isActiveView, max, min, selectedDate, selectionRange = EMPTY_SELECTIONRANGE, viewDate } = options;\n        if (!viewDate) {\n            return EMPTY_DATA$1;\n        }\n        const cells = range(0, CELLS_LENGTH$1);\n        const firstDate = firstYearOfDecade(viewDate);\n        const lastDate = lastYearOfDecade(viewDate);\n        const isSelectedDateInRange = isInRange(selectedDate, min, max);\n        const today = getToday();\n        return range(0, ROWS_LENGTH$1).map(rowOffset => {\n            const baseDate = addYears(firstDate, rowOffset * CELLS_LENGTH$1);\n            return cells.map(cellOffset => {\n                const cellDate = this.normalize(addYears(baseDate, cellOffset), min, max);\n                if (!this.isInRange(cellDate, min, max)) {\n                    return null;\n                }\n                const isRangeStart = this.isEqual(cellDate, selectionRange.start);\n                const isRangeEnd = this.isEqual(cellDate, selectionRange.end);\n                const isInMiddle = !isRangeStart && !isRangeEnd;\n                const isRangeMid = isInMiddle && isInSelectionRange(cellDate, selectionRange);\n                return {\n                    formattedValue: this.value(cellDate),\n                    id: `${cellUID}${cellDate.getTime()}`,\n                    isFocused: this.isEqual(cellDate, focusedDate),\n                    isSelected: isActiveView && isSelectedDateInRange && this.isEqual(cellDate, selectedDate),\n                    isWeekend: false,\n                    isRangeStart: isRangeStart,\n                    isRangeMid: isRangeMid,\n                    isRangeEnd: isRangeEnd,\n                    isRangeSplitEnd: isRangeMid && this.isEqual(cellDate, lastDate),\n                    isRangeSplitStart: isRangeMid && this.isEqual(cellDate, firstDate),\n                    isToday: this.isEqual(cellDate, today),\n                    title: this.cellTitle(cellDate),\n                    value: cellDate\n                };\n            });\n        });\n    }\n    isEqual(candidate, expected) {\n        if (!candidate || !expected) {\n            return false;\n        }\n        return candidate.getFullYear() === expected.getFullYear();\n    }\n    isInArray(date, dates) {\n        if (!dates.length) {\n            return false;\n        }\n        const year = date.getFullYear();\n        return dates[0].getFullYear() <= year && year <= (dates[dates.length - 1].getFullYear() + 9);\n    }\n    isInRange(candidate, min, max) {\n        const year = candidate.getFullYear();\n        const aboveMin = !min || min.getFullYear() <= year;\n        const belowMax = !max || year <= max.getFullYear();\n        return aboveMin && belowMax;\n    }\n    beginningOfPeriod(date) {\n        if (!date) {\n            return date;\n        }\n        const firstYear = firstYearOfDecade(date);\n        return createDate(firstYear.getFullYear(), 0, 1);\n    }\n    isRangeStart(value) {\n        return value.getFullYear() % 100 === 0;\n    }\n    move(value, action) {\n        const modifier = ACTIONS$1[action];\n        if (!modifier) {\n            return value;\n        }\n        return modifier(value);\n    }\n    cellTitle(value) {\n        return value.getFullYear().toString();\n    }\n    navigationTitle(value) {\n        return value ? firstYearOfDecade(value).getFullYear().toString() : '';\n    }\n    title(value) {\n        if (!value) {\n            return '';\n        }\n        return `${firstYearOfDecade(value).getFullYear()} - ${lastYearOfDecade(value).getFullYear()}`;\n    }\n    rowLength(_) {\n        return CELLS_LENGTH$1;\n    }\n    skip(value, min) {\n        return durationInDecades(min, value);\n    }\n    total(min, max) {\n        return durationInDecades(min, max) + 1;\n    }\n    value(current) {\n        return current ? current.getFullYear().toString() : '';\n    }\n    viewDate(date, max, viewsCount = 1) {\n        const viewsInRange = this.total(date, max);\n        if (viewsInRange < viewsCount) {\n            const decadesToSubtract = viewsCount - viewsInRange;\n            return addDecades(date, -1 * decadesToSubtract);\n        }\n        return date;\n    }\n    normalize(cellDate, min, max) {\n        if (cellDate < min && this.isEqual(cellDate, min)) {\n            return cloneDate(min);\n        }\n        if (cellDate > max && this.isEqual(cellDate, max)) {\n            return cloneDate(max);\n        }\n        return cellDate;\n    }\n}\nDecadeViewService.decorators = [\n    { type: Injectable },\n];\n\n/* tslint:disable:object-literal-sort-keys */\nconst EMPTY_DATA$2 = [[]];\nconst CELLS_LENGTH$2 = 7;\nconst ROWS_LENGTH$2 = 6;\nconst ACTIONS$2 = {\n    [Action.Left]: (date) => addDays(date, -1),\n    [Action.Up]: (date) => addWeeks(date, -1),\n    [Action.Right]: (date) => addDays(date, 1),\n    [Action.Down]: (date) => addWeeks(date, 1),\n    [Action.PrevView]: (date) => addMonths(date, -1),\n    [Action.NextView]: (date) => addMonths(date, 1),\n    [Action.FirstInView]: (date) => firstDayOfMonth(date),\n    [Action.LastInView]: (date) => lastDayOfMonth(date)\n};\n/**\n * @hidden\n */\nclass MonthViewService {\n    constructor(_intlService) {\n        this._intlService = _intlService;\n    }\n    addToDate(min, skip) {\n        return addMonths(min, skip);\n    }\n    datesList(start, count) {\n        return range(0, count).map(i => addMonths(start, i));\n    }\n    data(options) {\n        const { cellUID, focusedDate, isActiveView, max, min, selectedDate, selectionRange = EMPTY_SELECTIONRANGE, viewDate, isDateDisabled = () => false } = options;\n        if (!viewDate) {\n            return EMPTY_DATA$2;\n        }\n        const firstMonthDate = firstDayOfMonth(viewDate);\n        const firstMonthDay = getDate(firstMonthDate);\n        const lastMonthDate = lastDayOfMonth(viewDate);\n        const lastMonthDay = getDate(lastMonthDate);\n        const backward = -1;\n        const isSelectedDateInRange = isInRange(selectedDate, min, max);\n        const date = dayOfWeek(firstMonthDate, this._intlService.firstDay(), backward);\n        const cells = range(0, CELLS_LENGTH$2);\n        const today = getToday();\n        return range(0, ROWS_LENGTH$2).map(rowOffset => {\n            const baseDate = addDays(date, rowOffset * CELLS_LENGTH$2);\n            return cells.map(cellOffset => {\n                const cellDate = this.normalize(addDays(baseDate, cellOffset), min, max);\n                const cellDay = getDate(cellDate);\n                const otherMonth = cellDay < firstMonthDay || cellDay > lastMonthDay;\n                const outOfRange = cellDate < min || cellDate > max;\n                if (otherMonth || outOfRange) {\n                    return null;\n                }\n                const isRangeStart = this.isEqual(cellDate, selectionRange.start);\n                const isRangeEnd = this.isEqual(cellDate, selectionRange.end);\n                const isInMiddle = !isRangeStart && !isRangeEnd;\n                const isRangeMid = isInMiddle && isInSelectionRange(cellDate, selectionRange);\n                return {\n                    formattedValue: this.value(cellDate),\n                    id: `${cellUID}${cellDate.getTime()}`,\n                    isFocused: this.isEqual(cellDate, focusedDate),\n                    isSelected: isActiveView && isSelectedDateInRange && this.isEqual(cellDate, selectedDate),\n                    isWeekend: this.isWeekend(cellDate),\n                    isRangeStart: isRangeStart,\n                    isRangeMid: isRangeMid,\n                    isRangeEnd: isRangeEnd,\n                    isRangeSplitStart: isRangeMid && this.isEqual(cellDate, firstMonthDate),\n                    isRangeSplitEnd: isRangeMid && this.isEqual(cellDate, lastMonthDate),\n                    isToday: this.isEqual(cellDate, today),\n                    title: this.cellTitle(cellDate),\n                    value: cellDate,\n                    isDisabled: isDateDisabled(cellDate)\n                };\n            });\n        });\n    }\n    isEqual(candidate, expected) {\n        if (!candidate || !expected) {\n            return false;\n        }\n        return getDate(candidate).getTime() === getDate(expected).getTime();\n    }\n    isInArray(date, dates) {\n        if (dates.length === 0) {\n            return false;\n        }\n        const lowerBound = this.beginningOfPeriod(dates[0]);\n        const upperBound = this.beginningOfPeriod(addMonths(dates[dates.length - 1], 1));\n        return lowerBound <= date && date < upperBound;\n    }\n    isInRange(candidate, min, max) {\n        const value = getDate(candidate);\n        const aboveMin = !min || getDate(min) <= value;\n        const belowMax = !max || value <= getDate(max);\n        return aboveMin && belowMax;\n    }\n    beginningOfPeriod(date) {\n        if (!date) {\n            return date;\n        }\n        return createDate(date.getFullYear(), date.getMonth(), 1);\n    }\n    isRangeStart(value) {\n        return !value.getMonth();\n    }\n    move(value, action) {\n        const modifier = ACTIONS$2[action];\n        if (!modifier) {\n            return value;\n        }\n        return modifier(value);\n    }\n    cellTitle(value) {\n        return this._intlService.formatDate(value, 'D');\n    }\n    navigationTitle(value) {\n        if (!value) {\n            return '';\n        }\n        return this.isRangeStart(value) ? value.getFullYear().toString() : this.abbrMonthNames()[value.getMonth()];\n    }\n    title(current) {\n        return `${this.wideMonthNames()[current.getMonth()]} ${current.getFullYear()}`;\n    }\n    rowLength(prependCell) {\n        return CELLS_LENGTH$2 + (prependCell ? 1 : 0);\n    }\n    skip(value, min) {\n        return durationInMonths(min, value);\n    }\n    total(min, max) {\n        return durationInMonths(min, max) + 1;\n    }\n    value(current) {\n        return current ? current.getDate().toString() : \"\";\n    }\n    viewDate(date, max, viewsCount = 1) {\n        const viewsInRange = this.total(date, max);\n        if (viewsInRange < viewsCount) {\n            const monthsToSubtract = viewsCount - viewsInRange;\n            return addMonths(date, -1 * monthsToSubtract);\n        }\n        return date;\n    }\n    isWeekend(date) {\n        const { start, end } = this._intlService.weekendRange();\n        const day = date.getDay();\n        if (end < start) {\n            return day <= end || start <= day;\n        }\n        return start <= day && day <= end;\n    }\n    abbrMonthNames() {\n        return this._intlService.dateFormatNames({ nameType: 'abbreviated', type: 'months' });\n    }\n    normalize(cellDate, min, max) {\n        if (cellDate < min && this.isEqual(cellDate, min)) {\n            return cloneDate(min);\n        }\n        if (cellDate > max && this.isEqual(cellDate, max)) {\n            return cloneDate(max);\n        }\n        return cellDate;\n    }\n    wideMonthNames() {\n        return this._intlService.dateFormatNames({ nameType: 'wide', type: 'months' });\n    }\n}\nMonthViewService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nMonthViewService.ctorParameters = () => [\n    { type: IntlService }\n];\n\n/* tslint:disable:object-literal-sort-keys */\nconst EMPTY_DATA$3 = [[]];\nconst CELLS_LENGTH$3 = 5;\nconst ROWS_LENGTH$3 = 3;\nconst upStep = (month) => {\n    if (month > 4) {\n        return -5;\n    }\n    if (month < 2) {\n        return -2;\n    }\n    return -7;\n};\nconst downStep = (month) => {\n    if (month < 7) {\n        return 5;\n    }\n    if (month < 10) {\n        return 7;\n    }\n    return 2;\n};\nconst ACTIONS$3 = {\n    [Action.Left]: (date) => addMonths(date, -1),\n    [Action.Up]: (date) => addMonths(date, upStep(date.getMonth())),\n    [Action.Right]: (date) => addMonths(date, 1),\n    [Action.Down]: (date) => addMonths(date, downStep(date.getMonth())),\n    [Action.PrevView]: (date) => addYears(date, -1),\n    [Action.NextView]: (date) => addYears(date, 1),\n    [Action.FirstInView]: (date) => firstMonthOfYear(date),\n    [Action.LastInView]: (date) => lastMonthOfYear(date)\n};\n/**\n * @hidden\n */\nclass YearViewService {\n    constructor(_intlService) {\n        this._intlService = _intlService;\n    }\n    addToDate(min, skip) {\n        return addYears(min, skip);\n    }\n    datesList(start, count) {\n        return range(0, count).map(i => addYears(start, i));\n    }\n    data(options) {\n        const { cellUID, focusedDate, isActiveView, max, min, selectedDate, selectionRange = EMPTY_SELECTIONRANGE, viewDate } = options;\n        if (!viewDate) {\n            return EMPTY_DATA$3;\n        }\n        const months = this.abbrMonthNames();\n        const isSelectedDateInRange = isInRange(selectedDate, min, max);\n        const firstDate = firstMonthOfYear(viewDate);\n        const lastDate = lastMonthOfYear(viewDate);\n        const currentYear = firstDate.getFullYear();\n        const cells = range(0, CELLS_LENGTH$3);\n        const today = getToday();\n        return range(0, ROWS_LENGTH$3).map(rowOffset => {\n            const baseDate = addMonths(firstDate, rowOffset * CELLS_LENGTH$3);\n            return cells.map(cellOffset => {\n                const cellDate = this.normalize(addMonths(baseDate, cellOffset), min, max);\n                const changedYear = currentYear < cellDate.getFullYear();\n                if (!this.isInRange(cellDate, min, max) || changedYear) {\n                    return null;\n                }\n                const isRangeStart = this.isEqual(cellDate, selectionRange.start);\n                const isRangeEnd = this.isEqual(cellDate, selectionRange.end);\n                const isInMiddle = !isRangeStart && !isRangeEnd;\n                const isRangeMid = isInMiddle && isInSelectionRange(cellDate, selectionRange);\n                return {\n                    formattedValue: months[cellDate.getMonth()],\n                    id: `${cellUID}${cellDate.getTime()}`,\n                    isFocused: this.isEqual(cellDate, focusedDate),\n                    isSelected: isActiveView && isSelectedDateInRange && this.isEqual(cellDate, selectedDate),\n                    isWeekend: false,\n                    isRangeStart: isRangeStart,\n                    isRangeMid: isRangeMid,\n                    isRangeEnd: isRangeEnd,\n                    isRangeSplitEnd: isRangeMid && this.isEqual(cellDate, lastDate),\n                    isRangeSplitStart: isRangeMid && this.isEqual(cellDate, firstDate),\n                    isToday: this.isEqual(cellDate, today),\n                    title: this.cellTitle(cellDate),\n                    value: cellDate\n                };\n            });\n        });\n    }\n    isEqual(candidate, expected) {\n        if (!candidate || !expected) {\n            return false;\n        }\n        return candidate.getFullYear() === expected.getFullYear() &&\n            candidate.getMonth() === expected.getMonth();\n    }\n    isInArray(date, dates) {\n        if (!dates.length) {\n            return false;\n        }\n        const year = date.getFullYear();\n        return dates[0].getFullYear() <= year && year <= dates[dates.length - 1].getFullYear();\n    }\n    isInRange(candidate, min, max) {\n        const candidateValue = createDate(candidate.getFullYear(), candidate.getMonth(), 1);\n        const aboveMin = !min || createDate(min.getFullYear(), min.getMonth(), 1) <= candidateValue;\n        const belowMax = !max || candidateValue <= createDate(max.getFullYear(), max.getMonth(), 1);\n        return aboveMin && belowMax;\n    }\n    beginningOfPeriod(date) {\n        if (!date) {\n            return date;\n        }\n        return createDate(date.getFullYear(), 0, 1);\n    }\n    isRangeStart(value) {\n        return value.getFullYear() % 10 === 0;\n    }\n    move(value, action) {\n        const modifier = ACTIONS$3[action];\n        if (!modifier) {\n            return value;\n        }\n        return modifier(value);\n    }\n    cellTitle(value) {\n        return `${value.getFullYear()} ${this.value(value)}`;\n    }\n    navigationTitle(value) {\n        return this.title(value);\n    }\n    title(current) {\n        return current ? current.getFullYear().toString() : '';\n    }\n    rowLength(_) {\n        return CELLS_LENGTH$3;\n    }\n    skip(value, min) {\n        return durationInYears(min, value);\n    }\n    total(min, max) {\n        return durationInYears(min, max) + 1;\n    }\n    value(current) {\n        return current ? this.abbrMonthNames()[current.getMonth()] : '';\n    }\n    viewDate(date, max, viewsCount = 1) {\n        const viewsInRange = this.total(date, max);\n        if (viewsInRange < viewsCount) {\n            const yearsToSubtract = viewsCount - viewsInRange;\n            return addYears(date, -1 * yearsToSubtract);\n        }\n        return date;\n    }\n    abbrMonthNames() {\n        return this._intlService.dateFormatNames({ nameType: 'abbreviated', type: 'months' });\n    }\n    normalize(cellDate, min, max) {\n        if (cellDate < min && this.isEqual(cellDate, min)) {\n            return cloneDate(min);\n        }\n        if (cellDate > max && this.isEqual(cellDate, max)) {\n            return cloneDate(max);\n        }\n        return cellDate;\n    }\n}\nYearViewService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nYearViewService.ctorParameters = () => [\n    { type: IntlService }\n];\n\n/**\n * @hidden\n *\n * The Enum which defines all possible Calendar view types.\n */\nvar CalendarViewEnum;\n(function (CalendarViewEnum) {\n    CalendarViewEnum[CalendarViewEnum[\"month\"] = 0] = \"month\";\n    CalendarViewEnum[CalendarViewEnum[\"year\"] = 1] = \"year\";\n    CalendarViewEnum[CalendarViewEnum[\"decade\"] = 2] = \"decade\";\n    CalendarViewEnum[CalendarViewEnum[\"century\"] = 3] = \"century\";\n})(CalendarViewEnum || (CalendarViewEnum = {}));\n\nconst services = {\n    [CalendarViewEnum.month]: MonthViewService,\n    [CalendarViewEnum.year]: YearViewService,\n    [CalendarViewEnum.decade]: DecadeViewService,\n    [CalendarViewEnum.century]: CenturyViewService\n};\nconst viewOffset = (view, offset) => {\n    const candidate = CalendarViewEnum[CalendarViewEnum[view + offset]];\n    return candidate !== undefined ? candidate : view;\n};\n/**\n * @hidden\n */\nclass BusViewService {\n    constructor(injector) {\n        this.injector = injector;\n        this.viewChanged = new EventEmitter();\n        this.bottom = CalendarViewEnum.month;\n        this.top = CalendarViewEnum.century;\n    }\n    configure(bottom, top) {\n        this.bottom = bottom;\n        this.top = top;\n    }\n    service(view) {\n        const serviceType = services[view];\n        return serviceType ? this.injector.get(serviceType) : null;\n    }\n    moveDown(view) {\n        this.move(view, -1);\n    }\n    moveUp(view) {\n        this.move(view, 1);\n    }\n    moveToBottom(activeView) {\n        if (activeView === this.bottom) {\n            return;\n        }\n        this.viewChanged.emit({ view: this.bottom });\n    }\n    canMoveDown(view) {\n        return this.bottom < view;\n    }\n    canMoveUp(view) {\n        return view < this.top;\n    }\n    clamp(view) {\n        if (view < this.bottom) {\n            return this.bottom;\n        }\n        if (view > this.top) {\n            return this.top;\n        }\n        return view;\n    }\n    move(view, offset) {\n        const candidate = this.clamp(viewOffset(view, offset));\n        if (candidate === view) {\n            return;\n        }\n        this.viewChanged.emit({ view: candidate });\n    }\n}\nBusViewService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nBusViewService.ctorParameters = () => [\n    { type: Injector }\n];\n\nconst div = domContainerFactory('div');\nconst ul = domContainerFactory('ul');\nconst li = domContainerFactory('li');\nconst td = domContainerFactory('td');\nconst th = domContainerFactory('th');\nconst tr = domContainerFactory('tr');\nconst tbody = domContainerFactory('tbody');\nconst thead = domContainerFactory('thead');\nconst table = domContainerFactory('table');\nconst monthHeader = () => (div(`\n            <span class=\"k-calendar-title\">March 2017</span>\n            <span class=\"k-calendar-today\">TODAY</span>\n        `, 'k-calendar-header'));\nconst monthWeekHeader = () => (table([\n    thead([\n        tr([th('MO')])\n    ])\n], 'k-calendar-weekdays'));\nconst repeat = (count, mapper) => new Array(count).fill('1').map(mapper);\nconst content = (rows, cells = 1) => (table([\n    tbody([tr([th('1')])].concat(repeat(rows, () => tr(repeat(cells, c => td(`<span class=\"k-link\">${c}</span>`))))))\n]));\nconst scrollable = (children) => div(children, 'k-content k-scrollable');\nconst view = (contentElement, className, renderWeekHeader) => (div([\n    monthHeader(),\n    renderWeekHeader ? monthWeekHeader() : null,\n    scrollable([contentElement, contentElement])\n], className, { left: '-10000px', position: 'absolute' }));\nconst ɵ6 = () => {\n    let navElement;\n    return () => {\n        if (!isDocumentAvailable) {\n            return null;\n        }\n        if (!navElement) {\n            navElement = div([scrollable([ul([li('<span>FEB</span>')])])], 'k-calendar-navigation', { left: '0px', position: 'absolute' });\n        }\n        return navElement;\n    };\n};\nconst navigationList = (ɵ6)();\nconst viewFactory = ({ cells, rows }, className, renderWeekHeader) => {\n    let viewElement;\n    return () => {\n        if (!isDocumentAvailable) {\n            return null;\n        }\n        if (!viewElement) {\n            viewElement = view(content(rows, cells), className, renderWeekHeader);\n        }\n        return viewElement;\n    };\n};\nconst getScrollable = (element) => element.querySelector('.k-scrollable');\nconst horizontal = element => {\n    const scrollableElement = getScrollable(element);\n    scrollableElement.classList.add('k-scrollable-horizontal');\n    return element;\n};\nconst monthView = viewFactory({ cells: 7, rows: 6 }, 'k-calendar-view k-calendar-monthview', true);\nconst yearView = viewFactory({ cells: 5, rows: 3 }, 'k-calendar-view k-calendar-yearview', false);\nconst decadeView = viewFactory({ cells: 5, rows: 2 }, 'k-calendar-view k-calendar-decadeview', false);\nconst horzMonthView = () => horizontal(monthView());\nconst horzYearView = () => horizontal(yearView());\nconst horzDecadeView = () => horizontal(decadeView());\nconst height = (element) => (parseFloat(window.getComputedStyle(element).height) || element.offsetHeight);\nconst width = (element) => {\n    const styles = window.getComputedStyle(element);\n    const computed = parseFloat(styles.width)\n        + parseFloat(styles.paddingLeft)\n        + parseFloat(styles.paddingRight);\n    return computed || element.offsetWidth;\n};\nconst getBody = (element) => element.querySelector('tbody');\n/**\n * @hidden\n */\nclass CalendarDOMService {\n    ensureHeights() {\n        if (this.calendarHeight !== undefined) {\n            return;\n        }\n        this.calculateHeights();\n    }\n    calculateHeights(container) {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        this.hostContainer = container;\n        this.batch(monthView(), (contentElement) => {\n            const viewElement = getBody(contentElement);\n            this.calendarHeight = height(contentElement);\n            this.monthViewHeight = height(viewElement);\n            this.headerHeight = height(viewElement.children[0]);\n            this.scrollableContentHeight = height(getScrollable(contentElement));\n        });\n        this.batch(horzMonthView(), (contentElement) => {\n            const viewElement = getBody(contentElement);\n            this.calendarWidth = width(contentElement);\n            this.monthViewWidth = width(viewElement);\n            this.scrollableContentWidth = width(getScrollable(contentElement));\n        });\n        this.batch(yearView(), (contentElement) => {\n            this.yearViewHeight = height(getBody(contentElement));\n            this.scrollableYearContentHeight = height(getScrollable(contentElement));\n        });\n        this.batch(horzYearView(), (contentElement) => {\n            this.yearViewWidth = width(getBody(contentElement));\n        });\n        this.batch(decadeView(), (contentElement) => {\n            this.decadeViewHeight = height(getBody(contentElement));\n            this.centuryViewHeight = this.decadeViewHeight;\n        });\n        this.batch(horzDecadeView(), (contentElement) => {\n            this.decadeViewWidth = width(getBody(contentElement));\n            this.centuryViewWidth = this.decadeViewWidth;\n        });\n        this.batch(navigationList(), (contentElement) => {\n            this.navigationItemHeight = height(contentElement.querySelector('li'));\n        });\n    }\n    viewHeight(viewType) {\n        return this.viewDimension(viewType, 'height');\n    }\n    viewWidth(viewType) {\n        return this.viewDimension(viewType, 'width');\n    }\n    viewDimension(viewType, dimension) {\n        const viewProp = dimension === 'height' ? 'ViewHeight' : 'ViewWidth';\n        switch (viewType) {\n            case CalendarViewEnum.month:\n                return this[`month${viewProp}`];\n            case CalendarViewEnum.year:\n                return this[`year${viewProp}`];\n            case CalendarViewEnum.decade:\n                return this[`decade${viewProp}`];\n            case CalendarViewEnum.century:\n                return this[`century${viewProp}`];\n            default:\n                return 1;\n        }\n    }\n    batch(contentElement, action) {\n        const hostContainer = this.hostContainer || document.body;\n        const appendedContent = hostContainer.appendChild(contentElement);\n        action(appendedContent);\n        hostContainer.removeChild(appendedContent);\n    }\n}\nCalendarDOMService.decorators = [\n    { type: Injectable },\n];\n\n/**\n * @hidden\n */\nconst update = (arr, idx, value) => ([\n    ...arr.slice(0, idx + 1),\n    ...(arr.slice(idx + 1).map(x => x + value))\n]);\n/**\n * @hidden\n */\nclass RowHeightService {\n    constructor(total = 0, rowHeight, detailRowHeight) {\n        this.total = total;\n        this.rowHeight = rowHeight;\n        this.detailRowHeight = detailRowHeight;\n        this.offsets = [];\n        this.heights = [];\n        let agg = 0;\n        for (let idx = 0; idx < total; idx++) {\n            this.offsets.push(agg);\n            agg += rowHeight;\n            this.heights.push(rowHeight);\n        }\n    }\n    height(rowIndex) {\n        return this.heights[rowIndex];\n    }\n    expandDetail(rowIndex) {\n        if (this.height(rowIndex) === this.rowHeight) {\n            this.updateRowHeight(rowIndex, this.detailRowHeight);\n        }\n    }\n    collapseDetail(rowIndex) {\n        if (this.height(rowIndex) > this.rowHeight) {\n            this.updateRowHeight(rowIndex, this.detailRowHeight * -1);\n        }\n    }\n    index(position) {\n        if (position < 0) {\n            return undefined;\n        }\n        const result = this.offsets.reduce((prev, current, idx) => {\n            if (prev !== undefined) {\n                return prev;\n            }\n            else if (current === position) {\n                return idx;\n            }\n            else if (current > position) {\n                return idx - 1;\n            }\n            return undefined;\n        }, undefined); // tslint:disable-line:align\n        return result === undefined ? this.total - 1 : result;\n    }\n    offset(rowIndex) {\n        return this.offsets[rowIndex];\n    }\n    totalHeight() {\n        return this.heights.reduce((prev, curr) => prev + curr, 0);\n    }\n    updateRowHeight(rowIndex, value) {\n        this.heights[rowIndex] += value;\n        this.offsets = update(this.offsets, rowIndex, value);\n    }\n}\n\nconst normalize = x => Math.max(x, 0);\n/**\n * @hidden\n */\nclass ScrollAction {\n    constructor(offset) {\n        this.offset = offset;\n    }\n}\n/**\n * @hidden\n */\nclass PageAction {\n    constructor(skip) {\n        this.skip = skip;\n    }\n}\n/**\n * @hidden\n */\nclass ScrollerService {\n    constructor(scrollObservable) {\n        this.scrollObservable = scrollObservable;\n        this.firstLoaded = 0;\n        this.bottomOffset = 0;\n        this.topOffset = 0;\n    }\n    create(rowHeightService, skip, take, total, topOffset = 0, bottomOffset = 0, direction = 'vertical') {\n        this.rowHeightService = rowHeightService;\n        this.firstLoaded = skip;\n        this.lastLoaded = skip + take;\n        this.take = take;\n        this.total = total;\n        this.lastScroll = 0;\n        this.topOffset = topOffset;\n        this.bottomOffset = bottomOffset;\n        this.direction = direction;\n        const subject = new ReplaySubject(2);\n        const offsetBufferRows = this.rowsForHeight(topOffset);\n        const skipWithOffset = normalize(skip - offsetBufferRows);\n        subject.next(new ScrollAction(this.rowOffset(skipWithOffset)));\n        if (offsetBufferRows) {\n            subject.next(new PageAction(skipWithOffset));\n        }\n        this.subscription = Observable.create(observer => {\n            this.unsubscribe();\n            this.scrollSubscription = this.scrollObservable.subscribe(x => this.onScroll(x, observer));\n        }).subscribe(x => subject.next(x));\n        return subject;\n    }\n    destroy() {\n        this.unsubscribe();\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n        }\n    }\n    onScroll({ scrollLeft, scrollTop, offsetHeight, offsetWidth }, observer) {\n        const scrollPosition = this.direction === 'vertical' ? scrollTop : scrollLeft;\n        const offsetSize = this.direction === 'vertical' ? offsetHeight : offsetWidth;\n        if (this.lastScroll === scrollPosition) {\n            return;\n        }\n        const up = this.lastScroll >= scrollPosition;\n        this.lastScroll = scrollPosition;\n        const firstItemIndex = this.rowHeightService.index(normalize(scrollPosition - this.topOffset));\n        const lastItemIndex = this.rowHeightService.index(normalize(scrollPosition + offsetSize - this.bottomOffset));\n        if (!up && lastItemIndex >= this.lastLoaded && this.lastLoaded < this.total) {\n            this.firstLoaded = firstItemIndex;\n            observer.next(new ScrollAction(this.rowOffset(firstItemIndex)));\n            this.lastLoaded = Math.min(this.firstLoaded + this.take, this.total);\n            observer.next(new PageAction(this.firstLoaded));\n        }\n        if (up && firstItemIndex <= this.firstLoaded) {\n            const nonVisibleBuffer = Math.floor(this.take * 0.3);\n            this.firstLoaded = normalize(firstItemIndex - nonVisibleBuffer);\n            observer.next(new ScrollAction(this.rowOffset(this.firstLoaded)));\n            this.lastLoaded = Math.min(this.firstLoaded + this.take, this.total);\n            observer.next(new PageAction(this.firstLoaded));\n        }\n    }\n    rowOffset(index) {\n        return this.rowHeightService.offset(index) + this.topOffset;\n    }\n    rowsForHeight(height) {\n        return Math.ceil(height / this.rowHeightService.height(0));\n    }\n    unsubscribe() {\n        if (this.scrollSubscription) {\n            this.scrollSubscription.unsubscribe();\n            this.scrollSubscription = null;\n        }\n    }\n}\n\n/* tslint:disable:component-selector-name  component-selector-type */\n/**\n * @hidden\n */\nconst SCROLLER_FACTORY_TOKEN = new InjectionToken('dateinputs-scroll-service-factory');\n/**\n * @hidden\n */\nfunction DEFAULT_SCROLLER_FACTORY(observable) {\n    return new ScrollerService(observable);\n}\n/**\n * @hidden\n */\nvar ScrollDirection;\n(function (ScrollDirection) {\n    ScrollDirection[ScrollDirection[\"Backward\"] = 0] = \"Backward\";\n    ScrollDirection[ScrollDirection[\"Forward\"] = 1] = \"Forward\";\n})(ScrollDirection || (ScrollDirection = {}));\nconst FRAME_DURATION = 17;\nconst scrollModifiers = {\n    [ScrollDirection.Forward]: (step) => value => value + step,\n    [ScrollDirection.Backward]: (step) => value => value - step\n};\nconst scrollNormalizers = {\n    [ScrollDirection.Forward]: (end) => value => Math.min(value, end),\n    [ScrollDirection.Backward]: (end) => value => Math.max(value, end)\n};\nconst scrollValidators = {\n    [ScrollDirection.Forward]: end => start => start < end,\n    [ScrollDirection.Backward]: end => start => start > end\n};\nconst differenceToScroll = (scrollTop, staticOffset, maxScrollDifference) => {\n    return Math.min(Math.abs(staticOffset - scrollTop), maxScrollDifference);\n};\n/**\n * @hidden\n */\nclass VirtualizationComponent {\n    constructor(scrollerFactory, container, renderer, zone) {\n        this.container = container;\n        this.renderer = renderer;\n        this.zone = zone;\n        this.direction = 'vertical';\n        this.itemHeight = 1;\n        this.itemWidth = 1;\n        this.topOffset = 0;\n        this.bottomOffset = 0;\n        this.maxScrollDifference = 100;\n        this.scrollOffsetSize = 0;\n        this.scrollDuration = 150;\n        this.activeIndexChange = new EventEmitter();\n        this.pageChange = new EventEmitter();\n        this.scrollChange = new EventEmitter();\n        this.resolvedPromise = Promise.resolve(null);\n        this.dispatcher = new Subject();\n        this.scroller = scrollerFactory(this.dispatcher);\n    }\n    get totalVertexLength() {\n        const value = `${this.totalSize}px`;\n        return this.direction === 'vertical' ? { height: value } : { width: value };\n    }\n    get containerOffsetSize() {\n        return this.getContainerProperty(this.direction === 'vertical' ? 'offsetHeight' : 'offsetWidth');\n    }\n    get containerScrollSize() {\n        return this.getContainerProperty(this.direction === 'vertical' ? 'scrollHeight' : 'scrollWidth');\n    }\n    get containerScrollPosition() {\n        return this.getContainerProperty(this.direction === 'vertical' ? 'scrollTop' : 'scrollLeft');\n    }\n    get wrapperClasses() {\n        return true;\n    }\n    get horizontalClass() {\n        return this.direction === 'horizontal';\n    }\n    ngOnChanges(changes) {\n        if (changes.direction || changes.take || changes.total) {\n            this.initServices();\n            this.totalSize = this.rowHeightService.totalHeight() + this.bottomOffset;\n        }\n    }\n    ngOnInit() {\n        if (!this.rowHeightService) {\n            this.rowHeightService = this.createRowHeightService();\n        }\n    }\n    ngAfterViewInit() {\n        this.zone.runOutsideAngular(() => {\n            this.containerScrollSubscription = this.scroll$()\n                .pipe(map((event) => event.target))\n                .subscribe(t => {\n                this.dispatcher.next(t);\n                this.emitActiveIndex();\n            });\n        });\n    }\n    ngOnDestroy() {\n        if (this.containerScrollSubscription) {\n            this.containerScrollSubscription.unsubscribe();\n        }\n        if (this.scrollSubscription) {\n            this.scrollSubscription.unsubscribe();\n        }\n        if (this.animationSubscription) {\n            this.animationSubscription.unsubscribe();\n        }\n    }\n    getContainerProperty(propertyName) {\n        return this.container.nativeElement[propertyName];\n    }\n    activeIndex() {\n        return this.itemIndex(Math.ceil(this.containerScrollPosition)); //handle subpixeling\n    }\n    itemIndex(offset) {\n        return this.rowHeightService.index(offset);\n    }\n    itemOffset(index) {\n        return this.rowHeightService.offset(index);\n    }\n    isIndexVisible(index) {\n        if (!this.rowHeightService) {\n            return false;\n        }\n        const containerTop = this.containerScrollPosition;\n        const containerBottom = containerTop + this.containerOffsetSize;\n        const top = this.rowHeightService.offset(index);\n        const bottom = top + this.rowHeightService.height(index);\n        return top >= containerTop && bottom <= containerBottom;\n    }\n    isListScrolled(index) {\n        return this.containerScrollPosition !== this.rowHeightService.offset(index);\n    }\n    scrollTo(value) {\n        const scrollProperty = this.direction === \"vertical\" ? 'scrollTop' : 'scrollLeft';\n        this.renderer.setProperty(this.container.nativeElement, scrollProperty, value);\n    }\n    scrollToIndex(index) {\n        //XXX: scrolling with tick is required to prevent list jump in Chrome.\n        //Original issue: focus first day in the month and press LEFT arrow.\n        //Notice how the view jumps on every day change.\n        //\n        this.zone.runOutsideAngular(() => {\n            this.resolvedPromise.then(() => {\n                this.scrollTo(this.rowHeightService.offset(index));\n            });\n        });\n    }\n    scrollToBottom() {\n        this.scrollTo(this.totalSize);\n    }\n    animateToIndex(index) {\n        if (this.animationSubscription) {\n            this.animationSubscription.unsubscribe();\n        }\n        const indexOffset = this.rowHeightService.offset(index);\n        const direction = this.getContainerScrollDirection(indexOffset);\n        const { start, end } = this.scrollRange(indexOffset, direction);\n        if (start === end) {\n            return;\n        }\n        const step = this.scrollStep(start, end);\n        const modifyScroll = scrollModifiers[direction](step);\n        const normalizeScroll = scrollNormalizers[direction](end);\n        const isScrollValid = scrollValidators[direction](modifyScroll(end));\n        this.zone.runOutsideAngular(() => {\n            this.animationSubscription =\n                combineLatest(of(start), interval(0, animationFrameScheduler)).pipe(map(stream => stream[0]), scan(modifyScroll), takeWhile(isScrollValid), map(normalizeScroll)).subscribe((x) => this.scrollTo(x));\n        });\n    }\n    scrollRange(indexOffset, direction) {\n        const containerScroll = this.containerScrollPosition;\n        if (parseInt(indexOffset, 10) === parseInt(containerScroll, 10)) {\n            return { start: indexOffset, end: indexOffset };\n        }\n        const maxScroll = this.containerMaxScroll();\n        const sign = direction === ScrollDirection.Backward ? 1 : -1;\n        const difference = differenceToScroll(containerScroll, indexOffset, this.maxScrollDifference);\n        const end = Math.min(indexOffset, maxScroll);\n        const start = Math.min(Math.max(end + (sign * difference), 0), maxScroll);\n        return { start, end };\n    }\n    scrollStep(start, end) {\n        return Math.abs(end - start) / (this.scrollDuration / FRAME_DURATION);\n    }\n    scroll$() {\n        return isDocumentAvailable() ? fromEvent(this.container.nativeElement, 'scroll') : EMPTY;\n    }\n    initServices() {\n        this.rowHeightService = this.createRowHeightService();\n        if (this.scrollSubscription) {\n            this.scrollSubscription.unsubscribe();\n        }\n        this.scrollSubscription = this.scroller\n            .create(this.rowHeightService, this.skip, this.take, this.total, this.topOffset, this.scrollOffsetSize, this.direction)\n            .subscribe((x) => {\n            if (x instanceof PageAction) {\n                this.pageChange.emit(x);\n            }\n            else {\n                this.scrollChange.emit(x);\n            }\n        });\n    }\n    createRowHeightService() {\n        const dimension = this.direction === 'vertical' ? this.itemHeight : this.itemWidth;\n        return new RowHeightService(this.total, dimension, 0);\n    }\n    emitActiveIndex() {\n        const index = this.rowHeightService.index(this.containerScrollPosition - this.topOffset);\n        if (this.lastActiveIndex !== index) {\n            this.lastActiveIndex = index;\n            this.activeIndexChange.emit(index);\n        }\n    }\n    containerMaxScroll() {\n        return this.containerScrollSize - this.containerOffsetSize;\n    }\n    getContainerScrollDirection(indexOffset) {\n        return indexOffset < this.containerScrollPosition ? ScrollDirection.Backward : ScrollDirection.Forward;\n    }\n}\nVirtualizationComponent.decorators = [\n    { type: Component, args: [{\n                providers: [{\n                        provide: SCROLLER_FACTORY_TOKEN,\n                        useValue: DEFAULT_SCROLLER_FACTORY\n                    }],\n                selector: 'kendo-virtualization',\n                template: `\n    <ng-content></ng-content>\n    <div\n        class=\"k-scrollable-placeholder\"\n        [class.k-scrollable-horizontal-placeholder]=\"direction === 'horizontal'\"\n        [ngStyle]=\"totalVertexLength\"\n    ></div>\n  `\n            },] },\n];\n/** @nocollapse */\nVirtualizationComponent.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [SCROLLER_FACTORY_TOKEN,] }] },\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: NgZone }\n];\nVirtualizationComponent.propDecorators = {\n    direction: [{ type: Input }],\n    itemHeight: [{ type: Input }],\n    itemWidth: [{ type: Input }],\n    topOffset: [{ type: Input }],\n    bottomOffset: [{ type: Input }],\n    maxScrollDifference: [{ type: Input }],\n    scrollOffsetSize: [{ type: Input }],\n    scrollDuration: [{ type: Input }],\n    skip: [{ type: Input }],\n    take: [{ type: Input }],\n    total: [{ type: Input }],\n    activeIndexChange: [{ type: Output }],\n    pageChange: [{ type: Output }],\n    scrollChange: [{ type: Output }],\n    wrapperClasses: [{ type: HostBinding, args: ['class.k-content',] }, { type: HostBinding, args: ['class.k-scrollable',] }],\n    horizontalClass: [{ type: HostBinding, args: ['class.k-scrollable-horizontal',] }]\n};\n\n/**\n * @hidden\n */\nconst closestInScope = (node, predicate, scope) => {\n    while (node && node !== scope && !predicate(node)) {\n        node = node.parentNode;\n    }\n    if (node !== scope) {\n        return node;\n    }\n};\n/**\n * @hidden\n */\nconst closest = (node, predicate) => {\n    while (node && !predicate(node)) {\n        node = node.parentNode;\n    }\n    return node;\n};\n\n/* tslint:disable:component-selector-name  component-selector-type */\nconst ITEMS_COUNT = 30;\n/**\n * @hidden\n */\nclass NavigationComponent {\n    constructor(bus, dom, intl, cdr, renderer) {\n        this.bus = bus;\n        this.dom = dom;\n        this.intl = intl;\n        this.cdr = cdr;\n        this.renderer = renderer;\n        this.min = new Date(MIN_DATE);\n        this.max = new Date(MAX_DATE);\n        this.focusedDate = new Date();\n        this.valueChange = new EventEmitter();\n        this.pageChange = new EventEmitter();\n        this.dates = [];\n        this.take = ITEMS_COUNT;\n        this.indexToScroll = -1;\n    }\n    get getComponentClass() {\n        return true;\n    }\n    ngOnInit() {\n        this.dom.ensureHeights();\n        const calendarHeight = this.dom.calendarHeight;\n        this.itemHeight = this.dom.navigationItemHeight;\n        this.maxViewHeight = this.dom.monthViewHeight;\n        this.topOffset = (calendarHeight - this.itemHeight) / 2;\n        this.bottomOffset = calendarHeight - this.itemHeight;\n        this.intlSubscription = this.intl.changes.subscribe(this.intlChange.bind(this));\n    }\n    ngOnChanges(changes) {\n        this.service = this.bus.service(this.activeView);\n        if (!this.service) {\n            return;\n        }\n        this.activeViewValue = CalendarViewEnum[this.activeView];\n        const viewDate = dateInRange(this.focusedDate, this.min, this.max);\n        const total = this.service.total(this.min, this.max);\n        const totalChanged = this.total && this.total !== total;\n        this.skip = this.service.skip(viewDate, this.min);\n        this.total = total;\n        if (totalChanged || !this.service.isInArray(viewDate, this.dates)) {\n            this.dates = this.service.datesList(viewDate, this.getTake(this.skip));\n        }\n        if (!!changes.focusedDate || totalChanged) {\n            this.indexToScroll = this.service.skip(this.focusedDate, this.min);\n        }\n    }\n    ngOnDestroy() {\n        if (this.intlSubscription) {\n            this.intlSubscription.unsubscribe();\n        }\n    }\n    ngAfterViewInit() {\n        if (this.indexToScroll === -1) {\n            return;\n        }\n        this.virtualization.scrollToIndex(this.indexToScroll);\n        this.indexToScroll = -1;\n    }\n    ngAfterViewChecked() {\n        if (this.indexToScroll === -1) {\n            return;\n        }\n        this.virtualization.scrollToIndex(this.indexToScroll);\n        this.indexToScroll = -1;\n    }\n    onPageChange({ skip }) {\n        this.dates = this.service.datesList(this.service.addToDate(this.min, skip), this.getTake(skip));\n        this.pageChange.emit();\n    }\n    scrollChange({ offset }) {\n        const el = this.list.nativeElement;\n        const translate = `translateY(${offset}px)`;\n        this.renderer.setStyle(el, 'transform', translate);\n        this.renderer.setStyle(el, '-ms-transform', translate);\n    }\n    handleDateChange(args) {\n        const item = closestInScope(args.target, node => node.hasAttribute('data-date-index'), this.list.nativeElement);\n        if (item) {\n            const index = parseInt(item.getAttribute('data-date-index'), 10);\n            const candidate = this.dates[index];\n            this.valueChange.emit(cloneDate(candidate));\n        }\n    }\n    getTake(skip) {\n        return Math.min(this.total - skip, this.take);\n    }\n    intlChange() {\n        if (this.activeView === CalendarViewEnum.month) {\n            this.cdr.markForCheck();\n        }\n    }\n}\nNavigationComponent.decorators = [\n    { type: Component, args: [{\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                selector: 'kendo-calendar-navigation',\n                template: `\n    <span class=\"k-calendar-navigation-highlight\"></span>\n    <kendo-virtualization\n        [skip]=\"skip\"\n        [take]=\"take\"\n        [total]=\"total\"\n        [itemHeight]=\"itemHeight\"\n        [topOffset]=\"topOffset\"\n        [bottomOffset]=\"bottomOffset\"\n        [maxScrollDifference]=\"maxViewHeight\"\n        (pageChange)=\"onPageChange($event)\"\n        (scrollChange)=\"scrollChange($event)\"\n    >\n        <ul #list class=\"k-reset\" [kendoEventsOutsideAngular]=\"{ click: handleDateChange }\" [scope]=\"this\">\n            <li *kFor=\"let date of dates; let index=index\" [attr.data-date-index]=\"index\">\n                <span [class.k-calendar-navigation-marker]=\"service.isRangeStart(date)\">\n                    <ng-template [ngIf]=\"!templateRef\">{{service.navigationTitle(date)}}</ng-template>\n                    <ng-template\n                        [ngIf]=\"templateRef\"\n                        [ngTemplateOutlet]=\"templateRef\"\n                        [ngTemplateOutletContext]=\"{ $implicit: service.navigationTitle(date), activeView: activeViewValue, date: date }\"\n                    ></ng-template>\n                </span>\n            </li>\n        </ul>\n    </kendo-virtualization>\n  `\n            },] },\n];\n/** @nocollapse */\nNavigationComponent.ctorParameters = () => [\n    { type: BusViewService },\n    { type: CalendarDOMService },\n    { type: IntlService },\n    { type: ChangeDetectorRef },\n    { type: Renderer2 }\n];\nNavigationComponent.propDecorators = {\n    activeView: [{ type: Input }],\n    min: [{ type: Input }],\n    max: [{ type: Input }],\n    focusedDate: [{ type: Input }],\n    templateRef: [{ type: Input }],\n    valueChange: [{ type: Output }],\n    pageChange: [{ type: Output }],\n    virtualization: [{ type: ViewChild, args: [VirtualizationComponent,] }],\n    list: [{ type: ViewChild, args: ['list', { static: true },] }],\n    getComponentClass: [{ type: HostBinding, args: [\"class.k-calendar-navigation\",] }]\n};\n\nconst VIEWS_COUNT = 5;\nconst isEqualMonthYear = (date1, date2) => (date1 && date2 &&\n    date1.getFullYear() === date2.getFullYear() &&\n    date1.getMonth() === date2.getMonth());\n/**\n * @hidden\n */\nclass ViewListComponent {\n    constructor(bus, cdr, intl, dom, renderer) {\n        this.bus = bus;\n        this.cdr = cdr;\n        this.intl = intl;\n        this.dom = dom;\n        this.renderer = renderer;\n        this.isActive = true;\n        this.min = new Date(MIN_DATE);\n        this.max = new Date(MAX_DATE);\n        this.activeDateChange = new EventEmitter();\n        this.valueChange = new EventEmitter();\n        this.pageChange = new EventEmitter();\n        this.dates = [];\n        this.cols = [];\n        this.weekNames = [];\n        this.take = VIEWS_COUNT;\n        this.animateToIndex = true;\n        this.indexToScroll = -1;\n        this.minViewsToRender = 1;\n    }\n    get weekNumber() {\n        return this.showWeekNumbers && this.isMonthView();\n    }\n    set weekNumber(showWeekNumbers) {\n        this.showWeekNumbers = showWeekNumbers;\n    }\n    get getComponentClass() {\n        return true;\n    }\n    get getComponentMonthClass() {\n        return this.activeView === CalendarViewEnum.month;\n    }\n    get getComponentYearClass() {\n        return this.activeView === CalendarViewEnum.year;\n    }\n    get getComponentDecadeClass() {\n        return this.activeView === CalendarViewEnum.decade;\n    }\n    get getComponentCenturyClass() {\n        return this.activeView === CalendarViewEnum.century;\n    }\n    ngOnInit() {\n        this.weekNames = this.getWeekNames();\n        this.bottomOffset = this.getBottomOffset();\n        this.viewOffset = -1 * this.dom.headerHeight;\n        this.viewHeight = this.dom.viewHeight(this.activeView);\n        this.intlSubscription = this.intl.changes.subscribe(this.intlChange.bind(this));\n    }\n    ngOnChanges(changes) {\n        this.service = this.bus.service(this.activeView);\n        if (!this.service) {\n            return;\n        }\n        this.cols = new Array(this.service.rowLength(this.weekNumber)).fill('');\n        this.colWidth = Math.round(100 / this.cols.length);\n        this.weekNames = hasChange(changes, 'weekNumber') && this.weekNumber ? this.getWeekNames() : this.weekNames;\n        const activeViewChanged = hasChange(changes, 'activeView');\n        const focusedDate = this.focusedDate;\n        const viewDate = dateInRange(this.service.viewDate(focusedDate, this.max, this.minViewsToRender), this.min, this.max);\n        const total = this.service.total(this.min, this.max);\n        const totalChanged = this.total && this.total !== total;\n        const generateDates = totalChanged || !this.service.isInArray(focusedDate, this.dates);\n        this.skip = this.service.skip(viewDate, this.min);\n        this.total = total;\n        this.animateToIndex = !activeViewChanged;\n        this.bottomOffset = this.getBottomOffset();\n        this.viewHeight = this.dom.viewHeight(this.activeView);\n        if (generateDates) {\n            this.dates = this.service.datesList(viewDate, this.getTake(this.skip));\n        }\n        if (!isEqualMonthYear(this.activeDate, focusedDate)) {\n            this.activeDate = cloneDate(focusedDate);\n        }\n        const updateIndex = hasChange(changes, 'focusedDate') || activeViewChanged;\n        if (generateDates || updateIndex || this.virtualization.isIndexVisible(this.skip)) {\n            this.indexToScroll = this.service.skip(focusedDate, this.min);\n        }\n    }\n    ngOnDestroy() {\n        if (this.intlSubscription) {\n            this.intlSubscription.unsubscribe();\n        }\n    }\n    ngAfterViewInit() {\n        if (this.indexToScroll === -1) {\n            return;\n        }\n        this.virtualization.scrollToIndex(this.indexToScroll);\n        this.indexToScroll = -1;\n    }\n    ngAfterViewChecked() {\n        if (this.indexToScroll === -1) {\n            return;\n        }\n        this.virtualization[this.animateToIndex ? 'animateToIndex' : 'scrollToIndex'](this.indexToScroll);\n        this.animateToIndex = true;\n        this.indexToScroll = -1;\n    }\n    onPageChange({ skip }) {\n        this.dates = this.service.datesList(this.service.addToDate(this.min, skip), this.getTake(skip));\n        this.pageChange.emit();\n    }\n    scrollChange({ offset }) {\n        const el = this.list.nativeElement;\n        const translate = `translateY(${offset}px)`;\n        this.renderer.setStyle(el, 'transform', translate);\n        this.renderer.setStyle(el, '-ms-transform', translate);\n    }\n    setActiveDate(index) {\n        const candidate = this.service.addToDate(this.min, index);\n        if (isEqual(this.activeDate, candidate)) {\n            return;\n        }\n        this.activeDate = candidate;\n        this.activeDateChange.emit(candidate);\n        this.cdr.detectChanges();\n    }\n    handleDateChange(candidate) {\n        this.valueChange.emit(candidate);\n    }\n    isMonthView() {\n        return this.activeView === CalendarViewEnum.month;\n    }\n    isScrolled() {\n        return this.virtualization.isListScrolled(this.service.skip(this.focusedDate, this.min));\n    }\n    getBottomOffset() {\n        return this.getScrollableHeight() - this.dom.viewHeight(this.activeView);\n    }\n    getScrollableHeight() {\n        return this.activeView === CalendarViewEnum.month ?\n            this.dom.scrollableContentHeight :\n            this.dom.scrollableYearContentHeight;\n    }\n    getTake(skip) {\n        return Math.min(this.total - skip, this.take);\n    }\n    getWeekNames() {\n        const weekNames = shiftWeekNames(this.intl.dateFormatNames({ nameType: 'short', type: 'days' }), this.intl.firstDay());\n        return this.weekNumber ? [''].concat(weekNames) : weekNames;\n    }\n    intlChange() {\n        this.weekNames = this.getWeekNames();\n        if (this.isMonthView()) {\n            this.cdr.markForCheck();\n        }\n    }\n}\nViewListComponent.decorators = [\n    { type: Component, args: [{\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                selector: 'kendo-calendar-viewlist',\n                template: `\n    <kendo-calendar-header\n        [currentDate]=\"activeDate\"\n        [min]=\"min\"\n        [max]=\"max\"\n        [activeView]=\"activeView\"\n        [templateRef]=\"headerTitleTemplateRef\"\n        (today)=\"handleDateChange($event)\"\n    >\n    </kendo-calendar-header>\n    <table class=\"k-calendar-weekdays\" style=\"table-layout: auto;\" *ngIf=\"isMonthView()\">\n        <thead>\n            <tr>\n                <th *ngFor=\"let name of weekNames\" [style.width.%]=\"colWidth\">{{name}}</th>\n            </tr>\n        </thead>\n    </table>\n    <kendo-virtualization\n        [tabindex]=\"-1\"\n        [skip]=\"skip\"\n        [take]=\"take\"\n        [total]=\"total\"\n        [itemHeight]=\"viewHeight\"\n        [topOffset]=\"viewOffset\"\n        [bottomOffset]=\"bottomOffset\"\n        [scrollOffsetSize]=\"viewOffset\"\n        [maxScrollDifference]=\"viewHeight\"\n        (pageChange)=\"onPageChange($event)\"\n        (scrollChange)=\"scrollChange($event)\"\n        (activeIndexChange)=\"setActiveDate($event)\"\n        >\n        <table #list>\n            <colgroup><col *ngFor=\"let _ of cols\" /></colgroup>\n\n            <tbody *kFor=\"let date of dates\"\n                   kendoCalendarView\n                   role=\"rowgroup\"\n                   [activeView]=\"activeView\"\n                   [isActive]=\"isActive\"\n                   [min]=\"min\" [max]=\"max\"\n                   [cellUID]=\"cellUID\"\n                   [focusedDate]=\"focusedDate\"\n                   [selectedDate]=\"value\"\n                   [weekNumber]=\"weekNumber\"\n                   [templateRef]=\"cellTemplateRef\"\n                   [weekNumberTemplateRef]=\"weekNumberTemplateRef\"\n                   [viewDate]=\"date\"\n                   (change)=\"handleDateChange($event)\"\n            ></tbody>\n        </table>\n    </kendo-virtualization>\n  `\n            },] },\n];\n/** @nocollapse */\nViewListComponent.ctorParameters = () => [\n    { type: BusViewService },\n    { type: ChangeDetectorRef },\n    { type: IntlService },\n    { type: CalendarDOMService },\n    { type: Renderer2 }\n];\nViewListComponent.propDecorators = {\n    cellTemplateRef: [{ type: Input }],\n    weekNumberTemplateRef: [{ type: Input }],\n    headerTitleTemplateRef: [{ type: Input }],\n    activeView: [{ type: Input }],\n    cellUID: [{ type: Input }],\n    focusedDate: [{ type: Input }],\n    isActive: [{ type: Input }],\n    min: [{ type: Input }],\n    max: [{ type: Input }],\n    value: [{ type: Input }],\n    weekNumber: [{ type: Input }],\n    activeDateChange: [{ type: Output }],\n    valueChange: [{ type: Output }],\n    pageChange: [{ type: Output }],\n    virtualization: [{ type: ViewChild, args: [VirtualizationComponent,] }],\n    list: [{ type: ViewChild, args: ['list', { static: true },] }],\n    getComponentClass: [{ type: HostBinding, args: [\"class.k-calendar-view\",] }],\n    getComponentMonthClass: [{ type: HostBinding, args: [\"class.k-calendar-monthview\",] }],\n    getComponentYearClass: [{ type: HostBinding, args: [\"class.k-calendar-yearview\",] }],\n    getComponentDecadeClass: [{ type: HostBinding, args: [\"class.k-calendar-decadeview\",] }],\n    getComponentCenturyClass: [{ type: HostBinding, args: [\"class.k-calendar-centuryview\",] }]\n};\n\nconst KEY_TO_ACTION = {\n    '33': Action.PrevView,\n    '34': Action.NextView,\n    '35': Action.LastInView,\n    '36': Action.FirstInView,\n    '37': Action.Left,\n    '38': Action.Up,\n    '39': Action.Right,\n    '40': Action.Down,\n    'meta+38': Action.UpperView,\n    'meta+40': Action.LowerView\n};\n/**\n * @hidden\n */\nclass NavigationService {\n    constructor(bus) {\n        this.bus = bus;\n    }\n    action(event) {\n        const action = `${event.ctrlKey || event.metaKey ? 'meta+' : ''}${event.keyCode}`;\n        return KEY_TO_ACTION[action];\n    }\n    move(value, action, activeView) {\n        const service = this.bus.service(activeView);\n        if (!service) {\n            return value;\n        }\n        if (action === Action.UpperView && this.bus.canMoveUp(activeView)) {\n            this.bus.moveUp(activeView);\n            return value;\n        }\n        if (action === Action.LowerView && this.bus.canMoveDown(activeView)) {\n            this.bus.moveDown(activeView);\n            return value;\n        }\n        return service.move(value, action);\n    }\n}\nNavigationService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nNavigationService.ctorParameters = () => [\n    { type: BusViewService }\n];\n\nconst divideByMagnitude = (magnitude) => x => Math.floor(x / magnitude);\nconst powerByMagnitude = (magnitude) => x => x * magnitude;\n/**\n * @hidden\n */\nclass ScrollSyncService {\n    constructor(dom, zone) {\n        this.dom = dom;\n        this.zone = zone;\n    }\n    configure(activeView) {\n        const magnitude = Math.max(this.dom.viewHeight(activeView) / this.dom.navigationItemHeight, 1);\n        this.divideByMagnitude = divideByMagnitude(magnitude);\n        this.powerByMagnitude = powerByMagnitude(magnitude);\n    }\n    sync(navigator, view) {\n        this.unsubscribe();\n        if (!navigator || !view) {\n            return;\n        }\n        this.navigator = navigator;\n        this.view = view;\n        this.zone.runOutsideAngular(() => {\n            let navScrolled, monthScrolled;\n            this.navSubscription = navigator.scroll$()\n                .subscribe((e) => {\n                if (monthScrolled) {\n                    monthScrolled = false;\n                    return;\n                }\n                navScrolled = true;\n                this.scrollSiblingOf(e.target);\n            });\n            this.viewSubscription = view.scroll$()\n                .subscribe((e) => {\n                if (navScrolled) {\n                    navScrolled = false;\n                    return;\n                }\n                monthScrolled = true;\n                this.scrollSiblingOf(e.target);\n            });\n        });\n    }\n    scrollSiblingOf(scrolledElement) {\n        const component = this.siblingComponent(scrolledElement);\n        const scrollTop = this.calculateScroll(component, scrolledElement.scrollTop);\n        component.scrollTo(scrollTop);\n    }\n    siblingComponent(scrollableElement) {\n        return this.navigator.container.nativeElement === scrollableElement ? this.view : this.navigator;\n    }\n    calculateScroll(component, scrollTop) {\n        const modifier = component === this.navigator ? this.divideByMagnitude : this.powerByMagnitude;\n        return modifier(scrollTop);\n    }\n    destroy() {\n        this.unsubscribe();\n    }\n    unsubscribe() {\n        if (this.navSubscription) {\n            this.navSubscription.unsubscribe();\n        }\n        if (this.viewSubscription) {\n            this.viewSubscription.unsubscribe();\n        }\n    }\n}\nScrollSyncService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nScrollSyncService.ctorParameters = () => [\n    { type: CalendarDOMService },\n    { type: NgZone }\n];\n\n/**\n * Used for rendering the cell content of the Calendar. To define the cell template, nest an `<ng-template>` tag\n * with the `kendoCalendarCellTemplate` directive inside the component tag. The template context is set to the\n * current component. To get a reference to the current date, use the `let-date` directive. To provide more details\n * about the current cell, get a reference to the current `cellContext` by using the `let-cellContext` directive.\n *\n * For more examples, refer to the article on [templates]({% slug templates_calendar %}).\n *\n * > `kendoCalendarCellTemplate` is equivalent to\n * > [`kendoCalendarMonthCellTemplate`]({% slug api_dateinputs_monthcelltemplatedirective %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * styles: ['.custom { color: red; }'],\n * template: `\n *  <kendo-calendar>\n *    <ng-template kendoCalendarCellTemplate let-date>\n *      <span class=\"custom\">{{date.getDate()}}</span>\n *    </ng-template>\n *  </kendo-calendar>\n * `\n * })\n * class AppComponent { }\n * ```\n */\nclass CellTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nCellTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoCalendarCellTemplate]'\n            },] },\n];\n/** @nocollapse */\nCellTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef }\n];\n\n/**\n * Used for rendering the month cell content of the Calendar. To define the month cell template, nest an `<ng-template>` tag\n * with the `kendoCalendarMonthCellTemplate` directive inside the component tag. The template context is set to the current\n * component. To get a reference to the current date, use the `let-date` directive. To provide more details about the current\n * month cell, get a reference to the current `cellContext` by using the `let-cellContext` directive.\n *\n * For more examples, refer to the article on [templates]({% slug templates_calendar %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * styles: ['.custom { color: red; }'],\n * template: `\n *  <kendo-calendar>\n *    <ng-template kendoCalendarMonthCellTemplate let-context=\"cellContext\">\n *      <span class=\"custom\">{{context.formattedValue}}</span>\n *    </ng-template>\n *  </kendo-calendar>\n * `\n * })\n * class AppComponent { }\n * ```\n */\nclass MonthCellTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nMonthCellTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoCalendarMonthCellTemplate]'\n            },] },\n];\n/** @nocollapse */\nMonthCellTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef }\n];\n\n/**\n * Used for rendering the year cell content of the Calendar. To define the year cell template, nest an\n * `<ng-template>` tag with the `kendoCalendarYearCellTemplate` directive inside the component tag.\n * The template context is set to the current component. To get a reference to the current date, use\n * the `let-date` directive. To provide more details about the current year cell, get a reference to the\n * current `cellContext` by using the `let-cellContext` directive.\n *\n * For more examples, refer to the article on [templates]({% slug templates_calendar %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * styles: ['.custom { color: red; }'],\n * template: `\n *  <kendo-calendar [activeView]=\"activeView\">\n *    <ng-template kendoCalendarYearCellTemplate let-context=\"cellContext\">\n *      <span class=\"custom\">{{context.formattedValue}}</span>\n *    </ng-template>\n *  </kendo-calendar>\n * `\n * })\n * class AppComponent {\n *  public activeView: CalendarView = 'year';\n * }\n * ```\n */\nclass YearCellTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nYearCellTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoCalendarYearCellTemplate]'\n            },] },\n];\n/** @nocollapse */\nYearCellTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef }\n];\n\n/**\n * Used for rendering the decade cell content of the Calendar. To define the decade cell template, nest an `<ng-template>`\n * tag with the `kendoCalendarDecadeCellTemplate` directive inside the component tag. The template context is set to the\n * current component. To get a reference to the current date, use the `let-date` directive. To provide more details about\n * the current decade cell, get a reference to the current `cellContext` by using the `let-cellContext` directive.\n *\n * For more examples, refer to the article on [templates]({% slug templates_calendar %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * styles: ['.custom { color: red; }'],\n * template: `\n *  <kendo-calendar [activeView]=\"activeView\">\n *    <ng-template kendoCalendarDecadeCellTemplate let-context=\"cellContext\">\n *      <span class=\"custom\">{{context.formattedValue}}</span>\n *    </ng-template>\n *  </kendo-calendar>\n * `\n * })\n * class AppComponent {\n *  public activeView: CalendarView = 'decade';\n * }\n * ```\n */\nclass DecadeCellTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nDecadeCellTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoCalendarDecadeCellTemplate]'\n            },] },\n];\n/** @nocollapse */\nDecadeCellTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef }\n];\n\n/**\n * Used for rendering the century cell content of the Calendar. To define the century cell template, nest an `<ng-template>`\n * tag with the `kendoCalendarCenturyCellTemplate` directive inside the component tag. The template context is set to the\n * current component. To get a reference to the current date, use the `let-date` directive. To provide more details about\n * the current century cell, get a reference to the current `cellContext` by using the `let-cellContext` directive.\n *\n * For more examples, refer to the article on [templates]({% slug templates_calendar %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * styles: ['.custom { color: red; }'],\n * template: `\n *  <kendo-calendar [activeView]=\"activeView\">\n *    <ng-template kendoCalendarCenturyCellTemplate let-context=\"cellContext\">\n *      <span class=\"custom\">{{context.formattedValue}}</span>\n *    </ng-template>\n *  </kendo-calendar>\n * `\n * })\n * class AppComponent {\n *  public activeView: CalendarView = 'century';\n * }\n * ```\n */\nclass CenturyCellTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nCenturyCellTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoCalendarCenturyCellTemplate]'\n            },] },\n];\n/** @nocollapse */\nCenturyCellTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef }\n];\n\n/**\n * Used for rendering the week number cell content in the month view of the Calendar. To define the month week number cell template,\n * nest an `<ng-template>` tag with the `kendoCalendarWeekNumberCellTemplate` directive inside the component tag. The template\n * context is set to the current component. To get a reference to the current date, use the `let-date` directive. To provide more\n * details about the current week number cell, get a reference to the current `cellContext` by using the `let-cellContext` directive.\n *\n * For more examples, refer to the article on [templates]({% slug templates_calendar %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * styles: ['.custom { color: red; }'],\n * template: `\n *  <kendo-calendar [weekNumber]=\"true\">\n *    <ng-template kendoCalendarWeekNumberCellTemplate let-context=\"cellContext\">\n *      <span class=\"custom\">{{context.formattedValue}}</span>\n *    </ng-template>\n *  </kendo-calendar>\n * `\n * })\n * class AppComponent { }\n * ```\n */\nclass WeekNumberCellTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nWeekNumberCellTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoCalendarWeekNumberCellTemplate]'\n            },] },\n];\n/** @nocollapse */\nWeekNumberCellTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef }\n];\n\n/**\n * Used for rendering the header title of the Calendar. To define the header title template, nest an `<ng-template>` tag\n * with the `kendoCalendarHeaderTitleTemplate` directive inside the component tag. The template context is set to the\n * current component. To get a reference to the current title, use the `let-title` directive. To provide more details about\n * the current title, get a reference to the current `date` by using the `let-date` directive or get a reference to the\n * current active view  by using the `let-activeView` directive.\n *\n * For more examples, refer to the article on [templates]({% slug templates_calendar %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * styles: ['.custom { color: red; }'],\n * template: `\n *  <kendo-calendar>\n *    <ng-template kendoCalendarHeaderTitleTemplate let-title>\n *      <span class=\"custom\">{{title}}</span>\n *    </ng-template>\n *  </kendo-calendar>\n * `\n * })\n * class AppComponent { }\n * ```\n */\nclass HeaderTitleTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nHeaderTitleTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoCalendarHeaderTitleTemplate]'\n            },] },\n];\n/** @nocollapse */\nHeaderTitleTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef }\n];\n\n/**\n * Used for rendering the navigation item of the Calendar. To define the navigation item template, nest an `<ng-template>`\n * tag with the `kendoCalendarNavigationItemTemplate` directive inside the component tag. The template context is set to the\n * current component. To get a reference to the current item value, use the `let-title` directive. To provide more details\n * about the current title, get a reference to the current `date` by using the `let-date='date'` directive or get a reference\n * to the current active view by using the `let-activeView='activeView'` directive.\n *\n * For more examples, refer to the article on [templates]({% slug templates_calendar %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * styles: ['.custom { color: red; }'],\n * template: `\n *  <kendo-calendar>\n *    <ng-template kendoCalendarNavigationItemTemplate let-title>\n *      <span class=\"custom\">{{title}}</span>\n *    </ng-template>\n *  </kendo-calendar>\n * `\n * })\n * class AppComponent { }\n * ```\n */\nclass NavigationItemTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nNavigationItemTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoCalendarNavigationItemTemplate]'\n            },] },\n];\n/** @nocollapse */\nNavigationItemTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef }\n];\n\n/**\n * @hidden\n */\nclass PickerService {\n    constructor() {\n        this.onFocus = new EventEmitter();\n        this.onBlur = new EventEmitter();\n        this.sameDateSelected = new EventEmitter();\n    }\n}\n\n/**\n * @hidden\n */\nconst minValidator = (minValue) => {\n    return (control) => {\n        const err = {\n            minError: {\n                minValue: minValue,\n                value: control.value\n            }\n        };\n        if (!minValue || !control.value) {\n            return null;\n        }\n        return control.value < minValue ? err : null;\n    };\n};\n\n/**\n * @hidden\n */\nconst maxValidator = (maxValue) => {\n    return (control) => {\n        const err = {\n            maxError: {\n                maxValue: maxValue,\n                value: control.value\n            }\n        };\n        if (!maxValue || !control.value) {\n            return null;\n        }\n        return control.value > maxValue ? err : null;\n    };\n};\n\n/**\n * @hidden\n */\nconst requiresZoneOnBlur = (ngControl) => ngControl &&\n    (!ngControl.touched || (ngControl.control && ngControl.control.updateOn === 'blur'));\n/**\n * @hidden\n */\nconst preventDefault = (args) => args.preventDefault();\n/**\n * @hidden\n */\nconst currentFocusTarget = (blurArgs) => blurArgs.relatedTarget || document.activeElement;\n/**\n * @hidden\n */\nconst isPresent = (value) => value !== undefined && value !== null;\n/**\n * @hidden\n *\n * If the provided parameter is an array with at least one item\n * and all items in the array are numbers, returns `true.\n */\nconst isNumberArray = (value) => Array.isArray(value) && value.length > 0 && value.every(item => typeof item === 'number');\n/**\n * @hidden\n *\n * If the provided parameter is an array with at least one item\n * and all items in the array are dates, returns `true`.\n */\nconst isDateArray = (value) => Array.isArray(value) && value.length > 0 && value.every(item => item instanceof Date);\n\nconst noop$1 = () => false;\nconst DISABLED_DATES_DOC_LINK = 'https://www.telerik.com/kendo-angular-ui/components/dateinputs/calendar/disabled-dates/';\n/**\n * @hidden\n */\nclass DisabledDatesService {\n    constructor() {\n        /**\n         * Emits every time the `isDateDisabled` method changes.\n         */\n        this.changes = new Subject();\n        /**\n         * Based on the user-defined `disabledDates` input evaluates if the date is disabled.\n         * If not set, returns `false`.\n         */\n        this.isDateDisabled = noop$1;\n    }\n    /**\n     * Configures the `isDateDisabled` function.\n     *\n     * * If a function is provided, uses it as-is and passes each date to it for evaluation.\n     * The time part is set to `midnight`.\n     * * If a `Date[]` is provided, creates a function that checks the targeted date against\n     * the listed dates and, if the targeted date is listed, marks it as disabled.\n     * * If a `Day[]` is provided, creates a function that evaluates the provided days of the\n     * week as disabled.\n     */\n    initialize(disabledDates) {\n        if (typeof disabledDates === 'function') {\n            this.isDateDisabled = (date) => disabledDates(getDate(date));\n        }\n        else if (isNumberArray(disabledDates)) {\n            const disabledWeekDays = new Set(disabledDates);\n            this.isDateDisabled = (date) => disabledWeekDays.has(date.getDay());\n        }\n        else if (isDateArray(disabledDates)) {\n            const normalizedDisabledDates = new Set(disabledDates.map(date => getDate(date).getTime()));\n            this.isDateDisabled = (date) => normalizedDisabledDates.has(getDate(date).getTime());\n        }\n        else {\n            this.isDateDisabled = noop$1;\n            this.notifyInvalidInput(disabledDates);\n        }\n        this.notifyServiceChange();\n    }\n    notifyInvalidInput(disabledDates) {\n        if (isPresent(disabledDates) && isDevMode()) {\n            throw new Error(`The 'disabledDates' value should be a function, a Day array or a Date array. Check ${DISABLED_DATES_DOC_LINK} for more information.`);\n        }\n    }\n    notifyServiceChange() {\n        this.changes.next();\n    }\n}\nDisabledDatesService.decorators = [\n    { type: Injectable },\n];\n\n/* tslint:disable:no-forward-ref */\nconst BOTTOM_VIEW_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-bottomview';\nconst TOP_VIEW_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-topview';\nconst MIN_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-min';\nconst MAX_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-max';\nconst VALUE_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/calendar/#toc-using-with-json';\nconst virtualizationProp = x => x ? x.virtualization : null;\n/**\n * @hidden\n */\nconst CALENDAR_VALUE_ACCESSOR = {\n    multi: true,\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(() => CalendarComponent) //tslint:disable-line:no-use-before-declare\n};\n/**\n * @hidden\n */\nconst CALENDAR_RANGE_VALIDATORS = {\n    multi: true,\n    provide: NG_VALIDATORS,\n    useExisting: forwardRef(() => CalendarComponent) //tslint:disable-line:no-use-before-declare\n};\n/**\n * @hidden\n */\nconst KENDO_INPUT_PROVIDER = {\n    provide: KendoInput,\n    useExisting: forwardRef(() => CalendarComponent) //tslint:disable-line:no-use-before-declare\n};\n/**\n * Represents the [Kendo UI Calendar component for Angular]({% slug overview_calendar %}#toc-basic-usage).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-calendar></kendo-calendar>\n * `\n * })\n * class AppComponent { }\n * ```\n */\nclass CalendarComponent {\n    constructor(bus, dom, element, navigator, renderer, cdr, ngZone, injector, scrollSyncService, disabledDatesService, pickerService) {\n        this.bus = bus;\n        this.dom = dom;\n        this.element = element;\n        this.navigator = navigator;\n        this.renderer = renderer;\n        this.cdr = cdr;\n        this.ngZone = ngZone;\n        this.injector = injector;\n        this.scrollSyncService = scrollSyncService;\n        this.disabledDatesService = disabledDatesService;\n        this.pickerService = pickerService;\n        /**\n         * @hidden\n         */\n        this.id = guid();\n        /**\n         * Determines whether the built-in min or max validators are enforced when validating a form.\n         */\n        this.rangeValidation = false;\n        /**\n         * Sets or gets the `disabled` property of the Calendar and\n         * determines whether the component is active\n         * ([see example]({% slug disabled_calendar %})).\n         */\n        this.disabled = false;\n        /**\n         * Sets or gets the `tabindex` property of the Calendar. Based on the\n         * [HTML `tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) behavior,\n         * it determines whether the component is focusable.\n         */\n        this.tabindex = 0;\n        /**\n         * Sets or gets the `navigation` property of the Calendar\n         * and determines whether the navigation side-bar will be displayed\n         * ([see example]({% slug sidebar_calendar %})).\n         */\n        this.navigation = true;\n        /**\n         * Defines the active view that the Calendar initially renders\n         * ([see example]({% slug activeview_calendar %})).\n         * By default, the active view is `month`.\n         *\n         * > You have to set `activeView` within the `topView`-`bottomView` range.\n         */\n        this.activeView = CalendarViewEnum[CalendarViewEnum.month];\n        /**\n         * Defines the bottommost view to which the user can navigate\n         * ([see example]({% slug dates_calendar %}#toc-partial-dates)).\n         */\n        this.bottomView = CalendarViewEnum[CalendarViewEnum.month];\n        /**\n         * Defines the topmost view to which the user can navigate\n         * ([see example]({% slug sidebar_calendar %}#toc-partial-dates)).\n         */\n        this.topView = CalendarViewEnum[CalendarViewEnum.century];\n        /**\n         * Determines whether to display a week number column in the `month` view\n         * ([see example]({% slug weeknumcolumn_calendar %})).\n         */\n        this.weekNumber = false;\n        /**\n         * Fires when the active view is changed\n         * ([more information and example]({% slug overview_calendar %}#toc-events)).\n         */\n        this.activeViewChange = new EventEmitter();\n        /**\n         * Fires when the active view date is changed\n         * ([more information and example]({% slug overview_calendar %}#toc-events)).\n         */\n        this.activeViewDateChange = new EventEmitter();\n        /**\n         * Fires when the value is changed\n         * ([more information and example]({% slug overview_calendar %}#toc-events)).\n         */\n        this.valueChange = new EventEmitter();\n        this.isActive = false;\n        this.cellUID = guid();\n        this._min = new Date(MIN_DATE);\n        this._max = new Date(MAX_DATE);\n        this._focusedDate = getToday();\n        this.onControlChange = noop;\n        this.onControlTouched = noop;\n        this.onValidatorChange = noop;\n        this.minValidateFn = noop;\n        this.maxValidateFn = noop;\n        this.syncNavigation = true;\n        this.domEvents = [];\n        this.resolvedPromise = Promise.resolve(null);\n        this.destroyed = false;\n        this.setClasses(element.nativeElement);\n        if (this.pickerService) {\n            this.pickerService.calendar = this;\n        }\n    }\n    /**\n     * Sets or gets the `focusedDate` property of the Calendar and\n     * defines the focused date of the component\n     * ([see example]({% slug dates_calendar %}#toc-focused-dates)).\n     *\n     * > If the Calendar is out of the min or max range, it normalizes the defined `focusedDate`.\n     */\n    set focusedDate(focusedDate) {\n        this._focusedDate = focusedDate || getToday();\n        this.setAriaActivedescendant();\n    }\n    get focusedDate() {\n        return this._focusedDate;\n    }\n    /**\n     * Sets or gets the `min` property of the Calendar and\n     * defines the minimum allowed date value\n     * ([see example]({% slug dateranges_calendar %})).\n     * By default, the `min` value is `1900-1-1`.\n     */\n    set min(min) {\n        this._min = min || new Date(MIN_DATE);\n    }\n    get min() {\n        return this._min;\n    }\n    /**\n     * Sets or gets the `max` property of the Calendar and\n     * defines the maximum allowed date value\n     * ([see example]({% slug dateranges_calendar %})).\n     * By default, the `max` value is `2099-12-31`.\n     */\n    set max(max) {\n        this._max = max || new Date(MAX_DATE);\n    }\n    get max() {\n        return this._max;\n    }\n    /**\n     * Sets or gets the `value` property of the Calendar and defines the selected value of the component.\n     *\n     * > The `value` has to be a valid\n     * [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance.\n     */\n    get value() {\n        return this._value;\n    }\n    set value(candidate) {\n        this.verifyValue(candidate);\n        this._value = cloneDate(candidate);\n    }\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n        this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n        return this.tabindex;\n    }\n    /**\n     * Sets the dates of the Calendar that will be disabled\n     * ([see example]({% slug disabled_dates_calendar %})).\n     */\n    set disabledDates(value) {\n        this.disabledDatesService.initialize(value);\n    }\n    /**\n     * @hidden\n     */\n    set cellTemplateRef(template) {\n        this.cellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n    set monthCellTemplateRef(template) {\n        this.monthCellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n    set yearCellTemplateRef(template) {\n        this.yearCellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n    set decadeCellTemplateRef(template) {\n        this.decadeCellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n    set centuryCellTemplateRef(template) {\n        this.centuryCellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n    set weekNumberTemplateRef(template) {\n        this.weekNumberTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n    set headerTitleTemplateRef(template) {\n        this.headerTitleTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n    set navigationItemTemplateRef(template) {\n        this.navigationItemTemplate = template;\n    }\n    get activeViewEnum() {\n        const activeView = CalendarViewEnum[this.activeView];\n        return activeView < this.bottomViewEnum ? this.bottomViewEnum : activeView;\n    }\n    get bottomViewEnum() {\n        return CalendarViewEnum[this.bottomView];\n    }\n    get topViewEnum() {\n        return CalendarViewEnum[this.topView];\n    }\n    get widgetId() {\n        return this.id;\n    }\n    get widgetRole() {\n        return 'grid';\n    }\n    get calendarTabIndex() {\n        return this.disabled ? undefined : this.tabIndex;\n    }\n    get ariaDisabled() {\n        return this.disabled;\n    }\n    ngOnInit() {\n        this.dom.calculateHeights(this.element.nativeElement);\n        this.scrollSyncService.configure(this.activeViewEnum);\n        this.viewChangeSubscription = this.bus.viewChanged.subscribe(({ view }) => {\n            this.activeView = CalendarViewEnum[view];\n            this.emitEvent(this.activeViewChange, this.activeView);\n            this.scrollSyncService.configure(view);\n            this.detectChanges(); // requires zone if templates\n        });\n        this.control = this.injector.get(NgControl, null);\n        if (this.element) {\n            this.ngZone.runOutsideAngular(() => {\n                this.bindEvents();\n            });\n        }\n    }\n    ngOnChanges(changes) {\n        this.verifyChanges();\n        this.bus.configure(this.bottomViewEnum, this.topViewEnum);\n        this.scrollSyncService.configure(this.activeViewEnum);\n        const useValue = hasExistingValue(changes, 'value') && !hasExistingValue(changes, 'focusedDate');\n        const focusedDate = dateInRange(cloneDate(useValue ? this.value : this.focusedDate), this.min, this.max);\n        this.focusedDate = !isEqual(this.focusedDate, focusedDate) ? focusedDate : this.focusedDate;\n        if (changes.navigation) {\n            this.syncNavigation = true;\n        }\n        if (changes.min || changes.max || changes.rangeValidation) {\n            this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop;\n            this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop;\n            this.onValidatorChange();\n        }\n    }\n    ngAfterViewInit() {\n        this.setAriaActivedescendant();\n    }\n    ngAfterViewChecked() {\n        if (!this.syncNavigation) {\n            return;\n        }\n        this.syncNavigation = false;\n        this.scrollSyncService.sync(virtualizationProp(this.navigationView), virtualizationProp(this.monthView));\n    }\n    ngOnDestroy() {\n        this.scrollSyncService.destroy();\n        this.viewChangeSubscription.unsubscribe();\n        this.domEvents.forEach(unbindCallback => unbindCallback());\n        if (this.pickerService) {\n            this.pickerService.calendar = null;\n        }\n        if (this.pageChangeSubscription) {\n            this.pageChangeSubscription.unsubscribe();\n        }\n        this.destroyed = true;\n    }\n    /**\n     * Focuses the host element of the Calendar.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"calendar.focus()\">Focus calendar</button>\n     *  <kendo-calendar #calendar></kendo-calendar>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n        if (!this.element) {\n            return;\n        }\n        this.element.nativeElement.focus();\n    }\n    /**\n     * Blurs the Calendar component.\n     */\n    blur() {\n        if (!this.element) {\n            return;\n        }\n        this.element.nativeElement.blur();\n    }\n    /**\n     * @hidden\n     */\n    containsElement(element) {\n        return Boolean(closest(element, node => node === this.element.nativeElement));\n    }\n    /**\n     * @hidden\n     */\n    handleNavigation(candidate) {\n        if (this.disabled) {\n            return;\n        }\n        this.focusedDate = dateInRange(cloneDate(candidate) || this.focusedDate, this.min, this.max);\n        this.detectChanges();\n    }\n    /**\n     * @hidden\n     */\n    onPageChange() {\n        if (!NgZone.isInAngularZone()) {\n            if (this.pageChangeSubscription) {\n                this.pageChangeSubscription.unsubscribe();\n            }\n            this.pageChangeSubscription = from(this.resolvedPromise)\n                .subscribe(() => {\n                this.detectChanges(); // requires zone if templates\n            });\n        }\n    }\n    /**\n     * @hidden\n     */\n    handleDateChange(candidate) {\n        const canNavigateDown = this.bus.canMoveDown(this.activeViewEnum);\n        const isSameDate = !canNavigateDown && isEqual(candidate, this.value);\n        this.focusedDate = cloneDate(candidate) || this.focusedDate;\n        if (this.disabled) {\n            return;\n        }\n        if (isSameDate) {\n            this.emitSameDate();\n            return;\n        }\n        if (canNavigateDown) {\n            this.bus.moveDown(this.activeViewEnum);\n            return;\n        }\n        if (!this.disabledDatesService.isDateDisabled(candidate)) {\n            this.ngZone.run(() => {\n                this.value = cloneDate(candidate);\n                this.onControlChange(cloneDate(candidate));\n                this.valueChange.emit(cloneDate(candidate));\n                this.cdr.markForCheck();\n            });\n        }\n    }\n    /**\n     * @hidden\n     */\n    writeValue(candidate) {\n        this.verifyValue(candidate);\n        this.focusedDate = dateInRange(cloneDate(candidate) || this.focusedDate, this.min, this.max);\n        this.value = cloneDate(candidate);\n        this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.onControlChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.onControlTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n        this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n    validate(control) {\n        return this.minValidateFn(control) || this.maxValidateFn(control);\n    }\n    /**\n     * @hidden\n     */\n    registerOnValidatorChange(fn) {\n        this.onValidatorChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    activeCellTemplate() {\n        switch (this.activeViewEnum) {\n            case CalendarViewEnum.month:\n                return this.monthCellTemplate || this.cellTemplate;\n            case CalendarViewEnum.year:\n                return this.yearCellTemplate;\n            case CalendarViewEnum.decade:\n                return this.decadeCellTemplate;\n            case CalendarViewEnum.century:\n                return this.centuryCellTemplate;\n            default:\n                return null;\n        }\n    }\n    /**\n     * @hidden\n     */\n    emitEvent(emitter, args) {\n        if (hasObservers(emitter)) {\n            this.ngZone.run(() => {\n                emitter.emit(args);\n            });\n        }\n    }\n    setClasses(element) {\n        this.renderer.addClass(element, 'k-widget');\n        this.renderer.addClass(element, 'k-calendar');\n        this.renderer.addClass(element, 'k-calendar-infinite');\n    }\n    verifyChanges() {\n        if (!isDevMode()) {\n            return;\n        }\n        if (this.min > this.max) {\n            throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK} and ${MAX_DOC_LINK}.`);\n        }\n        if (this.bottomViewEnum > this.topViewEnum) {\n            throw new Error(`The topView should be greater than bottomView. See ${BOTTOM_VIEW_DOC_LINK} and ${TOP_VIEW_DOC_LINK}.`);\n        }\n    }\n    verifyValue(candidate) {\n        if (!isDevMode()) {\n            return;\n        }\n        if (candidate && !(candidate instanceof Date)) {\n            throw new Error(`The 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK} for possible resolution.`);\n        }\n    }\n    bindEvents() {\n        const element = this.element.nativeElement;\n        this.domEvents.push(this.renderer.listen(element, 'blur', this.handleBlur.bind(this)), this.renderer.listen(element, 'focus', this.handleFocus.bind(this)), this.renderer.listen(element, 'mousedown', preventDefault), this.renderer.listen(element, 'click', this.handleClick.bind(this)), this.renderer.listen(element, 'keydown', this.handleKeydown.bind(this)));\n    }\n    emitBlur(args) {\n        if (this.pickerService) {\n            this.pickerService.onBlur.emit(args);\n        }\n    }\n    emitFocus() {\n        if (this.pickerService) {\n            this.pickerService.onFocus.emit();\n        }\n    }\n    handleBlur(args) {\n        this.isActive = false;\n        // the injector can get the NgControl instance of the parent component (for example, the DateTimePicker)\n        // and enters the zone for no reason because the parent component is still untouched\n        if (!this.pickerService && requiresZoneOnBlur(this.control)) {\n            this.ngZone.run(() => {\n                this.onControlTouched();\n                this.emitBlur(args);\n            });\n        }\n        else {\n            this.emitBlur(args);\n            this.detectChanges();\n        }\n    }\n    handleFocus() {\n        this.isActive = true;\n        if (!NgZone.isInAngularZone()) {\n            this.detectChanges();\n        }\n        this.emitFocus();\n    }\n    handleClick() {\n        if (!this.isActive) {\n            if (this.monthView.isScrolled()) {\n                this.focusedDate = cloneDate(this.focusedDate); //XXX: forces change detect\n                this.detectChanges();\n            }\n            this.focus();\n        }\n    }\n    handleKeydown(args) {\n        // reserve the alt + arrow key commands for the picker\n        const arrowKeyPressed = [Keys.ArrowUp, Keys.ArrowRight, Keys.ArrowDown, Keys.ArrowLeft].indexOf(args.keyCode) !== -1;\n        if (isPresent(this.pickerService) && arrowKeyPressed && args.altKey) {\n            return;\n        }\n        const candidate = dateInRange(this.navigator.move(this.focusedDate, this.navigator.action(args), this.activeViewEnum), this.min, this.max);\n        if (!isEqual(this.focusedDate, candidate)) {\n            this.focusedDate = candidate;\n            this.detectChanges();\n            args.preventDefault();\n        }\n        if (args.keyCode === Keys.Enter) {\n            this.handleDateChange(this.focusedDate);\n        }\n    }\n    detectChanges() {\n        if (!this.destroyed) {\n            this.cdr.detectChanges();\n        }\n    }\n    emitSameDate() {\n        if (this.pickerService) {\n            this.pickerService.sameDateSelected.emit();\n        }\n    }\n    setAriaActivedescendant() {\n        if (!isPresent(this.element)) {\n            return;\n        }\n        const focusedCellId = this.cellUID + this.focusedDate.getTime();\n        this.renderer.setAttribute(this.element.nativeElement, 'aria-activedescendant', focusedCellId);\n    }\n}\nCalendarComponent.decorators = [\n    { type: Component, args: [{\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                exportAs: 'kendo-calendar',\n                providers: [\n                    BusViewService,\n                    CALENDAR_VALUE_ACCESSOR,\n                    CALENDAR_RANGE_VALIDATORS,\n                    KENDO_INPUT_PROVIDER,\n                    LocalizationService,\n                    DisabledDatesService,\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.calendar'\n                    },\n                    NavigationService,\n                    ScrollSyncService\n                ],\n                selector: 'kendo-calendar',\n                template: `\n    <ng-container kendoCalendarLocalizedMessages\n        i18n-today=\"kendo.calendar.today|The label for the today button in the calendar header\"\n        today=\"TODAY\"\n    >\n    </ng-container>\n    <kendo-calendar-navigation\n        *ngIf=\"navigation\"\n        [activeView]=\"activeViewEnum\"\n        [focusedDate]=\"focusedDate\"\n        [min]=\"min\"\n        [max]=\"max\"\n        [templateRef]=\"navigationItemTemplate?.templateRef\"\n        (valueChange)=\"handleNavigation($event)\"\n        (pageChange)=\"onPageChange()\"\n    >\n    </kendo-calendar-navigation>\n    <kendo-calendar-viewlist\n        [activeView]=\"activeViewEnum\"\n        [isActive]=\"isActive\"\n        [cellTemplateRef]=\"activeCellTemplate()?.templateRef\"\n        [headerTitleTemplateRef]=\"headerTitleTemplate?.templateRef\"\n        [weekNumberTemplateRef]=\"weekNumberTemplate?.templateRef\"\n        [cellUID]=\"cellUID\"\n        [min]=\"min\"\n        [max]=\"max\"\n        [focusedDate]=\"focusedDate\"\n        [weekNumber]=\"weekNumber\"\n        [value]=\"value\"\n        (valueChange)=\"handleDateChange($event)\"\n        (activeDateChange)=\"emitEvent(activeViewDateChange, $event)\"\n        (pageChange)=\"onPageChange()\"\n    >\n    </kendo-calendar-viewlist>\n  `\n            },] },\n];\n/** @nocollapse */\nCalendarComponent.ctorParameters = () => [\n    { type: BusViewService },\n    { type: CalendarDOMService },\n    { type: ElementRef },\n    { type: NavigationService },\n    { type: Renderer2 },\n    { type: ChangeDetectorRef },\n    { type: NgZone },\n    { type: Injector },\n    { type: ScrollSyncService },\n    { type: DisabledDatesService },\n    { type: PickerService, decorators: [{ type: Optional }] }\n];\nCalendarComponent.propDecorators = {\n    id: [{ type: Input }],\n    focusedDate: [{ type: Input }],\n    min: [{ type: Input }],\n    max: [{ type: Input }],\n    rangeValidation: [{ type: Input }],\n    value: [{ type: Input }],\n    disabled: [{ type: Input }],\n    tabindex: [{ type: Input }],\n    tabIndex: [{ type: Input }],\n    disabledDates: [{ type: Input }],\n    navigation: [{ type: Input }],\n    activeView: [{ type: Input }],\n    bottomView: [{ type: Input }],\n    topView: [{ type: Input }],\n    weekNumber: [{ type: Input }, { type: HostBinding, args: ['class.k-week-number',] }],\n    activeViewChange: [{ type: Output }],\n    activeViewDateChange: [{ type: Output }],\n    valueChange: [{ type: Output }],\n    cellTemplate: [{ type: ContentChild, args: [CellTemplateDirective, { static: true },] }],\n    cellTemplateRef: [{ type: Input, args: ['cellTemplate',] }],\n    monthCellTemplate: [{ type: ContentChild, args: [MonthCellTemplateDirective, { static: true },] }],\n    monthCellTemplateRef: [{ type: Input, args: ['monthCellTemplate',] }],\n    yearCellTemplate: [{ type: ContentChild, args: [YearCellTemplateDirective, { static: true },] }],\n    yearCellTemplateRef: [{ type: Input, args: ['yearCellTemplate',] }],\n    decadeCellTemplate: [{ type: ContentChild, args: [DecadeCellTemplateDirective, { static: true },] }],\n    decadeCellTemplateRef: [{ type: Input, args: ['decadeCellTemplate',] }],\n    centuryCellTemplate: [{ type: ContentChild, args: [CenturyCellTemplateDirective, { static: true },] }],\n    centuryCellTemplateRef: [{ type: Input, args: ['centuryCellTemplate',] }],\n    weekNumberTemplate: [{ type: ContentChild, args: [WeekNumberCellTemplateDirective, { static: true },] }],\n    weekNumberTemplateRef: [{ type: Input, args: ['weekNumberTemplate',] }],\n    headerTitleTemplate: [{ type: ContentChild, args: [HeaderTitleTemplateDirective, { static: true },] }],\n    headerTitleTemplateRef: [{ type: Input, args: ['headerTitleTemplate',] }],\n    navigationItemTemplate: [{ type: ContentChild, args: [NavigationItemTemplateDirective, { static: true },] }],\n    navigationItemTemplateRef: [{ type: Input, args: ['navigationItemTemplate',] }],\n    navigationView: [{ type: ViewChild, args: [NavigationComponent,] }],\n    monthView: [{ type: ViewChild, args: [ViewListComponent,] }],\n    widgetId: [{ type: HostBinding, args: ['attr.id',] }],\n    widgetRole: [{ type: HostBinding, args: ['attr.role',] }],\n    calendarTabIndex: [{ type: HostBinding, args: ['attr.tabindex',] }],\n    ariaDisabled: [{ type: HostBinding, args: ['attr.aria-disabled',] }, { type: HostBinding, args: ['class.k-state-disabled',] }]\n};\n\n/**\n * @hidden\n */\nvar Arrow;\n(function (Arrow) {\n    Arrow[Arrow[\"Up\"] = 0] = \"Up\";\n    Arrow[Arrow[\"Down\"] = 1] = \"Down\";\n    Arrow[Arrow[\"None\"] = 2] = \"None\";\n})(Arrow || (Arrow = {}));\n\n/* tslint:disable:max-line-length */\nconst MIN_DOC_LINK$1 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DateInputComponent/#toc-min';\nconst MAX_DOC_LINK$1 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DateInputComponent/#toc-max';\nconst VALUE_DOC_LINK$1 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/dateinput/#toc-using-with-json';\nconst DATE_PART_REGEXP = /year|month|<day>/;\nconst TIME_PART_REGEXP = /hour|minute|second|millisecond/;\nconst SHORT_PATTERN_LENGTH_REGEXP = /d|M|H|h|m|s/;\nconst getTime = (date) => date ? date.getTime() : null;\nconst padZero = (length) => new Array(Math.max(length, 0)).fill('0').join('');\nconst unpadZero = (value) => value.replace(/^0*/, '');\nclass Mask {\n    constructor() {\n        this.symbols = \"\";\n    }\n}\nclass KendoDate {\n    constructor(intl, formatPlaceholder, format, value) {\n        this.intl = intl;\n        this.formatPlaceholder = formatPlaceholder;\n        this.format = format;\n        this.year = true;\n        this.month = true;\n        this.date = true;\n        this.hours = true;\n        this.minutes = true;\n        this.seconds = true;\n        this.milliseconds = true;\n        this.leadingZero = null;\n        this.monthNames = null;\n        this.typedMonthPart = \"\";\n        this.value = getDate(new Date());\n        this.knownParts = \"adHhmMsEy\";\n        this.symbols = {\n            \"E\": \"E\",\n            \"H\": \"H\",\n            \"M\": \"M\",\n            \"a\": \"a\",\n            \"d\": \"d\",\n            \"h\": \"h\",\n            \"m\": \"m\",\n            \"s\": \"s\",\n            \"y\": \"y\"\n        };\n        this.monthNames = this.allFormatedMonths();\n        this.dayPeriods = this.allDayPeriods();\n        if (!value) {\n            this.value = getDate(new Date());\n            const sampleFormat = this.dateFormatString(this.value, this.format).symbols;\n            for (let i = 0; i < sampleFormat.length; i++) {\n                this.setExisting(sampleFormat[i], false);\n            }\n        }\n        else {\n            this.value = cloneDate(value);\n        }\n    }\n    hasValue() {\n        const pred = (a, p) => a || p.type !== 'literal' && p.type !== 'dayperiod' && this.getExisting(p.pattern[0]);\n        return this.intl.splitDateFormat(this.format).reduce(pred, false);\n    }\n    getDateObject() {\n        for (let i = 0; i < this.knownParts.length; i++) {\n            if (!this.getExisting(this.knownParts[i])) {\n                return null;\n            }\n        }\n        return cloneDate(this.value);\n    }\n    getTextAndFormat() {\n        return this.merge(this.intl.formatDate(this.value, this.format), this.dateFormatString(this.value, this.format));\n    }\n    getExisting(symbol) {\n        switch (symbol) {\n            case \"y\": return this.year;\n            case \"M\":\n            case \"L\": return this.month;\n            case \"d\": return this.date;\n            case \"E\": return this.date && this.month && this.year;\n            case \"h\":\n            case \"H\": return this.hours;\n            case \"m\": return this.minutes;\n            case \"s\": return this.seconds;\n            default: return true;\n        }\n    }\n    setExisting(symbol, value) {\n        switch (symbol) {\n            case \"y\":\n                this.year = value;\n                if (value === false) {\n                    this.value.setFullYear(2000);\n                }\n                break; //allow 2/29 dates\n            case \"M\":\n                this.month = value;\n                if (value === false) {\n                    this.value.setMonth(0);\n                }\n                break; //make sure you can type 31 at day part\n            case \"d\":\n                this.date = value;\n                break;\n            case \"h\":\n            case \"H\":\n                this.hours = value;\n                break;\n            case \"m\":\n                this.minutes = value;\n                break;\n            case \"s\":\n                this.seconds = value;\n                break;\n            default: return;\n        }\n    }\n    modifyPart(symbol, offset) {\n        let newValue = cloneDate(this.value);\n        switch (symbol) {\n            case \"y\":\n                newValue.setFullYear(newValue.getFullYear() + offset);\n                break;\n            case \"M\":\n                newValue = addMonths(this.value, offset);\n                break;\n            case \"d\":\n            case \"E\":\n                newValue.setDate(newValue.getDate() + offset);\n                break;\n            case \"h\":\n            case \"H\":\n                newValue.setHours(newValue.getHours() + offset);\n                break;\n            case \"m\":\n                newValue.setMinutes(newValue.getMinutes() + offset);\n                break;\n            case \"s\":\n                newValue.setSeconds(newValue.getSeconds() + offset);\n                break;\n            case \"a\":\n                newValue.setHours(newValue.getHours() + (12 * offset));\n                break;\n            default: break;\n        }\n        if (newValue.getFullYear() > 0) {\n            this.setExisting(symbol, true);\n            this.value = newValue;\n        }\n    }\n    parsePart(symbol, currentChar, resetSegmentValue) {\n        if (!currentChar) {\n            this.resetLeadingZero();\n            this.setExisting(symbol, false);\n            return { value: null, switchToNext: false };\n        }\n        let baseDate = this.intl.formatDate(this.value, this.format);\n        let dateParts = this.dateFormatString(this.value, this.format);\n        let baseFormat = dateParts.symbols;\n        let replaced = false;\n        let prefix = \"\";\n        let current = \"\";\n        let suffix = \"\";\n        for (let i = 0; i < baseDate.length; i++) {\n            if (baseFormat[i] === symbol) {\n                current += this.getExisting(symbol) ? baseDate[i] : \"0\";\n                replaced = true;\n            }\n            else if (!replaced) {\n                prefix += baseDate[i];\n            }\n            else {\n                suffix += baseDate[i];\n            }\n        }\n        let currentMaxLength = current.length - 3;\n        let parsedDate = null;\n        const month = this.matchMonth(currentChar);\n        const dayPeriod = this.matchDayPeriod(currentChar, symbol);\n        const isZeroCurrentChar = currentChar === '0';\n        const leadingZero = (this.leadingZero || {})[symbol] || 0;\n        if (isZeroCurrentChar) {\n            let valueNumber = parseInt(resetSegmentValue ? currentChar : current + currentChar, 10);\n            if (valueNumber === 0 && !this.isAbbrMonth(dateParts.partMap, symbol)) {\n                this.incrementLeadingZero(symbol);\n            }\n        }\n        else {\n            this.resetLeadingZero();\n        }\n        for (let i = Math.max(0, currentMaxLength); i <= current.length; i++) {\n            let middle = resetSegmentValue ? currentChar : (current.substring(i) + currentChar);\n            let middleNumber = parseInt(middle, 10);\n            parsedDate = this.intl.parseDate(prefix + middle + suffix, this.format);\n            if (!parsedDate && !isNaN(middleNumber) && !isNaN(parseInt(currentChar, 10))) {\n                if (symbol === 'M' && !month) {\n                    const monthNumber = middleNumber - 1;\n                    if (monthNumber > -1 && monthNumber < 12) {\n                        parsedDate = cloneDate(this.value);\n                        parsedDate.setMonth(monthNumber);\n                        if (parsedDate.getMonth() !== monthNumber) {\n                            parsedDate = lastDayOfMonth(addMonths(parsedDate, -1));\n                        }\n                    }\n                }\n                if (symbol === 'y') {\n                    parsedDate = createDate(parseInt(middle, 10), this.month ? this.value.getMonth() : 0, this.date ? this.value.getDate() : 1, this.hours ? this.value.getHours() : 0, this.minutes ? this.value.getMinutes() : 0, this.seconds ? this.value.getSeconds() : 0, this.milliseconds ? this.value.getMilliseconds() : 0);\n                    if (this.date && parsedDate.getDate() !== this.value.getDate()) {\n                        parsedDate = lastDayOfMonth(addMonths(parsedDate, -1));\n                    }\n                }\n            }\n            if (parsedDate) {\n                //move to next segment if the part will overflow with next char\n                //when start from empty date (01, then 010), padded zeros should be trimmed\n                const patternValue = this.partPattern(dateParts.partMap, symbol).pattern;\n                const peekDate = this.intl.parseDate(`${prefix}${this.peek(middle, patternValue)}${suffix}`, this.format);\n                const patternLength = this.patternLength(patternValue) || patternValue.length;\n                const patternSatisfied = (leadingZero + (unpadZero(middle) || currentChar).length) >= patternLength;\n                const switchToNext = peekDate === null || patternSatisfied;\n                this.value = parsedDate;\n                this.setExisting(symbol, true);\n                return { value: this.value, switchToNext: switchToNext };\n            }\n        }\n        if (month) {\n            parsedDate = this.intl.parseDate(prefix + month + suffix, this.format);\n            if (parsedDate) {\n                this.value = parsedDate;\n                this.setExisting(symbol, true);\n                return { value: this.value, switchToNext: false };\n            }\n        }\n        if (dayPeriod) {\n            parsedDate = this.intl.parseDate(prefix + dayPeriod + suffix, this.format);\n            if (parsedDate) {\n                this.value = parsedDate;\n                return { value: this.value, switchToNext: true };\n            }\n        }\n        if (isZeroCurrentChar) {\n            this.setExisting(symbol, false);\n        }\n        return { value: null, switchToNext: false };\n    }\n    resetLeadingZero() {\n        const hasLeadingZero = this.leadingZero !== null;\n        this.setLeadingZero(null);\n        return hasLeadingZero;\n    }\n    setLeadingZero(leadingZero) {\n        this.leadingZero = leadingZero;\n    }\n    incrementLeadingZero(symbol) {\n        const leadingZero = this.leadingZero || {};\n        leadingZero[symbol] = (leadingZero[symbol] || 0) + 1;\n        this.leadingZero = leadingZero;\n    }\n    isAbbrMonth(parts, symbol) {\n        const pattern = this.partPattern(parts, symbol);\n        return pattern.type === 'month' && pattern.names;\n    }\n    partPattern(parts, symbol) {\n        return parts.filter((part) => part.pattern.indexOf(symbol) !== -1)[0];\n    }\n    peek(value, pattern) {\n        const peekValue = unpadZero(value) + '0';\n        return padZero(pattern.length - peekValue.length) + peekValue;\n    }\n    matchMonth(typedChar) {\n        this.typedMonthPart += typedChar.toLowerCase();\n        if (!this.monthNames) {\n            return \"\";\n        }\n        while (this.typedMonthPart.length > 0) {\n            for (let i = 0; i < this.monthNames.length; i++) {\n                if (this.monthNames[i].toLowerCase().indexOf(this.typedMonthPart) === 0) {\n                    return this.monthNames[i];\n                }\n            }\n            const monthAsNum = parseInt(this.typedMonthPart, 10);\n            if (monthAsNum >= 1 && monthAsNum <= 12 && monthAsNum.toString() === this.typedMonthPart /*ensure they exact match*/) {\n                return this.monthNames[monthAsNum - 1];\n            }\n            this.typedMonthPart = this.typedMonthPart.substring(1, this.typedMonthPart.length);\n        }\n        return \"\";\n    }\n    matchDayPeriod(typedChar, symbol) {\n        const lowerChart = String(typedChar).toLowerCase();\n        if (symbol === 'a' && this.dayPeriods) {\n            if (this.dayPeriods.am.toLowerCase().startsWith(lowerChart)) {\n                return this.dayPeriods.am;\n            }\n            else if (this.dayPeriods.pm.toLowerCase().startsWith(lowerChart)) {\n                return this.dayPeriods.pm;\n            }\n        }\n        return '';\n    }\n    allFormatedMonths() {\n        const dateFormatParts = this.intl.splitDateFormat(this.format);\n        for (let i = 0; i < dateFormatParts.length; i++) {\n            if (dateFormatParts[i].type === \"month\" && dateFormatParts[i].names) {\n                return this.intl.dateFormatNames(dateFormatParts[i].names);\n            }\n        }\n        return null;\n    }\n    allDayPeriods() {\n        const dateFormatParts = this.intl.splitDateFormat(this.format);\n        for (let i = 0; i < dateFormatParts.length; i++) {\n            if (dateFormatParts[i].type === \"dayperiod\" && dateFormatParts[i].names) {\n                return this.intl.dateFormatNames(dateFormatParts[i].names);\n            }\n        }\n        return null;\n    }\n    patternLength(pattern) {\n        if (pattern[0] === 'y') {\n            return 4;\n        }\n        if (SHORT_PATTERN_LENGTH_REGEXP.test(pattern)) {\n            return 2;\n        }\n        return 0;\n    }\n    //TODO: REMOVE!\n    dateFormatString(date, format) {\n        const dateFormatParts = this.intl.splitDateFormat(format);\n        const parts = [];\n        const partMap = [];\n        for (let i = 0; i < dateFormatParts.length; i++) {\n            let partLength = this.intl.formatDate(date, { pattern: dateFormatParts[i].pattern }).length;\n            while (partLength > 0) {\n                parts.push(this.symbols[dateFormatParts[i].pattern[0]] || \"_\");\n                partMap.push(dateFormatParts[i]);\n                partLength--;\n            }\n        }\n        const returnValue = new Mask();\n        returnValue.symbols = parts.join(\"\");\n        returnValue.partMap = partMap;\n        return returnValue;\n    }\n    merge(text, mask) {\n        // Important: right to left.\n        let resultText = \"\";\n        let resultFormat = \"\";\n        let format = mask.symbols;\n        for (let r = format.length - 1; r >= 0; r--) {\n            if (this.knownParts.indexOf(format[r]) === -1 || this.getExisting(format[r])) {\n                resultText = text[r] + resultText;\n                resultFormat = format[r] + resultFormat;\n            }\n            else {\n                const currentSymbol = format[r];\n                while (r >= 0 && currentSymbol === format[r]) {\n                    r--;\n                }\n                r++;\n                if (this.leadingZero && this.leadingZero[currentSymbol]) {\n                    resultText = '0' + resultText;\n                }\n                else {\n                    resultText = this.dateFieldName(mask.partMap[r]) + resultText;\n                }\n                while (resultFormat.length < resultText.length) {\n                    resultFormat = format[r] + resultFormat;\n                }\n            }\n        }\n        return [resultText, resultFormat];\n    }\n    dateFieldName(part) {\n        const formatPlaceholder = this.formatPlaceholder || 'wide';\n        if (formatPlaceholder[part.type]) {\n            return formatPlaceholder[part.type];\n        }\n        if (formatPlaceholder === 'formatPattern') {\n            return part.pattern;\n        }\n        return this.intl.dateFieldName(Object.assign(part, { nameType: formatPlaceholder }));\n    }\n}\n/**\n * Represents the [Kendo UI DateInput component for Angular]({% slug overview_dateinput %}#toc-basic-usage).\n */\nclass DateInputComponent {\n    constructor(cdr, intl, renderer, element, ngZone, injector, localization, pickerService) {\n        this.cdr = cdr;\n        this.intl = intl;\n        this.renderer = renderer;\n        this.element = element;\n        this.ngZone = ngZone;\n        this.injector = injector;\n        this.localization = localization;\n        this.pickerService = pickerService;\n        /**\n         * @hidden\n         */\n        this.focusableId = `k-${guid()}`;\n        /**\n         * Sets or gets the `disabled` property of the DateInput and\n         * determines whether the component is active\n         * ([see example]({% slug disabled_dateinput %})).\n         */\n        this.disabled = false;\n        /**\n         * Sets or gets the read-only state of the DateInput\n         * ([see example]({% slug readonly_dateinput %})).\n         */\n        this.readonly = false;\n        /**\n         * Sets the title of the input element of the DateInput.\n         */\n        this.title = \"\";\n        /**\n         * Sets or gets the `tabIndex` property of the DateInput.\n         * .\n         */\n        this.tabindex = 0;\n        /**\n         * Specifies the date format that is used to display the input value\n         * ([see example]({% slug formats_dateinput %})).\n         */\n        this.format = \"d\";\n        /**\n         * Specifies the hint the DateInput displays when its value is `null`.\n         * For more information, refer to the article on\n         * [placeholders]({% slug placeholders_dateinput %}).\n         *\n         * @example\n         * ```ts\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-dateinput placeholder=\"Enter birth date...\"></kendo-dateinput>\n         * `\n         * })\n         * class AppComponent { }\n         * ```\n         */\n        this.placeholder = null;\n        /**\n         * Determines whether the built-in min or max validators are to be enforced when a form is being validated.\n         */\n        this.rangeValidation = true;\n        /**\n         * @hidden\n         * Based on the min and max values, specifies whether the value will be auto-corrected while typing.\n         */\n        this.autoCorrect = false;\n        /**\n         * Specifies whether the **Up** and **Down** spin buttons will be rendered.\n         * For more information, refer to the article on\n         * [spinner buttons]({% slug spinbuttons_dateinput %}).\n         */\n        this.spinners = false;\n        /**\n         * @hidden\n         */\n        this.isPopupOpen = false;\n        /**\n         * @hidden\n         */\n        this.hasPopup = false;\n        /**\n         * Fires each time the user selects a new value.\n         * For more information, refer to the section on\n         * [events]({% slug overview_dateinput %}#toc-events).\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * Fires each time the user selects a new value.\n         * For more information, refer to the section on\n         * [events]({% slug overview_dateinput %}#toc-events).\n         */\n        this.valueUpdate = new EventEmitter();\n        /**\n         * Fires each time the user focuses the input element.\n         * For more information, refer to the section on\n         * [events]({% slug overview_dateinput %}#toc-events).\n         *\n         * > To wire the event programmatically, use the `onFocus` property.\n         *\n         * @example\n         * ```ts\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-dateinput (focus)=\"handleFocus()\"></kendo-dateinput>\n         * `\n         * })\n         * class AppComponent {\n         *   public handleFocus(): void {\n         *      console.log(\"Component is focused\");\n         *   }\n         * }\n         * ```\n         *\n         */\n        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the input element gets blurred.\n         * For more information, refer to the section on\n         * [events]({% slug overview_dateinput %}#toc-events).\n         *\n         * > To wire the event programmatically, use the `onBlur` property.\n         *\n         * @example\n         * ```ts\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-dateinput (blur)=\"handleBlur()\"></kendo-dateinput>\n         * `\n         * })\n         * class AppComponent {\n         *   public handleBlur(): void {\n         *      console.log(\"Component is blurred\");\n         *   }\n         * }\n         * ```\n         *\n         */\n        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename\n        this.arrow = Arrow;\n        this.arrowDirection = Arrow.None;\n        this.formatSections = { date: false, time: false };\n        this.hasMousedown = false;\n        this.currentValue = \"\";\n        this.currentFormat = \"\";\n        this.backspace = false;\n        this.resetSegmentValue = true;\n        this.minValidateFn = noop;\n        this.maxValidateFn = noop;\n        this._value = null;\n        this._active = false;\n        this.kendoDate = null;\n        this.paste = false;\n        this.domEvents = [];\n        this.onControlChange = noop;\n        this.onControlTouched = noop;\n        this.onValidatorChange = noop;\n        this.symbolsMap = this.dateSymbolMap();\n        this.updateFormatSections();\n        if (this.pickerService) {\n            this.pickerService.input = this;\n        }\n    }\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n        this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n        return this.tabindex;\n    }\n    /**\n     * Specifies the biggest date that is valid\n     * ([see example]({% slug dateranges_dateinput %})).\n     */\n    set max(max) {\n        this._max = max;\n        this.ariaValueMax = getTime(max);\n    }\n    get max() {\n        return this._max;\n    }\n    /**\n     * Specifies the smallest date that is valid\n     * ([see example]({% slug dateranges_dateinput %})).\n     */\n    set min(min) {\n        this._min = min;\n        this.ariaValueMin = getTime(min);\n    }\n    get min() {\n        return this._min;\n    }\n    /**\n     * Specifies the value of the DateInput component.\n     *\n     * > The `value` has to be a valid [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance.\n     */\n    set value(value) {\n        this.verifyValue(value);\n        if (this.autoCorrect && !isInRange(value, this.min, this.max)) {\n            return;\n        }\n        this._value = cloneDate(value);\n        this.valueUpdate.emit(cloneDate(value));\n    }\n    get value() {\n        return this._value;\n    }\n    get wrapperClass() {\n        return true;\n    }\n    get disabledClass() {\n        return this.disabled;\n    }\n    get inputElement() {\n        return this.dateInput ? this.dateInput.nativeElement : null;\n    }\n    get inputValue() {\n        return (this.inputElement || {}).value || '';\n    }\n    get isActive() {\n        return this._active;\n    }\n    set isActive(value) {\n        this._active = value;\n        if (!this.wrap) {\n            return;\n        }\n        const element = this.wrap.nativeElement;\n        if (value) {\n            this.renderer.addClass(element, 'k-state-focused');\n        }\n        else {\n            this.renderer.removeClass(element, 'k-state-focused');\n        }\n    }\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the component is empty\n     */\n    isEmpty() {\n        return !this.currentValue || !String(this.currentValue).trim();\n    }\n    /**\n     * @hidden\n     */\n    containsElement(element) {\n        return Boolean(closest(element, node => node === this.element.nativeElement));\n    }\n    /**\n     * @hidden\n     */\n    ngOnChanges(changes) {\n        this.verifyRange();\n        if (changes.min || changes.max || changes.rangeValidation) {\n            this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop;\n            this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop;\n            this.onValidatorChange();\n        }\n        if (changes.format) {\n            this.symbolsMap = this.dateSymbolMap();\n            this.updateFormatSections();\n        }\n        const isEqualToKendoDate = this.kendoDate && isEqual(this.value, this.kendoDate.getDateObject());\n        if (changes.format || !isEqualToKendoDate || changes.placeholder) {\n            this.kendoDate = this.getKendoDate(this.value);\n            this.updateElementValue(this.isActive);\n        }\n    }\n    ngOnDestroy() {\n        if (this.intlSubscription) {\n            this.intlSubscription.unsubscribe();\n        }\n        if (this.pickerService) {\n            this.pickerService.input = null;\n        }\n        this.domEvents.forEach(unbindCallback => unbindCallback());\n    }\n    /**\n     * @hidden\n     */\n    validate(control) {\n        return this.minValidateFn(control) || this.maxValidateFn(control);\n    }\n    /**\n     * @hidden\n     */\n    registerOnValidatorChange(fn) {\n        this.onValidatorChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    ngOnInit() {\n        this.kendoDate = this.getKendoDate(this.value);\n        this.updateElementValue();\n        this.intlSubscription = this.intl.changes.subscribe(this.intlChange.bind(this));\n        this.control = this.injector.get(NgControl, null);\n        if (this.element) {\n            this.renderer.removeAttribute(this.element.nativeElement, 'tabindex');\n            this.ngZone.runOutsideAngular(() => {\n                this.bindEvents();\n            });\n        }\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n        this.cdr.markForCheck();\n    }\n    //ngModel binding\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n        this.verifyValue(value);\n        this.kendoDate = this.getKendoDate(value);\n        this.value = cloneDate(value);\n        this.updateElementValue(this.isActive);\n    }\n    /**\n     * @hidden\n     */\n    triggerChange() {\n        const value = this.kendoDate.getDateObject();\n        if (+value !== +this.value) {\n            this.value = cloneDate(value);\n            this.notify();\n        }\n    }\n    /**\n     * @hidden\n     */\n    notify() {\n        this.ngZone.run(() => {\n            this.onControlChange(cloneDate(this.value));\n            this.valueChange.emit(cloneDate(this.value));\n        });\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.onControlChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.onControlTouched = fn;\n    }\n    /**\n     * Focuses the DateInput component.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"dateinput.focus()\">Focus date input</button>\n     *  <kendo-dateinput #dateinput></kendo-dateinput>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n        const input = this.inputElement;\n        if (input) {\n            input.focus();\n            this.selectDateSegment(this.currentFormat[0]);\n        }\n    }\n    /**\n     * Blurs the DateInput component.\n     */\n    blur() {\n        const input = this.inputElement;\n        if (input) {\n            input.blur();\n        }\n    }\n    /**\n     * @hidden\n     */\n    handleButtonClick(offset) {\n        this.arrowDirection = Arrow.None;\n        this.modifyDateSegmentValue(offset);\n    }\n    /**\n     * @hidden\n     */\n    modifyDateSegmentValue(offset) {\n        const caret = this.caret();\n        const symbol = this.currentFormat[caret[0]];\n        const step = (this.steps || {})[this.symbolsMap[symbol]] || 1;\n        this.kendoDate.modifyPart(symbol, offset * step);\n        this.putDateInRange();\n        this.updateElementValue(this.isActive);\n        this.triggerChange();\n        this.selectDateSegment(symbol);\n    }\n    /**\n     * @hidden\n     */\n    switchDateSegment(offset) {\n        const caret = this.caret();\n        if (this.kendoDate.resetLeadingZero()) {\n            this.updateElementValue(this.isActive);\n        }\n        if (caret[0] < caret[1] && this.currentFormat[caret[0]] !== this.currentFormat[caret[1] - 1]) {\n            this.selectNearestSegment(offset > 0 ? caret[0] : caret[1] - 1);\n            this.resetSegmentValue = true;\n            return true;\n        }\n        const previousFormatSymbol = this.currentFormat[caret[0]];\n        let a = caret[0] + offset;\n        while (a > 0 && a < this.currentFormat.length) {\n            if (this.currentFormat[a] !== previousFormatSymbol &&\n                this.currentFormat[a] !== \"_\") {\n                break;\n            }\n            a += offset;\n        }\n        if (this.currentFormat[a] === \"_\") {\n            //there is not known symbol found\n            return false;\n        }\n        let b = a;\n        while (b >= 0 && b < this.currentFormat.length) {\n            if (this.currentFormat[b] !== this.currentFormat[a]) {\n                break;\n            }\n            b += offset;\n        }\n        if (a > b && (b + 1 !== caret[0] || a + 1 !== caret[1])) {\n            this.caret(b + 1, a + 1);\n            this.resetSegmentValue = true;\n            return true;\n        }\n        else if (a < b && (a !== caret[0] || b !== caret[1])) {\n            this.caret(a, b);\n            this.resetSegmentValue = true;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * @hidden\n     */\n    selectDateSegment(symbol) {\n        let begin = -1;\n        let end = 0;\n        for (let i = 0; i < this.currentFormat.length; i++) {\n            if (this.currentFormat[i] === symbol) {\n                end = i + 1;\n                if (begin === -1) {\n                    begin = i;\n                }\n            }\n        }\n        if (begin < 0) {\n            begin = 0;\n        }\n        this.caret(0, 0);\n        this.caret(begin, end);\n    }\n    /**\n     * @hidden\n     */\n    handleClick() {\n        this.hasMousedown = false;\n        if (this.isActive) {\n            this.selectNearestSegment(this.caret()[0]);\n        }\n    }\n    /**\n     * @hidden\n     */\n    handleDragAndDrop(args) {\n        args.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n    handleMousedown() {\n        this.hasMousedown = true;\n    }\n    /**\n     * @hidden\n     */\n    handleFocus(args) {\n        this.isActive = true;\n        this.updateElementValue();\n        if (!this.hasMousedown) {\n            this.caret(0, this.inputValue.length);\n        }\n        this.hasMousedown = false;\n        if (hasObservers(this.onFocus)) {\n            this.ngZone.run(() => {\n                this.emitFocus(args);\n            });\n        }\n        else {\n            this.emitFocus(args);\n        }\n    }\n    /**\n     * @hidden\n     */\n    handleBlur(args) {\n        this.isActive = false;\n        this.resetSegmentValue = true;\n        this.kendoDate.resetLeadingZero();\n        this.updateElementValue();\n        if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {\n            this.ngZone.run(() => {\n                this.onControlTouched();\n                this.emitBlur(args);\n            });\n        }\n        else {\n            this.emitBlur(args);\n        }\n    }\n    getKendoDate(value) {\n        const { leadingZero } = (this.kendoDate || {}) || null;\n        const kendoDate = new KendoDate(this.intl, this.formatPlaceholder, this.format, value);\n        kendoDate.setLeadingZero(this.isActive ? leadingZero : null);\n        return kendoDate;\n    }\n    dateSymbolMap() {\n        const reducer = (map$$1, part) => {\n            map$$1[part.pattern[0]] = part.type;\n            return map$$1;\n        };\n        return this.intl.splitDateFormat(this.format).reduce(reducer, {});\n    }\n    updateElementValue(isActive) {\n        const start = this.caret()[0]; //XXX: get caret position before input is updated\n        const texts = this.kendoDate.getTextAndFormat();\n        const showPlaceholder = !this.isActive && this.placeholder !== null && this.placeholder !== undefined && !this.kendoDate.hasValue();\n        const input = this.inputElement;\n        this.currentFormat = texts[1];\n        this.currentValue = !showPlaceholder ? texts[0] : '';\n        this.renderer.setProperty(input, \"value\", this.currentValue);\n        if (input.placeholder !== this.placeholder) {\n            this.renderer.setProperty(input, \"placeholder\", this.placeholder);\n        }\n        const currentDate = this.kendoDate.getDateObject();\n        this.ariaValueNow = getTime(currentDate);\n        this.ariaValueText = this.intl.formatDate(currentDate, this.format);\n        if (isActive) {\n            this.selectNearestSegment(start);\n        }\n    }\n    caret(start, end = start) {\n        const isPosition = start !== undefined;\n        let returnValue = [start, start];\n        const element = this.inputElement;\n        if (isPosition && (this.disabled || this.readonly)) {\n            return undefined;\n        }\n        try {\n            if (element.selectionStart !== undefined) {\n                if (isPosition) {\n                    if (isDocumentAvailable() && document.activeElement !== element) {\n                        element.focus();\n                    }\n                    element.setSelectionRange(start, end);\n                }\n                returnValue = [element.selectionStart, element.selectionEnd];\n            }\n        }\n        catch (e) {\n            returnValue = [];\n        }\n        return returnValue;\n    }\n    selectNearestSegment(index) {\n        // Finds the nearest (in both directions) known part.\n        for (let i = index, j = index - 1; i < this.currentFormat.length || j >= 0; i++, j--) {\n            if (i < this.currentFormat.length && this.currentFormat[i] !== \"_\") {\n                this.selectDateSegment(this.currentFormat[i]);\n                return;\n            }\n            if (j >= 0 && this.currentFormat[j] !== \"_\") {\n                this.selectDateSegment(this.currentFormat[j]);\n                return;\n            }\n        }\n    }\n    verifyRange() {\n        if (!isDevMode()) {\n            return;\n        }\n        if (!isValidRange(this.min, this.max)) {\n            throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK$1} and ${MAX_DOC_LINK$1}.`);\n        }\n    }\n    verifyValue(value) {\n        if (!isDevMode()) {\n            return;\n        }\n        if (value && !(value instanceof Date)) {\n            throw new Error(`The 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK$1} for possible resolution.`);\n        }\n    }\n    putDateInRange() {\n        const currentDate = this.kendoDate.getDateObject();\n        const candidate = dateInRange(currentDate, this.min, this.max);\n        if (this.autoCorrect && !isEqual(currentDate, candidate)) {\n            this.kendoDate = this.getKendoDate(candidate);\n        }\n    }\n    updateFormatSections() {\n        this.formatSections = this.intl.splitDateFormat(this.format)\n            .reduce(({ date, time }, p) => {\n            return {\n                date: date || DATE_PART_REGEXP.test(p.type),\n                time: time || TIME_PART_REGEXP.test(p.type)\n            };\n        }, { date: false, time: false });\n    }\n    intlChange() {\n        this.updateFormatSections();\n        this.kendoDate = this.getKendoDate(this.value);\n        this.updateElementValue(this.isActive);\n    }\n    updateOnPaste() {\n        const value = this.intl.parseDate(this.inputValue, this.format) || this.value;\n        const notify = +value !== +this.value;\n        this.writeValue(value);\n        if (notify) {\n            this.notify();\n        }\n    }\n    bindEvents() {\n        const element = this.element.nativeElement;\n        const mousewheelHandler = this.handleMouseWheel.bind(this);\n        this.domEvents.push(this.renderer.listen(element, 'DOMMouseScroll', mousewheelHandler), this.renderer.listen(element, 'mousewheel', mousewheelHandler), this.renderer.listen(element, 'keydown', this.handleKeydown.bind(this)), this.renderer.listen(element, 'paste', this.handlePaste.bind(this)), this.renderer.listen(element, 'input', this.handleInput.bind(this)));\n    }\n    handleMouseWheel(event) {\n        if (this.disabled || this.readonly || !this.isActive) {\n            return;\n        }\n        event = window.event || event;\n        if (event.shiftKey) {\n            this.switchDateSegment((event.wheelDelta || -event.detail) > 0 ? -1 : 1);\n        }\n        else {\n            this.modifyDateSegmentValue((event.wheelDelta || -event.detail) > 0 ? 1 : -1);\n        }\n        event.returnValue = false;\n        if (event.preventDefault) {\n            event.preventDefault();\n        }\n        if (event.stopPropagation) {\n            event.stopPropagation();\n        }\n    }\n    handlePaste() {\n        this.paste = true;\n    }\n    handleKeydown(event) {\n        if (this.disabled || this.readonly || event.altKey || event.ctrlKey || event.metaKey) {\n            return;\n        }\n        if (event.keyCode === Keys.Tab) {\n            const moved = this.switchDateSegment(event.shiftKey ? -1 : 1);\n            if (moved) {\n                event.preventDefault();\n            }\n            return;\n        }\n        if (event.keyCode === Keys.Backspace) {\n            this.backspace = true;\n            return;\n        }\n        switch (event.keyCode) {\n            case Keys.ArrowDown:\n                this.modifyDateSegmentValue(-1);\n                break;\n            case Keys.ArrowUp:\n                this.modifyDateSegmentValue(1);\n                break;\n            case Keys.ArrowRight:\n                this.switchDateSegment(1);\n                break;\n            case Keys.ArrowLeft:\n                this.switchDateSegment(-1);\n                break;\n            case Keys.Home:\n                this.selectNearestSegment(0);\n                break;\n            case Keys.End:\n                this.selectNearestSegment(this.inputValue.length);\n                break;\n            default:\n                return; //skip the preventDefault if we didn't handled the keyCode\n        }\n        event.preventDefault();\n    }\n    handleInput() {\n        if (this.disabled || this.readonly) {\n            return;\n        }\n        if (this.paste) {\n            this.updateOnPaste();\n            this.paste = false;\n            return;\n        }\n        const diff = approximateStringMatching(this.currentValue, this.currentFormat, this.inputValue, this.caret()[0]);\n        const navigationOnly = (diff.length === 1 && diff[0][1] === \"_\");\n        let switchPart = false;\n        if (!navigationOnly) {\n            let parsedPart;\n            for (let i = 0; i < diff.length; i++) {\n                parsedPart = this.kendoDate.parsePart(diff[i][0], diff[i][1], this.resetSegmentValue);\n                switchPart = parsedPart.switchToNext;\n            }\n            const candidate = this.kendoDate.getDateObject();\n            if (this.value && candidate && !this.formatSections.date) {\n                this.kendoDate = this.getKendoDate(setTime(this.value, candidate));\n            }\n        }\n        this.resetSegmentValue = false;\n        this.putDateInRange();\n        this.updateElementValue(this.isActive);\n        this.triggerChange();\n        if (diff.length && diff[0][0] !== \"_\") {\n            this.selectDateSegment(diff[0][0]);\n        }\n        if (switchPart || navigationOnly) {\n            this.switchDateSegment(1);\n        }\n        if (this.backspace) {\n            this.switchDateSegment(-1);\n        }\n        this.backspace = false;\n    }\n    emitFocus(args) {\n        this.onFocus.emit();\n        if (this.pickerService) {\n            this.pickerService.onFocus.emit(args);\n        }\n    }\n    emitBlur(args) {\n        this.onBlur.emit();\n        if (this.pickerService) {\n            this.pickerService.onBlur.emit(args);\n        }\n    }\n}\nDateInputComponent.decorators = [\n    { type: Component, args: [{\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                exportAs: 'kendo-dateinput',\n                providers: [\n                    { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => DateInputComponent), multi: true },\n                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => DateInputComponent), multi: true },\n                    { provide: L10N_PREFIX, useValue: 'kendo.dateinput' },\n                    { provide: KendoInput, useExisting: forwardRef(() => DateInputComponent) },\n                    LocalizationService\n                ],\n                selector: 'kendo-dateinput',\n                template: `\n    <ng-container kendoDateInputLocalizedMessages\n        i18n-increment=\"kendo.dateinput.increment|The label for the **Increment** button in the DateInput\"\n        increment=\"Increase value\"\n\n        i18n-decrement=\"kendo.dateinput.decrement|The label for the **Decrement** button in the DateInput\"\n        decrement=\"Decrease value\"\n    >\n    </ng-container>\n    <span class=\"k-dateinput-wrap\" #wrap>\n        <input\n            #dateInput\n            autocomplete=\"off\"\n            autocorrect=\"off\"\n            autocapitalize=\"off\"\n            spellcheck=\"false\"\n            class=\"k-input\"\n            role=\"spinbutton\"\n            [id]=\"focusableId\"\n            [title]=\"title\"\n            [tabindex]=\"tabindex\"\n            [disabled]=\"disabled\"\n            [readonly]=\"readonly\"\n            [placeholder]=\"placeholder\"\n            [attr.aria-expanded]=\"isPopupOpen\"\n            [attr.aria-haspopup]=\"hasPopup\"\n            [attr.aria-valuemin]=\"ariaValueMin\"\n            [attr.aria-valuemax]=\"ariaValueMax\"\n            [attr.aria-valuenow]=\"ariaValueNow\"\n            [attr.aria-valuetext]=\"ariaValueText\"\n            [kendoEventsOutsideAngular]=\"{\n                click: handleClick,\n                focus: handleFocus,\n                mousedown: handleMousedown,\n                touchstart: handleMousedown,\n                dragstart: handleDragAndDrop,\n                drop: handleDragAndDrop,\n                blur: handleBlur\n            }\"\n            [scope]=\"this\"\n            />\n        <span *ngIf=\"spinners\" class=\"k-select\" (mousedown)=\"$event.preventDefault()\">\n            <span\n                class=\"k-link k-link-increase\"\n                [class.k-state-active]=\"arrowDirection === arrow.Up\"\n                (mousedown)=\"arrowDirection = arrow.Up\"\n                (mouseleave)=\"arrowDirection = arrow.None\"\n                (click)=\"handleButtonClick(1)\"\n                [title]=\"localization.get('increment')\"\n                [attr.aria-label]=\"localization.get('increment')\">\n                <span class=\"k-icon k-i-arrow-n\"></span>\n            </span>\n            <span\n                class=\"k-link k-link-decrease\"\n                (click)=\"handleButtonClick(-1)\"\n                [class.k-state-active]=\"arrowDirection === arrow.Down\"\n                (mousedown)=\"arrowDirection = arrow.Down\"\n                (mouseleave)=\"arrowDirection = arrow.None\"\n                [title]=\"localization.get('decrement')\"\n                [attr.aria-label]=\"localization.get('decrement')\">\n                <span class=\"k-icon k-i-arrow-s\"></span>\n            </span>\n        </span>\n    </span>\n  `\n            },] },\n];\n/** @nocollapse */\nDateInputComponent.ctorParameters = () => [\n    { type: ChangeDetectorRef },\n    { type: IntlService },\n    { type: Renderer2 },\n    { type: ElementRef },\n    { type: NgZone },\n    { type: Injector },\n    { type: LocalizationService },\n    { type: PickerService, decorators: [{ type: Optional }] }\n];\nDateInputComponent.propDecorators = {\n    focusableId: [{ type: Input }],\n    disabled: [{ type: Input }],\n    readonly: [{ type: Input }],\n    title: [{ type: Input }],\n    tabindex: [{ type: Input }],\n    tabIndex: [{ type: Input }],\n    format: [{ type: Input }],\n    formatPlaceholder: [{ type: Input }],\n    placeholder: [{ type: Input }],\n    steps: [{ type: Input }],\n    max: [{ type: Input }],\n    min: [{ type: Input }],\n    rangeValidation: [{ type: Input }],\n    autoCorrect: [{ type: Input }],\n    value: [{ type: Input }],\n    spinners: [{ type: Input }],\n    isPopupOpen: [{ type: Input }],\n    hasPopup: [{ type: Input }],\n    valueChange: [{ type: Output }],\n    valueUpdate: [{ type: Output }],\n    onFocus: [{ type: Output, args: ['focus',] }],\n    onBlur: [{ type: Output, args: ['blur',] }],\n    dateInput: [{ type: ViewChild, args: ['dateInput', { static: true },] }],\n    wrap: [{ type: ViewChild, args: ['wrap',] }],\n    wrapperClass: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-dateinput',] }],\n    disabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }]\n};\n\n/**\n * A preventable event instance which is triggered by the `open` and `close` events.\n */\nclass PreventableEvent {\n    constructor() {\n        this.prevented = false;\n    }\n    /**\n     * Prevents the default action for a specified event.\n     * In this way, the source component suppresses the built-in behavior that follows the event.\n     */\n    preventDefault() {\n        this.prevented = true;\n    }\n    /**\n     * If the event is prevented by any of its subscribers, returns `true`.\n     *\n     * @returns `true` if the default action was prevented. Otherwise, returns `false`.\n     */\n    isDefaultPrevented() {\n        return this.prevented;\n    }\n}\n\n/**\n * @hidden\n */\nconst TOUCH_ENABLED = new InjectionToken('dateinputs-touch-enabled');\n\n/**\n * @hidden\n */\nconst disabledDatesValidator = (isDateDisabled) => {\n    return (control) => {\n        if (!isDateDisabled || !control.value) {\n            return null;\n        }\n        const error = {\n            disabledDate: true\n        };\n        return isDateDisabled(control.value) ? error : null;\n    };\n};\n\n/* tslint:disable:max-line-length */\nconst MIN_DOC_LINK$2 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DatePickerComponent/#toc-min';\nconst MAX_DOC_LINK$2 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DatePickerComponent/#toc-max';\nconst VALUE_DOC_LINK$2 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/datepicker/#toc-using-with-json';\n/**\n * Represents the [Kendo UI DatePicker component for Angular]({% slug overview_datepicker %}#toc-basic-usage).\n */\nclass DatePickerComponent {\n    constructor(zone, localization, cdr, popupService, element, renderer, injector, pickerService, disabledDatesService, touchEnabled$$1) {\n        this.zone = zone;\n        this.localization = localization;\n        this.cdr = cdr;\n        this.popupService = popupService;\n        this.element = element;\n        this.renderer = renderer;\n        this.injector = injector;\n        this.pickerService = pickerService;\n        this.disabledDatesService = disabledDatesService;\n        this.touchEnabled = touchEnabled$$1;\n        /**\n         * @hidden\n         */\n        this.focusableId = `k-${guid()}`;\n        /**\n         * Defines the active view that the Calendar initially renders\n         * ([see example]({% slug activeview_datepicker %})).\n         * By default, the active view is `month`.\n         *\n         * > You have to set `activeView` within the `topView`-`bottomView` range.\n         */\n        this.activeView = CalendarViewEnum[CalendarViewEnum.month];\n        /**\n         * Defines the bottommost Calendar view to which the user can navigate\n         * ([see example]({% slug dates_datepicker %}#toc-partial-dates)).\n         */\n        this.bottomView = CalendarViewEnum[CalendarViewEnum.month];\n        /**\n         * Defines the topmost Calendar view to which the user can navigate\n         * ([see example]({% slug dates_datepicker %}#toc-partial-dates)).\n         */\n        this.topView = CalendarViewEnum[CalendarViewEnum.century];\n        /**\n         * Sets or gets the `disabled` property of the DatePicker and determines whether the component is active\n         * ([see example]({% slug disabled_datepicker %})).\n         */\n        this.disabled = false;\n        /**\n         * Sets the read-only state of the DatePicker\n         * ([see example]({% slug readonly_datepicker %})).\n         */\n        this.readonly = false;\n        /**\n         * Sets or gets the `navigation` property of the Calendar\n         * and determines whether the navigation side-bar is displayed.\n         * ([see example]({% slug sidebar_datepicker %})).\n         */\n        this.navigation = true;\n        /**\n         * Specifies the smallest valid date\n         * ([see example]({% slug dateranges_datepicker %})).\n         */\n        this.min = cloneDate(MIN_DATE);\n        /**\n         * Specifies the biggest valid date\n         * ([see example]({% slug dateranges_datepicker %})).\n         */\n        this.max = cloneDate(MAX_DATE);\n        /**\n         * Specifies the focused date of the Calendar component\n         * ([see example]({% slug dates_datepicker %})).\n         */\n        this.focusedDate = null;\n        /**\n         * Specifies the date format that is used to display the input value\n         * ([see example]({% slug formats_datepicker %})).\n         */\n        this.format = \"d\";\n        /**\n         * Specifies the hint the DatePicker displays when its value is `null`.\n         * ([more information and exaples]({% slug placeholders_datepicker %})).\n         *\n         * @example\n         * ```ts\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-datepicker placeholder=\"Enter birth date...\"></kendo-datepicker>\n         * `\n         * })\n         * class AppComponent { }\n         * ```\n         */\n        this.placeholder = null;\n        /**\n         * Sets or gets the `tabindex` property of the DatePicker.\n         */\n        this.tabindex = 0;\n        /**\n         * Sets the title of the input element of the DatePicker.\n         */\n        this.title = \"\";\n        /**\n         * Determines whether the built-in min or max validators are enforced when validating a form.\n         */\n        this.rangeValidation = true;\n        /**\n         * Determines whether the built-in validator for disabled\n         * date ranges is enforced when validating a form\n         * ([see example]({% slug disabled_dates_datepicker %}#toc-validation)).\n         */\n        this.disabledDatesValidation = true;\n        /**\n         * Determines whether to display a week number column in the `month` view of the Calendar\n         * ([see example]({% slug weeknumcolumn_datepicker %})).\n         */\n        this.weekNumber = false;\n        /**\n         * Fires each time the user selects a new value\n         * ([more information and example]({% slug overview_datepicker %}#toc-events)).\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * Fires each time the user focuses the input element\n         * ([more information and example]({% slug overview_datepicker %}#toc-events)).\n         *\n         * > To wire the event programmatically, use the `onFocus` property.\n         *\n         * @example\n         * ```ts\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-datepicker (focus)=\"handleFocus()\"></kendo-datepicker>\n         * `\n         * })\n         * class AppComponent {\n         *   public handleFocus(): void {\n         *      console.log(\"Component is focused\");\n         *   }\n         * }\n         * ```\n         */\n        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the input element gets blurred\n         * ([more information and example]({% slug overview_datepicker %}#toc-events)).\n         *\n         * > To wire the event programmatically, use the `onBlur` property.\n         *\n         * @example\n         * ```ts\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-datepicker (blur)=\"handleBlur()\"></kendo-datepicker>\n         * `\n         * })\n         * class AppComponent {\n         *   public handleBlur(): void {\n         *      console.log(\"Component is blurred\");\n         *   }\n         * }\n         * ```\n         */\n        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the popup is about to open.\n         * This event is preventable. If you cancel the event, the popup will remain closed\n         * ([more information and example]({% slug overview_datepicker %}#toc-events)).\n         */\n        this.open = new EventEmitter();\n        /**\n         * Fires each time the popup is about to close.\n         * This event is preventable. If you cancel the event, the popup will remain open\n         * ([more information and example]({% slug overview_datepicker %}#toc-events)).\n         */\n        this.close = new EventEmitter();\n        this.popupUID = guid();\n        this._popupSettings = { animate: true };\n        this._show = false;\n        this._value = null;\n        this._active = false;\n        this.onControlChange = noop;\n        this.onControlTouched = noop;\n        this.onValidatorChange = noop;\n        this.minValidateFn = noop;\n        this.maxValidateFn = noop;\n        this.disabledDatesValidateFn = noop;\n        this.resolvedPromise = Promise.resolve(null);\n        this.domEvents = [];\n        this.pickerSubscriptions = this.pickerService.onFocus.subscribe(this.handleFocus.bind(this));\n        this.pickerSubscriptions.add(this.pickerService.onBlur.subscribe(this.handleBlur.bind(this)));\n        this.pickerSubscriptions.add(this.pickerService.sameDateSelected.subscribe(this.handleSameSelection.bind(this)));\n    }\n    /**\n     * @hidden\n     */\n    set cellTemplateRef(template) {\n        this.cellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n    set monthCellTemplateRef(template) {\n        this.monthCellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n    set yearCellTemplateRef(template) {\n        this.yearCellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n    set decadeCellTemplateRef(template) {\n        this.decadeCellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n    set centuryCellTemplateRef(template) {\n        this.centuryCellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n    set weekNumberTemplateRef(template) {\n        this.weekNumberTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n    set headerTitleTemplateRef(template) {\n        this.headerTitleTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n    set navigationItemTemplateRef(template) {\n        this.navigationItemTemplate = template;\n    }\n    /**\n     * Configures the popup options of the DatePicker.\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     */\n    set popupSettings(settings) {\n        this._popupSettings = Object.assign({}, { animate: true }, settings);\n    }\n    get popupSettings() {\n        return this._popupSettings;\n    }\n    /**\n     * Specifies the value of the DatePicker component.\n     *\n     * > The `value` has to be a valid\n     * [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance.\n     */\n    set value(value) {\n        this.verifyValue(value);\n        this._value = cloneDate(value);\n    }\n    get value() {\n        return this._value;\n    }\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n        this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n        return this.tabindex;\n    }\n    /**\n     * Sets the dates of the DatePicker that will be disabled\n     * ([see example]({% slug disabled_dates_datepicker %})).\n     */\n    set disabledDates(value) {\n        this._disabledDates = value;\n        this.disabledDatesService.initialize(value);\n    }\n    get disabledDates() {\n        return this._disabledDates;\n    }\n    /**\n     * @hidden\n     */\n    get wrapperClasses() {\n        return true;\n    }\n    /**\n     * @hidden\n     */\n    get disabledClass() {\n        return this.disabled;\n    }\n    get isActive() {\n        return this._active;\n    }\n    set isActive(value) {\n        this._active = value;\n        if (!this.wrapper) {\n            return;\n        }\n        const element = this.wrapper.nativeElement;\n        if (value) {\n            this.renderer.addClass(element, 'k-state-focused');\n        }\n        else {\n            this.renderer.removeClass(element, 'k-state-focused');\n        }\n    }\n    get show() {\n        return this._show;\n    }\n    set show(show) {\n        if (show && (this.disabled || this.readonly)) {\n            return;\n        }\n        const skipZone = !show && (!this._show || !hasObservers(this.close));\n        if (!skipZone) {\n            this.zone.run(() => {\n                this.togglePopup(show);\n            });\n        }\n        else {\n            this.togglePopup(show);\n        }\n    }\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the component is empty.\n     */\n    isEmpty() {\n        return !this.value && this.input.isEmpty();\n    }\n    /**\n     * @hidden\n     */\n    ngOnInit() {\n        this.localizationChangeSubscription = this.localization\n            .changes\n            .subscribe(() => this.cdr.markForCheck());\n        this.control = this.injector.get(NgControl, null);\n        if (this.element) {\n            this.renderer.removeAttribute(this.element.nativeElement, 'tabindex');\n            this.zone.runOutsideAngular(() => {\n                this.bindEvents();\n            });\n        }\n    }\n    /**\n     * @hidden\n     */\n    ngOnChanges(changes) {\n        this.verifySettings();\n        if (changes.min || changes.max || changes.rangeValidation || changes.disabledDatesValidation || changes.disabledDates) {\n            this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop;\n            this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop;\n            this.disabledDatesValidateFn = this.disabledDatesValidation ? disabledDatesValidator(this.disabledDatesService.isDateDisabled) : noop;\n            this.onValidatorChange();\n        }\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n        this.isActive = false;\n        this.show = false;\n        if (this.localizationChangeSubscription) {\n            this.localizationChangeSubscription.unsubscribe();\n        }\n        if (this.windowBlurSubscription) {\n            this.windowBlurSubscription.unsubscribe();\n        }\n        this.domEvents.forEach(unbindCallback => unbindCallback());\n        this.pickerSubscriptions.unsubscribe();\n    }\n    /**\n     * Returns the current open state of the popup.\n     */\n    get isOpen() {\n        return this.show;\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n        this.verifyValue(value);\n        this.value = cloneDate(value);\n        this.cdr.markForCheck();\n        if (!value && this.input) {\n            this.input.placeholder = this.placeholder;\n            this.input.writeValue(value);\n        }\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.onControlChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.onControlTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n        this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n    validate(control) {\n        return this.minValidateFn(control) || this.maxValidateFn(control) || this.disabledDatesValidateFn(control);\n    }\n    /**\n     * @hidden\n     */\n    registerOnValidatorChange(fn) {\n        this.onValidatorChange = fn;\n    }\n    /**\n     * Focuses the DatePicker component.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"datepicker.focus()\">Focus date picker</button>\n     *  <kendo-datepicker #datepicker></kendo-datepicker>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n        this.input.focus();\n    }\n    /**\n     * Blurs the DatePicker component.\n     */\n    blur() {\n        (this.calendar || this.input)['blur'](); //tslint:disable-line:no-string-literal\n    }\n    /**\n     * Toggles the visibility of the popup. If you use the `toggle` method to show or hide the popup,\n     * the `open` and `close` events do not fire.\n     *\n     * @param show - The state of the popup.\n     */\n    toggle(show) {\n        if (this.disabled || this.readonly) {\n            return;\n        }\n        this.resolvedPromise.then(() => {\n            this._toggle((show === undefined) ? !this.show : show);\n        });\n    }\n    /**\n     * @hidden\n     */\n    handleIconClick(event) {\n        if (this.disabled || this.readonly) {\n            return;\n        }\n        event.preventDefault();\n        this.focusInput();\n        //XXX: explicitly call the handleFocus handler here\n        //due to async IE focus event\n        this.handleFocus();\n        this.show = !this.show;\n        this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n    handleMousedown(args) {\n        args.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n    handleChange(value) {\n        this.cdr.markForCheck();\n        this.focusInput();\n        this.value = value;\n        this.show = false;\n        this.onControlChange(cloneDate(value));\n        this.valueChange.emit(cloneDate(value));\n    }\n    /**\n     * @hidden\n     */\n    handleInputChange(value) {\n        this.handleChange(this.input.formatSections.time ? value : this.mergeTime(value));\n    }\n    /**\n     * @hidden\n     */\n    get popupClasses() {\n        return [\n            'k-calendar-container',\n            'k-group',\n            'k-reset'\n        ].concat(this.popupSettings.popupClass || []);\n    }\n    /**\n     * @hidden\n     */\n    get appendTo() {\n        const { appendTo } = this.popupSettings;\n        if (!appendTo || appendTo === 'root') {\n            return undefined;\n        }\n        return appendTo === 'component' ? this.container : appendTo;\n    }\n    get input() {\n        return this.pickerService.input;\n    }\n    get calendar() {\n        return this.pickerService.calendar;\n    }\n    /**\n     * @hidden\n     */\n    mergeTime(value) {\n        return this.value && value ? setTime(value, this.value) : value;\n    }\n    /**\n     * @hidden\n     */\n    handleKeydown(e) {\n        const { altKey, keyCode } = e;\n        if (keyCode === Keys.Escape) {\n            this.show = false;\n        }\n        if (altKey) {\n            if (keyCode === Keys.ArrowDown && !this.show) {\n                this.show = true;\n            }\n            if (keyCode === Keys.ArrowUp) {\n                this.show = false;\n            }\n        }\n        if (keyCode === Keys.Tab && this.show && this.calendar.isActive) {\n            this.input.focus();\n            this.show = false;\n        }\n    }\n    togglePopup(show) {\n        const event = new PreventableEvent();\n        if (!this._show && show) {\n            this.open.emit(event);\n        }\n        else if (this._show && !show) {\n            this.close.emit(event);\n        }\n        if (event.isDefaultPrevented()) {\n            return;\n        }\n        this._toggle(show);\n        this.toggleFocus();\n    }\n    _toggle(show) {\n        this._show = show;\n        if (this.popupRef) {\n            this.popupRef.close();\n            this.popupRef = null;\n            this.subscription.unsubscribe();\n        }\n        if (this._show) {\n            const direction = this.localization.rtl ? 'right' : 'left';\n            this.popupRef = this.popupService.open({\n                anchor: this.wrapper,\n                anchorAlign: { vertical: 'bottom', horizontal: direction },\n                animate: this.popupSettings.animate,\n                appendTo: this.appendTo,\n                content: this.popupTemplate,\n                popupAlign: { vertical: 'top', horizontal: direction },\n                popupClass: this.popupClasses,\n                positionMode: 'absolute'\n            });\n            this.popupRef.popupElement.setAttribute('id', this.popupUID);\n            this.subscription = this.popupRef.popupAnchorViewportLeave.subscribe(() => this.show = false);\n        }\n    }\n    focusInput() {\n        if (this.touchEnabled) {\n            return;\n        }\n        this.input.focus();\n    }\n    toggleFocus() {\n        if (!this.isActive) {\n            return;\n        }\n        if (this.show) {\n            if (!this.calendar) {\n                this.cdr.detectChanges();\n            }\n            if (this.calendar) {\n                this.calendar.focus();\n            }\n        }\n        else if (!this.touchEnabled) {\n            this.input.focus();\n        }\n        else if (!this.input.isActive) {\n            this.handleBlur();\n        }\n    }\n    verifySettings() {\n        if (!isDevMode()) {\n            return;\n        }\n        if (!isValidRange(this.min, this.max)) {\n            throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK$2} and ${MAX_DOC_LINK$2}.`);\n        }\n    }\n    verifyValue(value) {\n        if (!isDevMode()) {\n            return;\n        }\n        if (value && !(value instanceof Date)) {\n            throw new Error(`The 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK$2} for possible resolution.`);\n        }\n    }\n    bindEvents() {\n        const element = this.element.nativeElement;\n        this.domEvents.push(this.renderer.listen(element, 'keydown', this.handleKeydown.bind(this)));\n        if (isWindowAvailable()) {\n            this.windowBlurSubscription = fromEvent(window, 'blur').subscribe(this.handleWindowBlur.bind(this));\n        }\n    }\n    handleFocus() {\n        if (this.isActive) {\n            return;\n        }\n        this.isActive = true;\n        if (hasObservers(this.onFocus)) {\n            this.zone.run(() => {\n                this.onFocus.emit();\n            });\n        }\n    }\n    handleWindowBlur() {\n        if (!this.isOpen) {\n            return;\n        }\n        this.show = false;\n    }\n    handleBlur(args) {\n        const currentTarget = args && currentFocusTarget(args);\n        if (currentTarget && (this.input.containsElement(currentTarget) ||\n            (this.calendar && this.calendar.containsElement(currentTarget)))) {\n            return;\n        }\n        if (hasObservers(this.onBlur) || (this.show && hasObservers(this.close)) || requiresZoneOnBlur(this.control)) {\n            this.zone.run(() => {\n                this.blurComponent();\n            });\n        }\n        else {\n            this.blurComponent();\n        }\n    }\n    blurComponent() {\n        this.isActive = false; // order is important ¯\\_(ツ)_/¯\n        this.show = false;\n        this.cdr.detectChanges();\n        this.onControlTouched();\n        this.onBlur.emit();\n    }\n    handleSameSelection() {\n        if (this.show) {\n            this.focusInput();\n            this.show = false;\n        }\n    }\n}\nDatePickerComponent.decorators = [\n    { type: Component, args: [{\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                exportAs: 'kendo-datepicker',\n                providers: [\n                    { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => DatePickerComponent), multi: true },\n                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => DatePickerComponent), multi: true },\n                    { provide: KendoInput, useExisting: forwardRef(() => DatePickerComponent) },\n                    LocalizationService,\n                    PickerService,\n                    DisabledDatesService,\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.datepicker'\n                    }\n                ],\n                selector: 'kendo-datepicker',\n                template: `\n        <ng-container kendoDatePickerLocalizedMessages\n            i18n-today=\"kendo.datepicker.today|The label for the today button in the calendar header\"\n            today=\"TODAY\"\n\n            i18n-toggle=\"kendo.datepicker.toggle|The label for the toggle button in the datepicker component\"\n            toggle=\"Toggle calendar\"\n        >\n        </ng-container>\n        <span #wrapper\n            class=\"k-picker-wrap k-state-default\"\n            [class.k-state-disabled]=\"disabled\"\n        >\n            <kendo-dateinput\n                #input\n                [focusableId]=\"focusableId\"\n                [hasPopup]=\"true\"\n                [isPopupOpen]=\"show\"\n                [disabled]=\"disabled\"\n                [readonly]=\"readonly\"\n                [tabindex]=\"tabindex\"\n                [title]=\"title\"\n                [format]=\"format\"\n                [formatPlaceholder]=\"formatPlaceholder\"\n                [placeholder]=\"placeholder\"\n                [min]=\"min\"\n                [max]=\"max\"\n                [value]=\"value\"\n                (valueChange)=\"handleInputChange($event)\"\n            ></kendo-dateinput>\n            <span class=\"k-select\"\n                role=\"button\"\n                [attr.title]=\"localization.get('toggle')\"\n                [attr.aria-label]=\"localization.get('toggle')\"\n                [attr.aria-controls]=\"popupUID\"\n                [kendoEventsOutsideAngular]=\"{\n                    click: handleIconClick,\n                    mousedown: handleMousedown\n                }\"\n                [scope]=\"this\"\n            >\n                <span class=\"k-icon k-i-calendar\"></span>\n            </span>\n        </span>\n        <ng-container #container></ng-container>\n        <ng-template #popupTemplate>\n            <kendo-calendar\n                #calendar\n                [min]=\"min\"\n                [max]=\"max\"\n                [navigation]=\"navigation\"\n                [activeView]=\"activeView\"\n                [bottomView]=\"bottomView\"\n                [topView]=\"topView\"\n                [weekNumber]=\"weekNumber\"\n                [cellTemplate]=\"cellTemplate\"\n                [monthCellTemplate]=\"monthCellTemplate\"\n                [yearCellTemplate]=\"yearCellTemplate\"\n                [decadeCellTemplate]=\"decadeCellTemplate\"\n                [centuryCellTemplate]=\"centuryCellTemplate\"\n                [weekNumberTemplate]=\"weekNumberTemplate\"\n                [headerTitleTemplate]=\"headerTitleTemplate\"\n                [navigationItemTemplate]=\"navigationItemTemplate\"\n                [focusedDate]=\"focusedDate\"\n                [value]=\"value\"\n                (valueChange)=\"handleChange(mergeTime($event))\"\n                [kendoEventsOutsideAngular]=\"{\n                    keydown: handleKeydown\n                }\"\n                [scope]=\"this\"\n                [disabledDates]=\"disabledDates\"\n            >\n                <kendo-calendar-messages [today]=\"localization.get('today')\">\n                </kendo-calendar-messages>\n            </kendo-calendar>\n        <ng-template>\n    `\n            },] },\n];\n/** @nocollapse */\nDatePickerComponent.ctorParameters = () => [\n    { type: NgZone },\n    { type: LocalizationService },\n    { type: ChangeDetectorRef },\n    { type: PopupService },\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: Injector },\n    { type: PickerService },\n    { type: DisabledDatesService },\n    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [TOUCH_ENABLED,] }] }\n];\nDatePickerComponent.propDecorators = {\n    container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef },] }],\n    popupTemplate: [{ type: ViewChild, args: ['popupTemplate',] }],\n    wrapper: [{ type: ViewChild, args: ['wrapper',] }],\n    cellTemplate: [{ type: ContentChild, args: [CellTemplateDirective,] }],\n    cellTemplateRef: [{ type: Input, args: ['cellTemplate',] }],\n    monthCellTemplate: [{ type: ContentChild, args: [MonthCellTemplateDirective,] }],\n    monthCellTemplateRef: [{ type: Input, args: ['monthCellTemplate',] }],\n    yearCellTemplate: [{ type: ContentChild, args: [YearCellTemplateDirective,] }],\n    yearCellTemplateRef: [{ type: Input, args: ['yearCellTemplate',] }],\n    decadeCellTemplate: [{ type: ContentChild, args: [DecadeCellTemplateDirective,] }],\n    decadeCellTemplateRef: [{ type: Input, args: ['decadeCellTemplate',] }],\n    centuryCellTemplate: [{ type: ContentChild, args: [CenturyCellTemplateDirective,] }],\n    centuryCellTemplateRef: [{ type: Input, args: ['centuryCellTemplate',] }],\n    weekNumberTemplate: [{ type: ContentChild, args: [WeekNumberCellTemplateDirective,] }],\n    weekNumberTemplateRef: [{ type: Input, args: ['weekNumberTemplate',] }],\n    headerTitleTemplate: [{ type: ContentChild, args: [HeaderTitleTemplateDirective,] }],\n    headerTitleTemplateRef: [{ type: Input, args: ['headerTitleTemplate',] }],\n    navigationItemTemplate: [{ type: ContentChild, args: [NavigationItemTemplateDirective,] }],\n    navigationItemTemplateRef: [{ type: Input, args: ['navigationItemTemplate',] }],\n    focusableId: [{ type: Input }],\n    activeView: [{ type: Input }],\n    bottomView: [{ type: Input }],\n    topView: [{ type: Input }],\n    disabled: [{ type: Input }],\n    readonly: [{ type: Input }],\n    popupSettings: [{ type: Input }],\n    navigation: [{ type: Input }],\n    min: [{ type: Input }],\n    max: [{ type: Input }],\n    focusedDate: [{ type: Input }],\n    value: [{ type: Input }],\n    format: [{ type: Input }],\n    formatPlaceholder: [{ type: Input }],\n    placeholder: [{ type: Input }],\n    tabindex: [{ type: Input }],\n    tabIndex: [{ type: Input }],\n    disabledDates: [{ type: Input }],\n    title: [{ type: Input }],\n    rangeValidation: [{ type: Input }],\n    disabledDatesValidation: [{ type: Input }],\n    weekNumber: [{ type: Input }],\n    valueChange: [{ type: Output }],\n    onFocus: [{ type: Output, args: ['focus',] }],\n    onBlur: [{ type: Output, args: ['blur',] }],\n    open: [{ type: Output }],\n    close: [{ type: Output }],\n    wrapperClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-datepicker',] }, { type: HostBinding, args: ['class.k-header',] }],\n    disabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }]\n};\n\n/**\n * @hidden\n */\nconst TIME_PART = {\n    dayperiod: 'dayperiod',\n    hour: 'hour',\n    millisecond: 'millisecond',\n    minute: 'minute',\n    second: 'second'\n};\n\n/**\n * @hidden\n */\nconst timeRangeValidator = (min, max) => {\n    return (control) => {\n        if (!min || !max || !control.value) {\n            return null;\n        }\n        const err = {\n            timeRangeError: {\n                maxValue: max,\n                minValue: min,\n                value: control.value\n            }\n        };\n        return isInTimeRange(control.value, min, max) ? null : err;\n    };\n};\n\nconst VALUE_DOC_LINK$3 = 'https://www.telerik.com/kendo-angular-ui/components/dateinputs/timepicker/#toc-integration-with-json';\nconst INTL_DATE_FORMAT = 'https://github.com/telerik/kendo-intl/blob/master/docs/date-formatting/index.md';\nconst formatRegExp = new RegExp(`${TIME_PART.hour}|${TIME_PART.minute}|${TIME_PART.second}|${TIME_PART.dayperiod}|literal`);\n/**\n * Represents the [Kendo UI TimePicker component for Angular]({% slug overview_timepicker %}#toc-basic-usage).\n */\nclass TimePickerComponent {\n    constructor(zone, localization, cdr, popupService, element, renderer, injector, pickerService, intl, touchEnabled$$1) {\n        this.zone = zone;\n        this.localization = localization;\n        this.cdr = cdr;\n        this.popupService = popupService;\n        this.element = element;\n        this.renderer = renderer;\n        this.injector = injector;\n        this.pickerService = pickerService;\n        this.intl = intl;\n        this.touchEnabled = touchEnabled$$1;\n        /**\n         * @hidden\n         */\n        this.focusableId = `k-${guid()}`;\n        /**\n         * Sets or gets the `disabled` property of the TimePicker and\n         * determines whether the component is active\n         * ([see example]({% slug disabled_timepicker %})).\n         */\n        this.disabled = false;\n        /**\n         * Sets the read-only state of the TimePicker\n         * ([see example]({% slug readonly_timepicker %})).\n         */\n        this.readonly = false;\n        /**\n         * Specifies the time format that is used to display the input value\n         * ([see example]({% slug formats_timepicker %})).\n         */\n        this.format = 't';\n        /**\n         * Specifies the hint the TimePicker displays when its value is `null`.\n         * For more information, refer to the article on\n         * [placeholders]({% slug placeholders_timepicker %}).\n         *\n         * @example\n         * ```ts\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-timepicker placeholder=\"Enter start...\"></kendo-timepicker>\n         * `\n         * })\n         * class AppComponent { }\n         * ```\n         */\n        this.placeholder = null;\n        /**\n         * Determines whether to display the **Cancel** button in the popup.\n         */\n        this.cancelButton = true;\n        /**\n         * Determines whether to display the **Now** button in the popup.\n         *\n         * > If the current time is out of range or the incremental step is greater than `1`, the **Now** button will be hidden.\n         */\n        this.nowButton = true;\n        /**\n         * Sets or gets the `tabindex` property of the TimePicker.\n         */\n        this.tabindex = 0;\n        /**\n         * Sets the title of the input element of the TimePicker.\n         */\n        this.title = \"\";\n        /**\n         * Determines whether the built-in min or max validators are enforced when a form is being validated.\n         */\n        this.rangeValidation = true;\n        /**\n         * Fires each time the user selects a new value.\n         * For more information, refer to the section on\n         * [events]({% slug overview_timepicker %}#toc-events).\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * Fires each time the user focuses the input element.\n         * For more information, refer to the section on\n         * [events]({% slug overview_timepicker %}#toc-events).\n         *\n         * > To wire the event programmatically, use the `onFocus` property.\n         *\n         * @example\n         * ```ts\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-timepicker (focus)=\"handleFocus()\"></kendo-timepicker>\n         * `\n         * })\n         * class AppComponent {\n         *   public handleFocus(): void {\n         *      console.log(\"Component is focused\");\n         *   }\n         * }\n         * ```\n         */\n        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the input element gets blurred.\n         * For more information, refer to the section on\n         * [events]({% slug overview_timepicker %}#toc-events).\n         *\n         * > To wire the event programmatically, use the `onBlur` property.\n         *\n         * @example\n         * ```ts\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-timepicker (blur)=\"handleBlur()\"></kendo-timepicker>\n         * `\n         * })\n         * class AppComponent {\n         *   public handleBlur(): void {\n         *      console.log(\"Component is blurred\");\n         *   }\n         * }\n         * ```\n         */\n        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the popup is about to open.\n         * This event is preventable. If you cancel the event, the popup will remain closed.\n         * For more information, refer to the section on\n         * [events]({% slug overview_timepicker %}#toc-events).\n         */\n        this.open = new EventEmitter();\n        /**\n         * Fires each time the popup is about to close.\n         * This event is preventable. If you cancel the event, the popup will remain open.\n         * For more information, refer to the section on\n         * [events]({% slug overview_timepicker %}#toc-events).\n         */\n        this.close = new EventEmitter();\n        this.popupUID = guid();\n        this.onControlChange = noop;\n        this.onControlTouched = noop;\n        this.onValidatorChange = noop;\n        this.resolvedPromise = Promise.resolve(null);\n        this.timeRangeValidateFn = noop;\n        this._min = cloneDate(MIN_TIME);\n        this._max = cloneDate(MAX_TIME);\n        this._popupSettings = { animate: true };\n        this._show = false;\n        this._steps = {};\n        this._value = null;\n        this._active = false;\n        this.domEvents = [];\n        this.pickerSubscriptions = this.pickerService.onFocus.subscribe(this.handleFocus.bind(this));\n        this.pickerSubscriptions.add(this.pickerService.onBlur.subscribe(this.handleBlur.bind(this)));\n    }\n    /**\n     * Specifies the smallest valid time value\n     * ([see example]({% slug timeranges_timepicker %})).\n     */\n    set min(min) {\n        this._min = cloneDate(min || MIN_TIME);\n    }\n    get min() {\n        return this._min;\n    }\n    /**\n     * Specifies the biggest valid time value\n     * ([see example]({% slug timeranges_timepicker %})).\n     */\n    set max(max) {\n        this._max = cloneDate(max || MAX_TIME);\n    }\n    get max() {\n        return this._max;\n    }\n    /**\n     * Configures the incremental steps of the TimePicker.\n     * For more information, refer to the article on\n     * [incremental steps]({% slug incrementalsteps_timepicker %}).\n     *\n     * > If the incremental step is greater than `1`, the **Now** button will be hidden.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <kendo-timepicker format=\"HH:mm:ss\" [steps]=\"steps\"></kendo-timepicker>\n     * `\n     * })\n     * class AppComponent {\n     *   public steps = { hour: 2, minute: 15, second: 15 };\n     * }\n     * ```\n     *\n     */\n    set steps(steps) {\n        this._steps = steps || {};\n    }\n    get steps() {\n        return this._steps;\n    }\n    /**\n     * Configures the popup of the TimePicker.\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     */\n    set popupSettings(settings) {\n        this._popupSettings = Object.assign({}, { animate: true }, settings);\n    }\n    get popupSettings() {\n        return this._popupSettings;\n    }\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n        this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n        return this.tabindex;\n    }\n    /**\n     * Specifies the value of the TimePicker component.\n     */\n    set value(value) {\n        this.verifyValue(value);\n        this._value = cloneDate(value);\n    }\n    get value() {\n        return this._value;\n    }\n    /**\n     * @hidden\n     */\n    get wrapperClasses() {\n        return true;\n    }\n    /**\n     * @hidden\n     */\n    get disabledClass() {\n        return this.disabled;\n    }\n    get isActive() {\n        return this._active;\n    }\n    set isActive(value) {\n        this._active = value;\n        if (!this.wrapper) {\n            return;\n        }\n        const element = this.wrapper.nativeElement;\n        if (value) {\n            this.renderer.addClass(element, 'k-state-focused');\n        }\n        else {\n            this.renderer.removeClass(element, 'k-state-focused');\n        }\n    }\n    get show() {\n        return this._show;\n    }\n    set show(show) {\n        if (show && (this.disabled || this.readonly)) {\n            return;\n        }\n        const skipZone = !show && (!this._show || !hasObservers(this.close));\n        if (!skipZone) {\n            this.zone.run(() => {\n                this.togglePopup(show);\n            });\n        }\n        else {\n            this.togglePopup(show);\n        }\n    }\n    get input() {\n        return this.pickerService.input;\n    }\n    get timeSelector() {\n        return this.pickerService.timeSelector;\n    }\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the component is empty\n     */\n    isEmpty() {\n        return !this.value && this.input.isEmpty();\n    }\n    /**\n     * @hidden\n     */\n    ngOnInit() {\n        this.localizationChangeSubscription = this.localization\n            .changes.subscribe(() => this.cdr.markForCheck());\n        this.control = this.injector.get(NgControl, null);\n        if (this.element) {\n            this.renderer.removeAttribute(this.element.nativeElement, 'tabindex');\n            this.zone.runOutsideAngular(() => {\n                this.bindEvents();\n            });\n        }\n    }\n    /**\n     * @hidden\n     */\n    ngOnChanges(changes) {\n        if (changes.min || changes.max || changes.rangeValidation) {\n            this.timeRangeValidateFn = this.rangeValidation ? timeRangeValidator(this.min, this.max) : noop;\n            this.onValidatorChange();\n        }\n        if (changes.format) {\n            this.verifyFormat();\n        }\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n        this.isActive = false;\n        this.show = false;\n        if (this.localizationChangeSubscription) {\n            this.localizationChangeSubscription.unsubscribe();\n        }\n        if (this.windowBlurSubscription) {\n            this.windowBlurSubscription.unsubscribe();\n        }\n        this.domEvents.forEach(unbindCallback => unbindCallback());\n        this.pickerSubscriptions.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n    handleKeydown(event) {\n        const { altKey, keyCode } = event;\n        if (keyCode === Keys.Escape) {\n            this.show = false;\n            return;\n        }\n        if (altKey) {\n            if (keyCode === Keys.ArrowUp) {\n                this.show = false;\n            }\n            if (keyCode === Keys.ArrowDown && !this.show) {\n                this.show = true;\n            }\n        }\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n        this.verifyValue(value);\n        this.value = cloneDate(value);\n        this.cdr.markForCheck();\n        if (!value && this.input) {\n            this.input.placeholder = this.placeholder;\n            this.input.writeValue(value);\n        }\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.onControlChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.onControlTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n        this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n    validate(control) {\n        return this.timeRangeValidateFn(control);\n    }\n    /**\n     * @hidden\n     */\n    registerOnValidatorChange(fn) {\n        this.onValidatorChange = fn;\n    }\n    /**\n     * Focuses the TimePicker component.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"timepicker.focus()\">Focus time picker</button>\n     *  <kendo-timepicker #timepicker></kendo-timepicker>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n        this.input.focus();\n    }\n    /**\n     * Blurs the TimePicker component.\n     */\n    blur() {\n        (this.timeSelector || this.input)['blur'](); //tslint:disable-line:no-string-literal\n    }\n    /**\n     * Toggles the visibility of the popup. If you use the `toggle` method to show or hide the popup,\n     * the `open` and `close` events do not fire.\n     *\n     * @param show - The state of the popup.\n     */\n    toggle(show) {\n        if (this.disabled || this.readonly) {\n            return;\n        }\n        this.resolvedPromise.then(() => {\n            this._toggle((show === undefined) ? !this.show : show);\n        });\n    }\n    /**\n     * Returns the current open state of the popup.\n     */\n    get isOpen() {\n        return this.show;\n    }\n    /**\n     * @hidden\n     */\n    get appendTo() {\n        const { appendTo } = this.popupSettings;\n        if (!appendTo || appendTo === 'root') {\n            return undefined;\n        }\n        return appendTo === 'component' ? this.container : appendTo;\n    }\n    /**\n     * @hidden\n     */\n    handleChange(value) {\n        if (isEqual(this.value, value)) {\n            this.focusInput();\n            this.show = false;\n            return;\n        }\n        this.value = cloneDate(value);\n        this.zone.run(() => {\n            this.focusInput();\n            this.show = false;\n            this.onControlChange(cloneDate(value));\n            this.valueChange.emit(cloneDate(value));\n        });\n    }\n    /**\n     * @hidden\n     */\n    handleReject() {\n        this.show = false;\n    }\n    /**\n     * @hidden\n     */\n    handleInputChange(value) {\n        const val = this.input.formatSections.date ? value : this.mergeTime(value);\n        this.handleChange(val);\n    }\n    /**\n     * @hidden\n     */\n    handleMousedown(args) {\n        args.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n    handleIconClick(event) {\n        if (this.disabled || this.readonly) {\n            return;\n        }\n        event.preventDefault();\n        this.focusInput();\n        //XXX: explicit call handleFocus handler here\n        //due to async IE focus event\n        this.handleFocus();\n        this.show = !this.show;\n    }\n    /**\n     * @hidden\n     */\n    get popupClasses() {\n        return [\n            'k-group',\n            'k-reset'\n        ].concat(this.popupSettings.popupClass || []);\n    }\n    /**\n     * @hidden\n     */\n    normalizeTime(date) {\n        return setTime(MIDNIGHT_DATE, date);\n    }\n    /**\n     * @hidden\n     */\n    mergeTime(value) {\n        return this.value && value ? setTime(this.value, value) : value;\n    }\n    togglePopup(show) {\n        const event = new PreventableEvent();\n        if (!this._show && show) {\n            this.open.emit(event);\n        }\n        else if (this._show && !show) {\n            this.close.emit(event);\n        }\n        if (event.isDefaultPrevented()) {\n            return;\n        }\n        this._toggle(show);\n        this.toggleFocus();\n    }\n    _toggle(show) {\n        this._show = show;\n        this.cdr.markForCheck();\n        if (this.popupRef) {\n            this.popupRef.close();\n            this.popupRef = null;\n        }\n        if (this._show) {\n            const direction = this.localization.rtl ? 'right' : 'left';\n            this.popupRef = this.popupService.open({\n                anchor: this.wrapper,\n                anchorAlign: { vertical: 'bottom', horizontal: direction },\n                animate: this.popupSettings.animate,\n                appendTo: this.appendTo,\n                content: this.popupTemplate,\n                popupAlign: { vertical: 'top', horizontal: direction },\n                popupClass: this.popupClasses,\n                positionMode: 'absolute'\n            });\n            this.popupRef.popupElement.setAttribute('id', this.popupUID);\n            this.popupRef.popupAnchorViewportLeave.subscribe(() => this.show = false);\n        }\n    }\n    focusInput() {\n        if (this.touchEnabled) {\n            return;\n        }\n        this.input.focus();\n    }\n    toggleFocus() {\n        if (!this.isActive) {\n            return;\n        }\n        if (this.show) {\n            if (!this.timeSelector) {\n                this.cdr.detectChanges();\n            }\n            if (this.isActive) {\n                this.timeSelector.focus();\n            }\n        }\n        else if (!this.touchEnabled) {\n            this.input.focus();\n        }\n        else if (!this.input.isActive) {\n            this.handleBlur();\n        }\n    }\n    verifyValue(value) {\n        if (!isDevMode()) {\n            return;\n        }\n        if (value && !(value instanceof Date)) {\n            throw new Error(`The 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK$3} for possible resolution.`);\n        }\n    }\n    verifyFormat() {\n        if (!isDevMode()) {\n            return;\n        }\n        const formatContainsDateParts = this.intl.splitDateFormat(this.format).some(part => !formatRegExp.test(part.type));\n        if (formatContainsDateParts) {\n            throw new Error(`Provided format is not supported. Supported specifiers are T|t|H|h|m|s|a. See ${INTL_DATE_FORMAT}`);\n        }\n    }\n    bindEvents() {\n        const element = this.element.nativeElement;\n        this.domEvents.push(this.renderer.listen(element, 'keydown', this.handleKeydown.bind(this)));\n        if (isWindowAvailable()) {\n            this.windowBlurSubscription = fromEvent(window, 'blur').subscribe(this.handleWindowBlur.bind(this));\n        }\n    }\n    handleWindowBlur() {\n        if (!this.isOpen) {\n            return;\n        }\n        this.show = false;\n    }\n    handleFocus() {\n        if (this.isActive) {\n            return;\n        }\n        this.isActive = true;\n        if (hasObservers(this.onFocus)) {\n            this.zone.run(() => {\n                this.onFocus.emit();\n            });\n        }\n    }\n    handleBlur(args) {\n        const currentTarget = args && currentFocusTarget(args);\n        if (currentTarget && (this.input.containsElement(currentTarget) ||\n            (this.timeSelector && this.timeSelector.containsElement(currentTarget)))) {\n            return;\n        }\n        if (hasObservers(this.onBlur) || (this.show && hasObservers(this.close)) || requiresZoneOnBlur(this.control)) {\n            this.zone.run(() => {\n                this.blurComponent();\n            });\n        }\n        else {\n            this.blurComponent();\n        }\n    }\n    blurComponent() {\n        this.isActive = false; // order is important ¯\\_(ツ)_/¯\n        this.show = false;\n        this.onControlTouched();\n        this.onBlur.emit();\n    }\n}\nTimePickerComponent.decorators = [\n    { type: Component, args: [{\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                exportAs: 'kendo-timepicker',\n                providers: [\n                    { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => TimePickerComponent), multi: true },\n                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => TimePickerComponent), multi: true },\n                    { provide: KendoInput, useExisting: forwardRef(() => TimePickerComponent) },\n                    LocalizationService,\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.timepicker'\n                    },\n                    PickerService\n                ],\n                selector: 'kendo-timepicker',\n                template: `\n        <ng-container kendoTimePickerLocalizedMessages\n            i18n-accept=\"kendo.timepicker.accept|The Accept button text in the timepicker component\"\n            accept=\"Set\"\n\n            i18n-acceptLabel=\"kendo.timepicker.acceptLabel|The label for the Accept button in the timepicker component\"\n            acceptLabel=\"Set time\"\n\n            i18n-cancel=\"kendo.timepicker.cancel|The Cancel button text in the timepicker component\"\n            cancel=\"Cancel\"\n\n            i18n-cancelLabel=\"kendo.timepicker.cancelLabel|The label for the Cancel button in the timepicker component\"\n            cancelLabel=\"Cancel changes\"\n\n            i18n-now=\"kendo.timepicker.now|The Now button text in the timepicker component\"\n            now=\"Now\"\n\n            i18n-nowLabel=\"kendo.timepicker.nowLabel|The label for the Now button in the timepicker component\"\n            nowLabel=\"Select now\"\n\n            i18n-toggle=\"kendo.timepicker.toggle|The label for the toggle button in the timepicker component\"\n            toggle=\"Toggle time list\"\n        >\n        </ng-container>\n        <span #wrapper\n            class=\"k-picker-wrap k-state-default\"\n            [class.k-state-disabled]=\"disabled\"\n        >\n            <kendo-dateinput\n                #input\n                [focusableId]=\"focusableId\"\n                [hasPopup]=\"true\"\n                [isPopupOpen]=\"show\"\n                [disabled]=\"disabled\"\n                [readonly]=\"readonly\"\n                [format]=\"format\"\n                [formatPlaceholder]=\"formatPlaceholder\"\n                [placeholder]=\"placeholder\"\n                [min]=\"normalizeTime(min)\"\n                [max]=\"normalizeTime(max)\"\n                [steps]=\"steps\"\n                [tabindex]=\"!show ? tabindex : -1\"\n                [title]=\"title\"\n                [value]=\"value\"\n                (valueChange)=\"handleInputChange($event)\"\n            ></kendo-dateinput>\n            <span class=\"k-select\"\n                role=\"button\"\n                [attr.title]=\"localization.get('toggle')\"\n                [attr.aria-label]=\"localization.get('toggle')\"\n                [attr.aria-controls]=\"popupUID\"\n                [kendoEventsOutsideAngular]=\"{\n                    click: handleIconClick,\n                    mousedown: handleMousedown\n                }\"\n                [scope]=\"this\"\n            >\n                <span class=\"k-icon k-i-clock\"></span>\n            </span>\n            <ng-template #popupTemplate>\n                <kendo-timeselector\n                    #timeSelector\n                    [cancelButton]=\"cancelButton\"\n                    [nowButton]=\"nowButton\"\n                    [format]=\"format\"\n                    [min]=\"min\"\n                    [max]=\"max\"\n                    [steps]=\"steps\"\n                    [value]=\"value\"\n                    [kendoEventsOutsideAngular]=\"{\n                        keydown: handleKeydown,\n                        mousedown: handleMousedown\n                    }\"\n                    [scope]=\"this\"\n                    (valueChange)=\"handleChange($event)\"\n                    (valueReject)=\"handleReject()\"\n                >\n                    <kendo-timeselector-messages\n                        [acceptLabel]=\"localization.get('acceptLabel')\"\n                        [accept]=\"localization.get('accept')\"\n                        [cancelLabel]=\"localization.get('cancelLabel')\"\n                        [cancel]=\"localization.get('cancel')\"\n                        [nowLabel]=\"localization.get('nowLabel')\"\n                        [now]=\"localization.get('now')\"\n                    >\n                    </kendo-timeselector-messages>\n                </kendo-timeselector>\n            </ng-template>\n        </span>\n        <ng-container #container></ng-container>\n    `\n            },] },\n];\n/** @nocollapse */\nTimePickerComponent.ctorParameters = () => [\n    { type: NgZone },\n    { type: LocalizationService },\n    { type: ChangeDetectorRef },\n    { type: PopupService },\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: Injector },\n    { type: PickerService },\n    { type: IntlService },\n    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [TOUCH_ENABLED,] }] }\n];\nTimePickerComponent.propDecorators = {\n    container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef },] }],\n    popupTemplate: [{ type: ViewChild, args: ['popupTemplate',] }],\n    wrapper: [{ type: ViewChild, args: ['wrapper',] }],\n    focusableId: [{ type: Input }],\n    disabled: [{ type: Input }],\n    readonly: [{ type: Input }],\n    format: [{ type: Input }],\n    formatPlaceholder: [{ type: Input }],\n    placeholder: [{ type: Input }],\n    min: [{ type: Input }],\n    max: [{ type: Input }],\n    cancelButton: [{ type: Input }],\n    nowButton: [{ type: Input }],\n    steps: [{ type: Input }],\n    popupSettings: [{ type: Input }],\n    tabindex: [{ type: Input }],\n    tabIndex: [{ type: Input }],\n    title: [{ type: Input }],\n    rangeValidation: [{ type: Input }],\n    value: [{ type: Input }],\n    valueChange: [{ type: Output }],\n    onFocus: [{ type: Output, args: ['focus',] }],\n    onBlur: [{ type: Output, args: ['blur',] }],\n    open: [{ type: Output }],\n    close: [{ type: Output }],\n    wrapperClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-timepicker',] }, { type: HostBinding, args: ['class.k-header',] }],\n    disabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }]\n};\n\nconst timeFormatRegExp = new RegExp(`${TIME_PART.hour}|${TIME_PART.minute}|${TIME_PART.second}|${TIME_PART.dayperiod}|literal`);\nconst VALUE_DOC_LINK$4 = 'https://www.telerik.com/kendo-angular-ui/components/dateinputs/datetimepicker/integration-with-json/';\nconst MIN_MAX_DOC_LINK = 'https://www.telerik.com/kendo-angular-ui/components/dateinputs/datetimepicker/date-time-limits/';\nconst DEFAULT_ACTIVE_TAB = 'date';\nconst DEFAULT_DATEINPUT_FORMAT = 'g';\nconst DEFAULT_TIMESELECTOR_FORMAT = 't';\n/**\n * Represents the [Kendo UI DateTimePicker component for Angular]({% slug overview_datetimepicker %}).\n */\nclass DateTimePickerComponent {\n    constructor(popupService, intl, cdr, pickerService, ngZone, host, touchEnabled$$1, localization, disabledDatesService) {\n        this.popupService = popupService;\n        this.intl = intl;\n        this.cdr = cdr;\n        this.pickerService = pickerService;\n        this.ngZone = ngZone;\n        this.host = host;\n        this.touchEnabled = touchEnabled$$1;\n        this.localization = localization;\n        this.disabledDatesService = disabledDatesService;\n        /**\n         * @hidden\n         */\n        this.hostClasses = true;\n        /**\n         * @hidden\n         */\n        this.focusableId = `k-${guid()}`;\n        /**\n         * Sets the title of the input element of the DateTimePicker.\n         */\n        this.title = '';\n        /**\n         * Sets or gets the `disabled` property of the DateTimePicker and determines whether the component is active\n         * ([see example]({% slug disabled_datetimepicker %})).\n         */\n        this.disabled = false;\n        /**\n         * Sets the read-only state of the DateTimePicker\n         * ([see example]({% slug readonly_datetimepicker %})).\n         */\n        this.readonly = false;\n        /**\n         * Determines whether to display the **Cancel** button in the popup\n         * ([see example]({% slug datetimepicker_popup_options %}#toc-toggling-the-cancel-button)).\n         */\n        this.cancelButton = true;\n        /**\n         * Determines whether to display a week number column in the `month` view of the popup Calendar\n         * ([see example]({% slug datetimepicker_calendar_options %}#toc-week-number-column)).\n         */\n        this.weekNumber = false;\n        /**\n         * Determines whether the built-in min or max validators are enforced when validating a form\n         * ([see example]({% slug dateranges_datetimepicker %}#toc-forms-range-validation)).\n         */\n        this.rangeValidation = true;\n        /**\n         * Determines whether the built-in validator for disabled\n         * date ranges is enforced when validating a form\n         * ([see example]({% slug disabled_dates_datetimepicker %}#toc-validation)).\n         */\n        this.disabledDatesValidation = true;\n        /**\n         * Fires each time the user selects a new value.\n         * ([more information and example]({% slug overview_datetimepicker %}#toc-methods-and-events)).\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * Fires each time the popup is about to open.\n         * This event is preventable. If you cancel the event by setting `event.preventDefault()`, the popup will remain closed.\n         * ([more information and example]({% slug overview_datetimepicker %}#toc-methods-and-events)).\n         */\n        this.open = new EventEmitter();\n        /**\n         * Fires each time the popup is about to close.\n         * This event is preventable. If you cancel the event by setting `event.preventDefault()`, the popup will remain open.\n         * ([more information and example]({% slug overview_datetimepicker %}#toc-methods-and-events)).\n         */\n        this.close = new EventEmitter();\n        /**\n         * Fires each time the user focuses the component.\n         * ([more information and example]({% slug overview_datetimepicker %}#toc-methods-and-events)).\n         */\n        this.onFocus = new EventEmitter();\n        /**\n         * Fires each time the user blurs the component.\n         * ([more information and example]({% slug overview_datetimepicker %}#toc-methods-and-events)).\n         */\n        this.onBlur = new EventEmitter();\n        /**\n         * Indicates whether the component or its popup content is focused.\n         */\n        this.isActive = false;\n        /**\n         * @hidden\n         *\n         * Controls whether the Calendar or the TimeSelector will be displayed.\n         */\n        this.activeTab = DEFAULT_ACTIVE_TAB;\n        /**\n         * @hidden\n         *\n         * Specifies the stripped time-related format that is used in the TimeSelector.\n         * Updates each time the `format` property value changes.\n         */\n        this.timeSelectorFormat = DEFAULT_TIMESELECTOR_FORMAT;\n        /**\n         * @hidden\n         */\n        this.timeSelectorMin = cloneDate(MIN_TIME);\n        /**\n         * @hidden\n         */\n        this.timeSelectorMax = cloneDate(MAX_TIME);\n        /**\n         * @hidden\n         */\n        this.calendarValue = null;\n        /**\n         * @hidden\n         */\n        this.calendarMin = cloneDate(MIN_DATE);\n        /**\n         * @hidden\n         */\n        this.calendarMax = lastMillisecondOfDate(MAX_DATE);\n        this._popupSettings = { animate: true };\n        this._value = null;\n        this._format = DEFAULT_DATEINPUT_FORMAT;\n        this._tabindex = 0;\n        this._defaultTab = DEFAULT_ACTIVE_TAB;\n        this._min = mergeDateAndTime(MIN_DATE, MIN_TIME);\n        this._max = mergeDateAndTime(MAX_DATE, MAX_TIME);\n        this.onControlTouched = noop;\n        this.onControlChange = noop;\n        this.onValidatorChange = noop;\n        this.minValidateFn = noop;\n        this.maxValidateFn = noop;\n        this.disabledDatesValidateFn = noop;\n        this.subscriptions = new Subscription();\n    }\n    /**\n     * @hidden\n     */\n    get input() {\n        return this.pickerService.input;\n    }\n    /**\n     * @hidden\n     */\n    get calendar() {\n        return this.pickerService.calendar;\n    }\n    /**\n     * @hidden\n     */\n    get timeSelector() {\n        return this.pickerService.timeSelector;\n    }\n    /**\n     * Specifies the value of the DateTimePicker component.\n     *\n     * > The `value` has to be a valid [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance.\n     */\n    set value(value) {\n        this.verifyValue(value);\n        this._value = cloneDate(value);\n        this.setCalendarValue(value);\n        this.cdr.markForCheck();\n    }\n    get value() {\n        return this._value;\n    }\n    /**\n     * Specifies the date format for displaying the input value\n     * ([see example]({% slug formats_datetimepicker %})).\n     */\n    set format(value) {\n        this._format = value;\n        this.timeSelectorFormat = this.getTimeSelectorFormat(value);\n    }\n    get format() {\n        return this._format;\n    }\n    /**\n     * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the DateTimePicker.\n     */\n    set tabindex(value) {\n        const tabindex = Number(value);\n        const defaultValue = 0;\n        this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;\n    }\n    get tabindex() {\n        return this.disabled ? -1 : this._tabindex;\n    }\n    /**\n     * Sets the dates of the DateTimePicker that will be disabled\n     * ([see example]({% slug disabled_dates_datetimepicker %})).\n     */\n    set disabledDates(value) {\n        this._disabledDates = value;\n        this.disabledDatesService.initialize(value);\n    }\n    get disabledDates() {\n        return this._disabledDates;\n    }\n    /**\n     * Configures the popup settings of the DateTimePicker\n     * ([see example]({% slug datetimepicker_popup_options %}#toc-customizing-the-popup)).\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `appendTo: 'root' | 'component' | ViewContainerRef`&mdash;Controls the popup container. By default, the popup will be appended to the root component.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     */\n    set popupSettings(settings) {\n        this._popupSettings = Object.assign({}, { animate: true }, settings);\n    }\n    get popupSettings() {\n        return this._popupSettings;\n    }\n    /**\n     * Specifies the smallest valid date.\n     * The Calendar will not display dates before this value.\n     * If the `min` value of the Calendar is selected, the TimePicker will not display\n     * time entries before the specified time portion of this value\n     * ([see example]({% slug dateranges_datetimepicker %})).\n     */\n    set min(value) {\n        if (!isPresent(value)) {\n            return;\n        }\n        this._min = cloneDate(value);\n        this.calendarMin = getDate(value);\n    }\n    get min() {\n        return this._min;\n    }\n    /**\n     * Specifies the biggest valid date.\n     * The Calendar will not display dates after this value.\n     * If the `max` value of the Calendar is selected, the TimePicker will not display\n     * time entries after the specified time portion of this value\n     * ([see example]({% slug dateranges_datetimepicker %})).\n     */\n    set max(value) {\n        if (!isPresent(value)) {\n            return;\n        }\n        this._max = cloneDate(value);\n        this.calendarMax = lastMillisecondOfDate(value);\n    }\n    get max() {\n        return this._max;\n    }\n    /**\n     * Indicates whether the component is currently open.\n     */\n    get isOpen() {\n        return isPresent(this.popupRef);\n    }\n    /**\n     * Sets the active tab on opening the popup\n     * ([see example]({% slug datetimepicker_popup_options %}#toc-setting-the-default-tab)).\n     */\n    set defaultTab(tab) {\n        this._defaultTab = tab || DEFAULT_ACTIVE_TAB;\n        this.activeTab = this.defaultTab;\n    }\n    get defaultTab() {\n        return this._defaultTab;\n    }\n    /**\n     * @hidden\n     */\n    get tabSwitchTransition() {\n        /*\n         When the popup is opening, disables the set transition in the themes. When `defaultTab` is set to `time`,\n         the popup opens with an active **Time** tab and the animation of the initial transition is undesired.\n         Setting the inline transition style to `none` overrides the set animation in the themes.\n         Setting the inline transition style to `null` does not apply any inline styles or override the themes CSS.\n        */\n        return this.isOpen ? null : 'none';\n    }\n    /**\n     * @hidden\n     *\n     * Indicates whether the Calendar will be disabled.\n     * The inactive tab component gets disabled and becomes inaccessible on tab click.\n     */\n    get disableCalendar() {\n        return this.activeTab !== 'date' && !this.calendar.isActive;\n    }\n    /**\n     * @hidden\n     *\n     * Indicates whether the TimeSelector will be disabled.\n     * The inactive tab component gets disabled and becomes inaccessible on tab click.\n     */\n    get disableTimeSelector() {\n        return this.activeTab !== 'time' && !this.timeSelector.isActive;\n    }\n    get activeTabComponent() {\n        if (!this.isOpen) {\n            return;\n        }\n        if (!(isPresent(this.calendar) || isPresent(this.timeSelector))) {\n            this.cdr.detectChanges();\n        }\n        return this.activeTab === 'date' ? this.calendar : this.timeSelector;\n    }\n    get appendTo() {\n        const { appendTo } = this.popupSettings;\n        if (!isPresent(appendTo) || appendTo === 'root') {\n            return undefined;\n        }\n        return appendTo === 'component' ? this.container : appendTo;\n    }\n    ngOnInit() {\n        this.subscriptions\n            // detect popup changes to disable the inactive view mark-up when the popup is open\n            .add(this.pickerService.onFocus.pipe(tap(this.detectPopupChanges.bind(this))).subscribe(this.handleFocus.bind(this)))\n            .add(this.pickerService.onBlur.subscribe(this.handleBlur.bind(this)))\n            .add(this.pickerService.sameDateSelected.subscribe(this.handleCalendarValueChange.bind(this)))\n            .add(this.localization.changes.subscribe(() => this.cdr.markForCheck()));\n        if (isWindowAvailable()) {\n            this.subscriptions.add(this.ngZone.runOutsideAngular(() => fromEvent(window, 'blur').subscribe(this.handleCancel.bind(this))));\n        }\n    }\n    ngOnChanges(changes) {\n        if (isPresent(changes.min) || isPresent(changes.max)) {\n            this.verifyMinMaxRange();\n        }\n        if (changes.min || changes.max || changes.rangeValidation || changes.disabledDatesValidation || changes.disabledDates) {\n            this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop;\n            this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop;\n            this.disabledDatesValidateFn = this.disabledDatesValidation ? disabledDatesValidator(this.disabledDatesService.isDateDisabled) : noop;\n            this.onValidatorChange();\n        }\n    }\n    ngOnDestroy() {\n        if (this.isOpen) {\n            this.closePopup();\n        }\n        this.subscriptions.unsubscribe();\n    }\n    /**\n     * * If the popup is closed, focuses the DateTimePicker input.\n     * * If the popup is open, the focus is moved to its content.\n     */\n    focus() {\n        if (this.disabled) {\n            return;\n        }\n        if (this.isOpen) {\n            this.activeTabComponent.focus();\n        }\n        else {\n            this.input.focus();\n        }\n    }\n    /**\n     * Blurs the DateTimePicker.\n     */\n    blur() {\n        if (this.isOpen && this.activeTabComponent.isActive) {\n            this.activeTabComponent.blur();\n        }\n        else {\n            this.input.blur();\n        }\n    }\n    /**\n     * Toggles the visibility of the popup. If you use the `toggle` method to show or hide the popup,\n     * the `open` and `close` events do not fire.\n     * ([more information and example]({% slug overview_datetimepicker %}#toc-methods-and-events)).\n     *\n     * @param show - The state of the popup.\n     */\n    toggle(show) {\n        if (this.disabled || this.readonly) {\n            return;\n        }\n        const shouldOpen = isPresent(show) ? show : !this.isOpen;\n        if (this.isOpen) {\n            this.closePopup();\n            // Changes the tab and the calendar or clock icon to the designated default.\n            if (this.activeTab !== this.defaultTab) {\n                this.activeTab = this.defaultTab;\n                this.cdr.detectChanges();\n            }\n        }\n        if (shouldOpen) {\n            this.openPopup();\n        }\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n        this.value = value;\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.onControlChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.onControlTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(disabled) {\n        this.disabled = disabled;\n        this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n    validate(control) {\n        return this.minValidateFn(control) || this.maxValidateFn(control) || this.disabledDatesValidateFn(control);\n    }\n    /**\n     * @hidden\n     */\n    registerOnValidatorChange(fn) {\n        this.onValidatorChange = fn;\n    }\n    /**\n     * @hidden\n     *\n     * Used by the TextBoxContainer to determine if the floating label will render in the input.\n     */\n    isEmpty() {\n        return !isPresent(this.value) && this.input.isEmpty();\n    }\n    /**\n     * @hidden\n     */\n    handleIconClick(event) {\n        if (this.disabled || this.readonly) {\n            return;\n        }\n        // prevents the event default to evade focusing the DateInput input when placed inside a label (FF/IE/Edge)\n        event.preventDefault();\n        const runInZone = !this.isOpen || hasObservers(this.close);\n        this.run(runInZone, () => {\n            // handle focus first to maintain correct event order `focus` => `open`\n            this.handleFocus();\n            this.togglePopup(!this.isOpen);\n        });\n    }\n    /**\n     * @hidden\n     */\n    handleFocus() {\n        if (this.isActive) {\n            return;\n        }\n        this.isActive = true;\n        this.cdr.detectChanges();\n        if (hasObservers(this.onFocus)) {\n            this.ngZone.run(() => this.onFocus.emit());\n        }\n    }\n    /**\n     * @hidden\n     */\n    handleBlur(event) {\n        if (!this.isActive || this.focusTargetInComponent(event)) {\n            return;\n        }\n        this.isActive = false;\n        this.cdr.detectChanges();\n        const isNgControlUntouched = this.host.nativeElement.classList.contains('ng-untouched');\n        const runInZone = isNgControlUntouched || hasObservers(this.onBlur) || (this.isOpen && hasObservers(this.close));\n        this.run(runInZone, () => {\n            this.onBlur.emit();\n            this.onControlTouched();\n            this.togglePopup(false);\n        });\n    }\n    /**\n     * @hidden\n     */\n    changeActiveTab(tab) {\n        if (!this.isOpen || this.activeTab === tab) {\n            return;\n        }\n        // persists the Tcurrent value of the TimeSelector when switching between tabs\n        if (!isEqual(this.timeSelector.value, this.timeSelector.current)) {\n            this.timeSelector.handleAccept();\n        }\n        this.activeTab = tab;\n        this.cdr.detectChanges();\n        this.detectPopupChanges();\n    }\n    /**\n     * @hidden\n     */\n    handleTabChangeTransitionEnd(dateTimeSelector, event) {\n        // handle only the .k-datetime-selector element transition, ignore any child element transitions\n        if (event.target !== dateTimeSelector) {\n            return;\n        }\n        this.activeTabComponent.focus();\n    }\n    /**\n     * @hidden\n     */\n    handleAccept() {\n        if (!this.isOpen) {\n            return;\n        }\n        const candidate = mergeDateAndTime(this.calendar.value, this.timeSelector.current);\n        const valueChangePresent = !isEqual(this.value, candidate);\n        const runInZone = valueChangePresent || hasObservers(this.close);\n        this.run(runInZone, () => {\n            this.handleValueChange(candidate);\n            this.togglePopup(false);\n        });\n    }\n    /**\n     * @hidden\n     */\n    handleCancel() {\n        if (!this.isOpen) {\n            return;\n        }\n        const runInZone = hasObservers(this.close);\n        this.run(runInZone, () => this.togglePopup(false));\n    }\n    /**\n     * @hidden\n     */\n    handleInputValueChange(value) {\n        this.handleValueChange(value);\n        if (this.isOpen) {\n            this.togglePopup(false);\n        }\n    }\n    /**\n     * @hidden\n     */\n    handleCalendarValueChange() {\n        this.setTimeSelectorMinMax(this.calendar.value);\n        this.changeActiveTab('time');\n    }\n    /**\n     * @hidden\n     */\n    handleKeyDown(event) {\n        if (this.disabled || this.readonly) {\n            return;\n        }\n        const { keyCode, altKey } = event;\n        switch (keyCode) {\n            case altKey && Keys.ArrowUp:\n            case Keys.Escape:\n                this.handleCancel();\n                break;\n            case !this.isOpen && altKey && Keys.ArrowDown:\n                this.ngZone.run(() => this.togglePopup(true));\n                break;\n            case altKey && Keys.ArrowRight:\n                this.changeActiveTab('time');\n                break;\n            case altKey && Keys.ArrowLeft:\n                this.changeActiveTab('date');\n                break;\n            case this.isOpen && this.timeSelector.isActive && isPresent(this.calendarValue) && Keys.Enter:\n                this.handleAccept();\n                break;\n            default: return;\n        }\n        event.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n    handleTabOut(event) {\n        const { keyCode, shiftKey, target } = event;\n        // if no focusable next sibling elements exist in the controls sections, the user is tabbing out of the popup\n        const focusableSiblingAvailable = isPresent(target.nextElementSibling) && !target.nextElementSibling.disabled;\n        if (keyCode === Keys.Tab && !shiftKey && !focusableSiblingAvailable) {\n            this.input.focus();\n            this.handleCancel();\n        }\n    }\n    /**\n     * @hidden\n     */\n    handleBackTabOut(event) {\n        const { keyCode, shiftKey } = event;\n        if (keyCode === Keys.Tab && shiftKey) {\n            this.input.focus();\n        }\n    }\n    /**\n     * @hidden\n     *\n     * Prevents the diversion of the focus from the currently active element in the component.\n     */\n    preventMouseDown(event) {\n        event.preventDefault();\n    }\n    verifyValue(value) {\n        if (!isDevMode()) {\n            return;\n        }\n        if (isPresent(value) && !(value instanceof Date)) {\n            throw new Error(`The 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK$4} for possible resolution.`);\n        }\n    }\n    verifyMinMaxRange() {\n        if (!isDevMode()) {\n            return;\n        }\n        if (!isValidRange(this.min, this.max)) {\n            throw new Error(`The max value should be bigger than the min. See ${MIN_MAX_DOC_LINK}.`);\n        }\n    }\n    /**\n     * Extracts the time slots and the literals that are not preceded by date parts\n     * and concatenates the resulting parts into a string.\n     * If the provided format value does not contain any time parts,\n     * returns the designated format of the default popup component of the TimePicker.\n     */\n    getTimeSelectorFormat(format) {\n        const timeSelectorFormat = this.intl\n            .splitDateFormat(format)\n            .filter(this.timeFormatPartFilter)\n            .reduce((format, part) => format += part.pattern, '');\n        return timeSelectorFormat || DEFAULT_TIMESELECTOR_FORMAT;\n    }\n    /**\n     * The filter expression that filters out all format parts\n     * except for `hour`, `minute`, `second`, `dayperiod`, and specific literals.\n     * Literals will be left only if they are not preceded by date parts.\n     */\n    timeFormatPartFilter(part, index, parts) {\n        const previousPart = index >= 1 && parts[index - 1];\n        if (previousPart && part.type === 'literal') {\n            return timeFormatRegExp.test(previousPart.type);\n        }\n        return timeFormatRegExp.test(part.type);\n    }\n    togglePopup(open) {\n        if (open === this.isOpen) {\n            return;\n        }\n        const event = new PreventableEvent();\n        open ? this.open.emit(event) : this.close.emit(event);\n        if (event.isDefaultPrevented()) {\n            return;\n        }\n        this.toggle(open);\n        this.switchFocus();\n    }\n    switchFocus() {\n        if (!this.isActive) {\n            return;\n        }\n        if (this.isOpen) {\n            this.activeTabComponent.focus();\n        }\n        else if (!this.touchEnabled) {\n            this.input.focus();\n        }\n        else if (!this.input.isActive) {\n            this.handleBlur();\n        }\n    }\n    openPopup() {\n        this.setCalendarValue(this.value);\n        this.setTimeSelectorMinMax(this.value);\n        const direction = this.localization.rtl ? 'right' : 'left';\n        this.popupRef = this.popupService.open({\n            anchor: this.wrapper,\n            content: this.popupTemplate,\n            positionMode: 'absolute',\n            animate: this.popupSettings.animate,\n            appendTo: this.appendTo,\n            popupClass: `k-datetime-container ${this.popupSettings.popupClass || ''}`,\n            anchorAlign: { vertical: 'bottom', horizontal: direction },\n            popupAlign: { vertical: 'top', horizontal: direction }\n        });\n        this.popupRef.popupAnchorViewportLeave.subscribe(() => this.handleCancel());\n    }\n    closePopup() {\n        if (!this.isOpen) {\n            return;\n        }\n        this.popupRef.close();\n        this.popupRef = null;\n    }\n    handleValueChange(value) {\n        if (isEqual(this.value, value)) {\n            return;\n        }\n        this.value = cloneDate(value);\n        this.valueChange.emit(cloneDate(value));\n        this.onControlChange(cloneDate(value));\n    }\n    /**\n     * Indicates whether the focus target is part of this component,\n     * that is, whether the focus target is inside the component wrapper or in the popup.\n     */\n    focusTargetInComponent(event) {\n        if (!isPresent(event)) {\n            return false;\n        }\n        const relatedTarget = event.relatedTarget || document.activeElement;\n        const focusInPopup = isPresent(this.popupRef) && this.popupRef.popupElement.contains(relatedTarget);\n        const focusInWrapper = this.wrapper.nativeElement.contains(relatedTarget);\n        return focusInPopup || focusInWrapper;\n    }\n    setTimeSelectorMinMax(selectedDate) {\n        const minDateSelected = isPresent(selectedDate) && isEqual(getDate(selectedDate), getDate(this.min));\n        this.timeSelectorMin = cloneDate(minDateSelected ? this.min : MIN_TIME);\n        const maxDateSelected = isPresent(selectedDate) && isEqual(getDate(selectedDate), getDate(this.max));\n        this.timeSelectorMax = cloneDate(maxDateSelected ? this.max : MAX_TIME);\n    }\n    setCalendarValue(value) {\n        const isInCalendarRange = isPresent(value) && isInRange(value, this.calendarMin, this.calendarMax);\n        this.calendarValue = isInCalendarRange ? getDate(value) : null;\n    }\n    /**\n     * If the popup is available, runs a popup change detection.\n     */\n    detectPopupChanges() {\n        if (!this.isOpen) {\n            return;\n        }\n        this.popupRef.popup.changeDetectorRef.detectChanges();\n    }\n    /**\n     * Depending on the predicate `runInZone` value that is passed,\n     * runs the provided function either in the Angular or in the current zone.\n     */\n    run(runInZone, fn) {\n        if (runInZone) {\n            this.ngZone.run(() => fn());\n        }\n        else {\n            fn();\n        }\n    }\n}\nDateTimePickerComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-datetimepicker',\n                exportAs: 'kendo-datetimepicker',\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                providers: [\n                    PickerService,\n                    LocalizationService,\n                    DisabledDatesService,\n                    { provide: L10N_PREFIX, useValue: 'kendo.datetimepicker' },\n                    { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => DateTimePickerComponent), multi: true },\n                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => DateTimePickerComponent), multi: true },\n                    { provide: KendoInput, useExisting: forwardRef(() => DateTimePickerComponent) }\n                ],\n                template: `\n        <ng-container\n            kendoDateTimePickerLocalizedMessages\n\n            i18n-dateTab=\"kendo.datetimepicker.dateTab|The Date tab text in the datetimepicker popup header\"\n            dateTab=\"Date\"\n\n            i18n-dateTabLabel=\"kendo.datetimepicker.dateTabLabel|The label for the Date tab in the datetimepicker popup header\"\n            dateTabLabel=\"Date tab\"\n\n            i18n-timeTab=\"kendo.datetimepicker.timeTab|The Time tab text in the datetimepicker popup header\"\n            timeTab=\"Time\"\n\n            i18n-timeTabLabel=\"kendo.datetimepicker.timeTabLabel|The label for the Time tab in the datetimepicker popup header\"\n            timeTabLabel=\"Time tab\"\n\n            i18n-toggle=\"kendo.datetimepicker.toggle|The label for the toggle button in the datetimepicker component\"\n            toggle=\"Toggle popup\"\n\n            i18n-accept=\"kendo.datetimepicker.accept|The Accept button text in the datetimepicker component\"\n            accept=\"Set\"\n\n            i18n-acceptLabel=\"kendo.datetimepicker.acceptLabel|The label for the Accept button in the datetimepicker component\"\n            acceptLabel=\"Set\"\n\n            i18n-cancel=\"kendo.datetimepicker.cancel|The Cancel button text in the datetimepicker component\"\n            cancel=\"Cancel\"\n\n            i18n-cancelLabel=\"kendo.datetimepicker.cancelLabel|The label for the Cancel button in the datetimepicker component\"\n            cancelLabel=\"Cancel\"\n\n            i18n-now=\"kendo.datetimepicker.now|The Now button text in the timepicker component\"\n            now=\"NOW\"\n\n            i18n-nowLabel=\"kendo.datetimepicker.nowLabel|The label for the Now button in the timepicker component\"\n            nowLabel=\"Select now\"\n\n            i18n-today=\"kendo.datetimepicker.today|The label for the today button in the calendar header\"\n            today=\"TODAY\"\n        >\n        </ng-container>\n\n        <span\n            #wrapper\n            class=\"k-picker-wrap\"\n            [class.k-state-default]=\"!disabled\"\n            [class.k-state-disabled]=\"disabled\"\n            [class.k-state-focused]=\"isActive\"\n        >\n            <kendo-dateinput\n                [value]=\"value\"\n                [format]=\"format\"\n                [min]=\"min\"\n                [max]=\"max\"\n                [formatPlaceholder]=\"formatPlaceholder\"\n                [placeholder]=\"placeholder\"\n                [disabled]=\"disabled\"\n                [readonly]=\"readonly\"\n                [steps]=\"steps\"\n                [tabindex]=\"tabindex\"\n                [title]=\"title\"\n                [focusableId]=\"focusableId\"\n                [hasPopup]=\"true\"\n                [isPopupOpen]=\"isOpen\"\n                (valueChange)=\"handleInputValueChange($event)\"\n                [kendoEventsOutsideAngular]=\"{\n                    keydown: handleKeyDown\n                }\"\n                [scope]=\"this\"\n            >\n            </kendo-dateinput>\n            <span class=\"k-select\"\n                [attr.title]=\"localization.get('toggle')\"\n                [attr.aria-label]=\"localization.get('toggle')\"\n                [kendoEventsOutsideAngular]=\"{\n                    mousedown: preventMouseDown,\n                    click: handleIconClick\n                }\"\n                [scope]=\"this\"\n            >\n                <span class=\"k-link k-link-date\">\n                    <span\n                        class=\"k-icon\"\n                        [class.k-i-calendar]=\"activeTab === 'date'\"\n                        [class.k-i-clock]=\"activeTab === 'time'\"\n                    >\n                    </span>\n                </span>\n            </span>\n        </span>\n\n        <ng-container #container></ng-container>\n\n        <ng-template #popupTemplate>\n            <div\n                class=\"k-datetime-wrap k-{{activeTab}}-tab\"\n                [kendoEventsOutsideAngular]=\"{\n                    mousedown: preventMouseDown,\n                    keydown: handleKeyDown\n                }\"\n                [scope]=\"this\"\n            >\n                <div class=\"k-datetime-buttongroup\"\n                    [kendoEventsOutsideAngular]=\"{\n                        focusin: handleFocus,\n                        focusout: handleBlur\n                    }\"\n                    [scope]=\"this\"\n                >\n                    <div class=\"k-button-group k-button-group-stretched\">\n                        <button\n                            type=\"button\"\n                            class=\"k-button k-date-tab\"\n                            [class.k-state-active]=\"activeTab === 'date'\"\n                            [attr.title]=\"localization.get('dateTabLabel')\"\n                            [attr.aria-label]=\"localization.get('dateTabLabel')\"\n                            [kendoEventsOutsideAngular]=\"{\n                                click: changeActiveTab.bind(this, 'date'),\n                                keydown: handleBackTabOut\n                            }\"\n                            [scope]=\"this\"\n                        >\n                            {{localization.get('dateTab')}}\n                        </button>\n                        <button\n                            type=\"button\"\n                            class=\"k-button k-time-tab\"\n                            [class.k-state-active]=\"activeTab === 'time'\"\n                            [attr.title]=\"localization.get('timeTabLabel')\"\n                            [attr.aria-label]=\"localization.get('timeTabLabel')\"\n                            [kendoEventsOutsideAngular]=\"{\n                                click: changeActiveTab.bind(this, 'time')\n                            }\"\n                        >\n                            {{localization.get('timeTab')}}\n                        </button>\n                    </div>\n                </div>\n                <div\n                    #dateTimeSelector\n                    class=\"k-datetime-selector\"\n                    [style.transition]=\"tabSwitchTransition\"\n                    [kendoEventsOutsideAngular]=\"{\n                        transitionend: handleTabChangeTransitionEnd.bind(this, dateTimeSelector)\n                    }\"\n                >\n                    <div class=\"k-datetime-calendar-wrap\">\n                        <kendo-calendar\n                            [(value)]=\"calendarValue\"\n                            [min]=\"calendarMin\"\n                            [max]=\"calendarMax\"\n                            [focusedDate]=\"focusedDate\"\n                            [weekNumber]=\"weekNumber\"\n                            [navigation]=\"false\"\n                            [cellTemplate]=\"cellTemplate\"\n                            [monthCellTemplate]=\"monthCellTemplate\"\n                            [yearCellTemplate]=\"yearCellTemplate\"\n                            [decadeCellTemplate]=\"decadeCellTemplate\"\n                            [centuryCellTemplate]=\"centuryCellTemplate\"\n                            [weekNumberTemplate]=\"weekNumberTemplate\"\n                            [headerTitleTemplate]=\"headerTitleTemplate\"\n                            [disabled]=\"disableCalendar\"\n                            [disabledDates]=\"disabledDates\"\n                            (valueChange)=\"handleCalendarValueChange()\"\n                        >\n                            <kendo-calendar-messages\n                                [today]=\"localization.get('today')\"\n                            >\n                            </kendo-calendar-messages>\n                        </kendo-calendar>\n                    </div>\n                    <div class=\"k-datetime-time-wrap\">\n                        <kendo-timeselector\n                            [value]=\"value\"\n                            [format]=\"timeSelectorFormat\"\n                            [min]=\"timeSelectorMin\"\n                            [max]=\"timeSelectorMax\"\n                            [setButton]=\"false\"\n                            [cancelButton]=\"false\"\n                            [steps]=\"steps\"\n                            [disabled]=\"disableTimeSelector\"\n                        >\n                            <kendo-timeselector-messages\n                                [now]=\"localization.get('now')\"\n                                [nowLabel]=\"localization.get('nowLabel')\"\n                            >\n                            </kendo-timeselector-messages>\n                        </kendo-timeselector>\n                    </div>\n                </div>\n                <div\n                    class=\"k-datetime-footer k-action-buttons\"\n                    [kendoEventsOutsideAngular]=\"{\n                        keydown: handleTabOut,\n                        focusin: handleFocus,\n                        focusout: handleBlur\n                    }\"\n                    [scope]=\"this\"\n                >\n                    <button\n                        *ngIf=\"cancelButton\"\n                        type=\"button\"\n                        class=\"k-button k-time-cancel\"\n                        [attr.title]=\"localization.get('cancelLabel')\"\n                        [attr.aria-label]=\"localization.get('cancelLabel')\"\n                        [kendoEventsOutsideAngular]=\"{\n                            click: handleCancel\n                        }\"\n                        [scope]=\"this\"\n                    >\n                        {{localization.get('cancel')}}\n                    </button>\n                    <button\n                        type=\"button\"\n                        class=\"k-time-accept k-button k-primary\"\n                        [attr.title]=\"localization.get('acceptLabel')\"\n                        [attr.aria-label]=\"localization.get('acceptLabel')\"\n                        [disabled]=\"!calendarValue\"\n                        [kendoEventsOutsideAngular]=\"{\n                            click: handleAccept\n                        }\"\n                        [scope]=\"this\"\n                    >\n                        {{localization.get('accept')}}\n                    </button>\n                </div>\n            </div>\n        </ng-template>\n    `\n            },] },\n];\n/** @nocollapse */\nDateTimePickerComponent.ctorParameters = () => [\n    { type: PopupService },\n    { type: IntlService },\n    { type: ChangeDetectorRef },\n    { type: PickerService },\n    { type: NgZone },\n    { type: ElementRef },\n    { type: Boolean, decorators: [{ type: Inject, args: [TOUCH_ENABLED,] }] },\n    { type: LocalizationService },\n    { type: DisabledDatesService }\n];\nDateTimePickerComponent.propDecorators = {\n    hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-datetimepicker',] }],\n    wrapper: [{ type: ViewChild, args: ['wrapper',] }],\n    value: [{ type: Input }],\n    format: [{ type: Input }],\n    tabindex: [{ type: Input }],\n    disabledDates: [{ type: Input }],\n    popupSettings: [{ type: Input }],\n    focusableId: [{ type: Input }],\n    title: [{ type: Input }],\n    disabled: [{ type: Input }],\n    readonly: [{ type: Input }],\n    cancelButton: [{ type: Input }],\n    formatPlaceholder: [{ type: Input }],\n    placeholder: [{ type: Input }],\n    steps: [{ type: Input }],\n    focusedDate: [{ type: Input }],\n    weekNumber: [{ type: Input }],\n    min: [{ type: Input }],\n    max: [{ type: Input }],\n    rangeValidation: [{ type: Input }],\n    disabledDatesValidation: [{ type: Input }],\n    valueChange: [{ type: Output }],\n    open: [{ type: Output }],\n    close: [{ type: Output }],\n    onFocus: [{ type: Output, args: ['focus',] }],\n    onBlur: [{ type: Output, args: ['blur',] }],\n    defaultTab: [{ type: Input }],\n    cellTemplate: [{ type: ContentChild, args: [CellTemplateDirective,] }],\n    monthCellTemplate: [{ type: ContentChild, args: [MonthCellTemplateDirective,] }],\n    yearCellTemplate: [{ type: ContentChild, args: [YearCellTemplateDirective,] }],\n    decadeCellTemplate: [{ type: ContentChild, args: [DecadeCellTemplateDirective,] }],\n    centuryCellTemplate: [{ type: ContentChild, args: [CenturyCellTemplateDirective,] }],\n    weekNumberTemplate: [{ type: ContentChild, args: [WeekNumberCellTemplateDirective,] }],\n    headerTitleTemplate: [{ type: ContentChild, args: [HeaderTitleTemplateDirective,] }],\n    container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef },] }],\n    popupTemplate: [{ type: ViewChild, args: ['popupTemplate', { read: TemplateRef },] }]\n};\n\n/**\n * A directive which renders the content of the DateRange Popup. To define the cell template, nest an\n * `<ng-template>` tag with the `kendoRangePopupTemplate` directive inside the component tag.\n */\nclass DateRangePopupTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nDateRangePopupTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoDateRangePopupTemplate]'\n            },] },\n];\n/** @nocollapse */\nDateRangePopupTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef }\n];\n\nconst isActive = (cmp) => (cmp && cmp.isActive) || false;\nconst hasActiveContent = (popup) => popup && popup.hasActiveContent();\n/**\n * A service that handles the communication between the components that are placed inside the DateRangeComponent.\n * For example, the start and end `DateInput` and `DateRangePopup` components.\n */\nclass DateRangeService {\n    constructor() {\n        /**\n         * An Observable instance that notifies when the `activeRangeEnd` state is changed.\n         */\n        this.activeRangeEnd$ = new BehaviorSubject(null);\n        /**\n         * An Observable instance that notifies when the `focusedDate` is changed.\n         */\n        this.focusedDate$ = new BehaviorSubject(null);\n        /**\n         * An Observable instance that notifies when the end `DateInput` component is changed.\n         * For example, when a new end `DateInput` is attached or when the old one is detached.\n         */\n        this.endInput$ = new BehaviorSubject(null);\n        /**\n         * An Observable instance that notifies when the start `DateInput` component is changed.\n         * For example, when a new start `DateInput` is attached or the old one is detached.\n         */\n        this.startInput$ = new BehaviorSubject(null);\n        /**\n         * An Observable instance that notifies when the `DateRangePopup` component is changed.\n         */\n        this.dateRangePopup$ = new BehaviorSubject(null);\n        /**\n         * An Observable instance that notifies when the state of the selection range is changed.\n         */\n        this.range$ = new BehaviorSubject(EMPTY_SELECTIONRANGE);\n    }\n    /**\n     * Gets the current `activeRangeEnd` value.\n     */\n    get activeRangeEnd() {\n        return this.activeRangeEnd$.value;\n    }\n    /**\n     * Gets the current `focusedDate` value.\n     */\n    get focusedDate() {\n        return this.focusedDate$.value;\n    }\n    /**\n     * Gets the `min` range value.\n     * The `min` value is extracted from the `start` DateInput value or the `min` value of the Calendar.\n     */\n    get min() {\n        return (this.startInput$.value || {}).min || null;\n    }\n    /**\n     * Gets the `max` range value.\n     * The `max` value is extracted from the `end` DateInput value or the `max` value of the Calendar.\n     */\n    get max() {\n        return (this.endInput$.value || {}).max || null;\n    }\n    /**\n     * Gets the current `selectionRange` value.\n     */\n    get selectionRange() {\n        return this.range$.value;\n    }\n    /**\n     * Activates the registered `DateRangePopup` component.\n     * The method opens the popup and focuses the calendar.\n     */\n    activatePopup() {\n        const dateRangePopup = this.dateRangePopup$.value;\n        if (!dateRangePopup) {\n            return;\n        }\n        dateRangePopup.activate();\n    }\n    /**\n     * Deactivates the registered `DateRangePopup` component.\n     * The method closes the popup.\n     */\n    deactivatePopup() {\n        const dateRangePopup = this.dateRangePopup$.value;\n        if (!(dateRangePopup && dateRangePopup.show)) {\n            return;\n        }\n        dateRangePopup.show = false;\n    }\n    /**\n     * @hidden\n     *\n     * Deactivates the registered `DateRangePopup` component and fires the `cancel` event.\n     * The method closes the popup.\n     */\n    cancelPopup() {\n        const dateRangePopup = this.dateRangePopup$.value;\n        if (!(dateRangePopup && dateRangePopup.show)) {\n            return;\n        }\n        dateRangePopup.cancelPopup();\n    }\n    /**\n     * Completes all observables to mitigate possible memory leaks.\n     * Calls the method when a component that uses it is destroyed.\n     */\n    destroy() {\n        this.activeRangeEnd$.complete();\n        this.dateRangePopup$.complete();\n        this.focusedDate$.complete();\n        this.endInput$.complete();\n        this.startInput$.complete();\n        this.range$.complete();\n    }\n    /**\n     * Returns `true` when an active component that is placed inside the `DateRangeComponent` is detected.\n     * For example, the opened popup or the focused DateInput.\n     *\n     * @returns `true` if an active component is present.\n     */\n    hasActiveComponent() {\n        const popup = this.dateRangePopup$.value;\n        const isPopup = isActive(popup);\n        const isStart = isActive(this.startInput$.value);\n        const isEnd = isActive(this.endInput$.value);\n        return isPopup || isStart || isEnd || hasActiveContent(popup) || false;\n    }\n    /**\n     * Registers a new start `DateInput` component. Notifies all `startInput$` listeners.\n     */\n    registerStartInput(startInput) {\n        this.startInput$.next(startInput);\n    }\n    /**\n     * Registers a new end `DateInput` component. Notifies all `endInput$` listeners.\n     */\n    registerEndInput(endInput) {\n        this.endInput$.next(endInput);\n    }\n    /**\n     * Registers a new `DateRangePopup` component. Notifies all `dateRangePopup$` listeners.\n     */\n    registerPopup(dateRangePopup) {\n        this.dateRangePopup$.next(dateRangePopup);\n    }\n    /**\n     * Updates the `activeRangeEnd` value. Notifies all `activeRangeEnd$` listeners.\n     */\n    setActiveRangeEnd(activeRange) {\n        if (!activeRange || this.activeRangeEnd === activeRange) {\n            return;\n        }\n        this.activeRangeEnd$.next(activeRange);\n    }\n    /**\n     * Updates the focused date. Notifies all `focusedDate$` listeners.\n     */\n    setFocusedDate(value) {\n        if (isEqual(this.focusedDate$.value, value)) {\n            return;\n        }\n        this.focusedDate$.next(value);\n    }\n    /**\n     * Updates the selection range. Notifies all `range$` listeners.\n     */\n    setRange(range = EMPTY_SELECTIONRANGE) {\n        this.range$.next(range);\n    }\n}\nDateRangeService.decorators = [\n    { type: Injectable },\n];\n\n/* tslint:disable:component-selector-name  component-selector-type */\nconst DEFAULT_VIEWS_LENGTH = 2;\n/**\n * @hidden\n */\nclass HorizontalViewListComponent {\n    constructor(bus, cdr) {\n        this.bus = bus;\n        this.cdr = cdr;\n        this.activeView = CalendarViewEnum.month;\n        this.isActive = true;\n        this.min = new Date(MIN_DATE);\n        this.max = new Date(MAX_DATE);\n        this.views = DEFAULT_VIEWS_LENGTH;\n        this.valueChange = new EventEmitter();\n        this.cellEnter = new EventEmitter();\n        this.cellLeave = new EventEmitter();\n        this.dates = [];\n    }\n    get weekNumber() {\n        return this.showWeekNumbers && this.isMonthView();\n    }\n    set weekNumber(showWeekNumbers) {\n        this.showWeekNumbers = showWeekNumbers;\n    }\n    get getComponentClass() {\n        return true;\n    }\n    get getComponentMonthClass() {\n        return this.activeView === CalendarViewEnum.month;\n    }\n    get getComponentYearClass() {\n        return this.activeView === CalendarViewEnum.year;\n    }\n    get getComponentDecadeClass() {\n        return this.activeView === CalendarViewEnum.decade;\n    }\n    get getComponentCenturyClass() {\n        return this.activeView === CalendarViewEnum.century;\n    }\n    ngOnChanges(changes) {\n        this.initService();\n        if (!this.service) {\n            return;\n        }\n        this.views = this.views || DEFAULT_VIEWS_LENGTH;\n        const focusedDate = this.focusedDate;\n        const viewDate = this.clampDate(this.service.viewDate(focusedDate, this.max, this.views));\n        this.skip = this.service.skip(viewDate, this.min);\n        this.total = this.service.total(this.min, this.max);\n        const activeViewChanged = hasChange(changes, 'activeView');\n        const viewsHasChanged = this.views > 0 && hasChange(changes, 'views');\n        if (activeViewChanged || !this.isInDates(focusedDate) || viewsHasChanged || !this.activeDate) {\n            this.dates = this.service.datesList(viewDate, this.getTake(this.skip));\n            this.activeDate = cloneDate(this.dates[0]);\n        }\n    }\n    initService() {\n        this.service = this.bus.service(this.activeView);\n    }\n    handleDateChange(candidate) {\n        this.valueChange.emit(candidate);\n    }\n    isMonthView() {\n        return this.activeView === CalendarViewEnum.month;\n    }\n    navigate(action) {\n        const candidate = this.move(action);\n        const list = this.service.datesList(candidate, this.getTake(this.skip));\n        if (this.isListInRange(list)) {\n            this.dates = list;\n        }\n        this.activeDate = cloneDate(this.dates[0]);\n        this.focusedDate = cloneDate(candidate);\n        this.cdr.markForCheck();\n        return cloneDate(candidate);\n    }\n    canNavigate(action) {\n        if (!this.service) {\n            return false;\n        }\n        return this.isListInRange(this.service.datesList(this.move(action), this.getTake(this.skip)));\n    }\n    clampDate(value) {\n        return dateInRange(value, this.min, this.max);\n    }\n    move(action) {\n        return this.service.move(this.dates[0] || this.focusedDate, action);\n    }\n    isListInRange(list) {\n        const lowerBound = this.service.beginningOfPeriod(this.min);\n        const upperBound = this.service.beginningOfPeriod(this.service.addToDate(this.max, 1));\n        return lowerBound <= list[0] && list[list.length - 1] < upperBound;\n    }\n    isInDates(value) {\n        return this.service.isInArray(value, this.dates);\n    }\n    getTake(skip) {\n        return Math.min(this.total - skip, this.views);\n    }\n}\nHorizontalViewListComponent.decorators = [\n    { type: Component, args: [{\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                selector: 'kendo-calendar-horizontal',\n                template: `\n    <kendo-calendar-header\n        [activeView]=\"activeView\"\n        [currentDate]=\"activeDate\"\n        [min]=\"min\"\n        [max]=\"max\"\n        [rangeLength]=\"views\"\n        [templateRef]=\"headerTitleTemplateRef\"\n        (today)=\"handleDateChange($event)\"\n    >\n    </kendo-calendar-header>\n    <table class=\"k-content\">\n        <tbody *kFor=\"let date of dates\"\n               kendoCalendarView\n               role=\"rowgroup\"\n               direction=\"horizontal\"\n               [activeView]=\"activeView\"\n               [isActive]=\"isActive\"\n               [min]=\"min\" [max]=\"max\"\n               [cellUID]=\"cellUID\"\n               [focusedDate]=\"focusedDate\"\n               [selectedDate]=\"value\"\n               [selectionRange]=\"selectionRange\"\n               [activeRangeEnd]=\"activeRangeEnd\"\n               [weekNumber]=\"weekNumber\"\n               [templateRef]=\"cellTemplateRef\"\n               [weekNumberTemplateRef]=\"weekNumberTemplateRef\"\n               [viewDate]=\"date\"\n               (change)=\"handleDateChange($event)\"\n               (cellEnter)=\"cellEnter.emit($event)\"\n               (cellLeave)=\"cellLeave.emit($event)\"\n        ></tbody>\n    </table>\n  `\n            },] },\n];\n/** @nocollapse */\nHorizontalViewListComponent.ctorParameters = () => [\n    { type: BusViewService },\n    { type: ChangeDetectorRef }\n];\nHorizontalViewListComponent.propDecorators = {\n    cellTemplateRef: [{ type: Input }],\n    weekNumberTemplateRef: [{ type: Input }],\n    headerTitleTemplateRef: [{ type: Input }],\n    activeRangeEnd: [{ type: Input }],\n    activeView: [{ type: Input }],\n    cellUID: [{ type: Input }],\n    focusedDate: [{ type: Input }],\n    isActive: [{ type: Input }],\n    min: [{ type: Input }],\n    max: [{ type: Input }],\n    selectionRange: [{ type: Input }],\n    value: [{ type: Input }],\n    views: [{ type: Input }],\n    weekNumber: [{ type: Input }],\n    valueChange: [{ type: Output }],\n    cellEnter: [{ type: Output }],\n    cellLeave: [{ type: Output }],\n    getComponentClass: [{ type: HostBinding, args: [\"class.k-calendar-view\",] }],\n    getComponentMonthClass: [{ type: HostBinding, args: [\"class.k-calendar-monthview\",] }],\n    getComponentYearClass: [{ type: HostBinding, args: [\"class.k-calendar-yearview\",] }],\n    getComponentDecadeClass: [{ type: HostBinding, args: [\"class.k-calendar-decadeview\",] }],\n    getComponentCenturyClass: [{ type: HostBinding, args: [\"class.k-calendar-centuryview\",] }]\n};\n\nconst noop$2 = () => null;\n/**\n * @hidden\n */\nconst disabledDatesRangeValidator = (isDateDisabled) => {\n    if (!isPresent(isDateDisabled)) {\n        return noop$2;\n    }\n    return (selectedRange) => {\n        const isRangeComplete = isPresent(selectedRange) && isPresent(selectedRange.start) && isPresent(selectedRange.end);\n        if (!isRangeComplete || selectedRange.start > selectedRange.end) {\n            return null;\n        }\n        const disabledDates = disabledDatesInRange(selectedRange.start, selectedRange.end, isDateDisabled);\n        const error = {\n            disabledDatesInRange: disabledDates\n        };\n        return disabledDates.length ? error : null;\n    };\n};\n\n/* tslint:disable:no-forward-ref */\nconst BOTTOM_VIEW_DOC_LINK$1 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-bottomview';\nconst TOP_VIEW_DOC_LINK$1 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-topview';\nconst MIN_DOC_LINK$3 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-min';\nconst MAX_DOC_LINK$3 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-max';\nconst VALUE_DOC_LINK$5 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/calendar/#toc-using-with-json';\n/**\n * @hidden\n */\nconst RANGE_CALENDAR_VALUE_ACCESSOR = {\n    multi: true,\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(() => MultiViewCalendarComponent) //tslint:disable-line:no-use-before-declare\n};\n/**\n * @hidden\n */\nconst RANGE_CALENDAR_RANGE_VALIDATORS = {\n    multi: true,\n    provide: NG_VALIDATORS,\n    useExisting: forwardRef(() => MultiViewCalendarComponent) //tslint:disable-line:no-use-before-declare\n};\n/**\n * Represents the Kendo UI MultiViewCalendar component for Angular.\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-multiviewcalendar></kendo-multiviewcalendar>\n * `\n * })\n * class AppComponent { }\n * ```\n */\nclass MultiViewCalendarComponent {\n    constructor(bus, element, localization, navigator, renderer, cdr, zone, disabledDatesService) {\n        this.bus = bus;\n        this.element = element;\n        this.localization = localization;\n        this.navigator = navigator;\n        this.renderer = renderer;\n        this.cdr = cdr;\n        this.zone = zone;\n        this.disabledDatesService = disabledDatesService;\n        /**\n         * @hidden\n         */\n        this.id = guid();\n        /**\n         * Determines whether the built-in min or max validators are enforced when validating a form.\n         */\n        this.rangeValidation = false;\n        /**\n         * Determines whether the built-in validator for disabled\n         * date ranges is enforced when validating a form\n         * ([see example]({% slug disabled_dates_multiviewcalendar %}#toc-validation)).\n         */\n        this.disabledDatesRangeValidation = false;\n        /**\n         * Sets or gets the `disabled` property of the Calendar and\n         * determines whether the component is active\n         * ([see example]({% slug disabled_multiviewcalendar %})).\n         */\n        this.disabled = false;\n        /**\n         * Sets or gets the `tabindex` property of the Calendar. Based on the\n         * [HTML `tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) behavior,\n         * it determines whether the component is focusable.\n         */\n        this.tabindex = 0;\n        /**\n         * Defines the active view that the Calendar initially renders\n         * ([see example]({% slug activeview_multiviewcalendar %})).\n         * By default, the active view is `month`.\n         *\n         * > You have to set `activeView` within the `topView`-`bottomView` range.\n         */\n        this.activeView = CalendarViewEnum[CalendarViewEnum.month];\n        /**\n         * Defines the bottommost view, to which the user can navigate\n         * ([see example]({% slug dates_multiviewcalendar %}#toc-partial-dates)).\n         */\n        this.bottomView = CalendarViewEnum[CalendarViewEnum.month];\n        /**\n         * Defines the topmost view, to which the user can navigate.\n         */\n        this.topView = CalendarViewEnum[CalendarViewEnum.century];\n        /**\n         * Determines whether to display a week number column in the `month` view\n         * ([see example]({% slug weeknumcolumn_multiviewcalendar %})).\n         */\n        this.weekNumber = false;\n        /**\n         * Sets or gets the `views` property of the Calendar and\n         * defines the number of rendered months.\n         */\n        this.views = 2;\n        /**\n         * Fires when the active view is changed\n         * ([more information and example]({% slug overview_multiviewcalendar %}#toc-events)).\n         */\n        this.activeViewChange = new EventEmitter();\n        /**\n         * Fires when a view cell is entered\n         * ([more information and example]({% slug overview_multiviewcalendar %}#toc-events)).\n         */\n        this.cellEnter = new EventEmitter();\n        /**\n         * Fires when a view cell is leaved\n         * ([more information and example]({% slug overview_multiviewcalendar %}#toc-events)).\n         */\n        this.cellLeave = new EventEmitter();\n        /**\n         * Fires when the value is changed\n         * ([more information and example]({% slug overview_multiviewcalendar %}#toc-events)).\n         */\n        this.valueChange = new EventEmitter();\n        this.cellUID = guid();\n        this.isActive = false;\n        this.isHovered = false;\n        this.isPrevDisabled = true;\n        this.isNextDisabled = true;\n        this.prevView = Action.PrevView;\n        this.nextView = Action.NextView;\n        this._min = new Date(MIN_DATE);\n        this._max = new Date(MAX_DATE);\n        this._focusedDate = getToday();\n        this.resolvedPromise = Promise.resolve();\n        this.onControlChange = noop;\n        this.onControlTouched = noop;\n        this.onValidatorChange = noop;\n        this.minValidateFn = noop;\n        this.maxValidateFn = noop;\n        this.disabledDatesRangeValidateFn = noop;\n        this.subscriptions = new Subscription(() => { });\n        this.setClasses(element.nativeElement);\n    }\n    /**\n     * Sets or gets the `focusedDate` property of the Calendar and\n     * defines the focused date of the component\n     * ([see example]({% slug dates_multiviewcalendar %}#toc-focused-dates)).\n     *\n     * > If the Calendar is out of the min or max range, it normalizes the defined `focusedDate`.\n     */\n    set focusedDate(focusedDate) {\n        this._focusedDate = focusedDate || getToday();\n    }\n    get focusedDate() {\n        return this._focusedDate;\n    }\n    /**\n     * Sets or gets the `min` property of the Calendar and\n     * defines the minimum allowed date value.\n     * By default, the `min` value is `1900-1-1`.\n     */\n    set min(min) {\n        this._min = min || new Date(MIN_DATE);\n    }\n    get min() {\n        return this._min;\n    }\n    /**\n     * Sets or gets the `max` property of the Calendar and\n     * defines the maximum allowed date value.\n     * By default, the `max` value is `2099-12-31`.\n     */\n    set max(max) {\n        this._max = max || new Date(MAX_DATE);\n    }\n    get max() {\n        return this._max;\n    }\n    /**\n     * Sets or gets the `value` property of the Calendar and defines the selected value of the component.\n     *\n     * > The `value` has to be a valid\n     * [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance.\n     */\n    get value() {\n        return this._value;\n    }\n    set value(candidate) {\n        this.verifyValue(candidate);\n        this._value = cloneDate(candidate);\n    }\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n        this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n        return this.tabindex;\n    }\n    /**\n     * Sets the dates of the MultiViewCalendar that will be disabled\n     * ([see example]({% slug disabled_dates_multiviewcalendar %})).\n     */\n    set disabledDates(value) {\n        this.disabledDatesService.initialize(value);\n    }\n    /**\n     * Sets or gets the `selectionRange` property of the Calendar and\n     * defines the selection range of the component\n     * ([see example]({% slug dates_multiviewcalendar %}#toc-selection-range)).\n     */\n    set selectionRange(range$$1) {\n        this._selectionRange = range$$1;\n        if (this.disabledDatesRangeValidation) {\n            this.onValidatorChange();\n        }\n    }\n    get selectionRange() {\n        return this._selectionRange;\n    }\n    /**\n     * @hidden\n     */\n    set cellTemplateRef(template) {\n        this.cellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n    set monthCellTemplateRef(template) {\n        this.monthCellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n    set yearCellTemplateRef(template) {\n        this.yearCellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n    set decadeCellTemplateRef(template) {\n        this.decadeCellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n    set centuryCellTemplateRef(template) {\n        this.centuryCellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n    set weekNumberTemplateRef(template) {\n        this.weekNumberTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n    set headerTitleTemplateRef(template) {\n        this.headerTitleTemplate = template;\n    }\n    get activeViewEnum() {\n        const activeView = CalendarViewEnum[this.activeView];\n        return activeView < this.bottomViewEnum ? this.bottomViewEnum : activeView;\n    }\n    get bottomViewEnum() {\n        return CalendarViewEnum[this.bottomView];\n    }\n    get topViewEnum() {\n        return CalendarViewEnum[this.topView];\n    }\n    get widgetId() {\n        return this.id;\n    }\n    get widgetRole() {\n        return 'grid';\n    }\n    get calendarTabIndex() {\n        return this.disabled ? undefined : this.tabIndex;\n    }\n    get ariaDisabled() {\n        return this.disabled;\n    }\n    get ariaActivedescendant() {\n        return this.cellUID + this.focusedDate.getTime();\n    }\n    /**\n     * @hidden\n     */\n    handleBlur() {\n        this.onControlTouched();\n        this.isActive = false;\n        this.isHovered = false; //ensure that hovered is also not active\n    }\n    /**\n     * @hidden\n     */\n    handleFocus() {\n        this.isActive = true;\n    }\n    /**\n     * @hidden\n     */\n    handleMouseEnter() {\n        this.isHovered = true;\n    }\n    /**\n     * @hidden\n     */\n    handleMouseLeave() {\n        this.isHovered = false;\n    }\n    /**\n     * @hidden\n     */\n    handleMousedown(event) {\n        event.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n    handleClick() {\n        if (this.isActive) {\n            return;\n        }\n        this.focus();\n    }\n    /**\n     * @hidden\n     */\n    keydown(event) {\n        const candidate = dateInRange(this.navigator.move(this.focusedDate, this.navigator.action(event), this.activeViewEnum), this.min, this.max);\n        if (isEqual(this.focusedDate, candidate)) {\n            return;\n        }\n        this.focusedDate = candidate;\n        event.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n    enter() {\n        this.handleDateChange(this.focusedDate);\n    }\n    ngOnInit() {\n        this.setMessages();\n        this.subscriptions.add(this.localization.changes.subscribe(() => this.setMessages()));\n        this.subscriptions.add(this.bus.viewChanged.subscribe(({ view }) => {\n            this.activeView = CalendarViewEnum[view];\n            this.activeViewChange.emit(this.activeView);\n            this.cdr.detectChanges();\n            this.updateButtonState();\n        }));\n    }\n    ngOnChanges(changes) {\n        this.verifyChanges();\n        this.bus.configure(this.bottomViewEnum, this.topViewEnum);\n        const useValue = hasExistingValue(changes, 'value') && !hasExistingValue(changes, 'focusedDate');\n        const focusedDate = dateInRange(cloneDate(useValue ? this.value : this.focusedDate), this.min, this.max);\n        this.focusedDate = !isEqual(this.focusedDate, focusedDate) ? focusedDate : this.focusedDate;\n        if (changes.min || changes.max || changes.rangeValidation || changes.disabledDates || changes.disabledDatesRangeValidation) {\n            this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop;\n            this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop;\n            this.disabledDatesRangeValidateFn = this.disabledDatesRangeValidation ? disabledDatesRangeValidator(this.disabledDatesService.isDateDisabled) : noop;\n            this.onValidatorChange();\n        }\n        if (changes.min || changes.max || changes.focusedDate || changes.activeView) {\n            this.updateButtonState();\n        }\n    }\n    ngOnDestroy() {\n        clearTimeout(this.messagesTimeout);\n        this.subscriptions.unsubscribe();\n    }\n    ngAfterViewInit() {\n        this.updateButtonState();\n    }\n    /**\n     * Focuses the host element of the Calendar.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"multiviewcalendar.focus()\">Focus calendar</button>\n     *  <kendo-multiviewcalendar #multiviewcalendar></kendo-multiviewcalendar>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n        if (!this.element) {\n            return;\n        }\n        this.element.nativeElement.focus();\n    }\n    /**\n     * Blurs the Calendar component.\n     */\n    blur() {\n        if (!this.element) {\n            return;\n        }\n        this.element.nativeElement.blur();\n    }\n    /**\n     * @hidden\n     */\n    handleDateChange(candidate) {\n        const canNavigateDown = this.bus.canMoveDown(this.activeViewEnum);\n        const isSameDate = !canNavigateDown && isEqual(candidate, this.value);\n        this.focusedDate = cloneDate(candidate) || this.focusedDate;\n        if (this.disabled || isSameDate) {\n            return;\n        }\n        if (canNavigateDown) {\n            this.bus.moveDown(this.activeViewEnum);\n            return;\n        }\n        if (!this.disabledDatesService.isDateDisabled(candidate)) {\n            this.value = cloneDate(candidate);\n            this.onControlChange(cloneDate(candidate));\n            this.valueChange.emit(cloneDate(candidate));\n        }\n    }\n    /**\n     * @hidden\n     */\n    writeValue(candidate) {\n        this.verifyValue(candidate);\n        this.focusedDate = dateInRange(cloneDate(candidate) || this.focusedDate, this.min, this.max);\n        this.value = cloneDate(candidate);\n        this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.onControlChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.onControlTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n        this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n    validate(control) {\n        return this.minValidateFn(control) || this.maxValidateFn(control) || this.disabledDatesRangeValidateFn(this.selectionRange);\n    }\n    /**\n     * @hidden\n     */\n    registerOnValidatorChange(fn) {\n        this.onValidatorChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    activeCellTemplate() {\n        switch (this.activeViewEnum) {\n            case CalendarViewEnum.month:\n                return this.monthCellTemplate || this.cellTemplate;\n            case CalendarViewEnum.year:\n                return this.yearCellTemplate;\n            case CalendarViewEnum.decade:\n                return this.decadeCellTemplate;\n            case CalendarViewEnum.century:\n                return this.centuryCellTemplate;\n            default:\n                return null;\n        }\n    }\n    /**\n     * @hidden\n     */\n    navigate(action) {\n        this.focusedDate = this.viewList.navigate(action);\n        this.updateButtonState();\n    }\n    /**\n     * @hidden\n     */\n    emitCellEvent(emitter, args) {\n        if (hasObservers(emitter)) {\n            this.zone.run(() => {\n                emitter.emit(args);\n            });\n        }\n    }\n    setClasses(element) {\n        this.renderer.addClass(element, 'k-widget');\n        this.renderer.addClass(element, 'k-calendar');\n        this.renderer.addClass(element, 'k-calendar-infinite');\n        this.renderer.addClass(element, 'k-calendar-range');\n    }\n    setMessages() {\n        this.zone.runOutsideAngular(() => {\n            clearTimeout(this.messagesTimeout);\n            this.messagesTimeout = setTimeout(() => {\n                this.prevButtonTitle = this.localization.get('prevButtonTitle');\n                this.nextButtonTitle = this.localization.get('nextButtonTitle');\n                this.cdr.detectChanges();\n            });\n        });\n    }\n    verifyChanges() {\n        if (!isDevMode()) {\n            return;\n        }\n        if (this.min > this.max) {\n            throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK$3} and ${MAX_DOC_LINK$3}.`);\n        }\n        if (this.bottomViewEnum > this.topViewEnum) {\n            throw new Error(`The topView should be greater than bottomView. See ${BOTTOM_VIEW_DOC_LINK$1} and ${TOP_VIEW_DOC_LINK$1}.`);\n        }\n    }\n    verifyValue(candidate) {\n        if (!isDevMode()) {\n            return;\n        }\n        if (candidate && !(candidate instanceof Date)) {\n            throw new Error(`The 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK$5} for possible resolution.`);\n        }\n    }\n    updateButtonState() {\n        this.resolvedPromise.then(() => {\n            this.isPrevDisabled = !this.viewList.canNavigate(this.prevView);\n            this.isNextDisabled = !this.viewList.canNavigate(this.nextView);\n            this.cdr.markForCheck();\n        });\n    }\n}\nMultiViewCalendarComponent.decorators = [\n    { type: Component, args: [{\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                exportAs: 'kendo-multiviewcalendar',\n                providers: [\n                    BusViewService,\n                    RANGE_CALENDAR_VALUE_ACCESSOR,\n                    RANGE_CALENDAR_RANGE_VALIDATORS,\n                    LocalizationService,\n                    DisabledDatesService,\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.multiviewcalendar'\n                    },\n                    NavigationService\n                ],\n                selector: 'kendo-multiviewcalendar',\n                template: `\n    <ng-container kendoMultiViewCalendarLocalizedMessages\n        i18n-today=\"kendo.multiviewcalendar.today|The label for the today button in the calendar header\"\n        today=\"TODAY\"\n\n        i18n-prevButtonTitle=\"kendo.multiviewcalendar.prevButtonTitle|The label for the previous button in the Multiview calendar\"\n        prevButtonTitle=\"Navigate to previous view\"\n\n        i18n-nextButtonTitle=\"kendo.multiviewcalendar.nextButtonTitle|The label for the next button in the Multiview calendar\"\n        nextButtonTitle=\"Navigate to next view\"\n    >\n    </ng-container>\n    <button\n        class=\"k-button k-prev-view\" type=\"button\"\n        [attr.aria-disabled]=\"isPrevDisabled\"\n        [disabled]=\"isPrevDisabled\"\n        [title]=\"prevButtonTitle\"\n        (click)=\"navigate(prevView)\"\n    >\n        <span class=\"k-icon k-i-arrow-chevron-left\"></span>\n    </button>\n    <kendo-calendar-horizontal\n        [activeView]=\"activeViewEnum\"\n        [isActive]=\"isActive || isHovered\"\n        [cellTemplateRef]=\"activeCellTemplate()?.templateRef\"\n        [headerTitleTemplateRef]=\"headerTitleTemplate?.templateRef\"\n        [weekNumberTemplateRef]=\"weekNumberTemplate?.templateRef\"\n        [cellUID]=\"cellUID\"\n        [views]=\"views\"\n        [min]=\"min\"\n        [max]=\"max\"\n        [focusedDate]=\"focusedDate\"\n        [weekNumber]=\"weekNumber\"\n        [activeRangeEnd]=\"activeRangeEnd\"\n        [selectionRange]=\"selectionRange\"\n        [value]=\"value\"\n        (valueChange)=\"handleDateChange($event)\"\n        (cellEnter)=\"emitCellEvent(cellEnter, $event)\"\n        (cellLeave)=\"emitCellEvent(cellLeave, $event)\"\n    >\n    </kendo-calendar-horizontal>\n    <button\n        class=\"k-button k-next-view\" type=\"button\"\n        [attr.aria-disabled]=\"isNextDisabled\"\n        [disabled]=\"isNextDisabled\"\n        [title]=\"nextButtonTitle\"\n        (click)=\"navigate(nextView)\"\n    >\n        <span class=\"k-icon k-i-arrow-chevron-right\"></span>\n    </button>\n  `\n            },] },\n];\n/** @nocollapse */\nMultiViewCalendarComponent.ctorParameters = () => [\n    { type: BusViewService },\n    { type: ElementRef },\n    { type: LocalizationService },\n    { type: NavigationService },\n    { type: Renderer2 },\n    { type: ChangeDetectorRef },\n    { type: NgZone },\n    { type: DisabledDatesService }\n];\nMultiViewCalendarComponent.propDecorators = {\n    id: [{ type: Input }],\n    focusedDate: [{ type: Input }],\n    min: [{ type: Input }],\n    max: [{ type: Input }],\n    rangeValidation: [{ type: Input }],\n    disabledDatesRangeValidation: [{ type: Input }],\n    value: [{ type: Input }],\n    disabled: [{ type: Input }],\n    tabindex: [{ type: Input }],\n    tabIndex: [{ type: Input }],\n    disabledDates: [{ type: Input }],\n    activeView: [{ type: Input }],\n    bottomView: [{ type: Input }],\n    topView: [{ type: Input }],\n    weekNumber: [{ type: Input }],\n    activeRangeEnd: [{ type: Input }],\n    selectionRange: [{ type: Input }],\n    views: [{ type: Input }],\n    activeViewChange: [{ type: Output }],\n    cellEnter: [{ type: Output }],\n    cellLeave: [{ type: Output }],\n    valueChange: [{ type: Output }],\n    cellTemplate: [{ type: ContentChild, args: [CellTemplateDirective, { static: true },] }],\n    cellTemplateRef: [{ type: Input, args: ['cellTemplate',] }],\n    monthCellTemplate: [{ type: ContentChild, args: [MonthCellTemplateDirective, { static: true },] }],\n    monthCellTemplateRef: [{ type: Input, args: ['monthCellTemplate',] }],\n    yearCellTemplate: [{ type: ContentChild, args: [YearCellTemplateDirective, { static: true },] }],\n    yearCellTemplateRef: [{ type: Input, args: ['yearCellTemplate',] }],\n    decadeCellTemplate: [{ type: ContentChild, args: [DecadeCellTemplateDirective, { static: true },] }],\n    decadeCellTemplateRef: [{ type: Input, args: ['decadeCellTemplate',] }],\n    centuryCellTemplate: [{ type: ContentChild, args: [CenturyCellTemplateDirective, { static: true },] }],\n    centuryCellTemplateRef: [{ type: Input, args: ['centuryCellTemplate',] }],\n    weekNumberTemplate: [{ type: ContentChild, args: [WeekNumberCellTemplateDirective, { static: true },] }],\n    weekNumberTemplateRef: [{ type: Input, args: ['weekNumberTemplate',] }],\n    headerTitleTemplate: [{ type: ContentChild, args: [HeaderTitleTemplateDirective, { static: true },] }],\n    headerTitleTemplateRef: [{ type: Input, args: ['headerTitleTemplate',] }],\n    viewList: [{ type: ViewChild, args: [HorizontalViewListComponent,] }],\n    widgetId: [{ type: HostBinding, args: ['attr.id',] }],\n    widgetRole: [{ type: HostBinding, args: ['attr.role',] }],\n    calendarTabIndex: [{ type: HostBinding, args: ['attr.tabindex',] }],\n    ariaDisabled: [{ type: HostBinding, args: ['attr.aria-disabled',] }, { type: HostBinding, args: ['class.k-state-disabled',] }],\n    ariaActivedescendant: [{ type: HostBinding, args: ['attr.aria-activedescendant',] }],\n    handleBlur: [{ type: HostListener, args: [\"blur\",] }],\n    handleFocus: [{ type: HostListener, args: [\"focus\",] }],\n    handleMouseEnter: [{ type: HostListener, args: [\"mouseenter\",] }],\n    handleMouseLeave: [{ type: HostListener, args: [\"mouseleave\",] }],\n    handleMousedown: [{ type: HostListener, args: [\"mousedown\", ['$event'],] }],\n    handleClick: [{ type: HostListener, args: [\"click\",] }],\n    keydown: [{ type: HostListener, args: [\"keydown\", [\"$event\"],] }],\n    enter: [{ type: HostListener, args: [\"keydown.enter\",] }]\n};\n\n/**\n * Represents the Kendo UI DateRangePopup component for Angular.\n *\n * @example\n * ```ts\n * import { DateInputsModule, DateRangeService } from '@progress/kendo-angular-dateinputs';\n *\n * _@Component({\n * providers: [DateRangeService],\n * selector: 'my-app',\n * template: `\n *  <button #anchor (click)=\"popup.toggle()\">Toggle</button>\n *  <kendo-daterange-popup [anchor]=\"anchor\" #popup></kendo-daterange-popup>\n * `\n * })\n * class AppComponent {\n * }\n * ```\n */\nclass DateRangePopupComponent {\n    constructor(popupService, dateRangeService, zone, rtl) {\n        this.popupService = popupService;\n        this.dateRangeService = dateRangeService;\n        this.zone = zone;\n        this.rtl = rtl;\n        /**\n         * Controls the popup animation.\n         * By default, the opening and closing animations are enabled.\n         * For more information about controlling the popup animations,\n         * refer to the article on [animations]({% slug animations_popup %}).\n         */\n        this.animate = true;\n        /**\n         * Configures the collision behavior of the popup.\n         * For more information, refer to the article on\n         * [viewport boundary detection]({% slug viewportboundarydetection_popup %}).\n         */\n        this.collision = { horizontal: 'fit', vertical: 'flip' };\n        /**\n         * Fires each time the popup is about to open.\n         * This event is preventable. If you cancel the event, the popup will remain closed.\n         * For more information, refer to the section on\n         * [events]({% slug overview_datepicker %}#toc-events).\n         */\n        this.open = new EventEmitter();\n        /**\n         * Fires each time the popup is about to close.\n         * This event is preventable. If you cancel the event, the popup will remain open.\n         * For more information, refer to the section on\n         * [events]({% slug overview_datepicker %}#toc-events).\n         */\n        this.close = new EventEmitter();\n        /**\n         * Fires each time the calendar element is blurred.\n         */\n        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the calendar element is focused.\n         */\n        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the popup is closed either on `ESC` keypress or on leaving the viewport.\n         */\n        this.cancel = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.popupUID = guid();\n        this.calendarSubscriptions = new Subscription(() => { });\n        this.popupSubscriptions = new Subscription(() => { });\n        this.resolvedPromise = Promise.resolve();\n    }\n    /**\n     * The active calendar that is visible in the popup.\n     *\n     * > When the popup is closed, the property returns `null`.\n     */\n    get calendar() {\n        return this._calendar;\n    }\n    set calendar(calendar) {\n        this._calendar = calendar;\n        this.subscribeFocusBlur(calendar);\n    }\n    /**\n     * Gets the active state of the component.\n     * When the opened calendar is active, returns `true`.\n     */\n    get isActive() {\n        return this.calendar && this.calendar.isActive;\n    }\n    /**\n     * Gets or sets the visibility state of the component.\n     */\n    set show(show) {\n        const event = new PreventableEvent();\n        if (this._show === show) {\n            return;\n        }\n        if (!this._show && show) {\n            this.open.emit(event);\n        }\n        else if (this._show && !show) {\n            this.close.emit(event);\n        }\n        if (event.isDefaultPrevented()) {\n            return;\n        }\n        this._toggle(show);\n    }\n    get show() {\n        return this._show;\n    }\n    ngOnInit() {\n        this.dateRangeService.registerPopup(this);\n    }\n    ngAfterViewInit() {\n        this.calendarSubscriptions.add(this.contentCalendar.changes.subscribe((changes) => this.calendar = changes.first));\n        this.calendarSubscriptions.add(this.viewCalendar.changes.subscribe((changes) => this.calendar = changes.first));\n        if (isWindowAvailable()) {\n            this.zone.runOutsideAngular(() => this.windowBlurSubscription = fromEvent(window, 'blur').subscribe(this.handleWindowBlur.bind(this)));\n        }\n    }\n    ngOnDestroy() {\n        this.popupSubscriptions.unsubscribe();\n        this.calendarSubscriptions.unsubscribe();\n        if (this.activateSubscription) {\n            this.activateSubscription.unsubscribe();\n        }\n        if (this.blurSubscription) {\n            this.blurSubscription.unsubscribe();\n            this.focusSubscription.unsubscribe();\n        }\n        if (this.windowBlurSubscription) {\n            this.windowBlurSubscription.unsubscribe();\n        }\n    }\n    /**\n     *  Opens the popup component and focuses the calendar.\n     */\n    activate() {\n        if (this.show === true) {\n            return;\n        }\n        if (this.activateSubscription) {\n            this.activateSubscription.unsubscribe();\n        }\n        this.show = true;\n        this.zone.runOutsideAngular(() => {\n            this.activateSubscription = merge(this.contentCalendar.changes, this.viewCalendar.changes)\n                .pipe(filter(changes => changes && changes.first), map(changes => changes.first))\n                .subscribe((calendar) => setTimeout(() => calendar.focus()));\n        });\n    }\n    /**\n     *  Focuses the calendar (if available).\n     */\n    focus() {\n        if (this.calendar) {\n            this.calendar.focus();\n        }\n    }\n    /**\n     * Checks if a focused element ids placed inside the popup.\n     *\n     * @return boolean;\n     */\n    hasActiveContent() {\n        if (!isDocumentAvailable() || !this.popupRef) {\n            return false;\n        }\n        return this.popupRef.popupElement.contains(document.activeElement);\n    }\n    /**\n     * Toggles the visibility of the popup.\n     * If you use the `toggle` method to show or hide the popup,\n     * the `open` and `close` events do not fire.\n     *\n     * @param show The state of the popup.\n     */\n    toggle(show) {\n        this.resolvedPromise.then(() => {\n            this._toggle((show === undefined) ? !this.show : show);\n        });\n    }\n    /**\n     * @hidden\n     *\n     * Closes the popup and triggers the `cancel` event.\n     */\n    cancelPopup() {\n        this.show = false;\n        this.cancel.emit();\n    }\n    handleWindowBlur() {\n        if (!this.show) {\n            return;\n        }\n        if (hasObservers(this.close)) {\n            this.zone.run(() => this.show = false);\n        }\n        else {\n            this.show = false;\n        }\n    }\n    handleMouseLeave() {\n        this.dateRangeService.setRange(this.dateRangeService.selectionRange);\n    }\n    handleKeydown(event) {\n        const { altKey, keyCode } = event;\n        if (keyCode === Keys.Escape || (altKey && keyCode === Keys.ArrowUp)) {\n            this.zone.run(() => this.cancelPopup());\n        }\n    }\n    subscribeFocusBlur(calendar) {\n        if (this.blurSubscription) {\n            this.blurSubscription.unsubscribe();\n            this.focusSubscription.unsubscribe();\n        }\n        if (!calendar) {\n            return;\n        }\n        const nativeElement = calendar.element.nativeElement;\n        this.blurSubscription = fromEvent(nativeElement, 'blur').subscribe(() => this.onBlur.emit());\n        this.focusSubscription = fromEvent(nativeElement, 'focus').subscribe(() => this.onFocus.emit());\n    }\n    addPopupSubscriptions(...subscriptions) {\n        subscriptions.map(s => this.popupSubscriptions.add(s));\n    }\n    get _appendTo() {\n        const appendTo = this.appendTo;\n        if (!appendTo || appendTo === 'root') {\n            return undefined;\n        }\n        return appendTo === 'component' ? this.container : appendTo;\n    }\n    _toggle(show) {\n        this._show = show;\n        if (this.popupRef) {\n            this.popupRef.close();\n            this.popupRef = null;\n            this.popupSubscriptions.unsubscribe();\n            this.popupSubscriptions = new Subscription(() => { });\n        }\n        if (this._show) {\n            const direction = this.rtl ? 'right' : 'left';\n            this.popupRef = this.popupService.open({\n                anchor: this.anchor,\n                anchorAlign: this.anchorAlign || { vertical: 'bottom', horizontal: direction },\n                animate: this.animate,\n                appendTo: this._appendTo,\n                collision: this.collision,\n                content: (this.contentTemplate || {}).templateRef || this.defaultTemplate,\n                margin: this.margin,\n                popupAlign: this.popupAlign || { vertical: 'top', horizontal: direction },\n                positionMode: 'absolute'\n            });\n            const { popupElement, popupAnchorViewportLeave } = this.popupRef;\n            popupElement.setAttribute('id', this.popupUID);\n            this.addPopupSubscriptions(this.zone.runOutsideAngular(() => fromEvent(popupElement, 'keydown').subscribe(this.handleKeydown.bind(this))), fromEvent(popupElement, 'mouseleave').subscribe(this.handleMouseLeave.bind(this)), popupAnchorViewportLeave.subscribe(() => this.cancelPopup()));\n        }\n    }\n}\nDateRangePopupComponent.decorators = [\n    { type: Component, args: [{\n                exportAs: 'kendo-daterange-popup',\n                selector: 'kendo-daterange-popup',\n                template: `\n        <ng-container #container></ng-container>\n        <ng-template #defaultTemplate>\n            <kendo-multiviewcalendar kendoDateRangeSelection></kendo-multiviewcalendar>\n        </ng-template>\n    `\n            },] },\n];\n/** @nocollapse */\nDateRangePopupComponent.ctorParameters = () => [\n    { type: PopupService },\n    { type: DateRangeService },\n    { type: NgZone },\n    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [RTL,] }] }\n];\nDateRangePopupComponent.propDecorators = {\n    container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef },] }],\n    defaultTemplate: [{ type: ViewChild, args: ['defaultTemplate',] }],\n    contentTemplate: [{ type: ContentChild, args: [DateRangePopupTemplateDirective,] }],\n    viewCalendar: [{ type: ViewChildren, args: [MultiViewCalendarComponent,] }],\n    contentCalendar: [{ type: ContentChildren, args: [MultiViewCalendarComponent,] }],\n    animate: [{ type: Input }],\n    anchor: [{ type: Input }],\n    anchorAlign: [{ type: Input }],\n    appendTo: [{ type: Input }],\n    collision: [{ type: Input }],\n    popupAlign: [{ type: Input }],\n    margin: [{ type: Input }],\n    open: [{ type: Output }],\n    close: [{ type: Output }],\n    onBlur: [{ type: Output, args: ['blur',] }],\n    onFocus: [{ type: Output, args: ['focus',] }],\n    cancel: [{ type: Output }]\n};\n\n/**\n * Represents the Kendo UI DateRange component for Angular.\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-daterange>\n *      <kendo-dateinput kendoDateRangeStartInput [(value)]=\"dateRange.start\"></kendo-dateinput>\n *      <kendo-dateinput kendoDateRangeEndInput [(value)]=\"dateRange.end\"></kendo-dateinput>\n *  </kendo-daterange>\n * `\n * })\n * class AppComponent {\n *   public dateRange: any = { start: null, end: null };\n * }\n * ```\n */\nclass DateRangeComponent {\n    constructor() {\n        /**\n         * @hidden\n         */\n        this.showDefault = false;\n    }\n    get hasContentPopup() {\n        return this.contentPopup.length > 0;\n    }\n    ngAfterContentInit() {\n        this.showDefault = !this.hasContentPopup;\n        this.subscription = this.contentPopup.changes.subscribe(() => {\n            this.showDefault = !this.hasContentPopup;\n        });\n    }\n    ngOnDestroy() {\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n        }\n    }\n}\nDateRangeComponent.decorators = [\n    { type: Component, args: [{\n                providers: [DateRangeService],\n                selector: 'kendo-daterange',\n                template: `\n        <ng-content></ng-content>\n        <kendo-daterange-popup *ngIf=\"showDefault\"></kendo-daterange-popup>\n    `\n            },] },\n];\nDateRangeComponent.propDecorators = {\n    contentPopup: [{ type: ContentChildren, args: [DateRangePopupComponent,] }]\n};\n\n/**\n * @hidden\n */\nclass DateRangeInput {\n    constructor(activeRangeEnd, dateRangeService, input, element, renderer, zone) {\n        this.activeRangeEnd = activeRangeEnd;\n        this.dateRangeService = dateRangeService;\n        this.input = input;\n        this.element = element;\n        this.renderer = renderer;\n        this.zone = zone;\n        this.navigateCalendarOnFocus = false;\n        this.popupSubscriptions = new Subscription(() => { });\n        this.subscriptions = new Subscription(() => { });\n    }\n    get isActiveEnd() {\n        return this.dateRangeService.activeRangeEnd === this.activeRangeEnd;\n    }\n    get popupCalendarActivated() {\n        const popup = this.dateRangeService.dateRangePopup$.value;\n        return isPresent(popup) && isPresent(popup.calendar);\n    }\n    init() {\n        if (this.input.value) {\n            this.dateRangeService.setRange(this.getRange(this.input.value));\n        }\n        [\n            this.input.onBlur.subscribe(() => this.deactivate()),\n            this.input.onFocus.pipe(filter(() => !this.popupCalendarActivated)).subscribe(() => this.activate()),\n            this.input.valueUpdate.subscribe(value => this.updateRange(value, 'change')),\n            this.dateRangeService.activeRangeEnd$.subscribe(() => {\n                if (this.navigateCalendarOnFocus) {\n                    this.focusActiveDate();\n                }\n                this.toggleActiveClass(this.isActiveEnd);\n            }),\n            this.dateRangeService.dateRangePopup$.subscribe(popup => this.initPopup(popup)),\n            this.dateRangeService.range$.subscribe(range => this.updateInputValue(range)),\n            fromEvent(this.element.nativeElement, 'click').subscribe(() => this.activate()),\n            fromEvent(this.element.nativeElement, 'keydown').subscribe((event) => this.togglePopup(event || {}))\n        ].map(s => this.subscriptions.add(s));\n    }\n    destroy() {\n        this.subscriptions.unsubscribe();\n        this.unsubscribePopup();\n    }\n    initPopup(popup) {\n        if (!popup) {\n            this.unsubscribePopup();\n            return;\n        }\n        if (!popup.anchor) {\n            popup.anchor = this.element.nativeElement;\n        }\n        [\n            popup.cancel.subscribe(() => this.isActiveEnd && this.input.focus()),\n            popup.onFocus.subscribe(() => this.toggleActiveClass(this.isActiveEnd)),\n            popup.onBlur.subscribe(() => this.deactivate())\n        ].map(s => this.popupSubscriptions.add(s));\n    }\n    unsubscribePopup() {\n        this.popupSubscriptions.unsubscribe();\n        this.popupSubscriptions = new Subscription(() => { });\n    }\n    activate() {\n        this.dateRangeService.setActiveRangeEnd(this.activeRangeEnd);\n        this.dateRangeService.activatePopup();\n    }\n    deactivate() {\n        this.zone.runOutsideAngular(() => {\n            setTimeout(() => {\n                this.updateRange(this.input.value, 'blur');\n                if (this.dateRangeService.hasActiveComponent()) {\n                    return;\n                }\n                this.toggleActiveClass(false);\n                this.zone.run(() => this.dateRangeService.deactivatePopup());\n            });\n        });\n    }\n    updateRange(value, correctOn) {\n        const range = this.getRange(value, correctOn);\n        if (range) {\n            this.focusActiveDate();\n            this.dateRangeService.setRange(range);\n        }\n    }\n    togglePopup({ altKey, keyCode }) {\n        if (keyCode === Keys.Escape) {\n            this.dateRangeService.cancelPopup();\n        }\n        else if (altKey && keyCode === Keys.ArrowDown) {\n            this.dateRangeService.activatePopup();\n        }\n    }\n    focusActiveDate() {\n        if (this.input.value && this.isActiveEnd) {\n            this.dateRangeService.setFocusedDate(cloneDate(this.input.value));\n        }\n    }\n    toggleActiveClass(show) {\n        const action = show ? 'addClass' : 'removeClass';\n        const nativeElement = this.element.nativeElement;\n        if (nativeElement && nativeElement.querySelector) {\n            this.renderer[action](nativeElement.querySelector('.k-dateinput-wrap'), 'k-state-focused');\n        }\n    }\n}\n\n/**\n * A directive which manages the end range selection.\n *\n * > You can use the DateRangeEndInputDirective only with a DateInput component.\n */\nclass DateRangeEndInputDirective extends DateRangeInput {\n    constructor(rangeService, dateInput, element, renderer, zone) {\n        super('end', rangeService, dateInput, element, renderer, zone);\n        this.rangeService = rangeService;\n        this.dateInput = dateInput;\n        /**\n         * Specifies the navigation behavior of the calendar when the active end is changed on input focus. When enabled,\n         * the calendar navigates to the value of the focused input. Otherwise, the calendar displays the last picked date.\n         *\n         * By default, the automatic navigation behavior on input focus is disabled.\n         *\n         * @example\n         * ```ts\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <h5>Toggle input focus to see the calendar navigating between range ends.</h5>\n         *  <kendo-daterange>\n         *      <kendo-dateinput kendoDateRangeStartInput [navigateCalendarOnFocus]=\"true\" [(value)]=\"start\"></kendo-dateinput>\n         *      <kendo-dateinput kendoDateRangeEndInput [navigateCalendarOnFocus]=\"true\" [(value)]=\"end\"></kendo-dateinput>\n         *  </kendo-daterange>\n         * `\n         * })\n         * class AppComponent {\n         *   public start: Date = new Date(2018, 3, 10);\n         *   public end: Date = new Date(2018, 10, 20);\n         * }\n         * ```\n         */\n        this.navigateCalendarOnFocus = false;\n    }\n    ngOnInit() {\n        this.rangeService.registerEndInput(this.dateInput);\n        super.init();\n    }\n    ngOnDestroy() {\n        super.destroy();\n    }\n    getRange(value, correctOn) {\n        const { min, max } = this.dateInput;\n        if (!isInRange(value, min, max)) {\n            return null;\n        }\n        const { start } = this.rangeService.selectionRange || EMPTY_SELECTIONRANGE;\n        return this.autoCorrectOn === correctOn && value < start ? clampRange(value) : { start, end: cloneDate(value) };\n    }\n    updateInputValue(range$$1) {\n        const { end } = range$$1 || EMPTY_SELECTIONRANGE;\n        const { min, max } = this.dateInput;\n        if (isEqual(this.dateInput.value, end) || !isInRange(end, min, max)) {\n            return;\n        }\n        this.dateInput.writeValue(cloneDate(end));\n        this.dateInput.notify();\n    }\n}\nDateRangeEndInputDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoDateRangeEndInput]'\n            },] },\n];\n/** @nocollapse */\nDateRangeEndInputDirective.ctorParameters = () => [\n    { type: DateRangeService },\n    { type: DateInputComponent },\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: NgZone }\n];\nDateRangeEndInputDirective.propDecorators = {\n    autoCorrectOn: [{ type: Input }],\n    navigateCalendarOnFocus: [{ type: Input }]\n};\n\n/**\n * A directive which manages the start selection range.\n *\n * > You can use the DateRangeStartInputDirective only with a DateInput component.\n */\nclass DateRangeStartInputDirective extends DateRangeInput {\n    constructor(rangeService, dateInput, element, renderer, zone) {\n        super('start', rangeService, dateInput, element, renderer, zone);\n        this.rangeService = rangeService;\n        this.dateInput = dateInput;\n        /**\n         * Specifies the navigation behavior of the calendar when the active end is changed on input focus.\n         * When enabled, the calendar navigates to the value of the focused input. Otherwise, the calendar\n         * displays the last picked date.\n         *\n         * By default, the automatic navigation behavior on input focus is disabled.\n         *\n         * @example\n         * ```ts\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <h5>Toggle input focus to see the calendar navigating between range ends.</h5>\n         *  <kendo-daterange>\n         *      <kendo-dateinput kendoDateRangeStartInput [navigateCalendarOnFocus]=\"true\" [(value)]=\"start\"></kendo-dateinput>\n         *      <kendo-dateinput kendoDateRangeEndInput [navigateCalendarOnFocus]=\"true\" [(value)]=\"end\"></kendo-dateinput>\n         *  </kendo-daterange>\n         * `\n         * })\n         * class AppComponent {\n         *   public start: Date = new Date(2018, 3, 10);\n         *   public end: Date = new Date(2018, 10, 20);\n         * }\n         * ```\n         */\n        this.navigateCalendarOnFocus = false;\n    }\n    ngOnInit() {\n        this.rangeService.registerStartInput(this.dateInput);\n        super.init();\n    }\n    ngOnDestroy() {\n        super.destroy();\n    }\n    getRange(value, correctOn) {\n        const { min, max } = this.dateInput;\n        if (!isInRange(value, min, max)) {\n            return null;\n        }\n        const { end } = this.rangeService.selectionRange || EMPTY_SELECTIONRANGE;\n        const shouldClamp = this.autoCorrectOn === correctOn && end && value > end;\n        return shouldClamp ? clampRange(value) : { start: cloneDate(value), end };\n    }\n    updateInputValue(range$$1) {\n        const { start } = range$$1 || EMPTY_SELECTIONRANGE;\n        const { min, max } = this.dateInput;\n        if (isEqual(this.dateInput.value, start) || !isInRange(start, min, max)) {\n            return;\n        }\n        this.dateInput.writeValue(cloneDate(start));\n        this.dateInput.notify();\n    }\n}\nDateRangeStartInputDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoDateRangeStartInput]'\n            },] },\n];\n/** @nocollapse */\nDateRangeStartInputDirective.ctorParameters = () => [\n    { type: DateRangeService },\n    { type: DateInputComponent },\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: NgZone }\n];\nDateRangeStartInputDirective.propDecorators = {\n    autoCorrectOn: [{ type: Input }],\n    navigateCalendarOnFocus: [{ type: Input }]\n};\n\n/**\n * A directive which manages the MultiViewCalendar range selection.\n */\nclass DateRangeSelectionDirective {\n    constructor(calendar, cdr, element, renderer, dateRangeService) {\n        this.calendar = calendar;\n        this.cdr = cdr;\n        this.element = element;\n        this.dateRangeService = dateRangeService;\n        /**\n         * Specifies the auto-correction behavior. If the start date is greater than the end date,\n         * the directive fixes the date range to a single date either on input change or on blur\n         * ([see example]({% slug autocorrect_daterange %}#toc-configuring-the-calendar-selection-directive)).\n         *\n         * By default, the auto-correction is triggered on change.\n         * To disable this behavior, set the `autoCorrectOn` property to `none`.\n         */\n        this.autoCorrectOn = 'change';\n        /**\n         * Fires when the active range end is changed. For more information, refer to\n         * the section on [events]({% slug overview_multiviewcalendar %}#toc-events).\n         */\n        this.activeRangeEndChange = new EventEmitter();\n        /**\n         * Fires when the selection range is changed. For more information, refer to\n         * the section on [events]({% slug overview_multiviewcalendar %}#toc-events).\n         */\n        this.selectionRangeChange = new EventEmitter();\n        this.calendarSubscriptions = new Subscription(() => { });\n        this.dateRangeService = this.dateRangeService || new DateRangeService();\n        renderer.setAttribute(element.nativeElement, 'aria-multiselectable', 'true');\n    }\n    /**\n     * Gets or sets the selection range of the calendar. When a new range is set,\n     * the connected DateRangeService notifies all related parties.\n     */\n    get selectionRange() {\n        return this.calendar ? this.calendar.selectionRange : null;\n    }\n    set selectionRange(range$$1) {\n        if (!this.isEqualCalendarRange(range$$1)) {\n            this.setSelectionRange(range$$1);\n        }\n        if (!isEqualRange(this.dateRangeService.selectionRange, range$$1)) {\n            this.dateRangeService.setRange(range$$1);\n        }\n        this.updateFocusedDate(range$$1);\n    }\n    /**\n     * Gets or sets the active end of the selection range. This option determines which range end will be updated on\n     * user interaction. When a new active end is set, the connected DateRangeService notifies all related parties.\n     */\n    /**\n     * Specifies which end of the selection range will be marked as active. The active end gets modified upon user\n     * interaction. When a new active end is set, the wired DateRangeService notifies all related components. For\n     * example, the start and end DateInput components.\n     *\n     * > If the selection range is undefined, the value is ignored.\n     */\n    get activeRangeEnd() {\n        return this.calendar.activeRangeEnd;\n    }\n    set activeRangeEnd(activeRange) {\n        if (this.dateRangeService.activeRangeEnd === activeRange) {\n            return;\n        }\n        this.calendar.activeRangeEnd = activeRange;\n        this.dateRangeService.setActiveRangeEnd(activeRange);\n    }\n    get calendarRange() {\n        return this.selectionRange || EMPTY_SELECTIONRANGE;\n    }\n    ngOnInit() {\n        const calendar = this.calendar;\n        const dateRangeService = this.dateRangeService;\n        calendar.min = either(dateRangeService.min, calendar.min);\n        calendar.max = either(dateRangeService.max, calendar.max);\n        this.addSubscriptions(calendar.cellEnter.subscribe((value) => this.handleHover(value)), calendar.valueChange.subscribe((value) => this.handleChange(value)), dateRangeService.focusedDate$.subscribe(focusedDate => {\n            if (!isEqual(calendar.focusedDate, focusedDate)) {\n                calendar.focusedDate = focusedDate;\n            }\n        }), dateRangeService.activeRangeEnd$.subscribe(rangeEnd => {\n            if (calendar.activeRangeEnd === rangeEnd) {\n                return;\n            }\n            calendar.activeRangeEnd = rangeEnd;\n            this.activeRangeEndChange.emit(rangeEnd);\n            this.cdr.markForCheck();\n        }), dateRangeService.range$.subscribe(range$$1 => {\n            if (!this.isEqualCalendarRange(range$$1)) {\n                this.acceptAndEmit(range$$1);\n            }\n            this.updateFocusedDate(range$$1);\n        }), fromEvent(this.element.nativeElement, 'blur').subscribe(() => this.handleBlur()));\n    }\n    ngOnDestroy() {\n        this.calendarSubscriptions.unsubscribe();\n    }\n    addSubscriptions(...subscriptions) {\n        subscriptions.map(s => this.calendarSubscriptions.add(s));\n    }\n    isEqualCalendarRange(range$$1) {\n        return isEqualRange(this.calendar.selectionRange, range$$1);\n    }\n    handleBlur() {\n        const { start, end } = this.calendarRange;\n        const autoCorrect = this.autoCorrectOn === 'blur' && start !== null && end !== null && end < start;\n        if (autoCorrect) {\n            this.dateRangeService.setRange(clampRange(start));\n        }\n    }\n    handleChange(value) {\n        const service = this.dateRangeService;\n        const autoCorrect = this.autoCorrectOn === 'change' && this.shouldAutoCorrect(value);\n        const activeEnd = this.calendar.activeRangeEnd !== 'end' ? 'end' : (autoCorrect ? 'end' : 'start');\n        const range$$1 = autoCorrect ? clampRange(value) : this.updateRange(value);\n        if (!isEqualRange(service.selectionRange, range$$1)) {\n            this.acceptAndEmit(range$$1);\n            service.setActiveRangeEnd(activeEnd);\n            service.setRange(range$$1);\n        }\n    }\n    handleHover(value) {\n        this.dateRangeService.setFocusedDate(cloneDate(value));\n        if (this.hasCompleteRange()) {\n            return;\n        }\n        const { start, end } = this.calendarRange;\n        const activeRangeEnd = this.calendar.activeRangeEnd;\n        const updateRange = (start && activeRangeEnd === 'end') || (end && activeRangeEnd === 'start');\n        if (updateRange) {\n            this.setSelectionRange(this.updateRange(value));\n        }\n    }\n    hasCompleteRange() {\n        const { start, end } = this.dateRangeService.selectionRange || EMPTY_SELECTIONRANGE;\n        return Boolean(start) && Boolean(end);\n    }\n    shouldAutoCorrect(value) {\n        const { end, start } = this.calendarRange;\n        if (this.calendar.activeRangeEnd !== 'end') {\n            return end !== null && value > end;\n        }\n        else {\n            return start !== null && value < start;\n        }\n    }\n    updateFocusedDate(range$$1) {\n        if (!range$$1 || this.dateRangeService.focusedDate) {\n            return;\n        }\n        this.dateRangeService.setFocusedDate(range$$1.start || range$$1.end);\n    }\n    updateRange(value) {\n        const { end, start } = this.calendarRange;\n        return this.calendar.activeRangeEnd !== 'end' ? ({ start: value, end }) : ({ start, end: value });\n    }\n    setSelectionRange(range$$1) {\n        this.calendar.selectionRange = range$$1;\n        this.calendar.writeValue(null);\n    }\n    acceptAndEmit(range$$1) {\n        this.setSelectionRange(range$$1);\n        this.selectionRangeChange.emit(range$$1);\n    }\n}\nDateRangeSelectionDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoDateRangeSelection]'\n            },] },\n];\n/** @nocollapse */\nDateRangeSelectionDirective.ctorParameters = () => [\n    { type: MultiViewCalendarComponent },\n    { type: ChangeDetectorRef },\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: DateRangeService, decorators: [{ type: Optional }] }\n];\nDateRangeSelectionDirective.propDecorators = {\n    autoCorrectOn: [{ type: Input }],\n    selectionRange: [{ type: Input }],\n    activeRangeEnd: [{ type: Input }],\n    activeRangeEndChange: [{ type: Output }],\n    selectionRangeChange: [{ type: Output }]\n};\n\n/* tslint:disable:directive-class-suffix directive-selector */\n/**\n * @hidden\n */\nclass KForOfContext {\n    constructor($implicit, kForOf, index, count) {\n        this.$implicit = $implicit;\n        this.kForOf = kForOf;\n        this.index = index;\n        this.count = count;\n    }\n    get first() { return this.index === 0; }\n    get last() { return this.index === this.count - 1; }\n    get even() { return this.index % 2 === 0; }\n    get odd() { return !this.even; }\n}\n/**\n * @hidden\n */\nclass KForOf {\n    constructor(_viewContainer, _template, _differs) {\n        this._viewContainer = _viewContainer;\n        this._template = _template;\n        this._differs = _differs;\n        this._differ = null;\n    }\n    set kForTemplate(value) {\n        if (value) {\n            this._template = value;\n        }\n    }\n    ngOnChanges(changes) {\n        if ('kForOf' in changes) {\n            const value = changes.kForOf.currentValue;\n            if (this._differ || !value) {\n                return;\n            }\n            try {\n                this._differ = this._differs.find(value).create(this.kForTrackBy);\n            }\n            catch (e) {\n                throw new Error(`Cannot find a differ supporting object '${value}' of type '${getTypeNameForDebugging(value)}'.`);\n            }\n        }\n    }\n    ngDoCheck() {\n        if (this._differ) {\n            const changes = this._differ.diff(this.kForOf);\n            if (changes) {\n                this._applyChanges(changes);\n            }\n        }\n    }\n    _applyChanges(changes) {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        const viewContainerLength = this._viewContainer.length;\n        const dataLength = this.kForOf.length;\n        const tuples = {};\n        changes.forEachOperation((record, _, currentIndex) => {\n            if (currentIndex !== null) {\n                tuples[currentIndex] = record.item;\n            }\n        });\n        for (let i = viewContainerLength; i < dataLength; i++) {\n            this._viewContainer.createEmbeddedView(this._template, new KForOfContext(null, this.kForOf, -1, -1), i);\n        }\n        for (let i = this._viewContainer.length; i > dataLength; i--) {\n            this._viewContainer.remove(i - 1);\n        }\n        for (let i = 0; i < this._viewContainer.length; i++) {\n            const view = this._viewContainer.get(i);\n            view.context.index = i;\n            view.context.count = length;\n            view.context.$implicit = tuples[i] || null;\n        }\n    }\n}\nKForOf.decorators = [\n    { type: Directive, args: [{ selector: '[kFor][kForOf]' },] },\n];\n/** @nocollapse */\nKForOf.ctorParameters = () => [\n    { type: ViewContainerRef },\n    { type: TemplateRef },\n    { type: IterableDiffers }\n];\nKForOf.propDecorators = {\n    kForOf: [{ type: Input }],\n    kForTrackBy: [{ type: Input }],\n    kForTemplate: [{ type: Input }]\n};\n/**\n * @hidden\n */\nfunction getTypeNameForDebugging(type) {\n    return type.name || typeof type;\n}\n\n/**\n * @hidden\n */\nclass HeaderComponent {\n    constructor(bus, cdr, localization, intl, disabledDatesService) {\n        this.bus = bus;\n        this.cdr = cdr;\n        this.localization = localization;\n        this.intl = intl;\n        this.disabledDatesService = disabledDatesService;\n        this.navigate = true;\n        this.todayAvailable = true;\n        this.min = new Date(MIN_DATE);\n        this.max = new Date(MAX_DATE);\n        this.rangeLength = 1;\n        this.today = new EventEmitter();\n        this.subscriptions = new Subscription();\n    }\n    get getComponentClass() {\n        return true;\n    }\n    ngOnInit() {\n        this.subscriptions\n            .add(this.intl.changes.subscribe(this.intlChange.bind(this)))\n            .add(this.localization.changes.subscribe(this.l10nChange.bind(this)))\n            .add(this.disabledDatesService.changes.subscribe(this.setTodayAvailability.bind(this)));\n    }\n    ngOnChanges(_) {\n        const service = this.bus.service(this.activeView);\n        if (!service) {\n            return;\n        }\n        this.activeViewValue = CalendarViewEnum[this.activeView];\n        this.todayMessage = this.localization.get('today');\n        this.setTodayAvailability();\n        this.navigate = this.bus.canMoveUp(this.activeView);\n        this.title = this.getTitle();\n    }\n    ngOnDestroy() {\n        this.subscriptions.unsubscribe();\n    }\n    handleTodayClick() {\n        if (!this.todayAvailable) {\n            return;\n        }\n        this.bus.moveToBottom(this.activeView);\n        this.today.emit(dateInRange(getToday(), this.min, this.max));\n    }\n    handleNavigation() {\n        if (!this.navigate) {\n            return;\n        }\n        this.bus.moveUp(this.activeView);\n    }\n    intlChange() {\n        if (this.currentDate && this.bus.service(this.activeView)) {\n            this.title = this.getTitle();\n            this.cdr.markForCheck();\n        }\n    }\n    l10nChange() {\n        this.todayMessage = this.localization.get('today');\n        this.cdr.markForCheck();\n    }\n    getTitle() {\n        if (!this.currentDate) {\n            return '';\n        }\n        const service = this.bus.service(this.activeView);\n        const take = this.rangeLength - 1;\n        const title = service.title(this.currentDate);\n        const nextDate = service.addToDate(this.currentDate, take);\n        if (take < 1 || !service.isInRange(nextDate, this.min, this.max)) {\n            return title;\n        }\n        return `${title} - ${service.title(nextDate)}`;\n    }\n    setTodayAvailability() {\n        const today = getToday();\n        const isTodayInRange = isInRange(today, getDate(this.min), getDate(this.max));\n        const isDisabled = this.disabledDatesService.isDateDisabled(today);\n        this.todayAvailable = isTodayInRange && !isDisabled;\n        this.cdr.markForCheck();\n    }\n}\nHeaderComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-calendar-header',\n                template: `\n    <span class=\"k-button k-bare k-title\" [class.k-state-disabled]=\"!navigate\"\n        [kendoEventsOutsideAngular]=\"{\n            click: handleNavigation\n        }\"\n        [scope]=\"this\">\n        <ng-template [ngIf]=\"!templateRef\">{{title}}</ng-template>\n        <ng-template\n            [ngIf]=\"templateRef\"\n            [ngTemplateOutlet]=\"templateRef\"\n            [ngTemplateOutletContext]=\"{ $implicit: title, activeView: activeViewValue, date: currentDate }\"\n        ></ng-template>\n    </span>\n    <span class=\"k-today\" [class.k-state-disabled]=\"!todayAvailable\"\n        [kendoEventsOutsideAngular]=\"{\n            click: handleTodayClick\n        }\"\n        [scope]=\"this\">\n        {{todayMessage}}\n    </span>\n  `\n            },] },\n];\n/** @nocollapse */\nHeaderComponent.ctorParameters = () => [\n    { type: BusViewService },\n    { type: ChangeDetectorRef },\n    { type: LocalizationService },\n    { type: IntlService },\n    { type: DisabledDatesService }\n];\nHeaderComponent.propDecorators = {\n    activeView: [{ type: Input }],\n    currentDate: [{ type: Input }],\n    min: [{ type: Input }],\n    max: [{ type: Input }],\n    rangeLength: [{ type: Input }],\n    templateRef: [{ type: Input }],\n    today: [{ type: Output }],\n    getComponentClass: [{ type: HostBinding, args: [\"class.k-calendar-header\",] }]\n};\n\n/**\n * @hidden\n */\nclass WeekNamesService {\n    constructor(intl) {\n        this.intl = intl;\n    }\n    getWeekNames(includeWeekNumber = false) {\n        const weekNames = shiftWeekNames(this.intl.dateFormatNames({ nameType: 'short', type: 'days' }), this.intl.firstDay());\n        return includeWeekNumber ? [''].concat(weekNames) : weekNames;\n    }\n}\nWeekNamesService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nWeekNamesService.ctorParameters = () => [\n    { type: IntlService }\n];\n\n/**\n * @hidden\n */\nclass ViewComponent {\n    constructor(bus, intl, cdr, weekService, element, zone, renderer, disabledDatesService) {\n        this.bus = bus;\n        this.intl = intl;\n        this.cdr = cdr;\n        this.weekService = weekService;\n        this.element = element;\n        this.zone = zone;\n        this.renderer = renderer;\n        this.disabledDatesService = disabledDatesService;\n        this.direction = 'vertical';\n        this.isActive = true;\n        this.change = new EventEmitter();\n        this.cellEnter = new EventEmitter();\n        this.cellLeave = new EventEmitter();\n        this.weekNames = [];\n        this.colSpan = 0;\n        this.subscriptions = new Subscription();\n        this.domEvents = [];\n        this.subscriptions\n            .add(this.intl.changes.subscribe(this.intlChange.bind(this)))\n            .add(this.disabledDatesService.changes.subscribe(this.disabledDatesChange.bind(this)));\n    }\n    get weekNumber() {\n        return this.showWeekNumbers && this.activeView === CalendarViewEnum.month;\n    }\n    set weekNumber(showWeekNumbers) {\n        this.showWeekNumbers = showWeekNumbers;\n    }\n    ngOnInit() {\n        if (this.element) {\n            this.zone.runOutsideAngular(() => {\n                this.bindEvents();\n            });\n        }\n    }\n    ngOnChanges(changes) {\n        this.service = this.bus.service(this.activeView);\n        if (!this.service) {\n            return;\n        }\n        const generateWeekNames = this.isHorizontal() && this.weekNames.length === 0;\n        if (generateWeekNames && (changes.weekNumber || changes.direction)) {\n            this.weekNames = this.weekService.getWeekNames(this.weekNumber);\n        }\n        this.colSpan = this.service.rowLength(this.weekNumber);\n        this.title = this.service.title(this.viewDate);\n        this.updateData();\n        if (changes.activeView) {\n            this.currentCellIndex = null;\n        }\n    }\n    ngOnDestroy() {\n        this.subscriptions.unsubscribe();\n        this.domEvents.forEach(unsubscribeCallback => unsubscribeCallback());\n    }\n    isHorizontal() {\n        return this.direction === 'horizontal';\n    }\n    isMonthView() {\n        return this.activeView === CalendarViewEnum.month;\n    }\n    firstDate(rowCtx) {\n        const ctx = this.firstWeekDateContext(rowCtx);\n        return ctx ? ctx.value : null;\n    }\n    getWeekNumber(date) {\n        if (!this.weekNumber) {\n            return null;\n        }\n        return weekInYear(date, this.intl.firstDay());\n    }\n    getWeekNumberContext(rowCtx) {\n        const ctx = this.firstWeekDateContext(rowCtx);\n        if (!this.weekNumber || !ctx) {\n            return null;\n        }\n        const weekNumber = weekInYear(ctx.value, this.intl.firstDay()).toString();\n        return {\n            formattedValue: weekNumber,\n            id: null,\n            isFocused: false,\n            isSelected: false,\n            isWeekend: false,\n            title: weekNumber,\n            value: cloneDate(ctx.value)\n        };\n    }\n    getStyles(context) {\n        const { isRangeEnd, isRangeStart } = context;\n        const isEndActive = this.activeRangeEnd === 'end' && isRangeEnd;\n        const isStartActive = this.activeRangeEnd === 'start' && isRangeStart;\n        return stringifyClassObject({\n            'k-range-end': isRangeEnd,\n            'k-range-mid': context.isRangeMid,\n            'k-range-split-end': context.isRangeSplitEnd,\n            'k-range-split-start': context.isRangeSplitStart,\n            'k-range-start': isRangeStart,\n            'k-state-active': isStartActive || isEndActive,\n            'k-state-focused': this.isActive && context.isFocused,\n            'k-state-selected': context.isSelected || isRangeStart || isRangeEnd,\n            'k-today': context.isToday,\n            'k-weekend': context.isWeekend,\n            'k-state-disabled': context.isDisabled\n        });\n    }\n    tableCellIndex(rowIndex, cellIndex) {\n        return `${rowIndex}:${cellIndex}`;\n    }\n    firstWeekDateContext(rowCtx) {\n        if (!this.weekNumber) {\n            return null;\n        }\n        let idx = 0;\n        let ctx = rowCtx[idx];\n        while (!ctx && idx < rowCtx.length) {\n            ctx = rowCtx[++idx];\n        }\n        return ctx;\n    }\n    updateData() {\n        const time = this.selectedDate || getToday();\n        const viewDate = setTime(this.viewDate, time);\n        this.data = this.service.data({\n            cellUID: this.cellUID,\n            focusedDate: this.focusedDate,\n            isActiveView: !this.bus.canMoveDown(this.activeView),\n            max: this.max,\n            min: this.min,\n            selectedDate: this.selectedDate,\n            selectionRange: this.selectionRange,\n            viewDate: viewDate,\n            isDateDisabled: this.disabledDatesService.isDateDisabled\n        });\n    }\n    intlChange() {\n        this.updateData();\n        if (this.isHorizontal()) {\n            this.weekNames = this.weekService.getWeekNames(this.weekNumber);\n        }\n        this.cdr.markForCheck();\n    }\n    disabledDatesChange() {\n        this.updateData();\n        this.cdr.markForCheck();\n    }\n    bindEvents() {\n        const element = this.element.nativeElement;\n        this.domEvents.push(this.renderer.listen(element, 'mouseover', this.cellMouseoverHandler.bind(this)), this.renderer.listen(element, 'mouseleave', this.mouseLeaveHandler.bind(this)), this.renderer.listen(element, 'click', this.clickHandler.bind(this)));\n    }\n    clickHandler(args) {\n        const cell = this.closestCell(args);\n        if (cell) {\n            const index = cell.getAttribute('data-cell-index');\n            const cellContext = this.cellByIndex(index);\n            if (!cellContext.isDisabled) {\n                this.change.emit(cellContext.value);\n            }\n        }\n    }\n    mouseLeaveHandler() {\n        if (this.currentCellIndex) {\n            this.emitCellLeave();\n        }\n    }\n    cellMouseoverHandler(args) {\n        const cell = this.closestCell(args);\n        if (cell) {\n            const index = cell.getAttribute('data-cell-index');\n            if (this.currentCellIndex && this.currentCellIndex !== index) {\n                this.emitCellLeave();\n            }\n            const value = this.cellByIndex(index).value;\n            this.cellEnter.emit(value);\n            this.currentCellIndex = index;\n        }\n        else if (this.currentCellIndex) {\n            this.emitCellLeave();\n        }\n    }\n    closestCell(eventArgs) {\n        return closestInScope(eventArgs.target, node => node.hasAttribute('data-cell-index'), this.element.nativeElement);\n    }\n    emitCellLeave() {\n        const item = this.cellByIndex(this.currentCellIndex);\n        if (item) {\n            this.cellLeave.emit(item.value);\n        }\n        this.currentCellIndex = null;\n    }\n    cellByIndex(index) {\n        const [rowIndex, cellIndex] = index.split(':');\n        return this.data[rowIndex][cellIndex];\n    }\n}\nViewComponent.decorators = [\n    { type: Component, args: [{\n                selector: '[kendoCalendarView]',\n                template: `\n    <ng-template #emptyCell><td class=\"k-empty\">&nbsp;</td></ng-template>\n    <tr *ngIf=\"!isHorizontal()\" role=\"row\"><th scope=\"col\" [colSpan]=\"colSpan\">{{title}}</th></tr>\n    <tr role=\"row\" *ngIf=\"isMonthView() && isHorizontal()\">\n        <th *ngFor=\"let name of weekNames\">{{name}}</th>\n    </tr>\n    <tr *kFor=\"let row of data; let rowIndex = index\" role=\"row\">\n        <ng-template [ngIf]=\"weekNumber\">\n            <td class=\"k-alt\" *ngIf=\"firstDate(row); else emptyCell\">\n                <ng-template [ngIf]=\"!weekNumberTemplateRef\">\n                    {{getWeekNumber(firstDate(row))}}\n                </ng-template>\n                <ng-template\n                    [ngIf]=\"weekNumberTemplateRef\"\n                    [ngTemplateOutlet]=\"weekNumberTemplateRef\"\n                    [ngTemplateOutletContext]=\"{\n                        $implicit: firstDate(row),\n                        cellContext: getWeekNumberContext(row)\n                    }\"\n                ></ng-template>\n            </td>\n        </ng-template>\n        <ng-container *kFor=\"let cell of row; let cellIndex = index\">\n            <td\n                *ngIf=\"cell; else emptyCell\"\n                role=\"gridcell\"\n                [attr.id]=\"cell.id\"\n                [attr.data-cell-index]=\"tableCellIndex(rowIndex, cellIndex)\"\n                [attr.aria-selected]=\"cell.isSelected || cell.isRangeStart || cell.isRangeMid || cell.isRangeEnd\"\n                [attr.aria-disabled]=\"cell.isDisabled\"\n                [ngClass]=\"getStyles(cell)\"\n                [title]=\"cell.title\"\n            >\n                <span class=\"k-link\">\n                    <ng-template [ngIf]=\"!templateRef\">{{cell.formattedValue}}</ng-template>\n                    <ng-template\n                        *ngIf=\"templateRef\"\n                        [ngTemplateOutlet]=\"templateRef\"\n                        [ngTemplateOutletContext]=\"{ $implicit: cell.value, cellContext: cell }\"\n                    ></ng-template>\n                </span>\n            </td>\n        </ng-container>\n    </tr>\n  `\n            },] },\n];\n/** @nocollapse */\nViewComponent.ctorParameters = () => [\n    { type: BusViewService },\n    { type: IntlService },\n    { type: ChangeDetectorRef },\n    { type: WeekNamesService },\n    { type: ElementRef },\n    { type: NgZone },\n    { type: Renderer2 },\n    { type: DisabledDatesService }\n];\nViewComponent.propDecorators = {\n    direction: [{ type: Input }],\n    isActive: [{ type: Input }],\n    activeView: [{ type: Input }],\n    cellUID: [{ type: Input }],\n    focusedDate: [{ type: Input }],\n    selectedDate: [{ type: Input }],\n    viewDate: [{ type: Input }],\n    activeRangeEnd: [{ type: Input }],\n    selectionRange: [{ type: Input }],\n    min: [{ type: Input }],\n    max: [{ type: Input }],\n    weekNumber: [{ type: Input }],\n    viewIndex: [{ type: Input }],\n    templateRef: [{ type: Input }],\n    weekNumberTemplateRef: [{ type: Input }],\n    change: [{ type: Output }],\n    cellEnter: [{ type: Output }],\n    cellLeave: [{ type: Output }]\n};\n\n/**\n * @hidden\n *\n * The exported package module.\n *\n * The package exports:\n * - `HeaderComponent`&mdash;The component that renders the UI for vertical navigation.\n * - `ViewComponent`&mdash;The component that renders the active Calendar view.\n */\nclass CalendarCommonModule {\n}\nCalendarCommonModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [\n                    KForOf,\n                    HeaderComponent,\n                    ViewComponent\n                ],\n                exports: [\n                    KForOf,\n                    HeaderComponent,\n                    ViewComponent\n                ],\n                imports: [CommonModule, EventsModule]\n            },] },\n];\n\n/**\n * @hidden\n *\n * The exported package module.\n *\n * The package exports:\n * - `CellTemplateDirective`&mdash;The month cell template directive.\n * - `MonthCellTemplateDirective`&mdash;The month cell template directive.\n * - `YearCellTemplateDirective`&mdash;The year cell template directive.\n * - `DecadeCellTemplateDirective`&mdash;The decade cell template directive.\n * - `CenturyCellTemplateDirective`&mdash;The century cell template directive.\n * - `WeekNumberCellTemplateDirective`&mdash;The month week number cell template directive.\n * - `HeaderTitleTemplateDirective`&mdash;The header title template directive.\n * - `NavigationItemTemplateDirective`&mdash;The navigation item template directive.\n */\nclass TemplatesModule {\n}\nTemplatesModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [\n                    CellTemplateDirective,\n                    MonthCellTemplateDirective,\n                    YearCellTemplateDirective,\n                    DecadeCellTemplateDirective,\n                    CenturyCellTemplateDirective,\n                    WeekNumberCellTemplateDirective,\n                    HeaderTitleTemplateDirective,\n                    NavigationItemTemplateDirective\n                ],\n                exports: [\n                    CellTemplateDirective,\n                    MonthCellTemplateDirective,\n                    YearCellTemplateDirective,\n                    DecadeCellTemplateDirective,\n                    CenturyCellTemplateDirective,\n                    WeekNumberCellTemplateDirective,\n                    HeaderTitleTemplateDirective,\n                    NavigationItemTemplateDirective\n                ]\n            },] },\n];\n\n/**\n * @hidden\n */\nclass CalendarMessages extends ComponentMessages {\n}\nCalendarMessages.propDecorators = {\n    today: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nclass CalendarLocalizedMessagesDirective extends CalendarMessages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n}\nCalendarLocalizedMessagesDirective.decorators = [\n    { type: Directive, args: [{\n                providers: [\n                    {\n                        provide: CalendarMessages,\n                        useExisting: forwardRef(() => CalendarLocalizedMessagesDirective) // tslint:disable-line:no-forward-ref\n                    }\n                ],\n                selector: '[kendoCalendarLocalizedMessages]'\n            },] },\n];\n/** @nocollapse */\nCalendarLocalizedMessagesDirective.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * Custom component messages override default component messages ([see example]({% slug globalization_dateinputs %}#toc-custom-messages)).\n */\nclass CalendarCustomMessagesComponent extends CalendarMessages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n    get override() {\n        return true;\n    }\n}\nCalendarCustomMessagesComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: CalendarMessages,\n                        useExisting: forwardRef(() => CalendarCustomMessagesComponent) // tslint:disable-line:no-forward-ref\n                    }\n                ],\n                selector: 'kendo-calendar-messages',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nCalendarCustomMessagesComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\nconst COMPONENT_DIRECTIVES = [\n    VirtualizationComponent\n];\n/**\n * @hidden\n *\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Virtualization component.\n */\nclass VirtualizationModule {\n}\nVirtualizationModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [COMPONENT_DIRECTIVES],\n                exports: [COMPONENT_DIRECTIVES],\n                imports: [CommonModule]\n            },] },\n];\n\n/**\n * The exported package module.\n *\n * The package exports:\n * - `CellTemplateDirective`&mdash;The month cell template directive.\n * - `MonthCellTemplateDirective`&mdash;The month cell template directive.\n * - `YearCellTemplateDirective`&mdash;The year cell template directive.\n * - `DecadeCellTemplateDirective`&mdash;The decade cell template directive.\n * - `CenturyCellTemplateDirective`&mdash;The century cell template directive.\n * - `WeekNumberCellTemplateDirective`&mdash;The month week number cell template directive.\n * - `HeaderTitleTemplateDirective`&mdash;The header title template directive.\n * - `NavigationItemTemplateDirective`&mdash;The navigation item template directive.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Calendar module\n * import { CalendarModule } from '@progress/kendo-angular-dateinputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, CalendarModule], // import Calendar module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nclass CalendarModule {\n}\nCalendarModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [\n                    CalendarComponent,\n                    NavigationComponent,\n                    CalendarCustomMessagesComponent,\n                    CalendarLocalizedMessagesDirective,\n                    ViewListComponent\n                ],\n                exports: [\n                    CalendarComponent,\n                    NavigationComponent,\n                    CalendarCustomMessagesComponent,\n                    CalendarLocalizedMessagesDirective,\n                    ViewListComponent,\n                    CalendarCommonModule,\n                    TemplatesModule\n                ],\n                imports: [CommonModule, CalendarCommonModule, IntlModule, TemplatesModule, VirtualizationModule, EventsModule],\n                providers: [\n                    CalendarDOMService,\n                    CenturyViewService,\n                    DecadeViewService,\n                    MonthViewService,\n                    YearViewService,\n                    WeekNamesService\n                ]\n            },] },\n];\n\n/**\n * @hidden\n */\nclass Messages extends ComponentMessages {\n}\nMessages.propDecorators = {\n    today: [{ type: Input }],\n    prevButtonTitle: [{ type: Input }],\n    nextButtonTitle: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nclass MultiViewCalendarLocalizedMessagesDirective extends Messages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n}\nMultiViewCalendarLocalizedMessagesDirective.decorators = [\n    { type: Directive, args: [{\n                providers: [\n                    {\n                        provide: Messages,\n                        useExisting: forwardRef(() => MultiViewCalendarLocalizedMessagesDirective) // tslint:disable-line:no-forward-ref\n                    }\n                ],\n                selector: '[kendoMultiViewCalendarLocalizedMessages]'\n            },] },\n];\n/** @nocollapse */\nMultiViewCalendarLocalizedMessagesDirective.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * Custom component messages override default component messages ([see example]({% slug globalization_dateinputs %}#toc-custom-messages)).\n */\nclass MultiViewCalendarCustomMessagesComponent extends Messages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n    get override() {\n        return true;\n    }\n}\nMultiViewCalendarCustomMessagesComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: Messages,\n                        useExisting: forwardRef(() => MultiViewCalendarCustomMessagesComponent) // tslint:disable-line:no-forward-ref\n                    }\n                ],\n                selector: 'kendo-multiviewcalendar-messages',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nMultiViewCalendarCustomMessagesComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * The package exports:\n * - `CellTemplateDirective`&mdash;The month cell template directive.\n * - `MonthCellTemplateDirective`&mdash;The month cell template directive.\n * - `YearCellTemplateDirective`&mdash;The year cell template directive.\n * - `DecadeCellTemplateDirective`&mdash;The decade cell template directive.\n * - `CenturyCellTemplateDirective`&mdash;The century cell template directive.\n * - `WeekNumberCellTemplateDirective`&mdash;The month week number cell template directive.\n * - `HeaderTitleTemplateDirective`&mdash;The header title template directive.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the MultiViewCalendar module\n * import { MultiViewCalendarModule } from '@progress/kendo-angular-dateinputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, MultiViewCalendarModule], // import MultiViewCalendar module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n */\nclass MultiViewCalendarModule {\n}\nMultiViewCalendarModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [\n                    HorizontalViewListComponent,\n                    MultiViewCalendarLocalizedMessagesDirective,\n                    MultiViewCalendarCustomMessagesComponent,\n                    MultiViewCalendarComponent\n                ],\n                exports: [\n                    HorizontalViewListComponent,\n                    MultiViewCalendarLocalizedMessagesDirective,\n                    MultiViewCalendarCustomMessagesComponent,\n                    MultiViewCalendarComponent,\n                    CalendarCommonModule,\n                    TemplatesModule\n                ],\n                imports: [CommonModule, CalendarCommonModule, IntlModule, TemplatesModule, PopupModule],\n                providers: [\n                    NavigationService,\n                    CenturyViewService,\n                    DecadeViewService,\n                    MonthViewService,\n                    YearViewService,\n                    WeekNamesService\n                ]\n            },] },\n];\n\n/**\n * The exported package module.\n *\n * The package exports:\n * - `CalendarModule`&mdash;The calendar module.\n * - `MultiViewCalendarModule`&mdash;The multi-view calendar module.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Calendars module\n * import { CalendarsModule } from '@progress/kendo-angular-dateinputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, CalendarsModule], // import the Calendars module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nclass CalendarsModule {\n}\nCalendarsModule.decorators = [\n    { type: NgModule, args: [{\n                exports: [\n                    CalendarModule,\n                    MultiViewCalendarModule\n                ],\n                imports: [\n                    CalendarModule,\n                    MultiViewCalendarModule\n                ]\n            },] },\n];\n\n/**\n * @hidden\n */\nclass DateInputMessages extends ComponentMessages {\n}\nDateInputMessages.propDecorators = {\n    decrement: [{ type: Input }],\n    increment: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nclass DateInputLocalizedMessagesDirective extends DateInputMessages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n}\nDateInputLocalizedMessagesDirective.decorators = [\n    { type: Directive, args: [{\n                providers: [\n                    {\n                        provide: DateInputMessages,\n                        useExisting: forwardRef(() => DateInputLocalizedMessagesDirective) // tslint:disable-line:no-forward-ref\n                    }\n                ],\n                selector: '[kendoDateInputLocalizedMessages]'\n            },] },\n];\n/** @nocollapse */\nDateInputLocalizedMessagesDirective.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * Custom component messages override default component messages ([see example]({% slug globalization_dateinputs %}#toc-custom-messages)).\n */\nclass DateInputCustomMessagesComponent extends DateInputMessages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n    get override() {\n        return true;\n    }\n}\nDateInputCustomMessagesComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: DateInputMessages,\n                        useExisting: forwardRef(() => DateInputCustomMessagesComponent) // tslint:disable-line:no-forward-ref\n                    }\n                ],\n                selector: 'kendo-dateinput-messages',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nDateInputCustomMessagesComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the DateInput component.\n */\nclass DateInputModule {\n}\nDateInputModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [\n                    DateInputComponent,\n                    DateInputCustomMessagesComponent,\n                    DateInputLocalizedMessagesDirective\n                ],\n                exports: [\n                    DateInputComponent,\n                    DateInputCustomMessagesComponent,\n                    DateInputLocalizedMessagesDirective\n                ],\n                imports: [CommonModule, IntlModule, EventsModule]\n            },] },\n];\n\n/**\n * @hidden\n */\nclass DatePickerMessages extends ComponentMessages {\n}\nDatePickerMessages.propDecorators = {\n    today: [{ type: Input }],\n    toggle: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nclass DatePickerLocalizedMessagesDirective extends DatePickerMessages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n}\nDatePickerLocalizedMessagesDirective.decorators = [\n    { type: Directive, args: [{\n                providers: [\n                    {\n                        provide: DatePickerMessages,\n                        useExisting: forwardRef(() => DatePickerLocalizedMessagesDirective) // tslint:disable-line:no-forward-ref\n                    }\n                ],\n                selector: '[kendoDatePickerLocalizedMessages]'\n            },] },\n];\n/** @nocollapse */\nDatePickerLocalizedMessagesDirective.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * Custom component messages override default component messages ([see example]({% slug globalization_dateinputs %}#toc-custom-messages)).\n */\nclass DatePickerCustomMessagesComponent extends DatePickerMessages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n    get override() {\n        return true;\n    }\n}\nDatePickerCustomMessagesComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: DatePickerMessages,\n                        useExisting: forwardRef(() => DatePickerCustomMessagesComponent) // tslint:disable-line:no-forward-ref\n                    }\n                ],\n                selector: 'kendo-datepicker-messages',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nDatePickerCustomMessagesComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\nconst ɵ0$e = touchEnabled;\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the DatePicker component.\n */\nclass DatePickerModule {\n}\nDatePickerModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [\n                    DatePickerComponent,\n                    DatePickerCustomMessagesComponent,\n                    DatePickerLocalizedMessagesDirective\n                ],\n                exports: [\n                    DatePickerComponent,\n                    DatePickerCustomMessagesComponent,\n                    DatePickerLocalizedMessagesDirective,\n                    TemplatesModule\n                ],\n                imports: [\n                    CommonModule,\n                    DateInputModule,\n                    CalendarModule,\n                    IntlModule,\n                    PopupModule,\n                    TemplatesModule,\n                    EventsModule\n                ],\n                providers: [{ provide: TOUCH_ENABLED, useValue: ɵ0$e }]\n            },] },\n];\n\nconst COMPONENT_DIRECTIVES$1 = [\n    DateRangeComponent,\n    DateRangePopupComponent,\n    DateRangePopupTemplateDirective,\n    DateRangeSelectionDirective,\n    DateRangeStartInputDirective,\n    DateRangeEndInputDirective\n];\nconst COMPONENT_MODULES = [\n    MultiViewCalendarModule,\n    DateInputModule,\n    PopupModule,\n    EventsModule\n];\n/**\n * The exported package module.\n *\n * The package exports:\n * - `DateRangeComponent`&mdash;The DateRange component class.\n * - `DateRangePopupComponent`&mdash;The DateRangePopup component class.\n * - `DateRangeSelectionDirective`&mdash;The MultiviewCalendar date range selection directive.\n * - `DateRangeEndInputDirective`&mdash;The end DateInput date range selection directive.\n * - `DateRangeStartInputDirective`&mdash;The start DateInput date range selection directive.\n * - `DateRangePopupTemplateDirective`&mdash;The DateRangePopup content template directive.\n * - `MultiViewCalendarModule`&mdash;The MultiViewCalendar module.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the DateRange module\n * import { DateRangeModule } from '@progress/kendo-angular-dateinputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, DateRangeModule], // import DateRange module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nclass DateRangeModule {\n}\nDateRangeModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [COMPONENT_DIRECTIVES$1],\n                exports: [COMPONENT_DIRECTIVES$1],\n                imports: [CommonModule, COMPONENT_MODULES]\n            },] },\n];\n\nconst div$1 = domContainerFactory('div');\nconst ul$1 = domContainerFactory('ul');\nconst li$1 = domContainerFactory('li');\nconst listItem = () => li$1('<span>02</span>', 'k-item');\nconst list = () => ul$1([listItem()], 'k-reset');\nconst scrollable$1 = () => (div$1([list()], 'k-time-container k-content k-scrollable'));\nconst timeListWrapper = () => {\n    if (!isDocumentAvailable()) {\n        return null;\n    }\n    return div$1([div$1([scrollable$1()], 'k-time-list')], 'k-time-list-wrapper', { left: '-10000px', position: 'absolute' });\n};\nconst TIMELIST_WRAPPER = timeListWrapper();\n/**\n * @hidden\n */\nclass TimePickerDOMService {\n    ensureHeights() {\n        if (this.timeListHeight !== undefined) {\n            return;\n        }\n        this.calculateHeights();\n    }\n    calculateHeights(container) {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        const listContainer = container && container.querySelector('.k-time-list-container');\n        const hostContainer = listContainer || document.body;\n        const wrapper = hostContainer.appendChild(TIMELIST_WRAPPER);\n        this.timeListHeight = wrapper.querySelector('.k-scrollable').getBoundingClientRect().height;\n        this.itemHeight = wrapper.querySelector('li').getBoundingClientRect().height;\n        hostContainer.removeChild(wrapper);\n    }\n    isActive(element) {\n        if (!isDocumentAvailable() || !element) {\n            return false;\n        }\n        return (element.nativeElement || element) === document.activeElement;\n    }\n}\nTimePickerDOMService.decorators = [\n    { type: Injectable },\n];\n\nconst HOURS_IN_DAY = 24;\nconst clampToRange = (rangeValue) => (value) => value % rangeValue;\nconst clamp = clampToRange(HOURS_IN_DAY);\nconst stepper = (start, step) => (idx) => clamp(start + (idx * step));\nconst distanceFromMin = (value, min) => clamp(HOURS_IN_DAY + value - min);\nconst limit = (borderValue) => (barrier, value) => {\n    const useBarrier = !value || getDate(barrier).getTime() === getDate(value).getTime();\n    return useBarrier ? barrier : setHours(barrier, borderValue);\n};\nconst limitDown = limit(0);\nconst limitUp = limit(HOURS_IN_DAY - 1);\n/**\n * @hidden\n */\nclass HoursService {\n    constructor(intl) {\n        this.intl = intl;\n        this.boundRange = false;\n        this.insertUndividedMax = false;\n    }\n    apply(value, candidate) {\n        return setHours(value, candidate.getHours());\n    }\n    configure(settings) {\n        const { boundRange = this.boundRange, insertUndividedMax = this.insertUndividedMax, min = this.min, max = this.max, part, step = this.step } = settings;\n        this.boundRange = boundRange;\n        this.insertUndividedMax = insertUndividedMax;\n        this.toListItem = (hour) => {\n            const date = setHours(MIDNIGHT_DATE, hour);\n            return {\n                text: this.intl.formatDate(date, part.pattern),\n                value: date\n            };\n        };\n        this.min = min;\n        this.max = max;\n        this.step = step;\n    }\n    data(selectedValue) {\n        const [min] = this.range(selectedValue);\n        const getHour = stepper(min, this.step);\n        const convertToItem = (idx) => (this.toListItem(getHour(idx)));\n        const data = range(0, this.countFromMin(selectedValue)).map(convertToItem);\n        this.addLast(data);\n        this.addMissing(data, selectedValue);\n        return data;\n    }\n    isRangeChanged(min, max) {\n        return !isEqual(this.min, min) || !isEqual(this.max, max);\n    }\n    limitRange(min, max, value) {\n        return this.boundRange ? [limitDown(min, value), limitUp(max, value)] : [min, max];\n    }\n    total(value) {\n        const last$$1 = this.insertUndividedMax && this.isLastMissing(value) ? 1 : 0;\n        const missing = this.isMissing(value) ? 1 : 0;\n        return this.countFromMin(value) + missing + last$$1;\n    }\n    selectedIndex(value) {\n        return Math.ceil(this.divideByStep(value));\n    }\n    valueInList(value) {\n        if (!value) {\n            return true;\n        }\n        const matchMax = this.insertUndividedMax && this.lastHour(value) === value.getHours();\n        return matchMax || !this.isMissing(value);\n    }\n    addLast(data, value) {\n        if (this.insertUndividedMax && this.isLastMissing(value)) {\n            data.push(this.toListItem(this.lastHour(value)));\n        }\n        return data;\n    }\n    addMissing(data, value) {\n        if (this.valueInList(value)) {\n            return data;\n        }\n        const missingItem = this.toListItem(value.getHours());\n        data.splice(this.selectedIndex(value), 0, missingItem);\n        return data;\n    }\n    countFromMin(value) {\n        const [min, max] = this.range(value);\n        return Math.floor(distanceFromMin(max, min) / this.step) + 1; /* include min */\n    }\n    isMissing(value) {\n        if (!value) {\n            return false;\n        }\n        return this.selectedIndex(value) !== this.divideByStep(value);\n    }\n    isLastMissing(value) {\n        return this.isMissing(setHours(this.max, this.lastHour(value)));\n    }\n    divideByStep(value) {\n        return distanceFromMin(value.getHours(), this.min.getHours()) / this.step;\n    }\n    lastHour(value) {\n        return this.range(value)[1];\n    }\n    range(value) {\n        const [min, max] = this.limitRange(this.min, this.max, value);\n        return [min.getHours(), max.getHours()];\n    }\n}\nHoursService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nHoursService.ctorParameters = () => [\n    { type: IntlService }\n];\n\nconst MINUTES_IN_HOUR = 60;\nconst clampToRange$1 = (rangeValue) => (value) => value % rangeValue;\nconst clamp$1 = clampToRange$1(MINUTES_IN_HOUR);\nconst stepper$1 = (start, step) => (idx) => clamp$1(start + (idx * step));\nconst distanceFromMin$1 = (value, min) => clamp$1(MINUTES_IN_HOUR + value - min);\nconst limit$1 = (borderValue) => (barrier, value) => {\n    const useBarrier = !value || barrier.getHours() === value.getHours();\n    return useBarrier ? barrier : setMinutes(barrier, borderValue);\n};\nconst limitDown$1 = limit$1(0);\nconst limitUp$1 = limit$1(MINUTES_IN_HOUR - 1);\n/**\n * @hidden\n */\nclass MinutesService {\n    constructor(intl) {\n        this.intl = intl;\n        this.insertUndividedMax = false;\n    }\n    apply(value, candidate) {\n        return setMinutes(value, candidate.getMinutes());\n    }\n    configure(settings) {\n        const { insertUndividedMax = this.insertUndividedMax, min = this.min, max = this.max, part, step = this.step } = settings;\n        this.insertUndividedMax = insertUndividedMax;\n        this.toListItem = (minute) => {\n            const date = setMinutes(MIDNIGHT_DATE, minute);\n            return {\n                text: this.intl.formatDate(date, part.pattern),\n                value: date\n            };\n        };\n        this.min = min;\n        this.max = max;\n        this.step = step;\n    }\n    data(selectedValue) {\n        const [min] = this.range(selectedValue);\n        const getMinute = stepper$1(min, this.step);\n        const convertToItem = (idx) => (this.toListItem(getMinute(idx)));\n        const data = range(0, this.countFromMin(selectedValue)).map(convertToItem);\n        this.addLast(data);\n        this.addMissing(data, selectedValue);\n        return data;\n    }\n    isRangeChanged(min, max) {\n        return !isEqual(this.min, min) || !isEqual(this.max, max);\n    }\n    limitRange(min, max, value) {\n        return [limitDown$1(min, value), limitUp$1(max, value)];\n    }\n    total(value) {\n        const last$$1 = this.insertUndividedMax && this.isLastMissing(value) ? 1 : 0;\n        const missing = this.isMissing(value) ? 1 : 0;\n        return this.countFromMin(value) + missing + last$$1;\n    }\n    selectedIndex(value) {\n        return Math.ceil(this.divideByStep(value));\n    }\n    valueInList(value) {\n        if (!value) {\n            return true;\n        }\n        const matchMax = this.insertUndividedMax && this.lastMinute(value) === value.getMinutes();\n        return matchMax || !this.isMissing(value);\n    }\n    addLast(data, value) {\n        if (this.insertUndividedMax && this.isLastMissing(value)) {\n            data.push(this.toListItem(this.lastMinute(value)));\n        }\n        return data;\n    }\n    addMissing(data, value) {\n        if (this.valueInList(value)) {\n            return data;\n        }\n        const missingItem = this.toListItem(value.getMinutes());\n        data.splice(this.selectedIndex(value), 0, missingItem);\n        return data;\n    }\n    countFromMin(value) {\n        const [min, max] = this.range(value);\n        return Math.floor(distanceFromMin$1(max, min) / this.step) + 1; /* include min */\n    }\n    isMissing(value) {\n        if (!value) {\n            return false;\n        }\n        return this.selectedIndex(value) !== this.divideByStep(value);\n    }\n    isLastMissing(value) {\n        return this.isMissing(setMinutes(this.max, this.lastMinute(value)));\n    }\n    divideByStep(value) {\n        return distanceFromMin$1(value.getMinutes(), this.min.getMinutes()) / this.step;\n    }\n    lastMinute(value) {\n        return this.range(value)[1];\n    }\n    range(value) {\n        const [min, max] = this.limitRange(this.min, this.max, value);\n        return [min.getMinutes(), max.getMinutes()];\n    }\n}\nMinutesService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nMinutesService.ctorParameters = () => [\n    { type: IntlService }\n];\n\nconst SECONDS_IN_HOUR = 60;\nconst clampToRange$2 = (rangeValue) => (value) => value % rangeValue;\nconst clamp$2 = clampToRange$2(SECONDS_IN_HOUR);\nconst stepper$2 = (start, step) => (idx) => clamp$2(start + (idx * step));\nconst distanceFromMin$2 = (value, min) => clamp$2(SECONDS_IN_HOUR + value - min);\nconst limit$2 = (borderValue) => (barrier, value) => {\n    const useBarrier = !value || barrier.getHours() === value.getHours() && barrier.getMinutes() === value.getMinutes();\n    return useBarrier ? barrier : setSeconds(barrier, borderValue);\n};\nconst limitDown$2 = limit$2(0);\nconst limitUp$2 = limit$2(SECONDS_IN_HOUR - 1);\n/**\n * @hidden\n */\nclass SecondsService {\n    constructor(intl) {\n        this.intl = intl;\n        this.insertUndividedMax = false;\n    }\n    apply(value, candidate) {\n        return setSeconds(value, candidate.getSeconds());\n    }\n    configure(settings) {\n        const { insertUndividedMax = this.insertUndividedMax, min = this.min, max = this.max, part, step = this.step } = settings;\n        this.insertUndividedMax = insertUndividedMax;\n        this.toListItem = (minute) => {\n            const date = setSeconds(MIDNIGHT_DATE, minute);\n            return {\n                text: this.intl.formatDate(date, part.pattern),\n                value: date\n            };\n        };\n        this.min = min;\n        this.max = max;\n        this.step = step;\n    }\n    data(selectedValue) {\n        const [min] = this.range(selectedValue);\n        const getSecond = stepper$2(min, this.step);\n        const convertToItem = (idx) => (this.toListItem(getSecond(idx)));\n        const data = range(0, this.countFromMin(selectedValue)).map(convertToItem);\n        this.addLast(data);\n        this.addMissing(data, selectedValue);\n        return data;\n    }\n    isRangeChanged(min, max) {\n        return !isEqual(this.min, min) || !isEqual(this.max, max);\n    }\n    limitRange(min, max, value) {\n        return [limitDown$2(min, value), limitUp$2(max, value)];\n    }\n    total(value) {\n        const last$$1 = this.insertUndividedMax && this.isLastMissing(value) ? 1 : 0;\n        const missing = this.isMissing(value) ? 1 : 0;\n        return this.countFromMin(value) + missing + last$$1;\n    }\n    selectedIndex(value) {\n        return Math.ceil(this.divideByStep(value));\n    }\n    valueInList(value) {\n        if (!value) {\n            return true;\n        }\n        const matchMax = this.insertUndividedMax && this.lastSecond(value) === value.getSeconds();\n        return matchMax || !this.isMissing(value);\n    }\n    divideByStep(value) {\n        return distanceFromMin$2(value.getSeconds(), this.min.getSeconds()) / this.step;\n    }\n    addLast(data, value) {\n        if (this.insertUndividedMax && this.isLastMissing(value)) {\n            data.push(this.toListItem(this.lastSecond(value)));\n        }\n        return data;\n    }\n    addMissing(data, value) {\n        if (this.valueInList(value)) {\n            return data;\n        }\n        const missingItem = this.toListItem(value.getSeconds());\n        data.splice(this.selectedIndex(value), 0, missingItem);\n        return data;\n    }\n    countFromMin(value) {\n        const [min, max] = this.range(value);\n        return Math.floor(distanceFromMin$2(max, min) / this.step) + 1; /* include min */\n    }\n    isMissing(value) {\n        if (!value) {\n            return false;\n        }\n        return this.selectedIndex(value) !== this.divideByStep(value);\n    }\n    isLastMissing(value) {\n        return this.isMissing(setSeconds(this.max, this.lastSecond(value)));\n    }\n    lastSecond(value) {\n        return this.range(value)[1];\n    }\n    range(value) {\n        const [min, max] = this.limitRange(this.min, this.max, value);\n        return [min.getSeconds(), max.getSeconds()];\n    }\n}\nSecondsService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nSecondsService.ctorParameters = () => [\n    { type: IntlService }\n];\n\nconst setHours$1 = (date, hours) => {\n    const clone = cloneDate(date);\n    clone.setHours(hours);\n    return clone;\n};\nconst isAM = (value) => value !== null && value < 12;\nconst isPM = (value) => value !== null && (!value || value > 11);\nconst inRange = (value, min, max) => ((!min && !max) || (value >= min && value <= max));\nconst inReverseRange = (value, min, max) => ((!min && !max) || value >= min || value <= max);\n/**\n * @hidden\n */\nclass DayPeriodService {\n    constructor(intl) {\n        this.intl = intl;\n    }\n    /**\n     * @hidden\n     */\n    apply(value, candidate) {\n        const hour = value.getHours();\n        const hourAM = isAM(hour);\n        const candidateAM = isAM(candidate.getHours());\n        if ((hourAM && candidateAM) || (!hourAM && !candidateAM)) {\n            return value;\n        }\n        const [min, max = 24] = this.normalizedRange();\n        const result = hour + (candidateAM ? -12 : 12);\n        return setHours$1(value, Math.min(Math.max(min, result), (max || 24)));\n    }\n    /**\n     * @hidden\n     */\n    configure(settings) {\n        const { min = this.min, max = this.max, part = this.part } = settings;\n        this.min = min;\n        this.max = max;\n        this.part = part;\n    }\n    /**\n     * @hidden\n     */\n    data(_) {\n        const names = this.part.names;\n        if (!names) {\n            return [];\n        }\n        const data = [];\n        const [min, max] = this.normalizedRange();\n        const dayPeriod = this.intl.dateFormatNames(names);\n        if (isAM(min)) {\n            data.push({ text: dayPeriod.am, value: setHours$1(this.min, min) });\n        }\n        if (isPM(max)) {\n            data.push({ text: dayPeriod.pm, value: setHours$1(this.min, Math.max(12, max)) });\n        }\n        return this.min.getHours() !== min ? data.reverse() : data;\n    }\n    /**\n     * @hidden\n     */\n    isRangeChanged(_, __) {\n        return false;\n    }\n    /**\n     * @hidden\n     */\n    limitRange(min, max, _) {\n        return [min, max];\n    }\n    /**\n     * @hidden\n     */\n    total() {\n        const [min, max] = this.normalizedRange();\n        if (!min && !max) {\n            return 2;\n        }\n        if (min > 11 || max < 12) {\n            return 1;\n        }\n        return 2;\n    }\n    /**\n     * @hidden\n     */\n    selectedIndex(value) {\n        if (!this.valueInList(value)) {\n            return -1;\n        }\n        const index = Math.floor(value.getHours() / 12);\n        return this.min.getHours() === this.normalizedRange()[0] ? index : (index === 0 ? 1 : 0);\n    }\n    /**\n     * @hidden\n     */\n    valueInList(value) {\n        const reverse = this.min.getHours() !== this.normalizedRange()[0];\n        const isInRange = reverse ? inReverseRange : inRange;\n        return isInRange(value.getHours(), this.min.getHours(), this.max.getHours());\n    }\n    normalizedRange() {\n        const minHour = this.min.getHours();\n        const maxHour = this.max.getHours();\n        return [\n            Math.min(minHour, maxHour),\n            Math.max(minHour, maxHour)\n        ];\n    }\n}\nDayPeriodService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nDayPeriodService.ctorParameters = () => [\n    { type: IntlService }\n];\n\n/* tslint:disable:component-selector-name  component-selector-type */\nconst SNAP_THRESHOLD = 0.05; //% of the item height\nconst SCROLL_THRESHOLD = 2; //< 2px threshold\nconst nil = () => (null);\nconst getters = {\n    35: (data, _) => data[data.length - 1],\n    36: (data, _) => data[0],\n    38: (data, index) => data[index - 1],\n    40: (data, index) => data[index + 1]\n};\nconst services$1 = {\n    [TIME_PART.dayperiod]: DayPeriodService,\n    [TIME_PART.hour]: HoursService,\n    [TIME_PART.minute]: MinutesService,\n    [TIME_PART.second]: SecondsService\n};\n/**\n * @hidden\n */\nclass TimeListComponent {\n    constructor(element, injector, dom, renderer, zone) {\n        this.element = element;\n        this.injector = injector;\n        this.dom = dom;\n        this.renderer = renderer;\n        this.zone = zone;\n        this.min = cloneDate(MIDNIGHT_DATE);\n        this.max = cloneDate(MAX_TIME);\n        this.step = 1;\n        this.disabled = false;\n        this.valueChange = new EventEmitter();\n        this.componentClass = true;\n        this.animateToIndex = true;\n        this.isActive = false;\n        this.skip = 0;\n        this.total = 60;\n        this.data = [];\n        this.indexToScroll = -1;\n        this.domEvents = [];\n    }\n    get tabIndex() {\n        return this.disabled ? undefined : 0;\n    }\n    ngOnChanges(changes) {\n        if (changes.part) {\n            this.service = this.injector.get(services$1[this.part.type]);\n            this.service.configure(this.serviceSettings());\n        }\n        const value = this.value;\n        const valueChanges = changes.value || {};\n        const [min, max] = this.service.limitRange(this.min, this.max, value);\n        if (this.service.isRangeChanged(min, max) || changes.min || changes.max || changes.step) {\n            this.data = [];\n            this.service.configure(this.serviceSettings({ min, max }));\n        }\n        // Skip the rendering of the list whenever possible\n        if (!this.data.length || this.hasMissingValue(valueChanges)) {\n            this.animateToIndex = false;\n            this.data = this.service.data(value);\n        }\n        this.animateToIndex = this.animateToIndex && this.textHasChanged(valueChanges);\n        this.total = this.service.total(value);\n        this.indexToScroll = this.selectedIndex(value);\n    }\n    ngOnInit() {\n        this.animateToIndex = true;\n        this.dom.ensureHeights();\n        this.itemHeight = this.dom.itemHeight;\n        this.listHeight = this.dom.timeListHeight;\n        this.topOffset = (this.listHeight - this.itemHeight) / 2;\n        this.bottomOffset = this.listHeight - this.itemHeight;\n        this.topThreshold = this.itemHeight * SNAP_THRESHOLD;\n        this.bottomThreshold = this.itemHeight * (1 - SNAP_THRESHOLD);\n        const translate = `translateY(${this.topOffset}px)`;\n        this.style = { transform: translate, '-ms-transform': translate };\n        if (this.element) {\n            this.zone.runOutsideAngular(() => {\n                this.bindEvents();\n            });\n        }\n    }\n    ngOnDestroy() {\n        this.scrollSubscription.unsubscribe();\n        this.domEvents.forEach(unbindCallback => unbindCallback());\n    }\n    ngAfterViewInit() {\n        this.scrollOnce((index) => this.virtualization.scrollToIndex(index));\n    }\n    ngAfterViewChecked() {\n        this.scrollOnce((index) => {\n            const action = this.animateToIndex ? 'animateToIndex' : 'scrollToIndex';\n            this.virtualization[action](index);\n            this.animateToIndex = true;\n        });\n    }\n    handleChange(dataItem) {\n        const candidate = this.service.apply(this.value, dataItem.value);\n        if (this.value.getTime() === candidate.getTime()) {\n            return;\n        }\n        this.indexToScroll = this.data.indexOf(dataItem);\n        this.value = candidate;\n        this.valueChange.emit(candidate);\n    }\n    handleItemClick(args) {\n        const item = closestInScope(args.target, node => node.hasAttribute('data-timelist-item-index'), this.element.nativeElement);\n        if (item) {\n            const index = item.getAttribute('data-timelist-item-index');\n            this.handleChange(this.data[index]);\n        }\n    }\n    /**\n     * Focuses the host element of the TimeList.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"timelist.focus()\">Focus TimeList</button>\n     *  <kendo-timelist #timelist></kendo-timelist>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n        if (!this.element) {\n            return;\n        }\n        this.element.nativeElement.focus();\n    }\n    /**\n     * Blurs the TimeList component.\n     */\n    blur() {\n        if (!this.element) {\n            return;\n        }\n        this.element.nativeElement.blur();\n    }\n    itemOffset(scrollTop) {\n        const valueIndex = this.selectedIndex(this.value);\n        const activeIndex = this.virtualization.activeIndex();\n        const offset = this.virtualization.itemOffset(activeIndex);\n        const distance = Math.abs(Math.ceil(scrollTop) - offset);\n        if (valueIndex === activeIndex && distance < SCROLL_THRESHOLD) {\n            return offset;\n        }\n        const scrollUp = valueIndex > activeIndex;\n        const moveToNext = scrollUp && distance >= this.bottomThreshold || !scrollUp && distance > this.topThreshold;\n        return moveToNext ? this.virtualization.itemOffset(activeIndex + 1) : offset;\n    }\n    hasMissingValue({ previousValue, currentValue }) {\n        const isPreviousMissing = previousValue && !this.service.valueInList(previousValue);\n        const isCurrentMissing = currentValue && !this.service.valueInList(currentValue);\n        return isPreviousMissing || isCurrentMissing;\n    }\n    scrollOnce(action) {\n        if (this.indexToScroll !== -1) {\n            action(this.indexToScroll);\n            this.indexToScroll = -1;\n        }\n    }\n    serviceSettings(settings) {\n        const defaults = {\n            boundRange: false,\n            insertUndividedMax: false,\n            max: this.max,\n            min: this.min,\n            part: this.part,\n            step: this.step\n        };\n        const result = Object.assign({}, defaults, settings);\n        result.boundRange = result.part.type !== 'hour';\n        return result;\n    }\n    selectedIndex(value) {\n        if (!value) {\n            return -1;\n        }\n        return this.service.selectedIndex(value);\n    }\n    textHasChanged({ previousValue, currentValue }) {\n        if (!previousValue || !currentValue) {\n            return false;\n        }\n        const oldData = this.data[this.selectedIndex(previousValue)];\n        const newData = this.data[this.selectedIndex(currentValue)];\n        return oldData && newData && oldData.text !== newData.text;\n    }\n    handleKeyDown(e) {\n        const getter = getters[e.keyCode] || nil;\n        const dataItem = getter(this.data, this.service.selectedIndex(this.value));\n        if (dataItem) {\n            this.handleChange(dataItem);\n            e.preventDefault();\n        }\n    }\n    bindEvents() {\n        this.scrollSubscription = this.virtualization\n            .scroll$()\n            .pipe(debounceTime(100), map((e) => e.target.scrollTop), map((top) => this.itemOffset(top)), map((itemOffset) => this.virtualization.itemIndex(itemOffset)))\n            .subscribe(index => {\n            this.virtualization.scrollToIndex(index);\n            this.handleChange(this.data[index]);\n        });\n        const element = this.element.nativeElement;\n        this.domEvents.push(this.renderer.listen(element, 'mouseover', () => !this.isActive && this.focus()), this.renderer.listen(element, 'click', () => this.focus()), this.renderer.listen(element, 'blur', () => this.isActive = false), this.renderer.listen(element, 'focus', () => this.isActive = true), this.renderer.listen(element, 'keydown', this.handleKeyDown.bind(this)));\n    }\n}\nTimeListComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-timelist',\n                template: `\n    <kendo-virtualization\n        [skip]=\"skip\"\n        [take]=\"total\"\n        [total]=\"total\"\n        [itemHeight]=\"itemHeight\"\n        [maxScrollDifference]=\"listHeight\"\n        [topOffset]=\"topOffset\"\n        [bottomOffset]=\"bottomOffset\"\n        class=\"k-time-container\"\n        role=\"presentation\"\n        tabindex=\"-1\"\n    >\n        <ul [ngStyle]=\"style\" class=\"k-reset\"\n            [kendoEventsOutsideAngular]=\"{\n                click: handleItemClick\n            }\"\n            [scope]=\"this\"\n        >\n            <li *ngFor=\"let item of data; let index = index;\" class=\"k-item\"\n                [attr.data-timelist-item-index]=\"index\">\n                <span>{{item.text}}</span>\n            </li>\n        </ul>\n    </kendo-virtualization>\n  `\n            },] },\n];\n/** @nocollapse */\nTimeListComponent.ctorParameters = () => [\n    { type: ElementRef },\n    { type: Injector },\n    { type: TimePickerDOMService },\n    { type: Renderer2 },\n    { type: NgZone }\n];\nTimeListComponent.propDecorators = {\n    min: [{ type: Input }],\n    max: [{ type: Input }],\n    part: [{ type: Input }],\n    step: [{ type: Input }],\n    disabled: [{ type: Input }],\n    value: [{ type: Input }],\n    valueChange: [{ type: Output }],\n    virtualization: [{ type: ViewChild, args: [VirtualizationComponent, { static: true },] }],\n    tabIndex: [{ type: HostBinding, args: [\"attr.tabindex\",] }],\n    componentClass: [{ type: HostBinding, args: [\"class.k-time-list\",] }]\n};\n\nconst isEqualTillMinute = (value, min) => value.getHours() === min.getHours() && value.getMinutes() === min.getMinutes();\nconst isEqualTillSecond = (value, min) => isEqualTillMinute(value, min) && value.getSeconds() === min.getSeconds();\nconst isEqualTillMillisecond = (value, min) => isEqualTillSecond(value, min) && value.getMilliseconds() === min.getMilliseconds();\nconst ɵ3$6 = (value) => value.getHours(), ɵ4$2 = (_, min) => min.getHours(), ɵ5$1 = (value) => value.getMinutes(), ɵ6$1 = (value, min) => isEqualTillMinute(value, min) ? min.getMinutes() : 0, ɵ7$1 = (value) => value.getSeconds(), ɵ8$1 = (value, min) => isEqualTillSecond(value, min) ? min.getSeconds() : 0, ɵ9$1 = (value) => value.getMilliseconds(), ɵ10$1 = (value, min) => isEqualTillMillisecond(value, min) ? min.getMilliseconds() : 0;\nconst defaultGetters = [\n    {\n        type: TIME_PART.hour,\n        getter: ɵ3$6,\n        minGetter: ɵ4$2\n    }, {\n        type: TIME_PART.minute,\n        getter: ɵ5$1,\n        minGetter: ɵ6$1\n    }, {\n        type: TIME_PART.second,\n        getter: ɵ7$1,\n        minGetter: ɵ8$1\n    }, {\n        type: TIME_PART.millisecond,\n        getter: ɵ9$1,\n        minGetter: ɵ10$1\n    }\n];\nconst left = getter => (origin, _) => getter(origin);\nconst right = getter => (_, candidate) => getter(candidate);\nconst convertToObject = (parts) => parts.reduce((obj, p) => { obj[p.type] = p.type; return obj; }, {});\nconst getterByPart = parts => g => parts[g.type] ? right(g.getter) : left(g.getter);\nconst gettersFactory = getters => parts => (getters.map(getterByPart(convertToObject(parts))));\nconst snapValue = (getter, minGetter, step) => (date, min) => {\n    const value = getter(date);\n    const minValue = minGetter(date, min);\n    const rest = value - minValue;\n    if (rest < 0) {\n        return minValue;\n    }\n    const mod = rest % step;\n    return value - mod + (mod > step / 2 ? step : 0);\n};\nconst snappersFactory = (getters) => steps => (getters.map(g => {\n    const step = steps[g.type];\n    return step ? snapValue(g.getter, g.minGetter, step) : g.getter;\n}));\n/**\n * @hidden\n */\nconst generateGetters = gettersFactory(defaultGetters);\n/**\n * @hidden\n */\nconst generateSnappers = snappersFactory(defaultGetters);\n/**\n * @hidden\n */\nconst valueMerger = getters => (origin, candidate) => {\n    origin.setHours(...getters.map(g => g(origin, candidate)));\n    return origin;\n};\n/**\n * @hidden\n */\nconst snapTime = snappers => (candidate, min) => {\n    const date = cloneDate(candidate);\n    date.setHours(...snappers.map(s => s(date, min)));\n    return date;\n};\n\nconst listReducer = (state, list, idx, all) => {\n    if (state.length || !list.isActive) {\n        return state;\n    }\n    return [{\n            next: all[idx + 1] || list,\n            prev: all[idx - 1] || list\n        }];\n};\nvar Direction;\n(function (Direction) {\n    Direction[Direction[\"Left\"] = 0] = \"Left\";\n    Direction[Direction[\"Right\"] = 1] = \"Right\";\n})(Direction || (Direction = {}));\n/**\n * @hidden\n *\n * Represents the Kendo UI TimeSelector component for Angular.\n */\nclass TimeSelectorComponent {\n    constructor(localization, cdr, element, intl, dom, zone, renderer, pickerService) {\n        this.localization = localization;\n        this.cdr = cdr;\n        this.element = element;\n        this.intl = intl;\n        this.dom = dom;\n        this.zone = zone;\n        this.renderer = renderer;\n        this.pickerService = pickerService;\n        /**\n         * @hidden\n         */\n        this.componentClass = true;\n        /**\n         * Specifies the time format used to display the time list columns.\n         */\n        this.format = 't';\n        /**\n         * Specifies the smallest valid time value.\n         */\n        this.min = cloneDate(MIN_TIME);\n        /**\n         * Specifies the biggest valid time value.\n         */\n        this.max = cloneDate(MAX_TIME);\n        /**\n         * Determines whether to display the **Cancel** button in the popup.\n         */\n        this.cancelButton = true;\n        /**\n         * Determines whether to display the **Set** button in the popup.\n         */\n        this.setButton = true;\n        /**\n         * Determines whether to display the **Now** button in the popup.\n         *\n         * > If the current time is out of range or the incremental step is greater than `1`, the **Now** button will be hidden.\n         */\n        this.nowButton = true;\n        /**\n         * Sets or gets the `disabled` property of the TimeSelector and determines whether the component is active.\n         */\n        this.disabled = false;\n        /**\n         * Specifies the value of the TimeSelector component.\n         */\n        this.value = null;\n        /**\n         * Fires each time the user selects a new value.\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * Fires each time the user cancels the selected value.\n         */\n        this.valueReject = new EventEmitter();\n        this.isActive = false;\n        this.showNowButton = true;\n        this._activeListIndex = -1;\n        this._steps = {};\n        this.domEvents = [];\n        if (this.pickerService) {\n            this.pickerService.timeSelector = this;\n        }\n    }\n    /**\n     * @hidden\n     */\n    get disabledClass() {\n        return this.disabled;\n    }\n    /**\n     * Configures the incremental steps of the TimeSelector.\n     *\n     * The available options are:\n     * - `hour: Number`&mdash;Controls the incremental step of the hour value.\n     * - `minute: Number`&mdash;Controls the incremental step of the minute value.\n     * - `second: Number`&mdash;Controls the incremental step of the second value.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <kendo-timeselector format=\"HH:mm:ss\" [steps]=\"steps\"></kendo-timeselector>\n     * `\n     * })\n     * class AppComponent {\n     *   public steps = { hour: 2, minute: 15, second: 15 };\n     * }\n     * ```\n     *\n     * > If the incremental step is greater than `1`, the **Now** button will be hidden.\n     */\n    set steps(steps) {\n        this._steps = steps || {};\n    }\n    get steps() {\n        return this._steps;\n    }\n    set current(value) {\n        this._current = timeInRange(this.snapTime(cloneDate(value || MIDNIGHT_DATE), this.min), this.min, this.max);\n        if (!NgZone.isInAngularZone()) {\n            this.cdr.detectChanges();\n        }\n    }\n    get current() {\n        return this._current;\n    }\n    get activeListIndex() {\n        return this._activeListIndex;\n    }\n    set activeListIndex(value) {\n        this._activeListIndex = value;\n        if (!this.timeListWrappers || !this.timeListWrappers.length) {\n            return;\n        }\n        this.timeListWrappers.forEach(listWrapper => {\n            this.renderer.removeClass(listWrapper.nativeElement, 'k-state-focused');\n        });\n        if (value >= 0) {\n            const listIndex = this.listIndex(value);\n            const focusedWrapper = this.timeListWrappers.toArray()[listIndex];\n            if (focusedWrapper) {\n                this.renderer.addClass(focusedWrapper.nativeElement, 'k-state-focused');\n            }\n        }\n    }\n    /**\n     * @hidden\n     */\n    ngOnInit() {\n        this.subscriptions = this.intl.changes.subscribe(this.intlChange.bind(this));\n        if (this.localization) {\n            this.subscriptions.add(this.localization\n                .changes\n                .subscribe(() => this.cdr.markForCheck()));\n        }\n        this.dom.calculateHeights(this.element.nativeElement);\n        this.init();\n        this.bindEvents();\n    }\n    /**\n     * @hidden\n     */\n    ngOnChanges(_) {\n        this.init();\n    }\n    ngOnDestroy() {\n        if (this.subscriptions) {\n            this.subscriptions.unsubscribe();\n        }\n        if (this.pickerService) {\n            this.pickerService.timeSelector = null;\n        }\n        this.domEvents.forEach(unbindCallback => unbindCallback());\n    }\n    /**\n     * Focuses the TimeSelector component.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"timeselector.focus()\">Focus time picker</button>\n     *  <kendo-timeselector #timeselector></kendo-timeselector>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n        const list = this.timeLists.first;\n        if (!list) {\n            return;\n        }\n        list.focus();\n    }\n    /**\n     * Blurs the TimeSelector component.\n     */\n    blur() {\n        const list = this.timeLists.first;\n        if (!list) {\n            return;\n        }\n        list.blur();\n    }\n    /**\n     * @hidden\n     */\n    handleAccept() {\n        this.handleChange(this.mergeValue(cloneDate(this.value || getDate(getNow())), this.current));\n    }\n    /**\n     * @hidden\n     */\n    handleNow() {\n        this.current = getNow();\n        this.handleChange(this.current);\n        this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n    handleReject() {\n        this.current = this.value;\n        this.valueReject.emit();\n    }\n    /**\n     * @hidden\n     */\n    handleFocus(args) {\n        if (this.isActive) {\n            return;\n        }\n        this.isActive = true;\n        this.emitFocus(args);\n    }\n    /**\n     * @hidden\n     */\n    handleListFocus(args) {\n        const index = parseInt(args.target.getAttribute('data-timelist-index'), 10);\n        this.activeListIndex = index;\n        this.handleFocus(args);\n    }\n    /**\n     * @hidden\n     */\n    handleBlur(args) {\n        const currentTarget = currentFocusTarget(args);\n        if (currentTarget && this.containsElement(currentTarget)) {\n            return;\n        }\n        this.activeListIndex = -1;\n        this.isActive = false;\n        this.emitBlur(args);\n    }\n    /**\n     * @hidden\n     */\n    containsElement(element) {\n        return Boolean(closest(element, node => node === this.element.nativeElement));\n    }\n    partStep(part) {\n        return this.steps[part.type] || 1;\n    }\n    init(changes) {\n        if (!changes || hasChange(changes, 'format')) {\n            this.dateFormatParts = this.intl.splitDateFormat(this.format);\n            this.mergeValue = valueMerger(generateGetters(this.dateFormatParts));\n        }\n        if (!changes || hasChange(changes, 'steps')) {\n            this.snapTime = snapTime(generateSnappers(this.steps));\n        }\n        if (!changes || hasChange(changes, 'value')) {\n            this.current = this.value;\n        }\n        this.showNowButton = !this.hasSteps() && this.nowButton && isInTimeRange(getNow(), this.min, this.max);\n    }\n    focusList(dir) {\n        if (!this.timeLists.length) {\n            return;\n        }\n        this.timeLists.reduce(listReducer, [])\n            .map(state => dir === Direction.Right ? state.next : state.prev)\n            .map(list => list && list.focus());\n    }\n    handleChange(value) {\n        this.value = value;\n        this.valueChange.emit(cloneDate(value));\n    }\n    hasActiveButton() {\n        if (!this.accept) {\n            return false;\n        }\n        return [this.accept, this.cancel, this.now].reduce((isActive, el) => isActive || this.dom.isActive(el), false);\n    }\n    hasSteps() {\n        const keys = Object.keys(this.steps);\n        return keys.length !== keys.reduce((acc, k) => acc + this.steps[k], 0);\n    }\n    intlChange() {\n        this.dateFormatParts = this.intl.splitDateFormat(this.format);\n        this.mergeValue = valueMerger(generateGetters(this.dateFormatParts));\n        this.cdr.markForCheck();\n    }\n    bindEvents() {\n        if (this.element) {\n            this.zone.runOutsideAngular(() => {\n                this.domEvents.push(this.renderer.listen(this.element.nativeElement, 'keydown', this.handleKeydown.bind(this)));\n            });\n        }\n    }\n    handleKeydown(args) {\n        const { keyCode, altKey } = args;\n        // reserve the alt + arrow key commands for the picker\n        const arrowKeyPressed = [Keys.ArrowLeft, Keys.ArrowRight].indexOf(keyCode) !== -1;\n        if (isPresent(this.pickerService) && arrowKeyPressed && altKey) {\n            return;\n        }\n        if (keyCode === Keys.Enter && !this.hasActiveButton()) {\n            this.handleAccept();\n        }\n        else if (keyCode === Keys.ArrowLeft || keyCode === Keys.ArrowRight) {\n            this.focusList(keyCode === Keys.ArrowLeft ? Direction.Left : Direction.Right);\n        }\n    }\n    emitBlur(args) {\n        if (this.pickerService) {\n            this.pickerService.onBlur.emit(args);\n        }\n    }\n    emitFocus(args) {\n        if (this.pickerService) {\n            this.pickerService.onFocus.emit(args);\n        }\n    }\n    listIndex(partIndex) {\n        let listIdx = 0;\n        let partIdx = 0;\n        while (partIdx < partIndex) {\n            if (this.dateFormatParts[partIdx].type !== 'literal') {\n                listIdx++;\n            }\n            partIdx++;\n        }\n        return listIdx;\n    }\n}\nTimeSelectorComponent.decorators = [\n    { type: Component, args: [{\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                exportAs: 'kendo-timeselector',\n                providers: [\n                    LocalizationService,\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.timeselector'\n                    }\n                ],\n                selector: 'kendo-timeselector',\n                template: `\n        <ng-container kendoTimeSelectorLocalizedMessages\n            i18n-accept=\"kendo.timeselector.accept|The Accept button text in the timeselector component\"\n            accept=\"Set\"\n\n            i18n-acceptLabel=\"kendo.timeselector.acceptLabel|The label for the Accept button in the timeselector component\"\n            acceptLabel=\"Set time\"\n\n            i18n-cancel=\"kendo.timeselector.cancel|The Cancel button text in the timeselector component\"\n            cancel=\"Cancel\"\n\n            i18n-cancelLabel=\"kendo.timeselector.cancelLabel|The label for the Cancel button in the timeselector component\"\n            cancelLabel=\"Cancel changes\"\n\n            i18n-now=\"kendo.timeselector.now|The Now button text in the timeselector component\"\n            now=\"Now\"\n\n            i18n-nowLabel=\"kendo.timeselector.nowLabel|The label for the Now button in the timeselector component\"\n            nowLabel=\"Select now\"\n        >\n        </ng-container>\n        <div class=\"k-time-header\">\n            <span class=\"k-title\">\n                {{ intl.formatDate(current, format) }}\n            </span>\n            <button\n                #now\n                *ngIf=\"showNowButton\"\n                class=\"k-button k-bare k-time-now\" type=\"button\"\n                [attr.title]=\"localization.get('nowLabel')\"\n                [attr.aria-label]=\"localization.get('nowLabel')\"\n                [kendoEventsOutsideAngular]=\"{\n                    click: handleNow,\n                    focus: handleFocus,\n                    blur: handleBlur\n                }\"\n                [scope]=\"this\"\n                [disabled]=\"disabled\"\n            >{{localization.get('now')}}</button>\n        </div>\n        <div class=\"k-time-list-container\">\n            <span class=\"k-time-highlight\"></span>\n            <ng-template ngFor [ngForOf]=\"dateFormatParts\" let-part let-idx=\"index\">\n                <div\n                    #listWrapper\n                    class=\"k-time-list-wrapper\"\n                    role=\"presentation\" tabindex=\"-1\"\n                    *ngIf=\"part.type !== 'literal'\"\n                >\n                    <span class=\"k-title\">{{intl.dateFieldName(part)}}</span>\n                    <kendo-timelist\n                        [min]=\"min\"\n                        [max]=\"max\"\n                        [part]=\"part\"\n                        [step]=\"partStep(part)\"\n                        [disabled]=\"disabled\"\n                        [(value)]=\"current\"\n                        [kendoEventsOutsideAngular]=\"{\n                            focus: handleListFocus,\n                            blur: handleBlur\n                        }\"\n                        [scope]=\"this\"\n                        [attr.data-timelist-index]=\"idx\"\n                    ></kendo-timelist>\n                </div>\n                <div class=\"k-time-separator\" *ngIf=\"part.type === 'literal'\">\n                    {{part.pattern}}\n                </div>\n            </ng-template>\n        </div>\n        <div class=\"k-time-footer k-action-buttons\" *ngIf=\"setButton || cancelButton\">\n            <button\n                #cancel\n                *ngIf=\"cancelButton\"\n                class=\"k-button k-time-cancel\" type=\"button\"\n                [attr.title]=\"localization.get('cancelLabel')\"\n                [attr.aria-label]=\"localization.get('cancelLabel')\"\n                [kendoEventsOutsideAngular]=\"{\n                    click: handleReject,\n                    focus: handleFocus,\n                    blur: handleBlur\n                }\"\n                [scope]=\"this\"\n                [disabled]=\"disabled\"\n            >{{localization.get('cancel')}}</button>\n            <button\n                #accept\n                *ngIf=\"setButton\"\n                type=\"button\"\n                class=\"k-time-accept k-button k-primary\"\n                [attr.title]=\"localization.get('acceptLabel')\"\n                [attr.aria-label]=\"localization.get('acceptLabel')\"\n                [kendoEventsOutsideAngular]=\"{\n                    click: handleAccept,\n                    focus: handleFocus,\n                    blur: handleBlur\n                }\"\n                [scope]=\"this\"\n                [disabled]=\"disabled\"\n            >{{localization.get('accept')}}</button>\n        </div>\n    `\n            },] },\n];\n/** @nocollapse */\nTimeSelectorComponent.ctorParameters = () => [\n    { type: LocalizationService },\n    { type: ChangeDetectorRef },\n    { type: ElementRef },\n    { type: IntlService },\n    { type: TimePickerDOMService },\n    { type: NgZone },\n    { type: Renderer2 },\n    { type: PickerService, decorators: [{ type: Optional }] }\n];\nTimeSelectorComponent.propDecorators = {\n    accept: [{ type: ViewChild, args: ['accept',] }],\n    cancel: [{ type: ViewChild, args: ['cancel',] }],\n    now: [{ type: ViewChild, args: ['now',] }],\n    timeLists: [{ type: ViewChildren, args: [TimeListComponent,] }],\n    timeListWrappers: [{ type: ViewChildren, args: ['listWrapper',] }],\n    componentClass: [{ type: HostBinding, args: ['class.k-timeselector',] }],\n    disabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }],\n    format: [{ type: Input }],\n    min: [{ type: Input }],\n    max: [{ type: Input }],\n    cancelButton: [{ type: Input }],\n    setButton: [{ type: Input }],\n    nowButton: [{ type: Input }],\n    disabled: [{ type: Input }],\n    steps: [{ type: Input }],\n    value: [{ type: Input }],\n    valueChange: [{ type: Output }],\n    valueReject: [{ type: Output }]\n};\n\n/**\n * @hidden\n */\nclass TimePickerMessages extends ComponentMessages {\n}\nTimePickerMessages.propDecorators = {\n    accept: [{ type: Input }],\n    acceptLabel: [{ type: Input }],\n    cancel: [{ type: Input }],\n    cancelLabel: [{ type: Input }],\n    now: [{ type: Input }],\n    nowLabel: [{ type: Input }],\n    toggle: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nclass TimePickerLocalizedMessagesDirective extends TimePickerMessages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n}\nTimePickerLocalizedMessagesDirective.decorators = [\n    { type: Directive, args: [{\n                providers: [\n                    {\n                        provide: TimePickerMessages,\n                        useExisting: forwardRef(() => TimePickerLocalizedMessagesDirective) // tslint:disable-line:no-forward-ref\n                    }\n                ],\n                selector: '[kendoTimePickerLocalizedMessages]'\n            },] },\n];\n/** @nocollapse */\nTimePickerLocalizedMessagesDirective.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * Custom component messages override default component messages ([see example]({% slug globalization_dateinputs %}#toc-custom-messages)).\n */\nclass TimePickerCustomMessagesComponent extends TimePickerMessages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n    get override() {\n        return true;\n    }\n}\nTimePickerCustomMessagesComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: TimePickerMessages,\n                        useExisting: forwardRef(() => TimePickerCustomMessagesComponent) // tslint:disable-line:no-forward-ref\n                    }\n                ],\n                selector: 'kendo-timepicker-messages',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nTimePickerCustomMessagesComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * @hidden\n */\nclass TimeSelectorLocalizedMessagesDirective extends TimePickerMessages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n}\nTimeSelectorLocalizedMessagesDirective.decorators = [\n    { type: Directive, args: [{\n                providers: [\n                    {\n                        provide: TimePickerMessages,\n                        useExisting: forwardRef(() => TimeSelectorLocalizedMessagesDirective) // tslint:disable-line:no-forward-ref\n                    }\n                ],\n                selector: '[kendoTimeSelectorLocalizedMessages]'\n            },] },\n];\n/** @nocollapse */\nTimeSelectorLocalizedMessagesDirective.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * @hidden\n *\n * Custom component messages override default component messages.\n */\nclass TimeSelectorCustomMessagesComponent extends TimePickerMessages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n    get override() {\n        return true;\n    }\n}\nTimeSelectorCustomMessagesComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: TimePickerMessages,\n                        useExisting: forwardRef(() => TimeSelectorCustomMessagesComponent) // tslint:disable-line:no-forward-ref\n                    }\n                ],\n                selector: 'kendo-timeselector-messages',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nTimeSelectorCustomMessagesComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\nconst COMPONENT_DIRECTIVES$2 = [\n    TimePickerLocalizedMessagesDirective,\n    TimeListComponent,\n    TimePickerCustomMessagesComponent,\n    TimePickerComponent,\n    TimeSelectorLocalizedMessagesDirective,\n    TimeSelectorCustomMessagesComponent,\n    TimeSelectorComponent\n];\nconst COMPONENT_MODULES$1 = [\n    DateInputModule,\n    IntlModule,\n    PopupModule,\n    VirtualizationModule,\n    EventsModule\n];\nconst ɵ0$n = touchEnabled;\nconst providers = [\n    TimePickerDOMService,\n    HoursService,\n    MinutesService,\n    SecondsService,\n    DayPeriodService,\n    {\n        provide: TOUCH_ENABLED,\n        useValue: ɵ0$n\n    }\n];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the TimePicker component.\n */\nclass TimePickerModule {\n}\nTimePickerModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [COMPONENT_DIRECTIVES$2],\n                exports: [COMPONENT_DIRECTIVES$2],\n                imports: [CommonModule, ...COMPONENT_MODULES$1],\n                providers: providers\n            },] },\n];\n\n/**\n * @hidden\n */\nclass Messages$1 extends ComponentMessages {\n}\nMessages$1.propDecorators = {\n    toggle: [{ type: Input }],\n    dateTab: [{ type: Input }],\n    dateTabLabel: [{ type: Input }],\n    timeTab: [{ type: Input }],\n    timeTabLabel: [{ type: Input }],\n    accept: [{ type: Input }],\n    acceptLabel: [{ type: Input }],\n    cancel: [{ type: Input }],\n    cancelLabel: [{ type: Input }],\n    today: [{ type: Input }],\n    now: [{ type: Input }],\n    nowLabel: [{ type: Input }]\n};\n\n/**\n * Custom component messages override default component messages ([see example]({% slug globalization_dateinputs %}#toc-custom-messages)).\n */\nclass DateTimePickerCustomMessagesComponent extends Messages$1 {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n    get override() {\n        return true;\n    }\n}\nDateTimePickerCustomMessagesComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: Messages$1,\n                        useExisting: forwardRef(() => DateTimePickerCustomMessagesComponent)\n                    }\n                ],\n                selector: 'kendo-datetimepicker-messages',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nDateTimePickerCustomMessagesComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * @hidden\n */\nclass LocalizedMessagesDirective extends Messages$1 {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n}\nLocalizedMessagesDirective.decorators = [\n    { type: Directive, args: [{\n                providers: [\n                    {\n                        provide: Messages$1,\n                        useExisting: forwardRef(() => LocalizedMessagesDirective)\n                    }\n                ],\n                selector: '[kendoDateTimePickerLocalizedMessages]'\n            },] },\n];\n/** @nocollapse */\nLocalizedMessagesDirective.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\nconst COMPONENT_DIRECTIVES$3 = [\n    DateTimePickerComponent,\n    DateTimePickerCustomMessagesComponent,\n    LocalizedMessagesDirective\n];\nconst ɵ0$o = touchEnabled;\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the DateTimePicker component.\n */\nclass DateTimePickerModule {\n}\nDateTimePickerModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [\n                    ...COMPONENT_DIRECTIVES$3\n                ],\n                exports: [\n                    ...COMPONENT_DIRECTIVES$3,\n                    TemplatesModule\n                ],\n                imports: [\n                    CommonModule,\n                    IntlModule,\n                    DateInputModule,\n                    CalendarModule,\n                    TimePickerModule,\n                    PopupModule,\n                    EventsModule,\n                    TemplatesModule\n                ],\n                providers: [\n                    { provide: TOUCH_ENABLED, useValue: ɵ0$o }\n                ]\n            },] },\n];\n\nconst COMPONENT_MODULES$2 = [\n    CalendarsModule,\n    DateInputModule,\n    DatePickerModule,\n    TimePickerModule,\n    DateRangeModule,\n    DateTimePickerModule\n];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Date Inputs components.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Date Inputs module\n * import { DateInputsModule } from '@progress/kendo-angular-dateinputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare the app component\n *     imports:      [BrowserModule, DateInputsModule], // import the Date Inputs module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nclass DateInputsModule {\n}\nDateInputsModule.decorators = [\n    { type: NgModule, args: [{\n                exports: COMPONENT_MODULES$2,\n                imports: COMPONENT_MODULES$2\n            },] },\n];\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CalendarCommonModule, CALENDAR_RANGE_VALIDATORS, CALENDAR_VALUE_ACCESSOR, KENDO_INPUT_PROVIDER, KForOf, KForOfContext, HeaderComponent, HorizontalViewListComponent, CalendarMessages, MultiViewCalendarCustomMessagesComponent, Messages, MultiViewCalendarComponent, RANGE_CALENDAR_RANGE_VALIDATORS, RANGE_CALENDAR_VALUE_ACCESSOR, NavigationComponent, BusViewService, CenturyViewService, DecadeViewService, DisabledDatesService, CalendarDOMService, MonthViewService, NavigationService, ScrollSyncService, WeekNamesService, YearViewService, TemplatesModule, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, ViewListComponent, ViewComponent, PickerService, DateInputMessages, DatePickerMessages, DateRangeInput, DateRangePopupTemplateDirective, DateTimePickerCustomMessagesComponent, LocalizedMessagesDirective, Messages$1, TimePickerMessages, TimePickerCustomMessagesComponent, TimeSelectorCustomMessagesComponent, DayPeriodService, TimePickerDOMService, HoursService, MinutesService, SecondsService, TimeListComponent, TimeSelectorComponent, TOUCH_ENABLED, ScrollerService, DEFAULT_SCROLLER_FACTORY, SCROLLER_FACTORY_TOKEN, VirtualizationComponent, VirtualizationModule, CalendarComponent, DateInputComponent, DatePickerComponent, TimePickerComponent, DateTimePickerComponent, DateRangeComponent, DateRangePopupComponent, DateRangeEndInputDirective, DateRangeStartInputDirective, DateRangeSelectionDirective, CalendarModule, CalendarsModule, DateInputModule, DatePickerModule, DateInputsModule, TimePickerModule, DateTimePickerModule, MultiViewCalendarModule, DateRangeModule, DateRangeService, CalendarCustomMessagesComponent, DateInputCustomMessagesComponent, DatePickerCustomMessagesComponent, PreventableEvent, CalendarLocalizedMessagesDirective, MultiViewCalendarLocalizedMessagesDirective, DateInputLocalizedMessagesDirective, DatePickerLocalizedMessagesDirective, TimePickerLocalizedMessagesDirective, TimeSelectorLocalizedMessagesDirective };\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6bC;;;0BAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8ID;;;0BAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuKD,+GAGC;;;;;;;4EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsKD,4GAGC;;;;;;;4EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6ED,yGAGC;;;;;;;yEAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsJD;;;0BAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiYD,0DAiBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAyBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuHD,mMAiCC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAoBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6JD,kEA0DC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBA+BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwCD,kHAGC;;;;;;;wEAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAqED,kHAGC;;;;;;;;qGAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiCD,0IAKC;;;;;;;;;;4EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8BD,yJAKC;;;;;;;;;;4EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiCD,sJAKC;;;;;;;;;;4EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgCD,4JAKC;;;;;;;;;;4EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgCD,+JAKC;;;;;;;;;;4EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8BD,wKAKC;;;;;;;;;;4EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA+BD,+JAKC;;;;;;;;;;4EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA+BD,wKAKC;;;;;;;;;;4EAIA;;;;;;;;;;;;;;AAWD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2HA;;;gDAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6kBD,wEAwDC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAwDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmoCD,8KA+EC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAuCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAguBD,oFAgGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBA+DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwqBD,wFA6GC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBA0CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAovBD,qGAqPC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAkDA;;;;;;;;;;;;CAUD,gKAKC;;;;;;;;;;4EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2KD;;;gDAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsGD,kEAwCC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBA6BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAojBD,gFAsEC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBA+DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwQD,4DAYC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBA0BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0CD,gFAUC;;;;;;;;;;;;;;;;;oBAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2KD,gSAKC;;;;;;;;;;;;;;;;;;;;;;oBAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgED,sSAKC;;;;;;;;;;;;;;;;;;;;;;oBAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuKD,6WAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAeA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgFD,wOAGC;;;;;;;;;;;;;;;;;;;;;oBAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4FD,sHA0BC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAkBA;;;;;;;;;;;;;;;CAaD,+GAGC;;;;;;;4EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuMD,wHAkDC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBA+BA;;;;;;;;;;;;;;CAYD;;;;;;;;;;;;;;;;;;;;;0BAeC;;;;;;;;;;;;;;;;;;;;CAkBD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAwBC;;;;;;;;wJAMD;;;;qFAGC;;;;;;;;;;;;;;;;;CAUD,iDAWC;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;;;CAaD,gKAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;CAYD;;;;;;;;;0BAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2CD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BA6BC;;;;;;;;gNAMD;;;;;;qEAKC;;;;;;;;;;;;;;;;;CAUD,iDAWC;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;;;CAaD,yKAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsCD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BA2BC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAqCD;;;;;;;;;;;;;;;;0BAYC;;;;;;;;0LAMD;;;;;uFAIC;;;;;;;;;;;;;;;;;CAUD,iDAWC;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;;;CAaD,iKAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;CAOD;;;;;;;;;;;;;;;;;;;;;0BAeC;;;;;;;;8KAMD;;;;;yFAIC;;;;;;;;;;;;;;;;;CAUD,iDAWC;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;;;CAaD,kKAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;;CAQD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAyBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwDD;;;;;;;;;;;;;;;;;;;;;;;0BAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0CD;;;0BAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2GD,mGAGC;;;;;;;4EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAyGD,yGAGC;;;;;;;4EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAyGD,yGAGC;;;;;;;4EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA+GD,+GAGC;;;;;;;4EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoND,yIA+BC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAoBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkaD,oNAoHC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBA+BA;;;;;;;;4RAMD;;;;;;;;;;yFASC;;;;;;;;;;;;;;;;;CAUD,iDAWC;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;;;CAaD,kKAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;CAUD,iDAWC;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;;;;;CAeD,oKAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmCD;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAQC;;;;;;;;gYAMD;;;;;;;;;;;;;;;yEAcC;;;;;;;;;;;;;;;;;;;;CAaD,sKAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;CAUD,iDAWC;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;CAaD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAwBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0CD;;;;;;;;;;;;;;;;;;0BAMC;;;;;;;"}