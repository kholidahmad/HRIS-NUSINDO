{"version":3,"file":"index.js","sources":["D:/project/projek_angular/hris_rni/node_modules/@progress/kendo-angular-grid/dist/fesm2015/index.js"],"sourcesContent":["/**-----------------------------------------------------------------------------------------\n* Copyright Â© 2020 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport { EventEmitter, Directive, TemplateRef, Optional, QueryList, Input, ContentChildren, ContentChild, InjectionToken, Component, forwardRef, SkipSelf, Host, Injectable, NgZone, ChangeDetectorRef, Output, Inject, isDevMode, Renderer2, SecurityContext, ElementRef, ViewEncapsulation, HostBinding, ViewChild, ViewChildren, Self, ViewContainerRef, Pipe, NgModule, ComponentFactoryResolver, ChangeDetectionStrategy, HostListener } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormControl, FormGroup, NG_VALUE_ACCESSOR, ReactiveFormsModule, FormsModule } from '@angular/forms';\nimport { merge, of, fromEvent, Subject, Subscription, zip, from, interval, BehaviorSubject, Observable } from 'rxjs';\nimport { auditTime, switchMap, take, map, distinctUntilChanged, filter, tap, throttleTime, takeUntil, switchMapTo, delay, debounceTime, bufferCount } from 'rxjs/operators';\nimport { isDocumentAvailable, Keys, isChanged, anyChanged, hasObservers, ResizeSensorComponent, DraggableModule, EventsModule, DraggableDirective, guid, ResizeSensorModule } from '@progress/kendo-angular-common';\nimport { orderBy, process, isCompositeFilterDescriptor, filterBy } from '@progress/kendo-data-query';\nimport { LocalizationService, L10N_PREFIX, ComponentMessages } from '@progress/kendo-angular-l10n';\nimport { PopupService, PopupModule } from '@progress/kendo-angular-popup';\nimport { DomSanitizer } from '@angular/platform-browser';\nimport { DropDownListModule, AutoCompleteModule } from '@progress/kendo-angular-dropdowns';\nimport { InputsModule, NumericTextBoxComponent, NumericTextBoxModule } from '@progress/kendo-angular-inputs';\nimport { DatePickerModule } from '@progress/kendo-angular-dateinputs';\nimport { getter } from '@progress/kendo-common';\nimport { IntlService } from '@progress/kendo-angular-intl';\nimport { trigger, state, style, transition, animate } from '@angular/animations';\nimport { Button } from '@progress/kendo-angular-buttons';\nimport { PDFMarginComponent, PDFTemplateDirective, PDFExportComponent } from '@progress/kendo-angular-pdf-export';\nimport { saveAs } from '@progress/kendo-file-saver';\nimport { workbookOptions, toDataURL, ColumnBase, ExcelExportModule } from '@progress/kendo-angular-excel-export';\n\n/**\n * @hidden\n */\nclass ZoneAwareEventEmitter extends EventEmitter {\n    constructor(ngZone, isAsync = false) {\n        super(isAsync);\n        this.ngZone = ngZone;\n    }\n    subscribe(generatorOrNext, error, complete) {\n        let schedulerFn;\n        let errorFn = (_) => null;\n        let completeFn = () => null;\n        if (generatorOrNext && typeof generatorOrNext === 'object') {\n            schedulerFn = (value) => { this.ngZone.run(() => generatorOrNext.next(value)); };\n            if (generatorOrNext.error) {\n                errorFn = (err) => { this.ngZone.run(() => generatorOrNext.error(err)); };\n            }\n            if (generatorOrNext.complete) {\n                completeFn = () => { this.ngZone.run(() => generatorOrNext.complete()); };\n            }\n        }\n        else {\n            schedulerFn = (value) => { this.ngZone.run(() => generatorOrNext(value)); };\n            if (error) {\n                errorFn = (err) => { this.ngZone.run(() => error(err)); };\n            }\n            if (complete) {\n                completeFn = () => { this.ngZone.run(() => complete()); };\n            }\n        }\n        return super.subscribe(schedulerFn, errorFn, completeFn);\n    }\n}\n\n/**\n * Represents the column cell template of the Grid ([more information and example]({% slug templates_columns_grid %}#toc-cell-template)).\n * Helps to customize the content of the cells. To define the cell template, nest an `<ng-template>` tag\n * with the `kendoGridCellTemplate` directive inside a `<kendo-grid-column>` tag.\n *\n * The template context is set to the current data item and the following additional fields are passed:\n * - `columnIndex`&mdash;The current column index. Use it as an alias for a template variable by utilizing the `let-columnIndex=\"columnIndex\"` syntax.\n * - `rowIndex`&mdash;The current data row index. Use it as an alias for a template variable by utilizing the `let-rowIndex=\"rowIndex\"` syntax.\n * - `dataItem`&mdash;The current data item. Represents the default context that will be assigned to any template variable which utilizes the `let-x` syntax&mdash;for example, `let-dataItem`.\n * - `column`&mdash;The current column instance. Use it as an alias for a template variable by utilizing the `let-column=\"column\"` syntax.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *         <kendo-grid [data]=\"gridData\">\n *             <kendo-grid-column field=\"ProductName\">\n *                 <ng-template kendoGridCellTemplate let-dataItem let-rowIndex=\"rowIndex\">\n *                     Data Row #: {{rowIndex}} /\n *                     <strong>{{dataItem.ProductName}}</strong>\n *                     ({{dataItem.Discontinued ? \"discontinued\" : \"active\"}})\n *                 </ng-template>\n *             </kendo-grid-column>\n *         </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *     public gridData = [{\n *         \"ProductID\": 1,\n *         \"ProductName\": \"Chai\",\n *         \"UnitPrice\": 18.0000,\n *         \"Discontinued\": false\n *       }, {\n *         \"ProductID\": 2,\n *         \"ProductName\": \"Chang\",\n *         \"UnitPrice\": 19.0000,\n *         \"Discontinued\": true\n *       }\n *     ];\n * }\n *\n * ```\n */\nclass CellTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nCellTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridCellTemplate]'\n            },] },\n];\n/** @nocollapse */\nCellTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef, decorators: [{ type: Optional }] }\n];\n\n/**\n * Represents the group-header cell template of the Grid which helps to customize the content of the group header item.\n * To define the group header template, nest an `<ng-template>` tag with the `kendoGridGroupHeaderTemplate`\n * directive inside `<kendo-grid-column>`.\n *\n * The template context is set to the current data item and the following additional fields are passed:\n * - `group`&mdash;The current group item.\n * - `field`&mdash;The name of the field by which data is grouped.\n * - `value`&mdash;The current group value.\n * - `aggregates`&mdash;All aggregate values for the current group.\n * - `index`&mdash;The index of the current group.\n * - `expanded`&mdash;A boolean value indicating if the group is currently expanded.\n * ([see example]({% slug groupable_grid_with_aggregates %})).\n *\n * @example\n * ```ts-preview\n * import { process } from '@progress/kendo-data-query';\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *         <kendo-grid [data]=\"gridData\" [group]=\"groups\">\n *             <kendo-grid-column field=\"ProductName\">\n *                 <ng-template kendoGridGroupHeaderTemplate let-group let-field=\"field\" let-value=\"value\">\n *                    <strong>{{field}}</strong>: {{value}}\n *                 </ng-template>\n *             </kendo-grid-column>\n *         </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *     public groups = [{ field: \"ProductName\" }];\n *\n *     public gridData = process([{\n *         \"ProductID\": 1,\n *         \"ProductName\": \"Chai\",\n *         \"UnitPrice\": 18.0000,\n *         \"Discontinued\": false\n *       }, {\n *         \"ProductID\": 2,\n *         \"ProductName\": \"Chang\",\n *         \"UnitPrice\": 19.0000,\n *         \"Discontinued\": true\n *       }\n *     ], {\n *      group: this.groups\n *     });\n * }\n *\n * ```\n */\nclass GroupHeaderTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nGroupHeaderTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridGroupHeaderTemplate]'\n            },] },\n];\n/** @nocollapse */\nGroupHeaderTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef, decorators: [{ type: Optional }] }\n];\n\n/**\n * Represents the group-header column template of the Grid which helps to customize the content of the group headers.\n * To define the group header template, nest an `<ng-template>` tag with the `kendoGridGroupHeaderColumnTemplate`\n * directive inside `<kendo-grid-column>`.\n *\n * The template context is set to the current data item and the following additional fields are passed:\n * - `group`&mdash;The current group item.\n * - `field`&mdash;The name of the field by which data is grouped.\n * - `value`&mdash;The current group value.\n * - `aggregates`&mdash;All aggregate values for the current group.\n *\n * @example\n * {% meta height:600 %}\n * {% embed_file grouping/app.component.ts preview %}\n * {% embed_file grouping/app.module.ts %}\n * {% embed_file grouping/main.ts %}\n * {% endmeta %}\n *\n * ```\n */\nclass GroupHeaderColumnTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nGroupHeaderColumnTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridGroupHeaderColumnTemplate]'\n            },] },\n];\n/** @nocollapse */\nGroupHeaderColumnTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef, decorators: [{ type: Optional }] }\n];\n\n/**\n * Represents the column edit-cell template of the Grid ([see example]({% slug editing_template_forms_grid %})).\n * Helps to customize the content of the edited cells. To define the cell template, nest an `<ng-template>`\n * tag with the `kendoGridEditTemplate` directive inside a `<kendo-grid-column>` tag.\n *\n * The template context contains the following fields:\n * - `formGroup`&mdash;The current [`FormGroup`]({{ site.data.urls.angular['formgroupapi'] }}).\n * If you use the Grid inside [Template-Driven Forms]({{ site.data.urls.angular['forms'] }}), it will be `undefined`.\n * - `rowIndex`&mdash;The current data row index. If inside a new item row, `rowIndex` is `-1`.\n * - `dataItem`&mdash;The current data item.\n * - `column`&mdash;The current column instance.\n * - `isNew`&mdash;The state of the current item.\n */\nclass EditTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nEditTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridEditTemplate]'\n            },] },\n];\n/** @nocollapse */\nEditTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef, decorators: [{ type: Optional }] }\n];\n\n/**\n * Represents the column group footer cell template of the Grid which helps to customize the group footer cell for the column.\n * To define the group footer template, nest an `<ng-template>` tag with the `kendoGridGroupFooterTemplate` directive\n * inside `<kendo-grid-column>`.\n *\n * The template context is set to the current aggregates and the following additional fields are passed:\n * - `column`&mdash;Defines an instance of the `ColumnComponent` option.\n * - `field`&mdash;The current column field name.\n * - `group`&mdash;The current group data item.\n * - `aggregates`&mdash;All aggregate values for the current group.\n *\n * @example\n * ```ts-preview\n * import { process } from '@progress/kendo-data-query';\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *         <kendo-grid [data]=\"gridData\" [group]=\"groups\">\n *             <kendo-grid-column field=\"ProductName\">\n *                 <ng-template kendoGridGroupFooterTemplate let-aggregates let-field=\"field\">\n *                    Count: {{aggregates[field].count}}\n *                 </ng-template>\n *             </kendo-grid-column>\n *         </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *     public groups = [{ field: \"ProductName\", aggregates: [{ field: \"ProductName\", aggregate: \"count\" }] }];\n *\n *     public gridData = process([{\n *         \"ProductID\": 1,\n *         \"ProductName\": \"Chai\",\n *         \"UnitPrice\": 18.0000,\n *         \"Discontinued\": false\n *       }, {\n *         \"ProductID\": 2,\n *         \"ProductName\": \"Chang\",\n *         \"UnitPrice\": 19.0000,\n *         \"Discontinued\": true\n *       }\n *     ], {\n *      group: this.groups\n *     });\n * }\n * ```\n */\nclass GroupFooterTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nGroupFooterTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridGroupFooterTemplate]'\n            },] },\n];\n/** @nocollapse */\nGroupFooterTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef, decorators: [{ type: Optional }] }\n];\n\n/**\n * Represents the column header cell template of the Grid\n * ([more information and example]({% slug templates_columns_grid %}#toc-header-template)).\n * Helps to customize the table header cell for the column.\n * To define a header template, nest an `<ng-template>` tag with the\n * [`kendoGridHeaderTemplate`]({% slug api_grid_headertemplatedirective %}) directive inside the `<kendo-grid-column>` tag.\n *\n *  The template context is set to the current column and then the following additional fields are passed:\n * * `column`&mdash;Defines an instance of the [`ColumnComponent`]({% slug api_grid_columncomponent %}) option.\n * * `columnIndex`&mdash;Defines the current column index.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *         <kendo-grid [data]=\"gridData\">\n *             <kendo-grid-column field=\"ProductName\">\n *                 <ng-template kendoGridHeaderTemplate let-column let-columnIndex=\"columnIndex\">\n *                   {{column.field}}({{columnIndex}})\n *                 </ng-template>\n *             </kendo-grid-column>\n *              <kendo-grid-column field=\"UnitPrice\">\n *                 <ng-template kendoGridHeaderTemplate let-column let-columnIndex=\"columnIndex\">\n *                   {{column.field}}({{columnIndex}})\n *                 </ng-template>\n *             </kendo-grid-column>\n *         </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *     public gridData = [{\n *         \"ProductID\": 1,\n *         \"ProductName\": \"Chai\",\n *         \"UnitPrice\": 18.0000,\n *         \"Discontinued\": false\n *       }, {\n *         \"ProductID\": 2,\n *         \"ProductName\": \"Chang\",\n *         \"UnitPrice\": 19.0000,\n *         \"Discontinued\": true\n *       }\n *     ];\n * }\n *\n * ```\n */\nclass HeaderTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nHeaderTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridHeaderTemplate]'\n            },] },\n];\n/** @nocollapse */\nHeaderTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef, decorators: [{ type: Optional }] }\n];\n\n/**\n * Represents the column footer cell template of the Grid\n * ([more information and example]({% slug templates_columns_grid %}#toc-footer-template)).\n * Helps to customize the table footer cell for the column.\n * To define a footer template, nest an `<ng-template>` tag with the\n * [`kendoGridFooterTemplate`]({% slug api_grid_footertemplatedirective %}) directive inside the `<kendo-grid-column>` tag.\n *\n * The template context is set to the current column and the following additional fields are passed:\n * * `column`&mdash;Defines an instance of the [`ColumnComponent`]({% slug api_grid_columncomponent %}) option.\n * * `columnIndex`&mdash;Defines the current column index.\n *\n * For more information on how to display aggregates in the footer of the Grid,\n * refer to the article on [aggregates]({% slug groupable_grid_with_aggregates %}).\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *         <kendo-grid [data]=\"gridData\" scrollable=\"none\">\n *             <kendo-grid-column field=\"ProductName\">\n *                 <ng-template kendoGridFooterTemplate let-column let-columnIndex=\"columnIndex\">\n *                   {{column.field}}({{columnIndex}})\n *                 </ng-template>\n *             </kendo-grid-column>\n *              <kendo-grid-column field=\"UnitPrice\">\n *                 <ng-template kendoGridFooterTemplate let-column let-columnIndex=\"columnIndex\">\n *                   {{column.field}}({{columnIndex}})\n *                 </ng-template>\n *             </kendo-grid-column>\n *         </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *     public gridData = [{\n *         \"ProductID\": 1,\n *         \"ProductName\": \"Chai\",\n *         \"UnitPrice\": 18.0000,\n *         \"Discontinued\": false\n *       }, {\n *         \"ProductID\": 2,\n *         \"ProductName\": \"Chang\",\n *         \"UnitPrice\": 19.0000,\n *         \"Discontinued\": true\n *       }\n *     ];\n * }\n *\n * ```\n */\nclass FooterTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nFooterTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridFooterTemplate]'\n            },] },\n];\n/** @nocollapse */\nFooterTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef, decorators: [{ type: Optional }] }\n];\n\n/* tslint:disable:max-line-length */\n/**\n * Represents the template for the column menu in the Grid. Provides an option for\n * customizing the content of the column menu for all or for specific columns.\n * To define the content template, nest an `<ng-template>` tag with the\n * `kendoGridColumnMenuTemplate` directive inside the `kendo-grid` or the `<kendo-grid-column>` component.\n *\n * The template context is passes through the following fields:\n * - `service`&mdash;Represents the [ColumnMenuService]({% slug api_grid_columnmenuservice %}).\n * - `column`&mdash;Represents the Grid column.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *       <kendo-grid [kendoGridBinding]=\"data\" [sortable]=\"true\" [columnMenu]=\"true\">\n *          <ng-template kendoGridColumnMenuTemplate let-service=\"service\">\n *              <kendo-grid-columnmenu-sort [service]=\"service\">\n *              </kendo-grid-columnmenu-sort>\n *          </ng-template>\n *          <kendo-grid-column field=\"Field1\" [width]=\"100\">\n *              <ng-template kendoGridColumnMenuTemplate let-service=\"service\">\n *                  <kendo-grid-columnmenu-lock [service]=\"service\">\n *                  </kendo-grid-columnmenu-lock>\n *                  <kendo-grid-columnmenu-sort [service]=\"service\">\n *                  </kendo-grid-columnmenu-sort>\n *              </ng-template>\n *          </kendo-grid-column>\n *          <kendo-grid-column field=\"Field2\" [width]=\"100\"></kendo-grid-column>\n *       </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }, { Field1: 'Foo1', Field2: 'Bar1' }];\n * }\n *\n * ```\n */\nclass ColumnMenuTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nColumnMenuTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridColumnMenuTemplate]'\n            },] },\n];\n/** @nocollapse */\nColumnMenuTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef, decorators: [{ type: Optional }] }\n];\n\n/**\n * @hidden\n */\nconst isSpanColumn = column => column.isSpanColumn;\n/**\n * @hidden\n */\nconst isCheckboxColumn = column => column.isCheckboxColumn;\nconst isColumnContainer = column => column.isColumnGroup || isSpanColumn(column);\n/**\n * The base class for the column components of the Grid.\n */\nclass ColumnBase$1 {\n    constructor(parent) {\n        this.parent = parent;\n        /**\n         * @hidden\n         */\n        this.matchesMedia = true;\n        /**\n         * The column index after reordering.\n         *\n         * > `orderIndex` is a read-only property. Setting this field does not affect column order.\n         */\n        this.orderIndex = 0;\n        /**\n         * @hidden\n         */\n        this.isColumnGroup = false;\n        /**\n         * @hidden\n         */\n        this.isSpanColumn = false;\n        /**\n         * Indicates whether the column is resizable.\n         * @default true\n         */\n        this.resizable = true;\n        /**\n         * Indicates whether the column is reorderable.\n         * @default true\n         */\n        this.reorderable = true;\n        /**\n         * The width (in pixels) below which the user is not able to resize the column by using the UI.\n         */\n        this.minResizableWidth = 10;\n        /**\n         * Toggles the locked (frozen) state of the columns ([more information and example]({% slug locked_columns_grid %})).\n         *\n         * @default false\n         *\n         * @example\n         * ```ts\n         * _@Component({\n         *    selector: 'my-app',\n         *    template: `\n         *        <kendo-grid [data]=\"gridData\" [scrollable]=\"scrollable\" style=\"height: 200px\">\n         *          <kendo-grid-column field=\"ProductID\" title=\"Product ID\" width=\"120\" [locked]=\"true\">\n         *          </kendo-grid-column>\n         *          <kendo-grid-column field=\"ProductName\" title=\"Product Name\" width=\"200\">\n         *          </kendo-grid-column>\n         *          <kendo-grid-column field=\"UnitPrice\" title=\"Unit Price\" width=\"230\">\n         *          </kendo-grid-column>\n         *        </kendo-grid>\n         *    `\n         * })\n         *\n         * class AppComponent {\n         *    public gridData: any[];\n         *\n         *    constructor() {\n         *        this.gridData = products;\n         *    }\n         * }\n         *\n         * const products = [{\n         *    \"ProductID\": 1,\n         *    \"ProductName\": \"Chai\",\n         *    \"UnitPrice\": 18.0000,\n         *    \"Discontinued\": true\n         *  }, {\n         *    \"ProductID\": 2,\n         *    \"ProductName\": \"Chang\",\n         *    \"UnitPrice\": 19.0000,\n         *    \"Discontinued\": false\n         *  }\n         * ];\n         *\n         * ```\n         */\n        this.locked = false;\n        /**\n         * Specifies if the column can be locked or unlocked from the column menu or by reordering the columns.\n         */\n        this.lockable = true;\n        /**\n         * Specifies if the column menu will be shown for the column.\n         */\n        this.columnMenu = true;\n        /**\n         * Specifies if the column will be included in the column-chooser list.\n         */\n        this.includeInChooser = true;\n        /**\n         * @hidden\n         */\n        this.headerTemplates = new QueryList();\n        /**\n         * @hidden\n         */\n        this.columnMenuTemplates = new QueryList();\n        if (parent && !isColumnContainer(parent)) {\n            throw new Error('Columns can be nested only inside ColumnGroupComponent');\n        }\n    }\n    /**\n     * The width of the column (in pixels).\n     */\n    set width(value) {\n        this._width = parseInt(value, 10);\n    }\n    get width() { return this._width; }\n    /**\n     * @hidden\n     */\n    get level() {\n        if (this.parent && isSpanColumn(this.parent)) {\n            return this.parent.level;\n        }\n        return this.parent ? this.parent.level + 1 : 0;\n    }\n    /**\n     * @hidden\n     */\n    get isLocked() {\n        return this.parent ? this.parent.isLocked : this.locked;\n    }\n    /**\n     * @hidden\n     */\n    get colspan() {\n        return 1;\n    }\n    /**\n     * @hidden\n     */\n    rowspan(totalColumnLevels) {\n        return this.level < totalColumnLevels ? (totalColumnLevels - this.level) + 1 : 1;\n    }\n    /**\n     * @hidden\n     */\n    get headerTemplateRef() {\n        const template = this.headerTemplates.first;\n        return template ? template.templateRef : undefined;\n    }\n    /**\n     * @hidden\n     */\n    get footerTemplateRef() {\n        return this.footerTemplate ? this.footerTemplate.templateRef : undefined;\n    }\n    /**\n     * @hidden\n     */\n    get columnMenuTemplateRef() {\n        const template = this.columnMenuTemplates.first;\n        return template ? template.templateRef : null;\n    }\n    /**\n     * @hidden\n     */\n    get displayTitle() {\n        return this.title;\n    }\n    /**\n     * @hidden\n     */\n    get isVisible() {\n        return !this.hidden && this.matchesMedia;\n    }\n}\nColumnBase$1.propDecorators = {\n    resizable: [{ type: Input }],\n    reorderable: [{ type: Input }],\n    minResizableWidth: [{ type: Input }],\n    title: [{ type: Input }],\n    width: [{ type: Input }],\n    autoSize: [{ type: Input }],\n    locked: [{ type: Input }],\n    hidden: [{ type: Input }],\n    media: [{ type: Input }],\n    lockable: [{ type: Input }],\n    columnMenu: [{ type: Input }],\n    includeInChooser: [{ type: Input }],\n    style: [{ type: Input }],\n    headerStyle: [{ type: Input }],\n    footerStyle: [{ type: Input }],\n    cssClass: [{ type: Input, args: ['class',] }],\n    headerClass: [{ type: Input }],\n    footerClass: [{ type: Input }],\n    headerTemplates: [{ type: ContentChildren, args: [HeaderTemplateDirective, { descendants: false },] }],\n    footerTemplate: [{ type: ContentChild, args: [FooterTemplateDirective,] }],\n    columnMenuTemplates: [{ type: ContentChildren, args: [ColumnMenuTemplateDirective,] }]\n};\n\nconst EMPTY_REGEX = /^\\s*$/;\n/**\n * @hidden\n */\nconst isPresent = (value) => value !== null && value !== undefined;\n/**\n * @hidden\n */\nconst isBlank = (value) => value === null || value === undefined;\n/**\n * @hidden\n */\nconst isArray = (value) => Array.isArray(value);\n/**\n * @hidden\n */\nconst isTruthy = (value) => !!value;\n/**\n * @hidden\n */\nconst isNullOrEmptyString = (value) => isBlank(value) || EMPTY_REGEX.test(value);\n/**\n * @hidden\n */\nconst observe = (list) => merge(of(list), list.changes);\n/**\n * @hidden\n */\nconst isUniversal = () => typeof document === 'undefined';\n/**\n * @hidden\n */\nconst isString = (value) => typeof value === 'string';\n/**\n * @hidden\n */\nconst isNumber = (value) => typeof value === \"number\" && !isNaN(value);\n/**\n * @hidden\n */\nconst extractFormat = (format) => {\n    if (isString(format) && !isNullOrEmptyString(format) && format.startsWith('{0:')) {\n        return format.slice(3, format.length - 1);\n    }\n    return format;\n};\n/**\n * @hidden\n */\nconst not = (fn) => (...args) => !fn.apply(null, args);\n/**\n * @hidden\n */\nconst or = (...conditions) => (value) => conditions.reduce((acc, x) => acc || x(value), false);\n/**\n * @hidden\n */\nconst and = (...conditions) => (value) => conditions.reduce((acc, x) => acc && x(value), true);\n/**\n * @hidden\n */\nconst Skip = new InjectionToken(\"Skip\"); // tslint:disable-line:variable-name\n/**\n * @hidden\n */\nconst createPromise = () => {\n    let resolveFn, rejectFn;\n    const promise = new Promise((resolve, reject) => {\n        resolveFn = (data) => {\n            resolve(data);\n            return promise;\n        };\n        rejectFn = (data) => {\n            reject(data);\n            return promise;\n        };\n    });\n    promise.resolve = resolveFn;\n    promise.reject = rejectFn;\n    return promise;\n};\n/** @hidden */\nconst iterator = getIterator();\n// TODO: Move to kendo-common\nfunction getIterator() {\n    if (typeof Symbol === 'function' && Symbol.iterator) {\n        return Symbol.iterator;\n    }\n    const keys = Object.getOwnPropertyNames(Map.prototype);\n    const proto = Map.prototype;\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (key !== 'entries' && key !== 'size' && proto[key] === proto.entries) {\n            return key;\n        }\n    }\n}\nconst FRAME_DURATION = 1000 / 60;\nconst wnd = typeof window !== 'undefined' ? window : {};\n/** @hidden */\nconst requestAnimationFrame = wnd.requestAnimationFrame || wnd.msRequestAnimationFrame || (callback => setTimeout(callback, FRAME_DURATION));\n/** @hidden */\nconst cancelAnimationFrame = wnd.cancelAnimationFrame || wnd.msCancelRequestAnimationFrame || clearTimeout;\n\n/**\n * Represents the filter-cell template ([see example]({% slug builtinfiltertemplate_grid %}#toc-customizing-filter-rows)).\n */\nclass FilterCellTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nFilterCellTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridFilterCellTemplate]'\n            },] },\n];\n/** @nocollapse */\nFilterCellTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef, decorators: [{ type: Optional }] }\n];\n\n/**\n * Represents the filter-menu template\n * ([see example]({% slug builtinfiltertemplate_grid %}#toc-customizing-filter-menus)).\n */\nclass FilterMenuTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nFilterMenuTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridFilterMenuTemplate]'\n            },] },\n];\n/** @nocollapse */\nFilterMenuTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef, decorators: [{ type: Optional }] }\n];\n\n/**\n * @hidden\n */\nfunction isColumnComponent(column) {\n    return isPresent(column.field);\n}\n/**\n * Represents the columns of the [Angular Data Grid]({% slug overview_grid %}).\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-grid [data]=\"gridData\">\n *          <kendo-grid-column field=\"ProductID\" title=\"Product ID\" width=\"120\">\n *          </kendo-grid-column>\n *          <kendo-grid-column field=\"ProductName\" title=\"Product Name\">\n *          </kendo-grid-column>\n *          <kendo-grid-column field=\"UnitPrice\" title=\"Unit Price\" width=\"230\">\n *          </kendo-grid-column>\n *          <kendo-grid-column field=\"Discontinued\" width=\"120\">\n *              <ng-template kendoGridCellTemplate let-dataItem>\n *                  <input type=\"checkbox\" [checked]=\"dataItem.Discontinued\" disabled/>\n *              </ng-template>\n *          </kendo-grid-column>\n *        </kendo-grid>\n *    `\n * })\n *\n * class AppComponent {\n *    public gridData: any[];\n *\n *    constructor() {\n *        this.gridData = products;\n *    }\n * }\n *\n * const products = [{\n *    \"ProductID\": 1,\n *    \"ProductName\": \"Chai\",\n *    \"UnitPrice\": 18.0000,\n *    \"Discontinued\": true\n *  }, {\n *    \"ProductID\": 2,\n *    \"ProductName\": \"Chang\",\n *    \"UnitPrice\": 19.0000,\n *    \"Discontinued\": false\n *  }\n * ];\n *\n * ```\n */\nclass ColumnComponent extends ColumnBase$1 {\n    constructor(parent) {\n        super(parent);\n        /**\n         * Allows the column headers to be clicked and the `sortChange` event emitted.\n         * You have to handle the `sortChange` event yourself and sort the data.\n         */\n        this.sortable = true;\n        /**\n         * Determines if the column can be dragged to the group panel. The default value is `true`.\n         * If set to `false`, you can group the columns by the column field by using the API of the Grid.\n         */\n        this.groupable = true;\n        /**\n         * Defines the editor type ([see example]({% slug editing_reactive_forms_grid %}#toc-setup)).\n         * Used when the column enters the edit mode. The default value is `text`.\n         *\n         * @example\n         * ```html-no-run\n         * <kendo-grid>\n         *    <kendo-grid-column field=\"UnitPrice\" editor=\"numeric\">\n         *    </kendo-grid-column>\n         * </kendo-grid>\n         * ```\n         */\n        this.editor = 'text';\n        /**\n         * Defines the filter type that is displayed inside the filter row. The default value is `text`.\n         *\n         * @example\n         * ```html-no-run\n         * <kendo-grid>\n         *    <kendo-grid-column field=\"UnitPrice\" filter=\"numeric\">\n         *    </kendo-grid-column>\n         * </kendo-grid>\n         * ```\n         */\n        this.filter = 'text';\n        /**\n         * Defines if a filter UI will be displayed for this column. The default value is `true`.\n         *\n         * @example\n         * ```html-no-run\n         * <kendo-grid>\n         *    <kendo-grid-column field=\"UnitPrice\" [filterable]=\"false\">\n         *    </kendo-grid-column>\n         * </kendo-grid>\n         * ```\n         */\n        this.filterable = true;\n        /**\n         * Defines whether the column is editable. The default value is `true`.\n         *\n         * @example\n         * ```html-no-run\n         * <kendo-grid>\n         *    <kendo-grid-column field=\"UnitPrice\" [editable]=\"false\">\n         *    </kendo-grid-column>\n         * </kendo-grid>\n         * ```\n         */\n        this.editable = true;\n    }\n    get templateRef() {\n        return this.template ? this.template.templateRef : undefined;\n    }\n    get groupHeaderTemplateRef() {\n        return this.groupHeaderTemplate ? this.groupHeaderTemplate.templateRef : undefined;\n    }\n    get groupHeaderColumnTemplateRef() {\n        return this.groupHeaderColumnTemplate ? this.groupHeaderColumnTemplate.templateRef : undefined;\n    }\n    get groupFooterTemplateRef() {\n        return this.groupFooterTemplate ? this.groupFooterTemplate.templateRef : undefined;\n    }\n    get editTemplateRef() {\n        return this.editTemplate ? this.editTemplate.templateRef : undefined;\n    }\n    get filterCellTemplateRef() {\n        return this.filterCellTemplate ? this.filterCellTemplate.templateRef : undefined;\n    }\n    get filterMenuTemplateRef() {\n        return this.filterMenuTemplate ? this.filterMenuTemplate.templateRef : undefined;\n    }\n    get displayTitle() {\n        return this.title === undefined ? this.field : this.title;\n    }\n}\nColumnComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: ColumnBase$1,\n                        useExisting: forwardRef(() => ColumnComponent)\n                    }\n                ],\n                selector: 'kendo-grid-column',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nColumnComponent.ctorParameters = () => [\n    { type: ColumnBase$1, decorators: [{ type: SkipSelf }, { type: Host }, { type: Optional }] }\n];\nColumnComponent.propDecorators = {\n    field: [{ type: Input }],\n    format: [{ type: Input }],\n    sortable: [{ type: Input }],\n    groupable: [{ type: Input }],\n    editor: [{ type: Input }],\n    filter: [{ type: Input }],\n    filterable: [{ type: Input }],\n    editable: [{ type: Input }],\n    template: [{ type: ContentChild, args: [CellTemplateDirective,] }],\n    groupHeaderTemplate: [{ type: ContentChild, args: [GroupHeaderTemplateDirective,] }],\n    groupHeaderColumnTemplate: [{ type: ContentChild, args: [GroupHeaderColumnTemplateDirective,] }],\n    groupFooterTemplate: [{ type: ContentChild, args: [GroupFooterTemplateDirective,] }],\n    editTemplate: [{ type: ContentChild, args: [EditTemplateDirective,] }],\n    filterCellTemplate: [{ type: ContentChild, args: [FilterCellTemplateDirective,] }],\n    filterMenuTemplate: [{ type: ContentChild, args: [FilterMenuTemplateDirective,] }]\n};\n\n/**\n * @hidden\n */\nfunction isSpanColumnComponent(column) {\n    return column.isSpanColumn;\n}\n/**\n * Represents a column which can be spanned over multiple data cells while the individual\n * header and footer cells are retained ([see example]({% slug spanned_columns_grid %})).\n * Enables you to achieve more flexible layout while keeping the built-in UI element for\n * [sorting]({% slug sorting_grid %}), [filtering]({% slug filtering_grid %}), and\n * [grouping]({% slug groupingbasics_grid %}). Wrap the columns that will be\n * merged inside the `<kendo-grid-span-column>` tag.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-grid\n *              [sortable]=\"true\"\n *              [filterable]=\"true\"\n *              [kendoGridBinding]=\"products\">\n *          <kendo-grid-column field=\"ProductID\" title=\"Product ID\" width=\"120\">\n *          </kendo-grid-column>\n *          <kendo-grid-span-column>\n *              <kendo-grid-column field=\"ProductName\" title=\"Product Name\">\n *              </kendo-grid-column>\n *              <kendo-grid-column field=\"UnitPrice\" title=\"Unit Price\" filter=\"numeric\" width=\"180\" format=\"{0:c}\">\n *              </kendo-grid-column>\n *          </kendo-grid-span-column>\n *          <kendo-grid-column field=\"Discontinued\" width=\"120\" filter=\"boolean\">\n *              <ng-template kendoGridCellTemplate let-dataItem>\n *                  <input type=\"checkbox\" [checked]=\"dataItem.Discontinued\" disabled/>\n *              </ng-template>\n *          </kendo-grid-column>\n *        </kendo-grid>\n *    `\n * })\n *\n * class AppComponent {\n *   public products = [{\n *      \"ProductID\": 1,\n *      \"ProductName\": \"Chai\",\n *      \"UnitPrice\": 18.0000,\n *      \"Discontinued\": true\n *    }, {\n *      \"ProductID\": 2,\n *      \"ProductName\": \"Chang\",\n *      \"UnitPrice\": 19.0000,\n *      \"Discontinued\": false\n *    }\n *   ];\n * }\n *\n * ```\n *\n * By default, the data cell displays the data for the specified fields. To further customize\n * the span-column functionality, use a [cell template]({% slug api_grid_celltemplatedirective %}).\n *\n * ```html-no-run\n * <kendo-grid-span-column>\n *  <kendo-grid-column field=\"field1\" title=\"Field 1\"></kendo-grid-column>\n *  <kendo-grid-column field=\"field2\" title=\"Field 2\"></kendo-grid-column>\n *    <ng-template kendoGridCellTemplate let-dataItem>\n *        <h5>{{ dataItem.field1 }}</h5>\n *        <p>{{ dataItem.field2 }}</p>\n *    </ng-template>\n *  </kendo-grid-span-column>\n * ```\n */\nclass SpanColumnComponent extends ColumnBase$1 {\n    constructor(parent) {\n        super(parent);\n        /*\n         * @hidden\n         */\n        this.isSpanColumn = true;\n        this.template = new QueryList();\n        this.editTemplate = new QueryList();\n        /**\n         * @hidden\n         */\n        this.childColumns = new QueryList();\n        /**\n         * @hidden\n         */\n        this.includeInChooser = false;\n        this._editable = true;\n        this._locked = false;\n        if (parent && parent.isSpanColumn) {\n            throw new Error('SpanColumn cannot be nested inside another SpanColumn');\n        }\n    }\n    /**\n     * Defines whether the edit template of the column will be rendered. The default value is `false`.\n     *\n     * > To enable the editing functionality for a spanned column, set an edit template for it.\n     *\n     * @example\n     * ```html-no-run\n     * <kendo-grid>\n     *    <kendo-grid-span-column [editable]=\"false\">\n     *      <kendo-grid-column field=\"UnitPrice\">\n     *      </kendo-grid-column>\n     *      <kendo-grid-column field=\"ProductName\">\n     *      </kendo-grid-column>\n     *      <ng-template kendoGridEditTemplate>\n     *         .....\n     *      </ng-template>\n     *    </kendo-grid-span-column>\n     * </kendo-grid>\n     * ```\n     */\n    set editable(value) {\n        this._editable = value;\n    }\n    get editable() {\n        return isPresent(this.editTemplateRef) && this._editable;\n    }\n    /**\n     * @hidden\n     * added for backwards compitability\n     */\n    set width(_value) {\n    }\n    get width() {\n        return this.childColumns.reduce((total, column) => total + column.width, 0);\n    }\n    /**\n     * @hidden\n     */\n    get leafIndex() {\n        return this.childColumns.first.leafIndex;\n    }\n    /**\n     * @hidden\n     */\n    get templateRef() {\n        const template = this.template.first;\n        return template ? template.templateRef : undefined;\n    }\n    /**\n     * @hidden\n     */\n    get editTemplateRef() {\n        const editTemplate = this.editTemplate.first;\n        return editTemplate ? editTemplate.templateRef : undefined;\n    }\n    /**\n     * @hidden\n     */\n    get colspan() {\n        return this.childColumns.filter(c => c.isVisible).length;\n    }\n    /**\n     * Toggles the locked (frozen) state of the columns. Locked columns are visible\n     * at all times during the horizontal scrolling of the Grid.\n     *\n     * For the option to work properly, make sure that:\n     * - Scrolling is enabled.\n     * - The `height` option of the Grid is set.\n     * - The widths of all Grid columns are explicitly set in pixels. In this way,\n     * the Grid adjusts the layout of the locked and unlocked columns.\n     *\n     * @default false\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     *    selector: 'my-app',\n     *    template: `\n     *        <kendo-grid [data]=\"gridData\" [scrollable]=\"scrollable\" style=\"height: 200px\">\n     *          <kendo-grid-span-column [locked]=\"true\">\n     *             <kendo-grid-column field=\"ProductID\" title=\"Product ID\" width=\"120\">\n     *             </kendo-grid-column>\n     *             <kendo-grid-column field=\"ProductName\" title=\"Product Name\" width=\"200\">\n     *             </kendo-grid-column>\n     *          </kendo-grid-span-column>\n     *          <kendo-grid-column field=\"UnitPrice\" title=\"Unit Price\" width=\"230\">\n     *          </kendo-grid-column>\n     *        </kendo-grid>\n     *    `\n     * })\n     *\n     * class AppComponent {\n     *    public gridData: any[];\n     *\n     *    constructor() {\n     *        this.gridData = products;\n     *    }\n     * }\n     *\n     * const products = [{\n     *    \"ProductID\": 1,\n     *    \"ProductName\": \"Chai\",\n     *    \"UnitPrice\": 18.0000,\n     *    \"Discontinued\": true\n     *  }, {\n     *    \"ProductID\": 2,\n     *    \"ProductName\": \"Chang\",\n     *    \"UnitPrice\": 19.0000,\n     *    \"Discontinued\": false\n     *  }\n     * ];\n     *\n     * ```\n     */\n    set locked(value) {\n        this._locked = value;\n    }\n    get locked() {\n        return this._locked || this.childColumns.some(c => c.locked);\n    }\n    get childrenArray() {\n        return this.childColumns.toArray();\n    }\n    get hasChildren() {\n        return this.childColumns.length > 0;\n    }\n}\nSpanColumnComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: ColumnBase$1,\n                        useExisting: forwardRef(() => SpanColumnComponent)\n                    }\n                ],\n                selector: 'kendo-grid-span-column',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nSpanColumnComponent.ctorParameters = () => [\n    { type: ColumnBase$1, decorators: [{ type: SkipSelf }, { type: Host }, { type: Optional }] }\n];\nSpanColumnComponent.propDecorators = {\n    template: [{ type: ContentChildren, args: [CellTemplateDirective, { descendants: false },] }],\n    editTemplate: [{ type: ContentChildren, args: [EditTemplateDirective, { descendants: false },] }],\n    childColumns: [{ type: ContentChildren, args: [ColumnComponent,] }],\n    editable: [{ type: Input }],\n    locked: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nconst expandColumns = (columns) => (columns.reduce((acc, column) => acc.concat(isSpanColumnComponent(column) ? column.childrenArray : [column]), []) // tslint:disable-line:align\n);\n/**\n * @hidden\n */\nconst expandColumnsWithSpan = (columns) => (columns.reduce((acc, column) => acc.concat(isSpanColumnComponent(column) ?\n    [column].concat(column.childrenArray) :\n    [column]), []) // tslint:disable-line:align\n);\n/**\n * @hidden\n */\nconst columnsToRender = (columns) => (expandColumns(columns).filter(x => x.isVisible));\nconst sumProp = (prop) => (array) => (array || []).reduce((prev, curr) => prev + (curr[prop] || 0), 0);\n/**\n * @hidden\n */\nconst sumColumnWidths = sumProp('width');\n/**\n * @hidden\n */\nconst columnsSpan = sumProp('colspan');\n// tslint:disable-next-line:max-line-length\nconst validField = new RegExp(`^[$A-Z\\_a-z][$A-Z\\_a-z0-9\\\\.]*$`);\n/**\n * @hidden\n */\nconst isValidFieldName = (fieldName) => !isNullOrEmptyString(fieldName) && validField.test(fieldName) &&\n    fieldName[0] !== \".\" && fieldName[fieldName.length - 1] !== \".\";\n/**\n * @hidden\n */\nconst children = column => column.children.filter(child => child !== column);\n/**\n * @hidden\n */\nconst leafColumns = columns => {\n    return columns.reduce((acc, column) => {\n        if (column.isColumnGroup) {\n            acc = acc.concat(leafColumns(children(column)));\n        }\n        else if (column.isSpanColumn) {\n            acc = acc.concat(column.childrenArray);\n        }\n        else {\n            acc.push(column);\n        }\n        return acc;\n    }, []).filter(x => x.isVisible); // tslint:disable-line:align\n};\n/**\n * @hidden\n */\nconst someLeafColumn = (callback, ...columns) => leafColumns(columns).some(callback);\n/**\n * @hidden\n */\nconst resizableColumns = columns => columns.filter(column => isTruthy(column.resizable) && column.isVisible);\n/**\n * @hidden\n */\nconst sortColumns = (columns) => orderBy(columns, [{ field: 'orderIndex', dir: 'asc' }]);\n/**\n * @hidden\n */\nconst isInSpanColumn = (column) => isTruthy(column.parent) && isSpanColumnComponent(column.parent);\n\n/**\n * @hidden\n */\nfunction isColumnGroupComponent(column) {\n    return column.isColumnGroup;\n}\n/**\n * Represents the column group header of the Grid\n * ([more information and examples]({% slug multicolumnheaders_columns_grid %})).\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *     <kendo-grid [data]=\"gridData\">\n *       <kendo-grid-column-group title=\"Product Info\">\n *         <ng-template kendoGridHeaderTemplate let-columnIndex=\"columnIndex\" let-column=\"column\">\n *               Column index: {{columnIndex}} / column title: {{column.title}}\n *         </ng-template>\n *         <kendo-grid-column field=\"ProductID\" title=\"Product ID\" width=\"120\">\n *         </kendo-grid-column>\n *         <kendo-grid-column field=\"ProductName\" title=\"Product Name\">\n *         </kendo-grid-column>\n *       </kendo-grid-column-group>\n *       <kendo-grid-column field=\"UnitPrice\" title=\"Unit Price\" width=\"230\">\n *       </kendo-grid-column>\n *       <kendo-grid-column field=\"Discontinued\" width=\"120\">\n *           <ng-template kendoGridCellTemplate let-dataItem>\n *               <input type=\"checkbox\" [checked]=\"dataItem.Discontinued\" disabled/>\n *           </ng-template>\n *       </kendo-grid-column>\n *     </kendo-grid>\n *    `\n * })\n *\n * class AppComponent {\n *    public gridData: any[];\n *\n *    constructor() {\n *        this.gridData = products;\n *    }\n * }\n *\n * const products = [{\n *    \"ProductID\": 1,\n *    \"ProductName\": \"Chai\",\n *    \"UnitPrice\": 18.0000,\n *    \"Discontinued\": true\n *  }, {\n *    \"ProductID\": 2,\n *    \"ProductName\": \"Chang\",\n *    \"UnitPrice\": 19.0000,\n *    \"Discontinued\": false\n *  }\n * ];\n *\n * ```\n */\nclass ColumnGroupComponent extends ColumnBase$1 {\n    constructor(parent) {\n        super(parent);\n        this.parent = parent;\n        /**\n         * @hidden\n         */\n        this.includeInChooser = false;\n        /**\n         * @hidden\n         */\n        this.isColumnGroup = true;\n        /**\n         * @hidden\n         */\n        this.minResizableWidth = 10;\n        if (parent && parent.isSpanColumn) {\n            throw new Error('ColumnGroupComponent cannot be nested inside SpanColumnComponent');\n        }\n    }\n    /**\n     * @hidden\n     */\n    rowspan() {\n        return 1;\n    }\n    /**\n     * @hidden\n     */\n    get colspan() {\n        if (!this.children || this.children.length === 1) {\n            return 1;\n        }\n        return columnsSpan(this.children\n            .filter(child => child !== this && child.isVisible));\n    }\n    /**\n     * @hidden\n     */\n    get leafIndex() {\n        return this.children ? (this.firstChild || {}).leafIndex : -1;\n    }\n    get childrenArray() {\n        return this.children.filter(c => c !== this);\n    }\n    get hasChildren() {\n        return Boolean(this.firstChild);\n    }\n    get firstChild() {\n        return this.children.find(column => column !== this);\n    }\n}\nColumnGroupComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: ColumnBase$1,\n                        useExisting: forwardRef(() => ColumnGroupComponent)\n                    }\n                ],\n                selector: 'kendo-grid-column-group',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nColumnGroupComponent.ctorParameters = () => [\n    { type: ColumnBase$1, decorators: [{ type: SkipSelf }, { type: Host }, { type: Optional }] }\n];\nColumnGroupComponent.propDecorators = {\n    children: [{ type: ContentChildren, args: [ColumnBase$1,] }]\n};\n\n/**\n * Represents the detail template of the Grid ([more information and examples]({% slug detailrowtemplate_grid %})).\n * To define the detail template, nest an `<ng-template>` tag with the `kendoGridDetailTemplate` directive inside a `<kendo-grid>` tag.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *   selector: 'my-app',\n *   template: `\n *       <kendo-grid\n *         [data]=\"data\"\n *         selectable=\"true\"\n *         style=\"height: 160px\"\n *         >\n *         <kendo-grid-column field=\"ProductID\"></kendo-grid-column>\n *         <kendo-grid-column field=\"ProductName\"></kendo-grid-column>\n *         <kendo-grid-column field=\"UnitPrice\"></kendo-grid-column>\n *         <ng-template kendoGridDetailTemplate let-dataItem>\n *           <div *ngIf=\"dataItem.Category\">\n *             <header>{{dataItem.Category?.CategoryName}}</header>\n *             <span>{{dataItem.Category?.Description}}</span>\n *           </div>\n *         </ng-template>\n *       </kendo-grid>\n *   `\n * })\n *\n * class AppComponent {\n *     public data = [{\n *         \"ProductID\": 1,\n *         \"ProductName\": \"Chai\",\n *         \"UnitPrice\": 18.0000,\n *         \"Discontinued\": false,\n *         \"Category\": {\n *             \"CategoryID\": 1,\n *             \"CategoryName\": \"Beverages\",\n *             \"Description\": \"Soft drinks, coffees, teas, beers, and ales\"\n *         }\n *       }, {\n *         \"ProductID\": 2,\n *         \"ProductName\": \"Chang\",\n *         \"UnitPrice\": 19.0000,\n *         \"Discontinued\": false,\n *         \"Category\": {\n *             \"CategoryID\": 1,\n *             \"CategoryName\": \"Beverages\",\n *             \"Description\": \"Soft drinks, coffees, teas, beers, and ales\"\n *         }\n *       }, {\n *         \"ProductID\": 3,\n *         \"ProductName\": \"Aniseed Syrup\",\n *         \"UnitPrice\": 10.0000,\n *         \"Discontinued\": false,\n *         \"Category\": {\n *             \"CategoryID\": 2,\n *             \"CategoryName\": \"Condiments\",\n *             \"Description\": \"Sweet and savory sauces, relishes, spreads, and seasonings\"\n *         }\n *     }];\n *\n * }\n *\n * ```\n *\n */\nclass DetailTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n        this._condition = () => true;\n    }\n    /**\n     * Defines the function that indicates if a given detail row and the associated **Expand** or **Collapse** button will be displayed.\n     */\n    set showIf(fn) {\n        if (typeof fn !== 'function') {\n            throw new Error(`showIf must be a function, but received ${JSON.stringify(fn)}.`);\n        }\n        this._condition = fn;\n    }\n    get showIf() {\n        return this._condition;\n    }\n}\nDetailTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridDetailTemplate]'\n            },] },\n];\n/** @nocollapse */\nDetailTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef, decorators: [{ type: Optional }] }\n];\nDetailTemplateDirective.propDecorators = {\n    showIf: [{ type: Input, args: [\"kendoGridDetailTemplateShowIf\",] }]\n};\n\nconst canCreateElement = () => isDocumentAvailable() && document.createElement;\nlet cachedScrollbarWidth = null;\nlet cachedPixelRatio;\nlet cachedRtlScrollLeft = null;\nfunction scrollbarWidth() {\n    if (cachedScrollbarWidth === null && canCreateElement()) {\n        cachedPixelRatio = window.devicePixelRatio || 1;\n        const div = document.createElement(\"div\");\n        div.style.cssText = \"overflow:scroll;overflow-x:hidden;zoom:1;clear:both;display:block\";\n        div.innerHTML = \"&nbsp;\";\n        document.body.appendChild(div);\n        cachedScrollbarWidth = div.offsetWidth - div.scrollWidth;\n        document.body.removeChild(div);\n    }\n    return cachedScrollbarWidth;\n}\nfunction rtlScrollLeft() {\n    if (cachedRtlScrollLeft === null && canCreateElement()) {\n        const div = document.createElement(\"div\");\n        div.style.cssText = \"overflow:scroll;zoom:1;clear:both;display:block;width:100px;visibility:hidden;position:absolute;left:-10000px;direction:rtl;\";\n        div.innerHTML = \"<div style='width:200px;height:1px;'</div>\";\n        document.body.appendChild(div);\n        const initial = div.scrollLeft;\n        div.scrollLeft = -1;\n        cachedRtlScrollLeft = div.scrollLeft < 0 ? div.scrollLeft : initial;\n        document.body.removeChild(div);\n    }\n    return cachedRtlScrollLeft;\n}\n/**\n * @hidden\n * move to kendo-common\n */\nclass BrowserSupportService {\n    constructor(zone, changeDetector) {\n        this.zone = zone;\n        this.changeDetector = changeDetector;\n        this.changes = new EventEmitter();\n        if (typeof window !== 'undefined') {\n            this.zone.runOutsideAngular(() => {\n                fromEvent(window, 'resize').pipe(auditTime(100)).subscribe(() => {\n                    if (cachedPixelRatio !== window.devicePixelRatio) {\n                        zone.run(() => {\n                            cachedScrollbarWidth = null;\n                            this.changes.emit();\n                            this.changeDetector.markForCheck();\n                        });\n                    }\n                });\n            });\n        }\n    }\n    get scrollbarWidth() {\n        return scrollbarWidth();\n    }\n    get rtlScrollLeft() {\n        return rtlScrollLeft();\n    }\n}\nBrowserSupportService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nBrowserSupportService.ctorParameters = () => [\n    { type: NgZone },\n    { type: ChangeDetectorRef }\n];\n\n/* tslint:disable:use-life-cycle-interface */\nconst isGroupItem = (source) => {\n    return source.items !== undefined &&\n        source.field !== undefined;\n};\nconst isVirtualGroupItem = (source) => {\n    return source.offset !== undefined &&\n        source.skipHeader !== undefined;\n};\nconst flattenGroups = (groups) => (groups.reduce((acc, curr) => {\n    if (isGroupItem(curr)) {\n        return acc.concat(flattenGroups(curr.items));\n    }\n    return acc.concat([curr]);\n}, []) // tslint:disable-line:align\n);\n/**\n * @hidden\n */\nconst itemAt = (data, index) => {\n    const first = data[0];\n    if (isPresent(first) && isGroupItem(first)) {\n        return flattenGroups(data)[index];\n    }\n    return data[index];\n};\n/**\n * @hidden\n */\nconst getIterator$1 = (data, { footers, level, dataIndex, parentGroupIndex, groupIndex }) => {\n    const first = data[0];\n    if (isPresent(first) && isGroupItem(first)) {\n        if (isVirtualGroupItem(first)) {\n            groupIndex = isPresent(first.offset) ? first.offset : groupIndex;\n        }\n        //tslint:disable-next-line:no-use-before-declare\n        return new GroupIterator(data, footers, level, dataIndex, parentGroupIndex, groupIndex);\n    }\n    //tslint:disable-next-line:no-use-before-declare\n    return new ItemIterator(data, dataIndex, parentGroupIndex);\n};\nclass ArrayIterator {\n    constructor(arr, idx = 0) {\n        this.arr = arr;\n        this.idx = idx;\n        this.arr = arr || [];\n    }\n    [iterator]() {\n        return this;\n    }\n    next() {\n        return this.idx < this.arr.length ? {\n            done: false,\n            value: this.arr[this.idx++]\n        } : { done: true, value: undefined };\n    }\n}\n/**\n * @hidden\n */\nclass Iterator {\n    constructor(arr, dataIndex = 0, resultMap = (x) => x) {\n        this.dataIndex = dataIndex;\n        this.resultMap = resultMap;\n        const iter = arr[iterator];\n        this._innerIterator = iter ? arr[iterator]() : new ArrayIterator(arr);\n    }\n    [iterator]() {\n        return this;\n    }\n    next() {\n        return this.resultMap(this._innerIterator.next(), this.dataIndex++);\n    }\n}\n/**\n * @hidden\n */\nclass ItemIterator extends Iterator {\n    constructor(arr, dataIndex, groupIndex) {\n        super(arr, dataIndex, (x, idx) => ({\n            done: x.done,\n            value: {\n                data: x.value,\n                groupIndex: groupIndex,\n                index: idx,\n                type: 'data'\n            }\n        }));\n    }\n    /**\n     * The index of the next record.\n     * @readonly\n     * @type {number}\n     */\n    get index() {\n        return this.dataIndex;\n    }\n}\nconst prefix = (s, n) => {\n    const p = s ? s + \"_\" : s;\n    return `${p}${n}`;\n};\n/**\n * @hidden\n */\nclass GroupIterator {\n    constructor(arr, outputFooters = false, level = 0, dataIndex = 0, parentIndex = \"\", groupIndex = 0) {\n        this.arr = arr;\n        this.outputFooters = outputFooters;\n        this.level = level;\n        this.dataIndex = dataIndex;\n        this.parentIndex = parentIndex;\n        this.groupIndex = groupIndex;\n        this.currentGroupIndex = \"\";\n        this.arr = arr || [];\n        this._iterator = new Iterator(this.arr, this.dataIndex);\n    }\n    [iterator]() {\n        return this;\n    }\n    nextGroupItem() {\n        this.current = this._iterator.next().value;\n        this._innerIterator = null;\n        if (this.current) {\n            this.currentGroupIndex = prefix(this.parentIndex, this.groupIndex++);\n            return {\n                done: false,\n                value: {\n                    data: this.current,\n                    index: this.currentGroupIndex,\n                    level: this.level,\n                    type: 'group'\n                }\n            };\n        }\n        else {\n            this.current = null;\n            return { done: true, value: undefined };\n        }\n    }\n    footerItem() {\n        if (this.current) {\n            const group = this.current;\n            this.current = null;\n            return {\n                done: false,\n                value: {\n                    data: group,\n                    groupIndex: this.currentGroupIndex,\n                    level: this.level,\n                    type: 'footer'\n                }\n            };\n        }\n        else {\n            this.current = null;\n            return { done: true, value: undefined };\n        }\n    }\n    innerIterator(group) {\n        if (!this._innerIterator) {\n            this._innerIterator = getIterator$1(group.items, {\n                dataIndex: this.dataIndex,\n                footers: this.outputFooters,\n                level: this.level + 1,\n                parentGroupIndex: this.currentGroupIndex\n            });\n        }\n        return this._innerIterator;\n    }\n    nextDataItem(group) {\n        const iterator$$1 = this.innerIterator(group);\n        const result = iterator$$1.next();\n        if (isPresent(result.value) && !result.done && result.value.type === \"data\") {\n            this.dataIndex = result.value.index + 1;\n        }\n        return !result.done ? result : undefined;\n    }\n    next() {\n        if (!isPresent(this.current)) {\n            return this.nextGroupItem();\n        }\n        const item = this.nextDataItem(this.current);\n        return item ? item : (this.outputFooters ? this.footerItem() : this.nextGroupItem());\n    }\n    /**\n     * The index of the last iterated data record.\n     * @readonly\n     * @type {number}\n     */\n    get index() {\n        return this.dataIndex + 1;\n    }\n}\n\n/**\n * @hidden\n */\nclass DataResultIterator {\n    constructor(source, skip = 0, groupFooters = false) {\n        this.source = source;\n        this.skip = skip;\n        this.groupFooters = groupFooters;\n        this.source = this.source ? this.source : [];\n        this.isObject = this.isGridDataResult(this.source);\n    }\n    isGridDataResult(source) {\n        return source.total !== undefined && source.data !== undefined;\n    }\n    get total() {\n        return this.isObject ? this.source.total : this.source.length;\n    }\n    get data() {\n        return this.isObject ? this.source.data : this.source;\n    }\n    map(fn) {\n        return this.data.map(fn);\n    }\n    filter(fn) {\n        return this.data.filter(fn);\n    }\n    reduce(fn, init) {\n        return this.data.reduce(fn, init);\n    }\n    forEach(fn) {\n        this.data.forEach(fn);\n    }\n    some(fn) {\n        return this.data.some(fn);\n    }\n    [iterator]() {\n        return getIterator$1(this.data, {\n            dataIndex: this.skip,\n            footers: this.groupFooters,\n            groupIndex: this.skip\n        });\n    }\n    toString() { return this.data.toString(); }\n}\n/**\n * @hidden\n */\nclass DataCollection {\n    constructor(accessor) {\n        this.accessor = accessor;\n    }\n    get total() { return this.accessor().total; }\n    get length() { return this.accessor().data.length; }\n    get first() { return this.accessor().data[0]; }\n    get last() { return this.accessor().data[this.length - 1]; }\n    at(index) {\n        return itemAt(this.accessor().data, index);\n    }\n    map(fn) { return this.accessor().map(fn); }\n    filter(fn) {\n        return this.accessor().filter(fn);\n    }\n    reduce(fn, init) {\n        return this.accessor().reduce(fn, init);\n    }\n    forEach(fn) {\n        this.accessor().forEach(fn);\n    }\n    some(fn) {\n        return this.accessor().some(fn);\n    }\n    [iterator]() {\n        return this.accessor()[iterator]();\n    }\n    toString() { return this.accessor().toString(); }\n}\n\n/**\n * @hidden\n */\nclass DomEventsService {\n    constructor() {\n        this.cellClick = new EventEmitter();\n        this.cellMousedown = new EventEmitter();\n        this.click = new EventEmitter();\n        this.keydown = new EventEmitter();\n        this.focus = new EventEmitter();\n        this.focusIn = new EventEmitter();\n        this.focusOut = new EventEmitter();\n        this.windowBlur = new EventEmitter();\n    }\n}\nDomEventsService.decorators = [\n    { type: Injectable },\n];\n\n/**\n * @hidden\n */\nclass LocalDataChangesService {\n    constructor() {\n        this.changes = new EventEmitter();\n    }\n}\nLocalDataChangesService.decorators = [\n    { type: Injectable },\n];\n\n/**\n * @hidden\n */\nclass SelectionService {\n    constructor(domEvents, localDataChangesService) {\n        this.changes = new EventEmitter();\n        this.lastSelectionStartIndex = 0;\n        this.currentSelection = [];\n        this.selectAllChecked = false;\n        this.cellClickSubscription = domEvents.cellClick.subscribe((args) => {\n            if (this.options.enabled && !this.options.checkboxOnly && args.type !== 'contextmenu') {\n                this.handleClick({ index: args.rowIndex, data: args.dataItem }, args.originalEvent);\n            }\n        });\n        this.mousedownSubscription = domEvents.cellMousedown.subscribe((args) => {\n            if (this.options.enabled && (!this.options.mode || this.options.mode === \"multiple\") &&\n                !this.options.checkboxOnly && args.originalEvent.shiftKey) {\n                args.originalEvent.preventDefault();\n            }\n        });\n        if (localDataChangesService) {\n            this.dataChangedSubscription = localDataChangesService.changes.subscribe((args) => {\n                if (isPresent(args.action) && args.action === 'remove') {\n                    this.deselect(args.item);\n                }\n            });\n        }\n    }\n    init(settings) {\n        this.settings = settings;\n        this.currentSelection = [];\n        if (settings.selectable && settings.selectable.enabled !== false) {\n            const iterator$$1 = this.getIterator();\n            this._selectAllState = true;\n            while (true) {\n                const item = iterator$$1.next();\n                if (item.done) {\n                    break;\n                }\n                if (item.value && item.value.type === \"data\") {\n                    const rowArgs = {\n                        dataItem: item.value.data,\n                        index: item.value.index\n                    };\n                    if (settings.rowSelected(rowArgs)) {\n                        this.currentSelection[item.value.index] = rowArgs;\n                    }\n                    else {\n                        this._selectAllState = undefined;\n                    }\n                }\n            }\n            if (this.currentSelection.length === 0) {\n                this._selectAllState = false;\n            }\n        }\n    }\n    isSelected(index) {\n        return this.options.enabled && isPresent(this.currentSelection[index]);\n    }\n    handleClick(item, event) {\n        let ev;\n        const ctrlKey = event.ctrlKey || event.metaKey;\n        if (this.options.mode === \"single\" && ctrlKey && this.isSelected(item.index)) {\n            ev = this.toggle(item);\n        }\n        else if (this.options.mode === \"multiple\") {\n            if (ctrlKey && !event.shiftKey) {\n                ev = this.toggle(item);\n            }\n            else if (event.shiftKey) {\n                ev = this.addAllTo(item, ctrlKey);\n            }\n        }\n        if (!isPresent(ev)) {\n            ev = this.select(item);\n            this.currentSelection[item.index] = {\n                dataItem: item.data,\n                index: item.index\n            };\n        }\n        if (!ev.selectedRows.length && !ev.deselectedRows.length) {\n            return;\n        }\n        ev.ctrlKey = event.ctrlKey || event.metaKey;\n        ev.shiftKey = event.shiftKey;\n        this.changes.emit(ev);\n    }\n    toggle(item) {\n        let selectedRows = [];\n        let deselectedRows = [];\n        this.lastSelectionStartIndex = item.index;\n        if (this.isSelected(item.index)) {\n            deselectedRows.push({ dataItem: item.data, index: item.index });\n        }\n        else {\n            selectedRows.push({ dataItem: item.data, index: item.index });\n        }\n        return {\n            deselectedRows: deselectedRows,\n            selectedRows: selectedRows\n        };\n    }\n    toggleByIndex(index) {\n        const iterator$$1 = this.getIterator();\n        if (this.selectAllChecked && this.isSelected(index)) {\n            this.selectAllChecked = false;\n        }\n        while (true) {\n            const item = iterator$$1.next();\n            if (item.done) {\n                break;\n            }\n            if (item.value && item.value.type === \"data\" && item.value.index === index) {\n                const itemToToggle = {\n                    data: item.value.data,\n                    index: item.value.index\n                };\n                if (this.isSelected(index) || this.options.mode === \"multiple\") {\n                    return this.toggle(itemToToggle);\n                }\n                else {\n                    return this.select(itemToToggle);\n                }\n            }\n        }\n    }\n    select(item) {\n        let deselectedRows = [];\n        let selectedRows = [];\n        this.lastSelectionStartIndex = item.index;\n        if (!this.isSelected(item.index)) {\n            selectedRows.push({ dataItem: item.data, index: item.index });\n        }\n        this.currentSelection.forEach((row) => {\n            if (row.index !== item.index) {\n                deselectedRows.push(row);\n            }\n        });\n        return {\n            deselectedRows: deselectedRows,\n            selectedRows: selectedRows\n        };\n    }\n    //Used to manually deselect removed items\n    deselect(removedItem) {\n        const iterator$$1 = this.getIterator();\n        while (true) {\n            const item = iterator$$1.next();\n            if (item.done) {\n                break;\n            }\n            if (item.value && item.value.type === \"data\" && item.value.data === removedItem) {\n                const rowArgs = {\n                    dataItem: item.value.data,\n                    index: item.value.index\n                };\n                if (this.isSelected(rowArgs.index)) {\n                    let ev = {\n                        ctrlKey: false,\n                        deselectedRows: [rowArgs],\n                        selectedRows: []\n                    };\n                    this.changes.emit(ev);\n                }\n            }\n        }\n    }\n    addAllTo(item, ctrlKey) {\n        let selectedRows = [];\n        let deselectedRows = [];\n        const start = Math.min(this.lastSelectionStartIndex, item.index);\n        const end = Math.max(this.lastSelectionStartIndex, item.index);\n        const iterator$$1 = this.getIterator();\n        while (true) {\n            const next = iterator$$1.next();\n            if (next.done) {\n                break;\n            }\n            if (next.value && next.value.type === \"data\") {\n                const idx = next.value.index;\n                if ((idx < start || idx > end) && this.isSelected(idx) && !ctrlKey) {\n                    deselectedRows.push({ dataItem: next.value.data, index: idx });\n                }\n                if ((idx >= start && idx <= end) && !this.isSelected(idx)) {\n                    selectedRows.push({ dataItem: next.value.data, index: idx });\n                }\n            }\n        }\n        return {\n            deselectedRows: deselectedRows,\n            selectedRows: selectedRows\n        };\n    }\n    updateAll(selectAllChecked) {\n        this.selectAllChecked = selectAllChecked;\n        let selectedRows = [];\n        let deselectedRows = [];\n        const iterator$$1 = this.getIterator();\n        while (true) {\n            const next = iterator$$1.next();\n            if (next.done) {\n                break;\n            }\n            if (next.value && next.value.type === \"data\") {\n                const idx = next.value.index;\n                if (this.isSelected(idx) && !selectAllChecked) {\n                    deselectedRows.push({ dataItem: next.value.data, index: idx });\n                }\n                if (!this.isSelected(idx) && selectAllChecked) {\n                    selectedRows.push({ dataItem: next.value.data, index: idx });\n                }\n            }\n        }\n        if (!selectedRows.length && !deselectedRows.length) {\n            return;\n        }\n        let ev = {\n            ctrlKey: true,\n            deselectedRows: deselectedRows,\n            selectedRows: selectedRows,\n            shiftKey: true\n        };\n        this.changes.emit(ev);\n    }\n    get selectAllState() {\n        return this._selectAllState;\n    }\n    get selected() {\n        return this.currentSelection.map((item) => {\n            return item.index;\n        }).filter((n) => typeof n === \"number\");\n    }\n    get options() {\n        const defaultOptions = {\n            checkboxOnly: false,\n            enabled: true,\n            mode: \"multiple\"\n        };\n        if (!isPresent(this.settings)) {\n            return defaultOptions;\n        }\n        if (typeof this.settings.selectable === 'boolean') {\n            return {\n                checkboxOnly: false,\n                enabled: this.settings.selectable,\n                mode: \"multiple\"\n            };\n        }\n        else {\n            return Object.assign(defaultOptions, this.settings.selectable);\n        }\n    }\n    ngOnDestroy() {\n        if (this.cellClickSubscription) {\n            this.cellClickSubscription.unsubscribe();\n            this.cellClickSubscription = null;\n        }\n        if (this.mousedownSubscription) {\n            this.mousedownSubscription.unsubscribe();\n            this.mousedownSubscription = null;\n        }\n        if (this.dataChangedSubscription) {\n            this.dataChangedSubscription.unsubscribe();\n            this.dataChangedSubscription = null;\n        }\n    }\n    getIterator() {\n        const accessor = this.settings.view.accessor();\n        if (!accessor) {\n            return;\n        }\n        return accessor[iterator]();\n    }\n}\nSelectionService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nSelectionService.ctorParameters = () => [\n    { type: DomEventsService },\n    { type: LocalDataChangesService }\n];\n\n/* tslint:disable:no-input-rename */\n/**\n * @hidden\n */\nclass Selection {\n    constructor(grid, cd) {\n        this.grid = grid;\n        this.cd = cd;\n        /**\n         * Defines the collection that will store the selected item keys.\n         */\n        this.selectedKeys = [];\n        /**\n         * Fires when the `selectedKeys` collection has been updated.\n         */\n        this.selectedKeysChange = new EventEmitter();\n        this.init();\n    }\n    init() {\n        if (!isPresent(this.grid.rowSelected)) {\n            this.grid.rowSelected = (row) => {\n                return this.selectedKeys.indexOf(this.getItemKey(row)) >= 0;\n            };\n        }\n        this.selectionChangeSubscription = this.grid\n            .selectionChange\n            .subscribe(this.onSelectionChange.bind(this));\n    }\n    /**\n     * @hidden\n     */\n    destroy() {\n        this.selectionChangeSubscription.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n    reset() {\n        this.selectedKeys.splice(0, this.selectedKeys.length);\n    }\n    getItemKey(row) {\n        if (this.selectionKey) {\n            if (typeof this.selectionKey === \"string\") {\n                return row.dataItem[this.selectionKey];\n            }\n            if (typeof this.selectionKey === \"function\") {\n                return this.selectionKey(row);\n            }\n        }\n        return row.index;\n    }\n    onSelectionChange(selection) {\n        selection.deselectedRows.forEach((item) => {\n            const itemKey = this.getItemKey(item);\n            const itemIndex = this.selectedKeys.indexOf(itemKey);\n            if (itemIndex >= 0) {\n                this.selectedKeys.splice(itemIndex, 1);\n            }\n        });\n        if (this.grid.selectableSettings.mode === \"single\" && this.selectedKeys.length > 0) {\n            this.reset();\n        }\n        selection.selectedRows.forEach((item) => {\n            const itemKey = this.getItemKey(item);\n            if (this.selectedKeys.indexOf(itemKey) < 0) {\n                this.selectedKeys.push(itemKey);\n            }\n        });\n        this.cd.markForCheck();\n        this.selectedKeysChange.emit(this.selectedKeys);\n    }\n}\nSelection.propDecorators = {\n    selectedKeys: [{ type: Input }],\n    selectionKey: [{ type: Input, args: [\"kendoGridSelectBy\",] }],\n    selectedKeysChange: [{ type: Output }]\n};\n\n/**\n * @hidden\n */\nclass PreventableEvent {\n    constructor() {\n        this.prevented = false;\n    }\n    /**\n     * Prevents the default action for a specified event.\n     * In this way, the source component suppresses\n     * the built-in behavior that follows the event.\n     */\n    preventDefault() {\n        this.prevented = true;\n    }\n    /**\n     * Returns `true` if the event was prevented\n     * by any of its subscribers.\n     *\n     * @returns `true` if the default action was prevented.\n     * Otherwise, returns `false`.\n     */\n    isDefaultPrevented() {\n        return this.prevented;\n    }\n}\n\n/**\n * Arguments for the `cellClose` event.\n */\nclass CellCloseEvent extends PreventableEvent {\n    constructor(options) {\n        super();\n        /**\n         * @hidden\n         */\n        this.action = 'cellClose';\n        Object.assign(this, options);\n    }\n}\n\n/**\n * @hidden\n */\nconst isEqual = (index) => (item) => item.index === index;\n/**\n * @hidden\n */\nconst isNotEqual = (index) => (item) => item.index !== index;\n/**\n * @hidden\n */\nconst isNewRow = (index) => index === -1 || index === undefined;\n/**\n * @hidden\n */\nclass EditService {\n    constructor(ngZone) {\n        this.ngZone = ngZone;\n        this.changes = new EventEmitter();\n        this.editedIndices = [];\n        this.keepEditCell = false;\n        this.closingCell = false;\n        this.changedSource = new Subject();\n        this.changed = this.changedSource.asObservable().pipe(switchMap(() => this.ngZone.onStable.asObservable().pipe(take(1))));\n    }\n    editRow(index, group = undefined) {\n        this.editedIndices.push({ index, group });\n        this.onChanged();\n    }\n    addRow(group) {\n        this.newItemGroup = { group };\n        this.onChanged();\n    }\n    editCell(rowIndex, column, group) {\n        if (isNewRow(rowIndex) || column.editable === false || !(column.editTemplate || column.field)) {\n            return;\n        }\n        this.preventCellClose();\n        if (!this.closeCell()) {\n            this.editRow(rowIndex, group);\n            this.column = column;\n            this.onChanged();\n        }\n    }\n    isEditing() {\n        return this.editedIndices.length > 0;\n    }\n    isEditingCell() {\n        return this.isEditing() && this.column !== undefined;\n    }\n    get hasNewItem() {\n        return isPresent(this.newItemGroup);\n    }\n    get newDataItem() {\n        if (this.hasNewItem) {\n            return this.newItemGroup.group.value;\n        }\n        return {};\n    }\n    close(index) {\n        if (isNewRow(index)) {\n            this.newItemGroup = undefined;\n            return;\n        }\n        this.editedIndices = this.editedIndices.filter(isNotEqual(index));\n        delete this.column;\n        this.onChanged();\n    }\n    closeCell(originalEvent) {\n        if (this.column && !this.closingCell) {\n            return this.ngZone.run(() => {\n                const { index, group } = this.editedIndices[0];\n                const args = new CellCloseEvent({\n                    column: this.column,\n                    formGroup: group,\n                    originalEvent: originalEvent,\n                    rowIndex: index\n                });\n                this.closingCell = true;\n                this.changes.emit(args);\n                this.closingCell = false;\n                if (!args.isDefaultPrevented()) {\n                    this.cancelCell();\n                }\n                return args.isDefaultPrevented();\n            });\n        }\n    }\n    cancelCell() {\n        if (this.column) {\n            this.editedIndices = [];\n            delete this.column;\n            this.onChanged();\n        }\n    }\n    shouldCloseCell() {\n        return this.column && !this.keepEditCell;\n    }\n    preventCellClose() {\n        this.ngZone.runOutsideAngular(() => {\n            window.clearTimeout(this.keepCellTimeout);\n            this.keepEditCell = true;\n            this.keepCellTimeout = window.setTimeout(() => {\n                this.keepEditCell = false;\n            }, 0); // tslint:disable-line:align\n        });\n    }\n    context(index) {\n        if (isNewRow(index)) {\n            return this.newItemGroup;\n        }\n        return this.findByIndex(index);\n    }\n    columnContext(index, column) {\n        if (isNewRow(index)) {\n            return this.newItemGroup;\n        }\n        if (!this.column || column === this.column) {\n            return this.findByIndex(index);\n        }\n    }\n    isEdited(index) {\n        if (isNewRow(index) && isPresent(this.newItemGroup)) {\n            return true;\n        }\n        return !this.column && isPresent(this.findByIndex(index));\n    }\n    hasEdited(index) {\n        return isPresent(this.context(index));\n    }\n    isEditedColumn(index, column) {\n        if (this.column && this.column === column) {\n            return isPresent(this.findByIndex(index));\n        }\n        return false;\n    }\n    beginEdit(rowIndex) {\n        this.changes.emit({ action: 'edit', rowIndex });\n    }\n    beginAdd() {\n        this.changes.emit({ action: 'add' });\n    }\n    endEdit(rowIndex) {\n        const { group: formGroup } = this.context(rowIndex);\n        this.changes.emit({ action: 'cancel', rowIndex, formGroup, isNew: isNewRow(rowIndex) });\n    }\n    save(rowIndex) {\n        const { group: formGroup } = this.context(rowIndex);\n        this.changes.emit({ action: 'save', rowIndex, formGroup, isNew: isNewRow(rowIndex) });\n    }\n    remove(rowIndex) {\n        this.changes.emit({ action: 'remove', rowIndex });\n    }\n    findByIndex(index) {\n        return this.editedIndices.find(isEqual(index));\n    }\n    onChanged() {\n        this.ngZone.runOutsideAngular(() => {\n            this.changedSource.next();\n        });\n    }\n}\nEditService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nEditService.ctorParameters = () => [\n    { type: NgZone }\n];\n\n/**\n * @hidden\n */\nclass ExpandStateService {\n    constructor(isInitiallyCollapsed) {\n        this.isInitiallyCollapsed = isInitiallyCollapsed;\n        this.changes = new Subject();\n        this.rowState = [];\n    }\n    toggleRow(index, dataItem) {\n        const rowIndex = this.rowState.indexOf(index);\n        const found = rowIndex === -1;\n        if (!this.emitEvent({ dataItem: dataItem, expand: this.isInitiallyCollapsed ? found : !found, index: index })) {\n            this.rowState = found ?\n                [...this.rowState, index] :\n                [...this.rowState.slice(0, rowIndex), ...this.rowState.slice(rowIndex + 1)];\n        }\n    }\n    isExpanded(index) {\n        const found = this.rowState.indexOf(index) >= 0;\n        return this.isInitiallyCollapsed ? found : !found;\n    }\n    reset() {\n        this.rowState = [];\n    }\n    emitEvent(args) {\n        this.changes.next(args);\n        return false;\n    }\n}\n\n/**\n * Arguments for the `detailExpand` event.\n */\nclass DetailExpandEvent extends PreventableEvent {\n    constructor(args) {\n        super();\n        Object.assign(this, args);\n    }\n}\n\n/**\n * Arguments for the `detailCollapse` event.\n */\nclass DetailCollapseEvent extends PreventableEvent {\n    constructor(args) {\n        super();\n        Object.assign(this, args);\n    }\n}\n\n/**\n * @hidden\n */\nclass DetailsService extends ExpandStateService {\n    constructor() {\n        super(true);\n    }\n    emitEvent(args) {\n        const eventArg = new (args.expand ? DetailExpandEvent : DetailCollapseEvent)(args);\n        this.changes.next(eventArg);\n        return eventArg.isDefaultPrevented();\n    }\n}\nDetailsService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nDetailsService.ctorParameters = () => [];\n\nconst removeLast = groupIndex => groupIndex.lastIndexOf(\"_\") > -1\n    ? groupIndex.slice(0, groupIndex.lastIndexOf(\"_\"))\n    : \"\";\n/**\n * @hidden\n */\nclass GroupsService extends ExpandStateService {\n    constructor(isCollapsed = false) {\n        super(isCollapsed);\n    }\n    isInExpandedGroup(groupIndex, skipSelf = true) {\n        if (skipSelf) {\n            groupIndex = removeLast(groupIndex);\n        }\n        let expanded = true;\n        while (groupIndex && expanded) {\n            expanded = this.isExpanded(groupIndex);\n            groupIndex = removeLast(groupIndex);\n        }\n        return expanded;\n    }\n    expandChildren(groupIndex) {\n        this.rowState = this.rowState.filter((x) => !x.startsWith(groupIndex));\n    }\n}\nGroupsService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nGroupsService.ctorParameters = () => [\n    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [Skip,] }] }\n];\n\nconst reset = (...lists) => {\n    let diff = false;\n    for (let idx = 0; idx < lists.length; idx++) {\n        const [list, columns] = lists[idx];\n        diff = diff || list.length !== columns.length;\n        list.reset(columns);\n    }\n    return diff;\n};\n/**\n * @hidden\n */\nclass ColumnsContainer {\n    constructor(columns) {\n        this.columns = columns;\n        this.allColumns = new QueryList();\n        this.leafColumns = new QueryList();\n        this.lockedColumns = new QueryList();\n        this.nonLockedColumns = new QueryList();\n        this.lockedLeafColumns = new QueryList();\n        this.nonLockedLeafColumns = new QueryList();\n        this.totalLevels = 0;\n        this.changes = new EventEmitter();\n        this.leafColumnsToRender = [];\n        this.lockedColumnsToRender = [];\n        this.nonLockedColumnsToRender = [];\n        this.hasGroupHeaderColumn = false;\n        this.hasGroupFooter = false;\n        this.hasFooter = false;\n        this.unlockedWidth = 0;\n    }\n    refresh() {\n        const currentLevels = this.totalLevels;\n        const leafColumns$$1 = new Array();\n        const lockedLeafColumns = new Array();\n        const nonLockedLeafColumns = new Array();\n        const lockedColumns = new Array();\n        const nonLockedColumns = new Array();\n        const allColumns = new Array();\n        const leafColumnsToRender = new Array();\n        const lockedColumnsToRender = new Array();\n        const nonLockedColumnsToRender = new Array();\n        let hasGroupHeaderColumn = false;\n        let hasGroupFooter = false;\n        let hasFooter = false;\n        let unlockedWidth = 0;\n        let leafIndex = 0;\n        this.totalLevels = 0;\n        this.columns().forEach(column => {\n            const containerLeafColumns = column.isLocked === true ? lockedLeafColumns : nonLockedLeafColumns;\n            const containerColumns = column.isLocked === true ? lockedColumns : nonLockedColumns;\n            const toRenderContainer = column.isLocked === true ? lockedColumnsToRender : nonLockedColumnsToRender;\n            if (!isColumnGroupComponent(column)) {\n                containerLeafColumns.push(column);\n                leafColumns$$1.push(column);\n                leafColumnsToRender.push.apply(leafColumnsToRender, columnsToRender([column]));\n                toRenderContainer.push.apply(toRenderContainer, columnsToRender([column]));\n                hasGroupHeaderColumn = hasGroupHeaderColumn || someLeafColumn(leaf => Boolean(leaf.groupHeaderColumnTemplateRef), column);\n                hasGroupFooter = hasGroupFooter || someLeafColumn(leaf => Boolean(leaf.groupFooterTemplateRef), column);\n                hasFooter = hasFooter || someLeafColumn(leaf => Boolean(leaf.footerTemplateRef), column);\n                if (!column.isLocked) {\n                    unlockedWidth += column.width || 0;\n                }\n                if (column.isSpanColumn) {\n                    column.childColumns.forEach(c => {\n                        c.leafIndex = leafIndex++;\n                    });\n                }\n                else {\n                    column.leafIndex = leafIndex++;\n                }\n            }\n            containerColumns.push(column);\n            allColumns.push(column);\n            this.totalLevels = column.level > this.totalLevels ? column.level : this.totalLevels;\n        });\n        this.hasGroupHeaderColumn = hasGroupHeaderColumn;\n        this.hasGroupFooter = hasGroupFooter;\n        this.hasFooter = hasFooter;\n        this.leafColumnsToRender = leafColumnsToRender;\n        this.lockedColumnsToRender = lockedColumnsToRender;\n        this.nonLockedColumnsToRender = nonLockedColumnsToRender;\n        this.unlockedWidth = unlockedWidth;\n        const changes = reset([this.leafColumns, leafColumns$$1], [this.lockedLeafColumns, lockedLeafColumns], [this.nonLockedLeafColumns, nonLockedLeafColumns], [this.lockedColumns, lockedColumns], [this.allColumns, allColumns], [this.nonLockedColumns, nonLockedColumns]) || currentLevels !== this.totalLevels;\n        if (changes) {\n            this.changes.emit();\n        }\n        return changes;\n    }\n}\n\nconst forEachColumn = (list, callback) => {\n    list.forEach((column) => {\n        callback(column);\n        if (column.isColumnGroup && column.hasChildren) {\n            forEachColumn(column.childrenArray, callback);\n        }\n    });\n};\nconst forEachLevel = (list, callback) => {\n    sortColumns(list)\n        .forEach((column) => {\n        callback(column);\n        if (column.isColumnGroup && column.hasChildren) {\n            forEachLevel(column.childrenArray, callback);\n        }\n    });\n};\nconst filterHierarchy = (list, predicate) => {\n    const result = [];\n    sortColumns(list)\n        .forEach((column) => {\n        if (predicate(column)) {\n            if (column.isColumnGroup) {\n                const children$$1 = filterHierarchy(column.childrenArray, predicate);\n                if (children$$1.length) {\n                    result.push(column, ...children$$1);\n                }\n            }\n            else if (!column.isSpanColumn || filterHierarchy(column.childrenArray, predicate).length) {\n                result.push(column);\n            }\n        }\n    });\n    return result;\n};\n/**\n * @hidden\n */\nclass ColumnList {\n    constructor(columns) {\n        this.columns = columns;\n    }\n    static empty() {\n        return new ColumnList(new QueryList());\n    }\n    forEach(callback) {\n        forEachColumn(this.columns, callback);\n    }\n    filter(callback) {\n        const result = [];\n        forEachColumn(this.columns, (column) => {\n            if (callback(column)) {\n                result.push(column);\n            }\n        });\n        return result;\n    }\n    filterHierarchy(predicate) {\n        return filterHierarchy(this.columns.toArray(), predicate);\n    }\n    filterSort(callback) {\n        const result = [];\n        forEachLevel(this.columns.toArray(), (column) => {\n            if (callback(column)) {\n                result.push(column);\n            }\n        });\n        return result;\n    }\n    toArray() {\n        const result = [];\n        forEachColumn(this.columns, (column) => {\n            result.push(column);\n        });\n        return result;\n    }\n    rootColumns() {\n        return this.columns.toArray();\n    }\n}\n\n/**\n * @hidden\n */\nclass GroupInfoService {\n    constructor() {\n        this._columnList = ColumnList.empty;\n    }\n    get columns() {\n        return expandColumns(this._columnList().toArray()).filter(isColumnComponent);\n    }\n    registerColumnsContainer(columns) {\n        this._columnList = columns;\n    }\n    formatForGroup(item) {\n        const column = this.columnForGroup(item);\n        return column ? column.format : \"\";\n    }\n    isGroupable(groupField) {\n        const [column] = this.columns.filter(x => x.field === groupField);\n        return column ? column.groupable : true;\n    }\n    groupTitle(item) {\n        const column = this.columnForGroup(item);\n        return column ? (column.title || column.field) : this.groupField(item);\n    }\n    groupHeaderTemplate(item) {\n        const column = this.columnForGroup(item);\n        return column ? column.groupHeaderTemplateRef || column.groupHeaderColumnTemplateRef : undefined;\n    }\n    groupField(group) {\n        return group.data ? group.data.field : group.field;\n    }\n    columnForGroup(group) {\n        const field = this.groupField(group);\n        const [column] = this.columns.filter(x => x.field === field);\n        return column;\n    }\n}\n\n/**\n * @hidden\n */\nclass ChangeNotificationService {\n    constructor(ngZone) {\n        this.ngZone = ngZone;\n        this.changes = new EventEmitter();\n    }\n    notify() {\n        if (!this.subscription || this.subscription.closed) {\n            this.subscription = this.ngZone.onStable\n                .asObservable().pipe(take(1))\n                .subscribe(() => this.changes.emit());\n        }\n    }\n}\nChangeNotificationService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nChangeNotificationService.ctorParameters = () => [\n    { type: NgZone }\n];\n\n/**\n * Represents the no-records template of the Grid. Provides an option to customize the\n * appearance of the item that is displayed when no data is present. To define the no-records template,\n * nest an `<ng-template>` tag with the `kendoGridNoRecordsTemplate` directive inside `<kendo-grid>`.\n *\n * > When the locked columns of the Grid are in use, the template is displayed in the non-locked part of the content.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *   selector: 'my-app',\n *   template: `\n *       <kendo-grid [data]=\"data\">\n *         <kendo-grid-column field=\"ProductID\"></kendo-grid-column>\n *         <kendo-grid-column field=\"ProductName\"></kendo-grid-column>\n *         <kendo-grid-column field=\"UnitPrice\"></kendo-grid-column>\n *         <ng-template kendoGridNoRecordsTemplate>\n *            There are not products. <a href=\"#\" (click)=\"refresh()\">Click here to refresh</a>.\n *         </ng-template>\n *       </kendo-grid>\n *   `\n * })\n *\n * class AppComponent {\n *     public data = [];\n *     public refresh() {\n *       this.data = [{\n *            \"ProductID\": 1,\n *            \"ProductName\": \"Chai\",\n *            \"UnitPrice\": 18.0000,\n *            \"Discontinued\": false,\n *            \"Category\": {\n *                \"CategoryID\": 1,\n *                \"CategoryName\": \"Beverages\",\n *                \"Description\": \"Soft drinks, coffees, teas, beers, and ales\"\n *            }\n *          }, {\n *            \"ProductID\": 2,\n *            \"ProductName\": \"Chang\",\n *            \"UnitPrice\": 19.0000,\n *            \"Discontinued\": false,\n *            \"Category\": {\n *                \"CategoryID\": 1,\n *                \"CategoryName\": \"Beverages\",\n *                \"Description\": \"Soft drinks, coffees, teas, beers, and ales\"\n *            }\n *          }, {\n *            \"ProductID\": 3,\n *            \"ProductName\": \"Aniseed Syrup\",\n *            \"UnitPrice\": 10.0000,\n *            \"Discontinued\": false,\n *            \"Category\": {\n *                \"CategoryID\": 2,\n *                \"CategoryName\": \"Condiments\",\n *                \"Description\": \"Sweet and savory sauces, relishes, spreads, and seasonings\"\n *            }\n *        }];\n *\n *     }\n * }\n *\n * ```\n */\nclass NoRecordsTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nNoRecordsTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridNoRecordsTemplate]'\n            },] },\n];\n/** @nocollapse */\nNoRecordsTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef, decorators: [{ type: Optional }] }\n];\n\nconst set = value => pair => pair.forEach(x => x.style.height = value);\nconst clearHeight = pairs => pairs\n    .filter(([left, right]) => left.style.height || right.style.height)\n    .forEach(set(\"\"));\nconst zip$1 = (arr1, arr2) => {\n    const result = [];\n    for (let idx = 0, len = arr1.length; idx < len; idx++) {\n        if (!arr2[idx]) {\n            break;\n        }\n        result.push([arr1[idx], arr2[idx]]);\n    }\n    return result;\n};\nconst setHeight = heights => (row, idx) => set(`${heights[idx] + 1}px`)(row);\nconst getHeights = rows => rows.map(([left, right]) => {\n    const height = left.offsetHeight;\n    const offsetHeight2 = right.offsetHeight;\n    if (height < offsetHeight2) {\n        return offsetHeight2;\n    }\n    return height;\n});\n/**\n * @hidden\n */\nconst syncRowsHeight = (table1, table2) => {\n    const activeElement = document.activeElement;\n    const rows = zip$1(table1.rows, table2.rows);\n    clearHeight(rows);\n    const heights = getHeights(rows);\n    [table1, table2].forEach(x => x.style.display = 'none');\n    rows.forEach(setHeight(heights));\n    [table1, table2].forEach(x => x.style.display = '');\n    if (document.activeElement !== activeElement &&\n        (table1.contains(activeElement) || table2.contains(activeElement))) {\n        activeElement.focus();\n    }\n};\n\n/**\n * @hidden\n */\nconst CELL_CONTEXT = new InjectionToken('grid-cell-context');\n/**\n * @hidden\n */\nconst EMPTY_CELL_CONTEXT = {};\n\n/**\n * Represents a service to set the filter descriptor\n * ([see example]({% slug reusablecustomfilters_grid %})).\n */\nclass FilterService {\n    constructor() {\n        /**\n         * Fires when the filter descriptors is set.\n         */\n        this.changes = new Subject();\n    }\n    /**\n     * Sets the filter descriptor.\n     *\n     * @param {CompositeFilterDescriptor} value - The filter descriptor that will be set.\n     */\n    filter(value) {\n        this.changes.next(value);\n    }\n}\n\n/**\n * Represents the pager template which helps to customize the pager appearance in the Grid. To define a pager\n * template, nest an `<ng-template>` tag with the `kendoPagerTemplate` directive inside `<kendo-grid>`.\n *\n * The template context provides the following fields:\n * * `currentPage`&mdash;The index of the displayed page.\n * * `pageSize`&mdash;The value of the current `pageSize`.\n * * `skip`&mdash;The current skip value.\n * * `total`&mdash;The total number of records.\n * * `totalPages`&mdash;The total number of available pages.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *      <kendo-grid\n *        [kendoGridBinding]=\"gridData\"\n *        [pageSize]=\"1\"\n *        [pageable]=\"true\"\n *      >\n *       <kendo-grid-column field=\"ProductID\" title=\"ID\" width=\"40\">\n *       </kendo-grid-column>\n *       <kendo-grid-column field=\"ProductName\" title=\"Name\" width=\"250\">\n *       </kendo-grid-column>\n *       <kendo-grid-column field=\"UnitPrice\" title=\"Price\" width=\"80\" format=\"{0:c}\">\n *       </kendo-grid-column>\n *\n *       <ng-template kendoPagerTemplate let-totalPages=\"totalPages\" let-currentPage=\"currentPage\">\n *          <kendo-pager-prev-buttons></kendo-pager-prev-buttons>\n *          <kendo-pager-numeric-buttons [buttonCount]=\"10\"></kendo-pager-numeric-buttons>\n *          <kendo-pager-next-buttons></kendo-pager-next-buttons>\n *          <kendo-pager-info></kendo-pager-info>\n *          Current page: {{currentPage}}\n *       </ng-template>\n *\n *    </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *     public gridData = [{\n *         \"ProductID\": 1,\n *         \"ProductName\": \"Chai\",\n *         \"UnitPrice\": 18.0000,\n *         \"Discontinued\": false\n *       }, {\n *         \"ProductID\": 2,\n *         \"ProductName\": \"Chang\",\n *         \"UnitPrice\": 19.0000,\n *         \"Discontinued\": true\n *       }\n *     ];\n * }\n *\n * ```\n */\nclass PagerTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nPagerTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoPagerTemplate]'\n            },] },\n];\n/** @nocollapse */\nPagerTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef, decorators: [{ type: Optional }] }\n];\n\n/**\n * @hidden\n */\nclass PagerContextService {\n    constructor() {\n        this.changes = new Subject();\n        this.pageChange = new Subject();\n    }\n    get currentPage() {\n        return this.skip / this.pageSize;\n    }\n    notifyChanges(changes) {\n        this.total = changes.total;\n        this.pageSize = changes.pageSize;\n        this.skip = changes.skip;\n        this.changes.next(changes);\n    }\n    changePage(page) {\n        this.pageChange.next({ skip: page * this.pageSize, take: this.pageSize });\n    }\n    changePageSize(value) {\n        this.pageChange.next({ skip: 0, take: value });\n    }\n    nextPage() {\n        const nextPage = this.currentPage + 1;\n        if (nextPage * this.pageSize <= this.total) {\n            this.changePage(nextPage);\n        }\n    }\n    prevPage() {\n        const prevPage = this.currentPage - 1;\n        if (prevPage * this.pageSize >= 0) {\n            this.changePage(prevPage);\n        }\n    }\n}\n\n/**\n * @hidden\n */\nclass PDFService {\n    constructor() {\n        this.savePDF = new EventEmitter();\n        this.drawPDF = new EventEmitter();\n        this.exportClick = new EventEmitter();\n        this.dataChanged = new EventEmitter();\n    }\n    save(component) {\n        this.emitEvent(this.savePDF, component);\n    }\n    draw(component, promise) {\n        this.emitEvent(this.drawPDF, { component, promise });\n    }\n    emitEvent(emitter, args) {\n        if (emitter.observers.length === 0) {\n            if (isDevMode()) {\n                throw new Error('Creating PDF requires including the PDFModule and adding the <kendo-grid-pdf> component.');\n            }\n        }\n        else {\n            emitter.emit(args);\n        }\n    }\n}\nPDFService.decorators = [\n    { type: Injectable },\n];\n\n/**\n * Arguments for the `pdfExport` event.\n */\nclass PDFExportEvent extends PreventableEvent {\n}\n\n/**\n * @hidden\n */\nclass SuspendService {\n    constructor() {\n        this.scroll = false;\n    }\n}\nSuspendService.decorators = [\n    { type: Injectable },\n];\n\n/* tslint:disable: object-literal-sort-keys */\nconst bootstrapToMedia = (media) => (({\n    \"xs\": \"(max-width: 576px)\",\n    \"sm\": \"(min-width: 576px)\",\n    \"md\": \"(min-width: 768px)\",\n    \"lg\": \"(min-width: 992px)\",\n    \"xl\": \"(min-width: 1200px)\"\n})[media] || media);\n/* tslint:enable: object-literal-sort-keys */\nconst browserMatchMedia = (media) => window.matchMedia(media).matches;\n/**\n * @hidden\n */\nclass ResponsiveService {\n    constructor() {\n        /**\n         * @hidden\n         */\n        this.matchMedia = browserMatchMedia;\n    }\n    /**\n     * @hidden\n     */\n    matchesMedia(media) {\n        return !media || this.matchMedia(bootstrapToMedia(media));\n    }\n}\nResponsiveService.decorators = [\n    { type: Injectable },\n];\n\n/**\n * @hidden\n */\nclass ExcelService {\n    constructor() {\n        this.saveToExcel = new EventEmitter();\n        this.exportClick = new EventEmitter();\n    }\n    save(component) {\n        if (this.saveToExcel.observers.length === 0) {\n            if (isDevMode()) {\n                throw new Error('Saving excel requires including the ExcelModule and adding the <kendo-grid-excel> component.');\n            }\n        }\n        else {\n            this.saveToExcel.emit(component);\n        }\n    }\n}\nExcelService.decorators = [\n    { type: Injectable },\n];\n\n/**\n * Represents the toolbar template of the Grid.\n *\n * The template context has the following field:\n * - `position`&mdash;The position at which the toolbar template is rendered. The possible values are \"top\" and \"bottom\".\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *       <div class=\"example-config\">\n *         <input type=\"radio\" id=\"top\" name=\"position\" class=\"k-radio\" value=\"top\" checked (click)=\"positionChange($event)\"/>\n *         <label class=\"k-radio-label\" for=\"top\">Top</label><br/>\n *         <input type=\"radio\" id=\"bottom\" name=\"position\" class=\"k-radio\" value=\"bottom\" (click)=\"positionChange($event)\"/>\n *         <label class=\"k-radio-label\" for=\"bottom\">Bottom</label><br/>\n *         <input type=\"radio\" id=\"both\" name=\"position\" value=\"both\" class=\"k-radio\" (click)=\"positionChange($event)\"/>\n *         <label class=\"k-radio-label\" for=\"both\">Both</label><br/>\n *       </div>\n *       <kendo-grid [data]=\"gridData\" style=\"height: 200px\">\n *            <ng-template kendoGridToolbarTemplate [position]=\"position\" let-position=\"position\">\n *                <button (click)=\"onClick()\" class=\"k-button\">Custom action</button>\n *            </ng-template>\n *            <kendo-grid-column field=\"ProductName\">\n *            </kendo-grid-column>\n *            <kendo-grid-column field=\"UnitPrice\">\n *            </kendo-grid-column>\n *        </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *     public position: 'top' | 'bottom' | 'both' = 'top';\n *\n *     public gridData = [{\n *         \"ProductID\": 1,\n *         \"ProductName\": \"Chai\",\n *         \"UnitPrice\": 18.0000,\n *         \"Discontinued\": false\n *       }, {\n *         \"ProductID\": 2,\n *         \"ProductName\": \"Chang\",\n *         \"UnitPrice\": 19.0000,\n *         \"Discontinued\": true\n *       }\n *     ];\n *\n *     public onClick(): void {\n *         console.log(\"button was clicked\");\n *     }\n *\n *     public positionChange({ target }): void {\n *        this.position = target.value;\n *     }\n * }\n *\n * ```\n */\nclass ToolbarTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n        this._position = \"top\";\n    }\n    /**\n     * The position of the toolbar ([see example]({% slug toolbartemplate_grid %})).\n     *\n     * The possible values are:\n     * - `top`&mdash;Positions the toolbar above the group panel or header.\n     * - `bottom`&mdash;Positions the toolbar below the pager.\n     * - `both`&mdash;Displays two toolbar instances. Positions the first one above\n     * the group panel or header and the second one below the pager.\n     */\n    set position(position) {\n        this._position = position;\n    }\n    get position() {\n        return this._position;\n    }\n}\nToolbarTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridToolbarTemplate]'\n            },] },\n];\n/** @nocollapse */\nToolbarTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef, decorators: [{ type: Optional }] }\n];\nToolbarTemplateDirective.propDecorators = {\n    position: [{ type: Input, args: [\"position\",] }]\n};\n\n/**\n * @hidden\n */\nclass ScrollSyncService {\n    constructor(ngZone) {\n        this.ngZone = ngZone;\n        this.changes = new Subject();\n        this.elements = [];\n        this.subscriptions = new Subscription();\n        this.headerSubscription = new Subscription();\n        this.bodySubscription = new Subscription();\n        this.subscriptions.add(this.changes.subscribe(args => this.scrollLeft(args)));\n    }\n    registerEmitter(el, sourceType) {\n        this.unregister(sourceType);\n        this.elements.push({ element: el, sourceType });\n        if (sourceType === \"body\" || sourceType === \"header\") {\n            this.ngZone.runOutsideAngular(() => {\n                const obs = fromEvent(el, \"scroll\").pipe(map(({ target: { scrollLeft } }) => ({\n                    scrollLeft,\n                    sourceType\n                })));\n                const subscription = obs.pipe(distinctUntilChanged((x, y) => (x.scrollLeft === y.scrollLeft)), filter(x => !this.source || this.source === x.sourceType), tap(x => this.source = x.sourceType))\n                    .subscribe((x) => this.changes.next(x));\n                subscription.add(obs.pipe(filter(x => this.source && this.source !== x.sourceType))\n                    .subscribe(() => this.source = undefined));\n                if (sourceType === \"body\") {\n                    this.bodySubscription.add(subscription);\n                }\n                else {\n                    this.headerSubscription.add(subscription);\n                }\n            });\n        }\n    }\n    /**\n     * destroy\n     */\n    destroy() {\n        this.subscriptions.unsubscribe();\n        this.headerSubscription.unsubscribe();\n        this.bodySubscription.unsubscribe();\n    }\n    scrollLeft({ scrollLeft, sourceType }) {\n        this.ngZone.runOutsideAngular(() => {\n            this.elements\n                .filter(x => sourceType !== x.sourceType)\n                .forEach(({ element }) => element.scrollLeft = scrollLeft);\n        });\n    }\n    unregister(sourceType) {\n        const index = this.elements.findIndex(x => x.sourceType === sourceType);\n        if (index > -1) {\n            if (sourceType === \"header\") {\n                this.headerSubscription.unsubscribe();\n                this.headerSubscription = new Subscription();\n            }\n            else if (sourceType === \"body\") {\n                this.bodySubscription.unsubscribe();\n                this.bodySubscription = new Subscription();\n            }\n            this.elements.splice(index, 1);\n        }\n    }\n}\nScrollSyncService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nScrollSyncService.ctorParameters = () => [\n    { type: NgZone }\n];\n\n/**\n * @hidden\n */\nclass ResizeService {\n    constructor() {\n        this.resizeSubscription = new Subscription(() => { });\n        this.dispatcher = new Subject();\n        // tslint:disable-next-line:member-ordering\n        this.changes = this.dispatcher.asObservable().pipe(throttleTime(100));\n    }\n    connect(resizes) {\n        this.resizeSubscription.add(resizes.subscribe(this.dispatcher));\n    }\n    destroy() {\n        if (this.resizeSubscription) {\n            this.resizeSubscription.unsubscribe();\n        }\n    }\n}\nResizeService.decorators = [\n    { type: Injectable },\n];\n\nconst focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;\nconst NODE_NAME_PREDICATES = {};\nconst toClassList = (classNames) => String(classNames).trim().split(' ');\n/**\n * @hidden\n */\nconst hasClasses = (element, classNames) => {\n    const namesList = toClassList(classNames);\n    return Boolean(toClassList(element.className).find((className) => namesList.indexOf(className) >= 0));\n};\n/**\n * @hidden\n */\nconst matchesClasses = (classNames) => (element) => hasClasses(element, classNames);\n/**\n * @hidden\n */\nconst matchesNodeName = (nodeName) => {\n    if (!NODE_NAME_PREDICATES[nodeName]) {\n        NODE_NAME_PREDICATES[nodeName] = (element) => String(element.nodeName).toLowerCase() === nodeName.toLowerCase();\n    }\n    return NODE_NAME_PREDICATES[nodeName];\n};\n/**\n * @hidden\n */\nconst closest = (node, predicate) => {\n    while (node && !predicate(node)) {\n        node = node.parentNode;\n    }\n    return node;\n};\n/**\n * @hidden\n */\nconst closestInScope = (node, predicate, scope) => {\n    while (node && node !== scope && !predicate(node)) {\n        node = node.parentNode;\n    }\n    if (node !== scope) {\n        return node;\n    }\n};\n/**\n * @hidden\n */\nconst contains = (parent, node, matchSelf = false) => {\n    const outside = !closest(node, (child) => child === parent);\n    if (outside) {\n        return false;\n    }\n    const el = closest(node, (child) => child === node);\n    return el && (matchSelf || el !== parent);\n};\n/**\n * @hidden\n */\nconst isVisible = (element) => {\n    const rect = element.getBoundingClientRect();\n    const hasSize = rect.width > 0 && rect.height > 0;\n    const hasPosition = rect.x !== 0 && rect.y !== 0;\n    // Elements can have zero size due to styling, but they will still count as visible.\n    // For example, the selection checkbox has no size, but is made visible through styling.\n    return (hasSize || hasPosition) && window.getComputedStyle(element).visibility !== 'hidden';\n};\n/**\n * @hidden\n */\nconst isFocusable = (element) => {\n    if (!element.tagName) {\n        return false;\n    }\n    const tagName = element.tagName.toLowerCase();\n    const hasTabIndex = Boolean(element.getAttribute('tabIndex'));\n    const focusable = !element.disabled && focusableRegex.test(tagName);\n    return focusable || hasTabIndex;\n};\n/**\n * @hidden\n */\nconst isFocusableWithTabKey = (element, checkVisibility = true) => {\n    if (!isFocusable(element)) {\n        return false;\n    }\n    const tabIndex = element.getAttribute('tabIndex');\n    const visible = !checkVisibility || isVisible(element);\n    return visible && tabIndex !== '-1';\n};\n/**\n * @hidden\n */\nconst findElement = (node, predicate, matchSelf = true) => {\n    if (!node) {\n        return;\n    }\n    if (matchSelf && predicate(node)) {\n        return node;\n    }\n    node = node.firstChild;\n    while (node) {\n        if (node.nodeType === 1) {\n            const element = findElement(node, predicate);\n            if (element) {\n                return element;\n            }\n        }\n        node = node.nextSibling;\n    }\n};\n/**\n * @hidden\n */\nconst findFocusable = (element, checkVisibility = true) => {\n    return findElement(element, (node) => isFocusableWithTabKey(node, checkVisibility));\n};\n/**\n * @hidden\n */\nconst findFocusableChild = (element, checkVisibility = true) => {\n    return findElement(element, (node) => isFocusableWithTabKey(node, checkVisibility), false);\n};\n/**\n * @hidden\n */\nfunction rtlScrollPosition(position, element, initial) {\n    let result = position;\n    if (initial < 0) {\n        result = -position;\n    }\n    else if (initial > 0) {\n        result = element.scrollWidth - element.offsetWidth - position;\n    }\n    return result;\n}\n\n/**\n * @hidden\n */\nconst isLocked = column => column.parent ? isLocked(column.parent) : !!column.locked;\n/**\n * @hidden\n */\nconst resizeArgs = (column, extra) => Object.assign({\n    columns: leafColumns([column]),\n    locked: isLocked(column)\n}, extra); // tslint:disable-line:align\n/**\n * @hidden\n */\nclass ColumnResizingService {\n    constructor() {\n        this.changes = new EventEmitter();\n        this.tables = [];\n        this.batch = null;\n    }\n    start(column) {\n        this.trackColumns(column);\n        const columns = (this.column.isColumnGroup ? [column] : [])\n            .concat(leafColumns([column]));\n        this.changes.emit({\n            columns: columns,\n            locked: isLocked(this.column),\n            type: 'start'\n        });\n    }\n    resizeColumns(deltaPercent) {\n        const action = resizeArgs(this.column, {\n            deltaPercent,\n            type: 'resizeColumn'\n        });\n        this.changes.emit(action);\n    }\n    resizeTable(column, delta) {\n        const action = resizeArgs(column, {\n            delta,\n            type: 'resizeTable'\n        });\n        this.changes.emit(action);\n    }\n    resizedColumn(state$$1) {\n        this.resizedColumns.push(state$$1);\n    }\n    end() {\n        this.changes.emit({\n            columns: [],\n            resizedColumns: this.resizedColumns,\n            type: 'end'\n        });\n    }\n    registerTable(tableMetadata) {\n        this.tables.push(tableMetadata);\n        const unregisterTable = () => {\n            this.tables.splice(this.tables.indexOf(tableMetadata), 1);\n        };\n        return unregisterTable;\n    }\n    measureColumns(info) {\n        if (this.batch !== null) {\n            this.batch.push(...info);\n        }\n        else {\n            this.autoFitBatch(info, () => this.end());\n        }\n    }\n    autoFit(...columns) {\n        const nonLockedColumns = columns.filter(column => !column.isLocked);\n        this.autoFitStart(nonLockedColumns);\n        this.autoFitBatch(this.batch, () => {\n            if (nonLockedColumns.length < columns.length) {\n                const lockedColumns = columns.filter(column => column.isLocked);\n                this.autoFitStart(lockedColumns);\n                this.autoFitBatch(this.batch, () => this.end());\n            }\n            else {\n                this.end();\n            }\n        });\n    }\n    trackColumns(column) {\n        this.resizedColumns = [];\n        this.column = column;\n    }\n    autoFitStart(columns) {\n        this.batch = [];\n        this.resizedColumns = [];\n        if (columns.length === 0) {\n            return;\n        }\n        const locked = columns[0].isLocked;\n        this.changes.emit({\n            type: 'start',\n            columns,\n            locked\n        });\n        this.changes.emit({\n            type: 'triggerAutoFit',\n            columns,\n            locked\n        });\n    }\n    autoFitBatch(info, onComplete) {\n        const locked = info.length > 0 ? info[0].column.isLocked : false;\n        const observables = this.tables\n            .filter(table => table.locked === locked)\n            .map(table => table.autoFit(info));\n        zip(...observables)\n            .pipe(take(1))\n            .subscribe(widths => {\n            this.changes.emit({\n                columns: info.map(i => i.column),\n                type: 'autoFitComplete',\n                widths,\n                locked\n            });\n            if (onComplete) {\n                onComplete();\n            }\n        });\n        this.batch = null;\n    }\n}\nColumnResizingService.decorators = [\n    { type: Injectable },\n];\n\n/**\n * @hidden\n */\n/**\n * @hidden\n */\nconst hasFilterMenu = (settings) => typeof settings === 'string' && settings.indexOf('menu') > -1;\n/**\n * @hidden\n */\nconst hasFilterRow = (settings) => settings === true || (typeof settings === 'string' && settings.indexOf('row') > -1);\n\nconst contains$1 = (node, predicate) => {\n    while (node) {\n        if (predicate(node)) {\n            return true;\n        }\n        node = node.parentNode;\n    }\n    return false;\n};\n/**\n * Arguments for the `close` event of the filter and column-menu popup.\n */\nclass PopupCloseEvent extends PreventableEvent {\n    constructor(e) {\n        super();\n        this.originalEvent = e;\n    }\n}\nconst DEFAULT_POPUP_CLASS = 'k-grid-filter-popup';\n/**\n * The service that is used for the popups of the filter and column menus\n * ([see example]({% slug reusablecustomfilters_grid %}#toc-filter-menu-with-popup)).\n */\nclass SinglePopupService {\n    constructor(popupService, renderer, ngZone, scrollSyncService, localization) {\n        this.popupService = popupService;\n        this.renderer = renderer;\n        this.ngZone = ngZone;\n        this.localization = localization;\n        /**\n         * Fires when the filter or column menus are about to close because the user clicked outside their popups.\n         * Used to prevent the popup from closing.\n         */\n        this.onClose = new Subject();\n        this.scrollSubscription = scrollSyncService.changes.subscribe(() => this.destroy());\n    }\n    /**\n     * @hidden\n     */\n    open(anchor, template, popupRef, popupClass = DEFAULT_POPUP_CLASS) {\n        const toggle = isPresent(popupRef) && this.popupRef === popupRef;\n        this.destroy();\n        if (!toggle) {\n            const direction = this.localization.rtl ? 'right' : 'left';\n            this.popupRef = this.popupService.open({\n                anchorAlign: { vertical: 'bottom', horizontal: direction },\n                popupAlign: { vertical: 'top', horizontal: direction },\n                anchor: anchor,\n                popupClass: popupClass,\n                content: template,\n                positionMode: \"absolute\"\n            });\n            this.renderer.setAttribute(this.popupRef.popupElement, 'dir', this.localization.rtl ? 'rtl' : 'ltr');\n            this.attachClose(anchor);\n        }\n        return this.popupRef;\n    }\n    /**\n     * @hidden\n     */\n    destroy() {\n        if (this.popupRef) {\n            this.detachClose();\n            this.popupRef.close();\n            this.popupRef = null;\n        }\n    }\n    ngOnDestroy() {\n        this.destroy();\n        this.scrollSubscription.unsubscribe();\n    }\n    detachClose() {\n        if (this.removeClick) {\n            this.removeClick();\n        }\n    }\n    attachClose(skipElement) {\n        this.detachClose();\n        this.ngZone.runOutsideAngular(() => this.removeClick = this.renderer.listen(\"document\", \"click\", (e) => {\n            if (!contains$1(e.target, x => this.popupRef.popupElement === x || x === skipElement)) {\n                const args = new PopupCloseEvent(e);\n                this.onClose.next(args);\n                if (!args.isDefaultPrevented()) {\n                    this.destroy();\n                }\n            }\n        }));\n    }\n}\nSinglePopupService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nSinglePopupService.ctorParameters = () => [\n    { type: PopupService },\n    { type: Renderer2 },\n    { type: NgZone },\n    { type: ScrollSyncService },\n    { type: LocalizationService }\n];\n\n/* tslint:disable: no-bitwise */\n/**\n * @hidden\n */\nconst append = (element) => {\n    let appended = false;\n    return () => {\n        if (!appended) {\n            document.body.appendChild(element);\n            appended = true;\n        }\n        return element;\n    };\n};\n/**\n * @hidden\n */\nconst getDocument = element => element.ownerDocument.documentElement;\n/**\n * @hidden\n */\nconst getWindow = element => element.ownerDocument.defaultView;\n/**\n * @hidden\n */\nconst offset = element => {\n    const { clientTop, clientLeft } = getDocument(element);\n    const { pageYOffset, pageXOffset } = getWindow(element);\n    const { top, left } = element.getBoundingClientRect();\n    return {\n        top: top + pageYOffset - clientTop,\n        left: left + pageXOffset - clientLeft\n    };\n};\n/**\n * @hidden\n * If the target is before the draggable element, returns `true`.\n *\n * DOCUMENT_POSITION_FOLLOWING = 4\n */\nconst isTargetBefore = (draggable, target) => (target.compareDocumentPosition(draggable) & 4) !== 0;\n/**\n * @hidden\n * If the container and the element are the same\n * or if the container holds (contains) the element, returns `true`.\n *\n * DOCUMENT_POSITION_CONTAINED_BY = 16\n */\nconst contains$2 = (element, container) => element === container ||\n    (container.compareDocumentPosition(element) & 16) !== 0;\n/**\n * @hidden\n */\nconst position = (target, before) => {\n    const targetRect = offset(target);\n    const { offsetWidth, offsetHeight } = target;\n    const left = targetRect.left + (before ? 0 : offsetWidth);\n    const top = targetRect.top;\n    const height = offsetHeight;\n    return { left, top, height };\n};\n\n/**\n * @hidden\n */\nclass DragAndDropService {\n    constructor() {\n        this.changes = new EventEmitter();\n        this.register = [];\n        this.lastTarget = null;\n    }\n    add(target) {\n        this.register.push(target);\n    }\n    remove(target) {\n        this.register = this.register.filter(current => current !== target);\n    }\n    notifyDrag(draggable, element, mouseEvent) {\n        const target = this.targetFor(element);\n        if (this.lastTarget === target) {\n            return;\n        }\n        this.changes.next({\n            draggable,\n            mouseEvent,\n            target: this.lastTarget,\n            type: 'leave'\n        });\n        if (target) {\n            this.changes.next({\n                draggable,\n                mouseEvent,\n                target,\n                type: 'enter'\n            });\n        }\n        this.lastTarget = target;\n    }\n    notifyDrop(draggable, mouseEvent) {\n        this.changes.next({\n            draggable,\n            mouseEvent,\n            target: this.lastTarget,\n            type: 'drop'\n        });\n        this.lastTarget = null;\n    }\n    targetFor(element) {\n        const comparer = contains$2.bind(null, element);\n        return this.register.find(({ element: { nativeElement } }) => comparer(nativeElement));\n    }\n}\nDragAndDropService.decorators = [\n    { type: Injectable },\n];\n\nconst updateClass = (element, valid) => {\n    const icon = element.querySelector('.k-icon');\n    icon.className = icon.className\n        .replace(/(plus|cancel)/, valid ? 'plus' : 'cancel');\n};\nconst updateLock = (element, locked = null) => {\n    const icon = element.querySelectorAll('.k-icon')[1];\n    const value = locked == null ? '' : (locked ? 'k-i-lock' : 'k-i-unlock');\n    icon.className = icon.className\n        .replace(/(k-i-unlock|k-i-lock)/, '') + ` ${value}`;\n};\nconst decorate = (element, target) => {\n    const targetStyles = getComputedStyle(target);\n    element.className = 'k-header k-drag-clue';\n    element.style.position = 'absolute';\n    element.style.zIndex = '20000';\n    element.style.paddingLeft = targetStyles.paddingLeft;\n    element.style.paddingTop = targetStyles.paddingTop;\n    element.style.paddingBottom = targetStyles.paddingBottom;\n    element.style.paddingRight = targetStyles.paddingRight;\n    element.style.width = targetStyles.width;\n    element.style.height = targetStyles.height;\n};\n/**\n * @hidden\n */\nclass DragHintService {\n    constructor(santizer) {\n        this.santizer = santizer;\n    }\n    create(down, target, title) {\n        this.initCoords(down);\n        this.dom = document.createElement(\"div\");\n        decorate(this.dom, target);\n        const safeTitle = this.santizer.sanitize(SecurityContext.HTML, title);\n        this.dom.innerHTML = `\n            <span class=\"k-icon k-drag-status k-i-cancel k-icon-with-modifier\">\n                <span class=\"k-icon k-icon-modifier\"></span>\n            </span>\n            ${safeTitle}\n        `;\n    }\n    attach() {\n        return append(this.dom);\n    }\n    remove() {\n        if (this.dom && this.dom.parentNode) {\n            (function (el) {\n                setTimeout(() => document.body.removeChild(el));\n            })(this.dom); // hack for IE + pointer events!\n            this.dom = null;\n        }\n    }\n    show() {\n        this.dom.style.display = \"\";\n    }\n    hide() {\n        this.dom.style.display = \"none\";\n    }\n    enable() {\n        updateClass(this.dom, true);\n    }\n    disable() {\n        updateClass(this.dom, false);\n    }\n    removeLock() {\n        updateLock(this.dom);\n    }\n    toggleLock(locked) {\n        updateLock(this.dom, locked);\n    }\n    move(move) {\n        this.dom.style.top = this.initialTop + move.pageY + 'px';\n        this.dom.style.left = this.initialLeft + move.pageX + 'px';\n    }\n    initCoords(down) {\n        const { top, left } = offset(down.originalEvent.target);\n        this.initialTop = top - down.pageY;\n        this.initialLeft = left - down.pageX;\n    }\n}\nDragHintService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nDragHintService.ctorParameters = () => [\n    { type: DomSanitizer }\n];\n\n/**\n * @hidden\n */\nclass DropCueService {\n    create() {\n        this.dom = document.createElement(\"div\");\n        this.dom.className = 'k-grouping-dropclue';\n        this.hide();\n    }\n    attach() {\n        return append(this.dom);\n    }\n    remove() {\n        if (this.dom && this.dom.parentElement) {\n            document.body.removeChild(this.dom);\n            this.dom = null;\n        }\n    }\n    hide() {\n        this.dom.style.display = \"none\";\n    }\n    position({ left, top, height }) {\n        this.dom.style.display = 'block';\n        this.dom.style.height = height + 'px';\n        this.dom.style.top = top + 'px';\n        const width = this.dom.offsetWidth / 2;\n        this.dom.style.left = left - width + 'px';\n    }\n}\nDropCueService.decorators = [\n    { type: Injectable },\n];\n\n/**\n * @hidden\n */\nclass ColumnReorderService {\n    constructor() {\n        this.changes = new EventEmitter();\n    }\n    reorder(e) {\n        this.changes.emit(e);\n    }\n}\nColumnReorderService.decorators = [\n    { type: Injectable },\n];\n\n/**\n * Arguments for the `columnReorder` event.\n */\nclass ColumnReorderEvent extends PreventableEvent {\n    /**\n     * @hidden\n     */\n    constructor({ column, newIndex, oldIndex }) {\n        super();\n        this.column = column;\n        this.newIndex = newIndex;\n        this.oldIndex = oldIndex;\n    }\n}\n\n/**\n * @hidden\n */\nclass FocusRoot {\n    constructor() {\n        this.groups = new Set();\n    }\n    registerGroup(group) {\n        if (this.alive) {\n            this.groups.add(group);\n        }\n    }\n    unregisterGroup(group) {\n        if (this.alive) {\n            this.groups.delete(group);\n        }\n    }\n    activate() {\n        if (this.alive) {\n            this.groups.forEach(f => f.activate());\n        }\n    }\n    deactivate() {\n        if (this.alive) {\n            this.groups.forEach(f => f.deactivate());\n        }\n    }\n}\nFocusRoot.decorators = [\n    { type: Injectable },\n];\n\nconst isButton = matchesNodeName('button');\nconst isInputTag = matchesNodeName('input');\nconst navigableRegex = /(button|checkbox|color|file|radio|reset|submit)/i;\nconst isNavigableInput = element => isInputTag(element) && navigableRegex.test(element.type);\nconst isNavigable = element => !element.disabled && (isButton(element) || isNavigableInput(element));\n/**\n * @hidden\n */\nclass DefaultFocusableElement {\n    constructor(host, renderer) {\n        this.renderer = renderer;\n        this.element = host.nativeElement;\n        this.focusable = findFocusable(this.element, false) || this.element;\n    }\n    get enabled() {\n        return this.focusable && !this.focusable.disabled;\n    }\n    get visible() {\n        return this.focusable && isVisible(this.focusable);\n    }\n    isNavigable() {\n        return this.canFocus() && isNavigable(this.element);\n    }\n    toggle(active) {\n        this.renderer.setAttribute(this.focusable, 'tabIndex', active ? '0' : '-1');\n    }\n    focus() {\n        if (this.focusable) {\n            this.focusable.focus();\n        }\n    }\n    canFocus() {\n        return this.visible && this.enabled;\n    }\n    hasFocus() {\n        return document.activeElement !== this.element && closest(document.activeElement, e => e === this.element);\n    }\n}\n\n/**\n * A directive that controls the way focusable elements receive\n * [focus in a navigable Grid]({% slug keyboard_navigation_grid %}).\n *\n * @example\n * ```ts-preview\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *      <input type=\"text\" placeholder=\"Tab stop #0\" />\n *      <kendo-grid [data]=\"data\" [navigable]=\"true\">\n *          <kendo-grid-column field=\"ProductID\" title=\"Product ID\" width=\"40\">\n *          </kendo-grid-column>\n *          <kendo-grid-column field=\"ProductName\" title=\"Product Name\" width=\"100\">\n *          </kendo-grid-column>\n *          <kendo-grid-column>\n *              <ng-template kendoGridCellTemplate let-dataItem>\n *                  <!-- The first focusable element will be focused when pressing Enter on the cell -->\n *                  <input type=\"text\" kendoGridFocusable [value]=\"dataItem.ProductName\" />\n *                  <input type=\"button\" kendoGridFocusable value=\"Update\" />\n *              </ng-template>\n *          </kendo-grid-column>\n *          <kendo-grid-column width=\"80\">\n *              <ng-template kendoGridCellTemplate>\n *                  <!-- A single focusable element will be focused during navigation -->\n *                  <input type=\"button\" kendoGridFocusable value=\"Delete\" />\n *              </ng-template>\n *          </kendo-grid-column>\n *      </kendo-grid>\n *      <input type=\"text\" placeholder=\"Tab stop #2\" />\n *    `\n * })\n *\n * class AppComponent {\n *     public readonly data: any = [{\n *         \"ProductID\": 1,\n *         \"ProductName\": \"Chai\",\n *         \"UnitPrice\": 18.0000,\n *         \"Discontinued\": true\n *     }, {\n *         \"ProductID\": 2,\n *         \"ProductName\": \"Chang\",\n *         \"UnitPrice\": 19.0000,\n *         \"Discontinued\": false\n *     }];\n * }\n * ```\n */\nclass FocusableDirective {\n    constructor(cellContext, hostElement, renderer) {\n        this.cellContext = cellContext;\n        this.hostElement = hostElement;\n        this.renderer = renderer;\n        this.active = true;\n        if (this.cellContext) {\n            this.group = this.cellContext.focusGroup;\n        }\n        if (this.group) {\n            this.group.registerElement(this);\n        }\n    }\n    ngAfterViewInit() {\n        if (!this.element) {\n            this.element = new DefaultFocusableElement(this.hostElement, this.renderer);\n        }\n        if (this.group) {\n            const isActive = this.group.isActive;\n            this.toggle(isActive);\n        }\n    }\n    ngOnDestroy() {\n        if (this.group) {\n            this.group.unregisterElement(this);\n        }\n    }\n    /**\n     * @hidden\n     */\n    toggle(active) {\n        if (this.element && active !== this.active) {\n            this.active = active;\n            this.element.toggle(active);\n        }\n    }\n    /**\n     * @hidden\n     */\n    canFocus() {\n        return this.element && this.element.canFocus();\n    }\n    /**\n     * @hidden\n     */\n    isNavigable() {\n        return this.element && this.element.isNavigable();\n    }\n    /**\n     * @hidden\n     */\n    focus() {\n        if (this.element) {\n            this.element.focus();\n        }\n    }\n    /**\n     * @hidden\n     */\n    hasFocus() {\n        return this.element && this.element.hasFocus();\n    }\n    /**\n     * @hidden\n     */\n    registerElement(element) {\n        this.element = element;\n    }\n}\nFocusableDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridFocusable]' + `,\n        [kendoGridEditCommand],\n        [kendoGridRemoveCommand],\n        [kendoGridSaveCommand],\n        [kendoGridCancelCommand],\n        [kendoGridSelectionCheckbox]\n    `\n            },] },\n];\n/** @nocollapse */\nFocusableDirective.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CELL_CONTEXT,] }, { type: SkipSelf }] },\n    { type: ElementRef },\n    { type: Renderer2 }\n];\n\n/**\n * @hidden\n */\nclass GridFocusableElement {\n    constructor(navigationService) {\n        this.navigationService = navigationService;\n    }\n    focus() {\n        this.navigationService.focusCell();\n    }\n    toggle(active) {\n        this.navigationService.toggle(active);\n    }\n    canFocus() {\n        return true;\n    }\n    hasFocus() {\n        return this.navigationService.hasFocus();\n    }\n    isNavigable() {\n        return false;\n    }\n}\n\n/**\n * @hidden\n */\nclass NavigationCursor {\n    constructor(model) {\n        this.model = model;\n        this.changes = new Subject();\n        this.activeRow = 0;\n        this.activeCol = 0;\n        this.virtualCol = 0;\n        this.virtualRow = 0;\n    }\n    get row() {\n        return this.model.findRow(this.activeRow);\n    }\n    get cell() {\n        const row = this.row;\n        if (row) {\n            return this.model.findCell(this.activeCol, row);\n        }\n    }\n    get dataRowIndex() {\n        const row = this.row;\n        if (row) {\n            return row.dataRowIndex;\n        }\n        return -1;\n    }\n    /**\n     * Assumes and announces a new cursor position.\n     */\n    reset(rowIndex = this.activeRow, colIndex = this.activeCol, force = true) {\n        if (this.activate(rowIndex, colIndex, force)) {\n            this.virtualRow = rowIndex;\n            this.virtualCol = colIndex;\n        }\n    }\n    activate(rowIndex, colIndex, force) {\n        if (!force && this.isActiveRange(rowIndex, colIndex)) {\n            return false;\n        }\n        const prevColIndex = this.activeCol;\n        const prevRowIndex = this.activeRow;\n        this.activeCol = colIndex;\n        this.activeRow = rowIndex;\n        this.changes.next({\n            colIndex,\n            prevColIndex,\n            prevRowIndex,\n            rowIndex\n        });\n        return true;\n    }\n    isActiveRange(rowIndex, colIndex) {\n        if (this.activeRow !== rowIndex) {\n            return false;\n        }\n        const cell = this.cell;\n        const { start, end } = this.model.cellRange(cell);\n        return !Boolean(cell) || (start <= colIndex && colIndex <= end);\n    }\n    /**\n     * Assumes a new cursor position without announcing it.\n     */\n    assume(rowIndex = this.activeRow, colIndex = this.activeCol) {\n        this.virtualRow = rowIndex;\n        this.virtualCol = colIndex;\n        this.activeCol = colIndex;\n        this.activeRow = rowIndex;\n    }\n    /**\n     * Announces a current cursor position to subscribers.\n     */\n    announce() {\n        this.changes.next({\n            colIndex: this.activeCol,\n            prevColIndex: this.activeCol,\n            prevRowIndex: this.activeRow,\n            rowIndex: this.activeRow\n        });\n    }\n    activateVirtualCell(cell) {\n        const rowRange = this.model.rowRange(cell);\n        const cellRange = this.model.cellRange(cell);\n        const activeCol = this.activeCol;\n        const activeRow = this.activeRow;\n        if (rowRange.start <= activeRow && activeRow <= rowRange.end &&\n            cellRange.start <= activeCol && activeCol <= cellRange.end) {\n            this.activeRow = cell.rowIndex;\n            this.activeCol = cell.colIndex;\n            return true;\n        }\n    }\n    isActive(rowIndex, colIndex) {\n        return this.activeCol === colIndex && this.activeRow === rowIndex;\n    }\n    moveUp(offset = 1) {\n        return this.offsetRow(-offset);\n    }\n    moveDown(offset = 1) {\n        return this.offsetRow(offset);\n    }\n    moveLeft(offset = 1) {\n        return this.offsetCol(-offset);\n    }\n    moveRight(offset = 1) {\n        return this.offsetCol(offset);\n    }\n    lastCellIndex(row) {\n        return this.metadata.columns.leafColumnsToRender.length - 1 +\n            (this.metadata.hasDetailTemplate && (!row || !row.groupItem) ? 1 : 0);\n    }\n    offsetCol(offset) {\n        const prevRow = this.model.findRow(this.virtualRow);\n        const lastIndex = this.lastCellIndex(prevRow);\n        const virtualCol = this.virtualCol;\n        this.virtualCol = Math.max(0, Math.min(virtualCol + offset, lastIndex));\n        let nextColIndex = this.virtualCol;\n        let nextRowIndex = this.virtualRow;\n        let cell = this.model.findCell(this.virtualCol, prevRow);\n        if (!cell && this.metadata.virtualColumns) {\n            return this.activate(nextRowIndex, nextColIndex);\n        }\n        if (cell.colSpan > 1 && cell.colIndex <= virtualCol && virtualCol < cell.colIndex + cell.colSpan) {\n            nextColIndex = offset > 0 ? Math.min(cell.colIndex + cell.colSpan, lastIndex) : Math.max(0, cell.colIndex + offset);\n            const nextCell = this.model.findCell(nextColIndex, prevRow);\n            if (cell !== nextCell) {\n                cell = nextCell;\n                this.virtualCol = cell.colIndex;\n            }\n            else {\n                this.virtualCol = virtualCol;\n            }\n        }\n        return this.activate(cell.rowIndex, cell.colIndex);\n    }\n    offsetRow(offset) {\n        let nextColIndex = this.virtualCol;\n        if (this.metadata && this.metadata.isVirtual) {\n            const maxIndex = this.metadata.maxLogicalRowIndex;\n            let nextIndex = Math.max(0, Math.min(this.activeRow + offset, maxIndex));\n            if (this.metadata.hasDetailTemplate && !this.model.findRow(nextIndex)) {\n                nextIndex = offset > 0 ? nextIndex + 1 : nextIndex - 1;\n                nextIndex = Math.max(0, Math.min(nextIndex, maxIndex));\n            }\n            if (this.metadata.hasDetailTemplate && nextIndex === maxIndex) {\n                if (this.model.lastRow.index !== maxIndex) {\n                    // Don't attempt to navigate past the last collapsed row.\n                    nextIndex--;\n                }\n            }\n            const nextRow = this.model.findRow(nextIndex);\n            if (nextRow) {\n                // remove duplication\n                let cell = this.model.findCell(this.virtualCol, nextRow);\n                if (cell.rowIndex <= this.virtualRow && offset > 0 && cell.rowSpan > 1) {\n                    cell = this.model.findCell(this.virtualCol, this.model.findRow(cell.rowIndex + cell.rowSpan - 1 + offset));\n                }\n                nextIndex = cell.rowIndex;\n                nextColIndex = cell.colIndex;\n            }\n            this.virtualRow = nextIndex;\n            return this.activate(nextIndex, nextColIndex);\n        }\n        const nextRow = this.model.findRow(this.virtualRow + offset) || this.model.nextRow(this.virtualRow, offset);\n        if (!nextRow) {\n            return false;\n        }\n        let cell = this.model.findCell(this.virtualCol, nextRow);\n        if (cell && cell.rowIndex <= this.virtualRow && offset > 0 && cell.rowSpan > 1) { // spanned cell go to next\n            const nextPos = cell.rowIndex + cell.rowSpan - 1 + offset;\n            cell = this.model.findCell(this.virtualCol, this.model.findRow(nextPos));\n        }\n        if (!cell && this.metadata.virtualColumns) {\n            return this.activate(this.virtualRow + offset, this.virtualCol);\n        }\n        this.virtualRow = cell.rowIndex;\n        return this.activate(this.virtualRow, cell.colIndex);\n    }\n}\n\n/**\n * @hidden\n */\nclass ItemMap {\n    constructor() {\n        this.count = 0;\n        this.items = {};\n    }\n    get first() {\n        if (this.count > 0) {\n            let result;\n            this.forEach(item => {\n                result = item;\n                return true;\n            });\n            return result;\n        }\n    }\n    get last() {\n        if (this.count > 0) {\n            const keys = Object.keys(this.items);\n            return this.items[keys[keys.length - 1]];\n        }\n    }\n    removeItem(key) {\n        if (this.items[key]) {\n            delete this.items[key];\n            this.count--;\n        }\n    }\n    setItem(key, item) {\n        if (!this.items[key]) {\n            this.count++;\n        }\n        this.items[key] = item;\n    }\n    getItem(key) {\n        return this.items[key];\n    }\n    toArray() {\n        const result = [];\n        this.forEach(item => {\n            result.push(item);\n        });\n        return result;\n    }\n    forEach(callback) {\n        for (let key in this.items) {\n            if (this.items.hasOwnProperty(key) && callback(this.items[key])) {\n                return this.items[key];\n            }\n        }\n    }\n    find(callback) {\n        return this.forEach(callback);\n    }\n}\n\n/**\n * @hidden\n *\n * Contains information for the currently rendered rows and cells.\n */\nclass NavigationModel {\n    constructor() {\n        this.rows = new ItemMap();\n    }\n    get firstRow() {\n        return this.rows.first;\n    }\n    get lastRow() {\n        return this.rows.last;\n    }\n    registerCell(cell) {\n        const row = this.rows.getItem(cell.logicalRowIndex);\n        if (!row) {\n            return;\n        }\n        const colIndex = cell.logicalColIndex;\n        const modelCell = {\n            uid: cell.uid,\n            colIndex,\n            rowIndex: row.index,\n            colSpan: cell.colSpan,\n            rowSpan: cell.rowSpan,\n            detailExpandCell: cell.detailExpandCell,\n            dataItem: row.dataItem,\n            dataRowIndex: row.dataRowIndex,\n            focusGroup: cell.focusGroup\n        };\n        row.cells.setItem(colIndex, modelCell);\n        if (cell.groupItem) {\n            row.groupItem = cell.groupItem;\n        }\n        return modelCell;\n    }\n    unregisterCell(index, rowIndex, cell) {\n        const row = this.rows.getItem(rowIndex);\n        if (row) {\n            const match = row.cells.getItem(index);\n            if (match && match.uid === cell.uid) {\n                row.cells.removeItem(index);\n            }\n        }\n    }\n    registerRow(row) {\n        const modelRow = {\n            uid: row.uid,\n            index: row.logicalRowIndex,\n            dataItem: row.dataItem,\n            dataRowIndex: row.dataRowIndex,\n            cells: new ItemMap()\n        };\n        this.rows.setItem(row.logicalRowIndex, modelRow);\n    }\n    updateRow(row) {\n        const current = this.rows.getItem(row.logicalRowIndex);\n        if (current) {\n            Object.assign(current, {\n                dataItem: row.dataItem,\n                dataRowIndex: row.dataRowIndex\n            });\n        }\n    }\n    unregisterRow(index, row) {\n        const match = this.rows.getItem(index);\n        if (match && match.uid === row.uid) {\n            this.rows.removeItem(index);\n        }\n    }\n    cellRange(cell) {\n        if (cell) {\n            const start = cell.colIndex;\n            const end = cell.colIndex + (cell.colSpan || 1) - 1;\n            return {\n                start,\n                end\n            };\n        }\n        return {};\n    }\n    rowRange(cell) {\n        if (cell) {\n            const start = cell.rowIndex;\n            const end = cell.rowIndex + (cell.rowSpan || 1) - 1;\n            return {\n                start,\n                end\n            };\n        }\n        return {};\n    }\n    nextRow(rowIndex, offset) {\n        const rows = this.rows.toArray();\n        const row = this.rows.getItem(rowIndex);\n        const position = rows.indexOf(row);\n        const next = rows[position + offset];\n        return next;\n    }\n    findRow(index) {\n        return this.rows.getItem(index);\n    }\n    findCell(index, row) {\n        if (!row) {\n            return;\n        }\n        const rowIndex = row.index;\n        let cell = row.cells.getItem(index);\n        let currentIndex = rowIndex;\n        while (!cell && row) {\n            row = this.rows.getItem(currentIndex);\n            cell = this.rowCell(index, row);\n            currentIndex--;\n        }\n        if (cell && rowIndex <= row.index + (cell.rowSpan || 1) - 1) {\n            return cell;\n        }\n    }\n    rowCell(index, row) {\n        if (!row || !row.cells.count) {\n            return;\n        }\n        const firstCell = row.cells.first;\n        let cell, currentIndex = index;\n        while (!cell && currentIndex >= firstCell.colIndex) {\n            cell = row.cells.getItem(currentIndex);\n            currentIndex--;\n        }\n        if (cell && index <= cell.colIndex + (cell.colSpan || 1) - 1) {\n            return cell;\n        }\n    }\n}\n\n/**\n * @hidden\n */\nclass ScrollRequestService {\n    constructor() {\n        this.requests = new Subject();\n    }\n    scrollTo(request) {\n        this.requests.next(request);\n    }\n}\nScrollRequestService.decorators = [\n    { type: Injectable },\n];\n\nconst isInSameGrid = (element, gridElement) => closest(element, matchesNodeName('kendo-grid')) === gridElement;\nconst matchHeaderCell = matchesNodeName('th');\nconst matchDataCell = matchesNodeName('td');\nconst matchCell = (element) => matchDataCell(element) || matchHeaderCell(element);\nconst gridCell = (element, gridElement) => {\n    let target = closest(element, matchCell);\n    while (target && !isInSameGrid(target, gridElement)) {\n        target = closest(target.parentElement, matchCell);\n    }\n    return target;\n};\nconst targetCell = (target, gridElement) => {\n    const cell = gridCell(target, gridElement);\n    const row = closest(cell, matchesNodeName('tr'));\n    if (cell && row) {\n        let rowIndex = row.getAttribute('aria-rowindex');\n        rowIndex = rowIndex ? parseInt(rowIndex, 10) - 1 : null;\n        let colIndex = cell.getAttribute('aria-colindex');\n        colIndex = colIndex ? parseInt(colIndex, 10) - 1 : null;\n        if (rowIndex !== null && colIndex !== null) {\n            return { colIndex, rowIndex, element: cell };\n        }\n    }\n};\nconst isArrowKey = keyCode => keyCode === Keys.ArrowLeft || keyCode === Keys.ArrowRight ||\n    keyCode === Keys.ArrowUp || keyCode === Keys.ArrowDown;\nconst isNavigationKey = keyCode => isArrowKey(keyCode) ||\n    keyCode === Keys.PageUp || keyCode === Keys.PageDown ||\n    keyCode === Keys.Home || keyCode === Keys.End;\nconst isInput = matchesNodeName('input');\nconst isTextInput = element => element && isInput(element) && element.type.toLowerCase() === 'text';\nconst isPrintableCharacter = (str) => str.length === 1 && str.match(/\\S/);\n/**\n * @hidden\n */\nclass NavigationViewport {\n    constructor(firstItemIndex, lastItemIndex) {\n        this.firstItemIndex = firstItemIndex;\n        this.lastItemIndex = lastItemIndex;\n    }\n    containsRow(dataRowIndex) {\n        const headerRow = dataRowIndex < 0;\n        return headerRow || (dataRowIndex >= this.firstItemIndex && dataRowIndex <= this.lastItemIndex);\n    }\n    intersects(start, end) {\n        return (start <= this.firstItemIndex && this.lastItemIndex <= end) ||\n            (this.firstItemIndex <= start && start <= this.lastItemIndex) ||\n            (this.firstItemIndex <= end && end <= this.lastItemIndex);\n    }\n}\n/**\n * @hidden\n */\nclass NavigationService {\n    constructor(zone, domEvents, pagerContextService, scrollRequestService, groupsService, detailsService, focusRoot, editService, cd, localization, focusableParent) {\n        this.zone = zone;\n        this.domEvents = domEvents;\n        this.pagerContextService = pagerContextService;\n        this.scrollRequestService = scrollRequestService;\n        this.groupsService = groupsService;\n        this.detailsService = detailsService;\n        this.focusRoot = focusRoot;\n        this.editService = editService;\n        this.cd = cd;\n        this.localization = localization;\n        this.focusableParent = focusableParent;\n        this.cellKeydown = new EventEmitter();\n        this.activeRowIndex = 0;\n        this.alive = false;\n        this.active = true;\n        this.mode = 0 /* Standby */;\n        this.model = new NavigationModel();\n        this.cursor = new NavigationCursor(this.model);\n        this.changes = this.cursor.changes;\n    }\n    set metadata(value) {\n        this.meta = value;\n        this.cursor.metadata = value;\n    }\n    get metadata() {\n        return this.meta;\n    }\n    get enabled() {\n        return this.alive;\n    }\n    get activeCell() {\n        if (this.mode !== 0 /* Standby */) {\n            return this.cursor.cell;\n        }\n    }\n    get activeRow() {\n        if (this.mode !== 0 /* Standby */) {\n            return Object.assign({}, this.cursor.row, {\n                cells: this.cursor.row.cells.toArray()\n            });\n        }\n    }\n    get activeDataRow() {\n        return Math.max(0, this.activeRowIndex - this.meta.headerRows);\n    }\n    init(meta) {\n        this.alive = true;\n        this.focusRoot.alive = true;\n        this.metadata = meta;\n        const onStableSubscriber = (...operators) => (args) => this.zone.isStable ?\n            from([true]).pipe(map(() => args)) :\n            this.zone.onStable.pipe(take(1), map(() => args), ...operators);\n        const onStable = onStableSubscriber();\n        this.subs = new Subscription();\n        this.subs.add(this.cursor.changes\n            .subscribe(args => this.onCursorChanges(args)));\n        this.subs.add(this.domEvents.focus.pipe(switchMap(onStable))\n            .subscribe((args) => this.navigateTo(args.target)));\n        this.subs.add(this.domEvents.focusOut.pipe(filter(() => this.mode !== 0 /* Standby */), switchMap(onStableSubscriber(takeUntil(this.domEvents.focus))))\n            .subscribe(args => this.onFocusOut(args)));\n        this.subs.add(this.domEvents.windowBlur.pipe(filter(() => this.mode !== 0 /* Standby */))\n            .subscribe(() => this.onWindowBlur()));\n        this.subs.add(\n        // Closing the editor will not always trigger focusout in Firefox.\n        // To get around this, we ensure that the cell is closed after editing.\n        this.editService.changes.pipe(filter(e => e.action !== 'edit' && this.mode === 2 /* Content */), filter((e) => e.action === 'cellClose' && !e.prevented), switchMap(onStable))\n            .subscribe(() => this.leaveCell()));\n        this.subs.add(this.pagerContextService.pageChange\n            .subscribe(() => this.cursor.reset(0, 0)));\n        this.subs.add(this.domEvents.keydown\n            .subscribe(args => this.onKeydown(args)));\n        this.subs.add(this.domEvents.keydown.pipe(filter(args => args.keyCode === Keys.Tab && this.mode === 2 /* Content */), switchMapTo(this.domEvents.focusOut.pipe(takeUntil(\n        // Timeout if focusOut doesn't fire very soon\n        interval(0).pipe(take(1))))))\n            .subscribe(() => this.onTabout()));\n        if (this.focusableParent) {\n            const element = new GridFocusableElement(this);\n            this.focusableParent.registerElement(element);\n        }\n        this.deactivateElements();\n    }\n    ngOnDestroy() {\n        if (this.subs) {\n            this.subs.unsubscribe();\n        }\n        this.alive = false;\n    }\n    registerCell(cell) {\n        if (cell.logicalRowIndex !== this.pendingRowIndex) {\n            const modelCell = this.model.registerCell(cell);\n            if (this.virtualCell && this.cursor.activateVirtualCell(modelCell)) {\n                this.virtualCell = false;\n            }\n        }\n    }\n    registerCellOnCurrentRow(cell) {\n        if (cell.logicalRowIndex === this.pendingRowIndex) {\n            this.model.registerCell(cell);\n        }\n    }\n    unregisterCell(index, rowIndex, cell) {\n        this.model.unregisterCell(index, rowIndex, cell);\n    }\n    registerRow(row) {\n        this.model.registerRow(row);\n        this.pendingRowIndex = row.logicalRowIndex;\n    }\n    updateRow(row) {\n        this.model.updateRow(row);\n    }\n    unregisterRow(index, row) {\n        this.model.unregisterRow(index, row);\n    }\n    isCellFocusable(cell) {\n        return this.alive &&\n            this.active &&\n            this.mode !== 2 /* Content */ &&\n            this.cursor.isActive(cell.logicalRowIndex, cell.logicalColIndex);\n    }\n    isCellFocused(cell) {\n        return this.mode === 1 /* Cursor */ && this.isCellFocusable(cell);\n    }\n    navigateTo(el) {\n        if (!this.alive) {\n            return;\n        }\n        const cell = targetCell(el, this.meta.gridElement.nativeElement);\n        if (!cell) {\n            return;\n        }\n        const oldMode = this.mode;\n        const focusInCell = contains(cell.element, document.activeElement);\n        const focusInActiveRowContent = this.mode === 2 /* Content */ &&\n            this.activeRowIndex === cell.rowIndex &&\n            el !== cell.element;\n        if (focusInCell) {\n            this.mode = 2 /* Content */;\n            this.cursor.reset(cell.rowIndex, cell.colIndex);\n            this.activateRow();\n        }\n        else if (!focusInActiveRowContent) {\n            this.mode = 1 /* Cursor */;\n            this.deactivateElements();\n            const alreadyActive = this.cursor.isActive(cell.rowIndex, cell.colIndex);\n            const isCursor = oldMode === 1 /* Cursor */ && alreadyActive;\n            if (!isCursor) {\n                this.cursor.reset(cell.rowIndex, cell.colIndex);\n            }\n        }\n    }\n    tryFocus(el) {\n        this.activateElements();\n        const focusable = findFocusableChild(el);\n        if (focusable) {\n            const cell = targetCell(focusable, this.meta.gridElement.nativeElement);\n            if (cell) {\n                this.cursor.reset(cell.rowIndex, cell.colIndex);\n                this.deactivateElements();\n                this.enterCell();\n            }\n            focusable.focus();\n        }\n        else {\n            this.deactivateElements();\n        }\n        return !!focusable;\n    }\n    needsViewport() {\n        return this.meta && this.meta.isVirtual;\n    }\n    setViewport(firstItemIndex, lastItemIndex) {\n        this.viewport = new NavigationViewport(firstItemIndex, lastItemIndex);\n        if (this.meta && this.meta.isVirtual && this.activeDataRow > -1) {\n            const dataRowIndex = this.activeDataRow;\n            const ahead = firstItemIndex - dataRowIndex;\n            const behind = dataRowIndex - lastItemIndex;\n            if (ahead > 0) {\n                this.cursor.reset(firstItemIndex + this.meta.headerRows);\n            }\n            else if (behind > 0) {\n                this.cursor.reset(lastItemIndex - this.meta.headerRows);\n            }\n        }\n    }\n    setColumnViewport(firstItemIndex, lastItemIndex) {\n        this.columnViewport = new NavigationViewport(firstItemIndex, lastItemIndex);\n    }\n    focusCell(rowIndex = undefined, colIndex = undefined) {\n        this.mode = 1 /* Cursor */;\n        this.cursor.reset(rowIndex, colIndex);\n        return this.activeCell;\n    }\n    focusNextCell(wrap = true) {\n        return this.focusAdjacentCell(true, wrap);\n    }\n    focusPrevCell(wrap = true) {\n        return this.focusAdjacentCell(false, wrap);\n    }\n    toggle(active) {\n        this.active = active;\n        this.cursor.announce();\n    }\n    hasFocus() {\n        return this.mode === 1 /* Cursor */ || this.mode === 2 /* Content */;\n    }\n    autoFocusCell(start, end) {\n        return !this.meta.virtualColumns || end < this.meta.columns.lockedLeafColumns.length || this.columnViewport.intersects(start, end);\n    }\n    focusAdjacentCell(fwd, wrap) {\n        this.focusCell();\n        let success = fwd ? this.moveCursorFwd() : this.moveCursorBwd();\n        if (wrap && !success) {\n            success = fwd ? this.cursor.moveDown(1) : this.cursor.moveUp(1);\n            if (success) {\n                const row = this.cursor.row;\n                const colIdx = fwd ? 0 : this.cursor.lastCellIndex(row);\n                this.cursor.reset(row.index, colIdx);\n            }\n        }\n        if (success) {\n            return this.activeCell;\n        }\n        else {\n            this.mode = 0 /* Standby */;\n            this.cursor.announce();\n        }\n        return null;\n    }\n    enterCell() {\n        const cell = this.cursor.cell;\n        if (!cell) {\n            return;\n        }\n        const group = cell.focusGroup;\n        const focusable = group && group.canFocus();\n        this.mode = focusable ? 2 /* Content */ : 1 /* Cursor */;\n        this.cursor.announce();\n        if (focusable) {\n            this.activateRow();\n            group.focus();\n        }\n    }\n    leaveCell() {\n        const cell = this.cursor.cell;\n        if (!cell) {\n            return;\n        }\n        const group = cell.focusGroup;\n        const focusable = group && group.canFocus();\n        if (!focusable) {\n            this.deactivateElements();\n        }\n        this.mode = 1 /* Cursor */;\n        this.cursor.announce();\n    }\n    activateElements() {\n        this.focusRoot.activate();\n    }\n    deactivateElements() {\n        this.focusRoot.deactivate();\n    }\n    activateRow() {\n        this.cursor.row.cells\n            .forEach(cell => cell.focusGroup && cell.focusGroup.activate());\n    }\n    moveCursorFwd() {\n        return this.localization.rtl ? this.cursor.moveLeft() : this.cursor.moveRight();\n    }\n    moveCursorBwd() {\n        return this.localization.rtl ? this.cursor.moveRight() : this.cursor.moveLeft();\n    }\n    onCursorKeydown(args) {\n        let preventDefault = false;\n        const modifier = args.ctrlKey || args.metaKey;\n        const step = modifier ? 5 : 1;\n        if (!this.onCellKeydown(args)) {\n            return;\n        }\n        const row = this.cursor.row;\n        switch (args.keyCode) {\n            case Keys.ArrowDown:\n                preventDefault = this.cursor.moveDown(step);\n                break;\n            case Keys.ArrowUp:\n                preventDefault = this.cursor.moveUp(step);\n                break;\n            case Keys.ArrowRight:\n                preventDefault = this.moveCursorFwd();\n                break;\n            case Keys.ArrowLeft:\n                preventDefault = this.moveCursorBwd();\n                break;\n            case Keys.PageDown:\n                if (this.metadata.isVirtual && this.viewport) {\n                    let nextItemIndex = this.meta.headerRows + this.viewport.lastItemIndex + 1;\n                    if (this.metadata.hasDetailTemplate) {\n                        nextItemIndex++;\n                    }\n                    nextItemIndex = Math.min(this.meta.maxLogicalRowIndex, nextItemIndex);\n                    this.cursor.reset(nextItemIndex);\n                    preventDefault = true;\n                }\n                else if (this.metadata.hasPager) {\n                    this.zone.run(() => this.pagerContextService.nextPage());\n                    preventDefault = true;\n                }\n                break;\n            case Keys.PageUp:\n                if (this.metadata.isVirtual && this.viewport) {\n                    let viewportSize = this.viewport.lastItemIndex - this.viewport.firstItemIndex;\n                    let firstItemIndex = this.viewport.firstItemIndex;\n                    let nextItemIndex = Math.max(this.meta.headerRows, firstItemIndex - viewportSize - 1);\n                    this.cursor.reset(nextItemIndex);\n                    preventDefault = true;\n                }\n                else if (this.metadata.hasPager) {\n                    this.zone.run(() => this.pagerContextService.prevPage());\n                    preventDefault = true;\n                }\n                break;\n            case Keys.Home:\n                if (modifier) {\n                    if (this.meta.isVirtual) {\n                        this.cursor.reset(this.meta.headerRows, 0, false);\n                    }\n                    else {\n                        this.cursor.reset(this.model.firstRow.index, 0, false);\n                    }\n                }\n                else {\n                    this.cursor.reset(row.index, 0, false);\n                }\n                preventDefault = true;\n                break;\n            case Keys.End:\n                if (modifier) {\n                    if (this.meta.isVirtual) {\n                        let lastRowIndex = this.meta.maxLogicalRowIndex;\n                        if (this.meta.hasDetailTemplate) {\n                            lastRowIndex--;\n                        }\n                        this.cursor.reset(lastRowIndex, this.cursor.lastCellIndex(), false);\n                    }\n                    else {\n                        this.cursor.reset(this.model.lastRow.index, this.cursor.lastCellIndex(this.model.lastRow), false);\n                    }\n                }\n                else {\n                    const lastIndex = this.cursor.lastCellIndex(row);\n                    const cell = this.model.findCell(lastIndex, row);\n                    if (cell) {\n                        this.cursor.reset(cell.rowIndex, cell.colIndex);\n                    }\n                    else {\n                        this.cursor.reset(row.index, lastIndex);\n                    }\n                }\n                preventDefault = true;\n                break;\n            case Keys.Enter:\n            case Keys.F2:\n                const groupItem = row.groupItem;\n                if (groupItem) {\n                    this.zone.run(() => this.groupsService.toggleRow(groupItem.index, groupItem.data));\n                }\n                else if (this.cursor.cell.detailExpandCell) {\n                    this.zone.run(() => this.detailsService.toggleRow(row.dataRowIndex, row.dataItem));\n                }\n                else {\n                    this.enterCell();\n                    if (!this.cursor.cell.focusGroup.isNavigable()) {\n                        preventDefault = true;\n                    }\n                }\n                break;\n            default:\n                if (!args.ctrlKey && !args.altKey && isPrintableCharacter(args.key)) {\n                    this.enterCell();\n                }\n        }\n        if (preventDefault) {\n            args.preventDefault();\n        }\n    }\n    onContentKeydown(args) {\n        if (!this.onCellKeydown(args)) {\n            return;\n        }\n        const confirm = !args.defaultPrevented && args.keyCode === Keys.Enter && isTextInput(args.srcElement);\n        if (args.keyCode === Keys.Escape || args.keyCode === Keys.F2 || confirm) {\n            this.leaveCell();\n            this.cursor.reset();\n            args.stopPropagation();\n        }\n        else if (isNavigationKey(args.keyCode) && this.cursor.cell.focusGroup.isNavigable()) {\n            this.onCursorKeydown(args);\n            if (args.defaultPrevented) {\n                this.leaveCell();\n            }\n        }\n    }\n    onCellKeydown(args) {\n        if (this.editService.isEditingCell()) {\n            const confirm = args.keyCode === Keys.Enter;\n            const cancel = args.keyCode === Keys.Escape;\n            const navigate = isNavigationKey(args.keyCode);\n            if (confirm) {\n                this.editService.closeCell(args);\n            }\n            else if (cancel) {\n                this.editService.cancelCell();\n                this.cd.detectChanges();\n            }\n            else if (navigate) {\n                return false;\n            }\n        }\n        this.cellKeydown.emit(args);\n        return true;\n    }\n    onCursorChanges(args) {\n        this.activeRowIndex = args.rowIndex;\n        const dataRowIndex = this.activeDataRow;\n        if (this.meta && (this.meta.isVirtual && this.viewport &&\n            !this.viewport.containsRow(dataRowIndex) && dataRowIndex > -1)) {\n            this.scrollRequestService.scrollTo({ row: dataRowIndex });\n        }\n        if (this.meta.virtualColumns && args.colIndex >= this.meta.columns.lockedLeafColumns.length) {\n            const cell = this.activeCell;\n            const { start, end } = this.model.cellRange(cell);\n            if (!cell) {\n                this.virtualCell = true;\n            }\n            if ((!cell && this.mode !== 0 /* Standby */) || (cell && !this.columnViewport.intersects(start, end))) {\n                this.scrollRequestService.scrollTo({ column: args.colIndex - (this.metadata.hasDetailTemplate ? 1 : 0) });\n            }\n        }\n    }\n    onFocusOut(args) {\n        if (isVisible(args.target)) {\n            this.mode = 0 /* Standby */;\n        }\n        else {\n            // Focused target is no longer visible,\n            // reset to cursor mode and recapture focus.\n            this.mode = 1 /* Cursor */;\n        }\n        this.deactivateElements();\n        this.cursor.announce();\n    }\n    onWindowBlur() {\n        this.mode = 0 /* Standby */;\n        this.deactivateElements();\n        this.cursor.announce();\n    }\n    onKeydown(args) {\n        if (this.mode === 1 /* Cursor */) {\n            this.onCursorKeydown(args);\n        }\n        else if (this.mode === 2 /* Content */) {\n            this.onContentKeydown(args);\n        }\n    }\n    onTabout() {\n        // Tabbed out of the last focusable content element\n        // reset to cursor mode and recapture focus.\n        if (this.cursor.cell.focusGroup.isNavigable()) {\n            // Unless the cell has a single focusable element,\n            // otherwise we'd return to Content mode and enter an endless loop\n            return;\n        }\n        this.leaveCell();\n        this.cursor.reset();\n    }\n}\nNavigationService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nNavigationService.ctorParameters = () => [\n    { type: NgZone },\n    { type: DomEventsService },\n    { type: PagerContextService },\n    { type: ScrollRequestService },\n    { type: GroupsService },\n    { type: DetailsService },\n    { type: FocusRoot },\n    { type: EditService },\n    { type: ChangeDetectorRef },\n    { type: LocalizationService },\n    { type: FocusableDirective, decorators: [{ type: Optional }] }\n];\n\n/**\n * @hidden\n */\nclass NavigationMetadata {\n    constructor(dataRows, headerRows, isVirtual, hasPager, hasDetailTemplate, gridElement, virtualColumns, columns) {\n        this.dataRows = dataRows;\n        this.headerRows = headerRows;\n        this.isVirtual = isVirtual;\n        this.hasPager = hasPager;\n        this.hasDetailTemplate = hasDetailTemplate;\n        this.gridElement = gridElement;\n        this.virtualColumns = virtualColumns;\n        this.columns = columns;\n    }\n    get maxLogicalRowIndex() {\n        const dataRows = this.hasDetailTemplate ? this.dataRows * 2 : this.dataRows;\n        return this.headerRows + dataRows - 1;\n    }\n}\n\n// Incremented each time the service is instantiated.\nlet sequence = 0;\n/**\n * @hidden\n */\nclass IdService {\n    constructor() {\n        this.prefix = `k-grid${sequence++}`;\n    }\n    cellId(rowIndex, colIndex) {\n        return `${this.prefix}-r${rowIndex}c${colIndex}`;\n    }\n    selectionCheckboxId(itemIndex) {\n        return `${this.prefix}-checkbox${itemIndex}`;\n    }\n    selectAllCheckboxId() {\n        return `${this.prefix}-select-all`;\n    }\n}\nIdService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nIdService.ctorParameters = () => [];\n\n/**\n * @hidden\n */\nclass ColumnInfoService {\n    constructor() {\n        this.visibilityChange = new EventEmitter();\n        this.lockedChange = new EventEmitter();\n        this.columnRangeChange = new EventEmitter();\n        this.columnsContainer = new ColumnsContainer(() => []);\n    }\n    get lockedLeafColumns() {\n        return this.columnsContainer.lockedLeafColumns;\n    }\n    get nonLockedLeafColumns() {\n        return this.columnsContainer.nonLockedLeafColumns;\n    }\n    get isLocked() {\n        return this.lockedLeafColumns.length > 0;\n    }\n    get totalLevels() {\n        return this.columnsContainer.totalLevels;\n    }\n    get leafNamedColumns() {\n        const columns = expandColumns(this.list().filterSort(column => !column.isColumnGroup))\n            .filter(column => column.matchesMedia && column.displayTitle);\n        return orderBy(columns, [{ field: 'locked', dir: 'desc' }]);\n    }\n    get unlockedRootCount() {\n        return this.list().rootColumns().filter(column => !column.locked && column.isVisible).length;\n    }\n    init(columns, list) {\n        this.columnsContainer = columns;\n        this.list = list;\n    }\n    changeVisibility(columns) {\n        this.visibilityChange.emit(columns);\n    }\n    changeLocked(columns) {\n        this.lockedChange.emit(columns);\n    }\n}\nColumnInfoService.decorators = [\n    { type: Injectable },\n];\n\n/**\n * @hidden\n */\nclass SortService {\n    constructor() {\n        this.changes = new Subject();\n    }\n    sort(value) {\n        this.changes.next(value);\n    }\n}\n\n/**\n * Arguments for the `columnVisibilityChange` event.\n */\nclass ColumnVisibilityChangeEvent {\n    /**\n     * @hidden\n     */\n    constructor(columns) {\n        this.columns = columns;\n    }\n}\n\n/**\n * Arguments for the `columnLockedChange` event.\n */\nclass ColumnLockedChangeEvent {\n    /**\n     * @hidden\n     */\n    constructor(columns) {\n        this.columns = columns;\n    }\n}\n\n/**\n * @hidden\n */\nconst GROUP_CELL_WIDTH = 32; // this should be the value of group-cell inside the theme!\n\n/**\n * @hidden\n */\nfunction defaultTrackBy(index, item) {\n    if (item.type === 'data' && item.isEditing) {\n        return item.data;\n    }\n    return index;\n}\n\nconst createControl = (source) => (acc, key) => {\n    acc[key] = new FormControl(source[key]);\n    return acc;\n};\nconst validateColumnsField = (columns) => expandColumns(columns.toArray())\n    .filter(isColumnComponent)\n    .filter(({ field }) => !isValidFieldName(field))\n    .forEach(({ field }) => console.warn(`\n                Grid column field name '${field}' does not look like a valid JavaScript identifier.\n                Identifiers can contain only alphanumeric characters (including \"$\" or \"_\"), and may not start with a digit.\n                Please use only valid identifier names to ensure error-free operation.\n            `));\nconst handleExpandCollapseService = (service, expandEmitter, collapseEmitter, map$$1) => (service.changes.pipe(filter(({ dataItem }) => isPresent(dataItem)))\n    .subscribe((x) => x.expand ? expandEmitter.emit(map$$1(x)) : collapseEmitter.emit(map$$1(x))));\nconst isInEditedCell = (element, gridElement) => closest(element, matchesClasses('k-grid-edit-cell')) &&\n    closest(element, matchesNodeName('kendo-grid')) === gridElement;\nconst Éµ4$2 = EMPTY_CELL_CONTEXT;\n/**\n * Represents the Kendo UI Grid component for Angular.\n *\n * @example\n * ```ts-preview\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-grid [data]=\"gridData\">\n *        </kendo-grid>\n *    `\n * })\n * class AppComponent {\n *    public gridData: any[] = products;\n * }\n *\n * const products = [{\n *    \"ProductID\": 1,\n *    \"ProductName\": \"Chai\",\n *    \"UnitPrice\": 18.0000,\n *    \"Discontinued\": true\n *  }, {\n *    \"ProductID\": 2,\n *    \"ProductName\": \"Chang\",\n *    \"UnitPrice\": 19.0000,\n *    \"Discontinued\": false\n *  }\n * ];\n * ```\n */\nclass GridComponent {\n    constructor(supportService, selectionService, wrapper, groupInfoService, groupsService, changeNotification, detailsService, editService, filterService, pdfService, responsiveService, renderer, excelService, ngZone, scrollSyncService, domEvents, columnResizingService, changeDetectorRef, columnReorderService, columnInfoService, navigationService, sortService, scrollRequestService, localization) {\n        this.supportService = supportService;\n        this.selectionService = selectionService;\n        this.wrapper = wrapper;\n        this.groupInfoService = groupInfoService;\n        this.groupsService = groupsService;\n        this.changeNotification = changeNotification;\n        this.detailsService = detailsService;\n        this.editService = editService;\n        this.filterService = filterService;\n        this.pdfService = pdfService;\n        this.responsiveService = responsiveService;\n        this.renderer = renderer;\n        this.excelService = excelService;\n        this.ngZone = ngZone;\n        this.scrollSyncService = scrollSyncService;\n        this.domEvents = domEvents;\n        this.columnResizingService = columnResizingService;\n        this.changeDetectorRef = changeDetectorRef;\n        this.columnReorderService = columnReorderService;\n        this.columnInfoService = columnInfoService;\n        this.navigationService = navigationService;\n        this.sortService = sortService;\n        this.scrollRequestService = scrollRequestService;\n        /**\n         * Sets the data of the Grid. If an array is provided, the Grid automatically gets the total count\n         * ([more information and example]({% slug databinding_grid %})).\n         */\n        this.data = [];\n        /**\n         * Defines the scroll mode used by the Grid.\n         *\n         * The available options are:\n         *  - `none`&mdash;Renders no scrollbar.\n         *  - `scrollable`&mdash;The default scroll mode. It requires the setting of the `height` option.\n         *  - `virtual`&mdash;Displays no pager and renders a portion of the data (optimized rendering) while the user is scrolling the content.\n         */\n        this.scrollable = 'scrollable';\n        /**\n         * Enables the single-row [selection]({% slug selection_grid %}) of the Grid.\n         */\n        this.selectable = false;\n        /**\n         * A function that defines how to track changes for the data rows.\n         *\n         * By default, the Grid tracks changes by the index of the data item.\n         * Edited rows are tracked by reference.\n         * In some cases, you might need to override the default behavior,\n         * for example, when you implement editing with immutable data items.\n         *\n         * The following example demonstrates how to track items only by index.\n         *\n         * @example\n         * ```ts\n         * import { Component } from '@angular/core';\n         * import { GridItem } from '@progress/kendo-angular-grid';\n         *\n         * _@Component({\n         *    selector: 'my-app',\n         *    template: `\n         *        <kendo-grid [data]=\"gridData\" [trackBy]=\"trackBy\">\n         *        </kendo-grid>\n         *    `\n         * })\n         * class AppComponent {\n         *    public gridData: any[] = products;\n         *\n         *    public trackBy(index: number, item: GridItem): any {\n         *        console.log(item);\n         *        return index;\n         *    }\n         * }\n         *\n         * const products = [{\n         *    \"ProductID\": 1,\n         *    \"ProductName\": \"Chai\",\n         *    \"UnitPrice\": 18.0000,\n         *    \"Discontinued\": true\n         *  }, {\n         *    \"ProductID\": 2,\n         *    \"ProductName\": \"Chang\",\n         *    \"UnitPrice\": 19.0000,\n         *    \"Discontinued\": false\n         *  }\n         * ];\n         * ```\n         */\n        this.trackBy = defaultTrackBy;\n        /**\n         * If set to `true`, the grid will render only the columns in the current viewport.\n         */\n        this.virtualColumns = false;\n        /**\n         * Enables the [filtering]({% slug filtering_grid %}) of the Grid columns that have their `field` option set.\n         */\n        this.filterable = false;\n        /**\n         * Enables the [sorting]({% slug sorting_grid %}) of the Grid columns that have their `field` option set.\n         */\n        this.sortable = false;\n        /**\n         * Configures the pager of the Grid ([see example]({% slug paging_grid %})).\n         *\n         * The available options are:\n         * - `buttonCount: Number`&mdash;Sets the maximum numeric buttons count before the buttons are collapsed.\n         * - `info: Boolean`&mdash;Toggles the information about the current page and the total number of records.\n         * - `type: PagerType`&mdash;Accepts the `numeric` (buttons with numbers) and `input` (input for typing the page number) values.\n         * - `pageSizes: Boolean` or `Array<number>`&mdash;Shows a menu for selecting the page size.\n         * - `previousNext: Boolean`&mdash;Toggles the **Previous** and **Next** buttons.\n         */\n        this.pageable = false;\n        /**\n         * If set to `true`, the user can group the Grid by dragging the column header cells.\n         * By default, grouping is disabled ([see example]({% slug groupingbasics_grid %})).\n         */\n        this.groupable = false;\n        /**\n         * If set to `true`, the user can use dedicated shortcuts to interact with the Grid.\n         * By default, navigation is disabled and the Grid content is accessible in the normal tab sequence.\n         */\n        this.navigable = false;\n        /**\n         * Indicates whether the Grid columns will be resized during initialization so that\n         * they fit their headers and row content. Defaults to `false`.\n         * Columns with `autoSize` set to `false` are excluded.\n         * To dynamically update the column width to match the new content,\n         * refer to [this example]({% slug resizing_columns_grid %}).\n         */\n        this.autoSize = false;\n        /**\n         * If set to `true`, the user can resize columns by dragging the edges (resize handles) of their header cells\n         * ([see example]({% slug resizing_columns_grid %})).\n         *\n         * @default false\n         */\n        this.resizable = false;\n        /**\n         * If set to `true`, the user can reorder columns by dragging their header cells\n         * ([see example]({% slug reordering_columns_grid %})).\n         *\n         * @default false\n         */\n        this.reorderable = false;\n        /**\n         * Specifies if the loading indicator of the Grid will be displayed ([see example]({% slug databinding_grid %})).\n         *\n         * @default false\n         */\n        this.loading = false;\n        /**\n         * Specifies if the column menu of the columns will be displayed ([see example]({% slug columnmenu_grid %})).\n         *\n         * @default false\n         */\n        this.columnMenu = false;\n        /**\n         * Specifies if the header of the grid will be hidden. The header is visible by default.\n         *\n         * > The header includes column headers and the [filter row]({% slug filtering_grid %}#toc-filter-row).\n         */\n        this.hideHeader = false;\n        /**\n         * Fires when the Grid filter is modified through the UI.\n         * You have to handle the event yourself and filter the data.\n         */\n        this.filterChange = new EventEmitter();\n        /**\n         * Fires when the page of the Grid is changed ([see example]({% slug paging_grid %})).\n         * You have to handle the event yourself and page the data.\n         */\n        this.pageChange = new EventEmitter();\n        /**\n         * Fires when the grouping of the Grid is changed.\n         * You have to handle the event yourself and group the data ([see example]({% slug groupingbasics_grid %})).\n         */\n        this.groupChange = new ZoneAwareEventEmitter(this.ngZone);\n        /**\n         * Fires when the sorting of the Grid is changed ([see example]({% slug sorting_grid %})).\n         * You have to handle the event yourself and sort the data.\n         */\n        this.sortChange = new EventEmitter();\n        /**\n         * Fires when the user selects a Grid row.\n         * Emits the [`SelectionEvent`]({% slug api_grid_selectionevent %}#toc-selectionchange).\n         */\n        this.selectionChange = new EventEmitter();\n        /**\n         * Fires when the data state of the Grid is changed.\n         */\n        this.dataStateChange = new EventEmitter();\n        /**\n         * Fires when the user expands a group header.\n         */\n        this.groupExpand = new EventEmitter();\n        /**\n         * Fires when the user collapses a group header.\n         */\n        this.groupCollapse = new EventEmitter();\n        /**\n         * Fires when the user expands a master row.\n         */\n        this.detailExpand = new EventEmitter();\n        /**\n         * Fires when the user collapses a master row.\n         */\n        this.detailCollapse = new EventEmitter();\n        /**\n         * Fires when the user clicks the **Edit** command button to edit a row\n         * ([see example]({% slug editing_template_forms_grid %}#toc-editing-records)).\n         */\n        this.edit = new EventEmitter();\n        /**\n         * Fires when the user clicks the **Cancel** command button to close a row\n         * ([see example]({% slug editing_template_forms_grid %}#toc-cancelling-editing)).\n         */\n        this.cancel = new EventEmitter();\n        /**\n         * Fires when the user clicks the **Save** command button to save changes in a row\n         * ([see example]({% slug editing_template_forms_grid %}#toc-saving-records)).\n         */\n        this.save = new EventEmitter();\n        /**\n         * Fires when the user clicks the **Remove** command button to remove a row\n         * ([see example]({% slug editing_template_forms_grid %}#toc-removing-records)).\n         */\n        this.remove = new EventEmitter();\n        /**\n         * Fires when the user clicks the **Add** command button to add a new row\n         * ([see example]({% slug editing_template_forms_grid %}#toc-adding-records)).\n         */\n        this.add = new EventEmitter();\n        /**\n         * Fires when the user leaves an edited cell ([see example]({% slug editing_incell_grid %}#toc-basic-concepts)).\n         */\n        this.cellClose = new EventEmitter();\n        /**\n         * Fires when the user clicks a cell ([see example]({% slug editing_incell_grid %}#toc-basic-concepts)).\n         */\n        this.cellClick = new ZoneAwareEventEmitter(this.ngZone);\n        /**\n         * Fires when the user clicks the **Export to PDF** command button.\n         */\n        this.pdfExport = new EventEmitter();\n        /**\n         * Fires when the user clicks the **Export to Excel** command button.\n         */\n        this.excelExport = new EventEmitter();\n        /**\n         * Fires when the user completes the resizing of the column.\n         */\n        this.columnResize = new ZoneAwareEventEmitter(this.ngZone);\n        /**\n         * Fires when the user completes the reordering of the column.\n         */\n        this.columnReorder = new EventEmitter();\n        /**\n         * Fires when the user changes the visibility of the columns from the column menu or column chooser.\n         */\n        this.columnVisibilityChange = new EventEmitter();\n        /**\n         * Fires when the user changes the locked state of the columns from the column menu or by reordering the columns.\n         */\n        this.columnLockedChange = new EventEmitter();\n        /**\n         * Fires when the user scrolls to the last record on the page and enables endless scrolling\n         * ([see example]({% slug scrollmmodes_grid %}#toc-endless-scrolling)).\n         * You have to handle the event yourself and page the data.\n         */\n        this.scrollBottom = new EventEmitter();\n        /**\n         * Fires when the grid content is scrolled.\n         * For performance reasons, the event is triggered outside the Angular zone. Enter the Angular zone if you make any changes that require change detection.\n         */\n        this.contentScroll = new EventEmitter();\n        /**\n         * A query list of all declared columns.\n         */\n        this.columns = new QueryList();\n        this.footer = new QueryList();\n        this.selectionDirective = false;\n        this.columnsContainer = new ColumnsContainer(() => this.columnList.filterHierarchy(column => {\n            column.matchesMedia = this.matchesMedia(column);\n            return column.isVisible;\n        }));\n        this.view = new DataCollection(() => new DataResultIterator(this.data, this.skip, this.hasGroupFooters));\n        this.shouldGenerateColumns = true;\n        this._sort = new Array();\n        this._group = new Array();\n        this._skip = 0;\n        this.cachedWindowWidth = 0;\n        this._rowSelected = null;\n        this.rtl = false;\n        this._rowClass = () => null;\n        this.localizationSubscription = localization.changes.subscribe(({ rtl }) => {\n            this.rtl = rtl;\n            this.direction = this.rtl ? 'rtl' : 'ltr';\n        });\n        this.groupInfoService.registerColumnsContainer(() => this.columnList);\n        this.columnInfoService.init(this.columnsContainer, () => this.columnList);\n        this.columnVisibilityChangeSubscription = this.columnInfoService.visibilityChange.subscribe((changed) => {\n            this.columnVisibilityChange.emit(new ColumnVisibilityChangeEvent(changed));\n        });\n        this.columnLockedChangeSubscription = this.columnInfoService.lockedChange.subscribe((changed) => {\n            this.columnLockedChange.emit(new ColumnLockedChangeEvent(changed));\n        });\n        if (selectionService) {\n            this.selectionSubscription = selectionService.changes.subscribe((event) => {\n                this.ngZone.run(() => this.selectionChange.emit(event));\n            });\n        }\n        this.groupExpandCollapseSubscription = handleExpandCollapseService(groupsService, this.groupExpand, this.groupCollapse, ({ dataItem: group, index }) => ({ group, groupIndex: index }));\n        this.detailsServiceSubscription = handleExpandCollapseService(detailsService, this.detailExpand, this.detailCollapse, args => args);\n        this.filterSubscription = this.filterService.changes.subscribe(x => {\n            this.filterChange.emit(x);\n        });\n        this.sortSubscription = this.sortService.changes.subscribe(x => {\n            this.sortChange.emit(x);\n        });\n        this.attachStateChangesEmitter();\n        this.attachEditHandlers();\n        this.attachDomEventHandlers();\n        this.pdfSubscription = this.pdfService.exportClick.subscribe(this.emitPDFExportEvent.bind(this));\n        this.excelSubscription = this.excelService.exportClick.subscribe(this.saveAsExcel.bind(this));\n        this.columnsContainerChange();\n        this.handleColumnResize();\n        this.columnList = new ColumnList(this.columns);\n        this.columnReorderSubscription = this.columnReorderService\n            .changes.subscribe(this.reorder.bind(this));\n        this.columnRangeChangeSubscription = this.columnInfoService.columnRangeChange.subscribe(this.onColumnRangeChange.bind(this));\n    }\n    /**\n     * Defines the number of records to be skipped by the pager.\n     * Required by the [paging]({% slug paging_grid %}) functionality.\n     */\n    get skip() {\n        return this._skip;\n    }\n    set skip(value) {\n        if (value >= 0) {\n            this._skip = value;\n        }\n    }\n    /**\n     * The descriptors by which the data will be sorted ([see example]({% slug sorting_grid %})).\n     */\n    set sort(value) {\n        if (isArray(value)) {\n            this._sort = value;\n        }\n    }\n    get sort() {\n        return this._sort;\n    }\n    /**\n     * The descriptors by which the data will be grouped ([see example]({% slug groupingbasics_grid %})).\n     */\n    set group(value) {\n        if (isArray(value)) {\n            this._group = value;\n        }\n    }\n    /**\n     */\n    get group() {\n        return this._group;\n    }\n    /**\n     * @hidden\n     */\n    get showTopToolbar() {\n        return this.toolbarTemplate && ['top', 'both'].indexOf(this.toolbarTemplate.position) > -1;\n    }\n    /**\n     * @hidden\n     */\n    get showBottomToolbar() {\n        return this.toolbarTemplate && ['bottom', 'both'].indexOf(this.toolbarTemplate.position) > -1;\n    }\n    /**\n     * @hidden\n     */\n    get isLocked() {\n        return this.lockedLeafColumns.length > 0;\n    }\n    /**\n     * @hidden\n     */\n    get showPager() {\n        return !this.isVirtual && this.pageable !== false;\n    }\n    /**\n     * @hidden\n     */\n    get showGroupPanel() {\n        return this.groupable && this.groupable.enabled !== false;\n    }\n    /**\n     * @hidden\n     */\n    get groupableEmptyText() {\n        return this.groupable.emptyText;\n    }\n    /**\n     * @hidden\n     *\n     * An alias for `navigable` for users who migrate from Kendo UI for jQuery.\n     */\n    set navigatable(value) {\n        this.navigable = value;\n    }\n    /**\n     * @hidden\n     */\n    get navigatable() {\n        return this.navigable;\n    }\n    /**\n     * Defines a function that is executed for every data row in the component.\n     *\n     * @example\n     * ```ts\n     * import { Component, ViewEncapsulation } from '@angular/core';\n     * import { RowClassArgs } from '@progress/kendo-angular-grid';\n     *\n     * _@Component({\n     *    selector: 'my-app',\n     *    encapsulation: ViewEncapsulation.None,\n     *    styles: [`\n     *        .k-grid tr.even { background-color: #f45c42; }\n     *        .k-grid tr.odd { background-color: #41f4df; }\n     *    `],\n     *    template: `\n     *        <kendo-grid [data]=\"gridData\" [rowClass]=\"rowCallback\">\n     *        </kendo-grid>\n     *    `\n     * })\n     * class AppComponent {\n     *    public gridData: any[] = products;\n     *\n     *    public rowCallback(context: RowClassArgs) {\n     *        const isEven = context.index % 2 == 0;\n     *        return {\n     *            even: isEven,\n     *            odd: !isEven\n     *        };\n     *    }\n     * }\n     *\n     * const products = [{\n     *    \"ProductID\": 1,\n     *    \"ProductName\": \"Chai\",\n     *    \"UnitPrice\": 18.0000,\n     *    \"Discontinued\": true\n     *  }, {\n     *    \"ProductID\": 2,\n     *    \"ProductName\": \"Chang\",\n     *    \"UnitPrice\": 19.0000,\n     *    \"Discontinued\": false\n     *  }\n     * ];\n     * ```\n     */\n    set rowClass(fn) {\n        if (typeof fn !== 'function') {\n            throw new Error(`rowClass must be a function, but received ${JSON.stringify(fn)}.`);\n        }\n        this._rowClass = fn;\n    }\n    get rowClass() {\n        return this._rowClass;\n    }\n    /**\n     * Defines a Boolean function that is executed for each data row in the component\n     * ([see example]({% slug selection_grid %}#toc-setting-the-selected-rows)).\n     * Determines whether the row will be selected.\n     */\n    set rowSelected(fn) {\n        if (typeof fn !== 'function') {\n            throw new Error(`rowSelected must be a function, but received ${JSON.stringify(fn)}.`);\n        }\n        this._rowSelected = fn;\n    }\n    get rowSelected() {\n        return this._rowSelected;\n    }\n    /**\n     * Returns the currently focused cell (if any).\n     */\n    get activeCell() {\n        return this.navigationService.activeCell;\n    }\n    /**\n     * Returns the currently focused row (if any).\n     */\n    get activeRow() {\n        return this.navigationService.activeRow;\n    }\n    get dir() {\n        return this.direction;\n    }\n    get hostClasses() {\n        return true;\n    }\n    get lockedClasses() {\n        return this.lockedLeafColumns.length > 0;\n    }\n    get virtualClasses() {\n        return this.isVirtual;\n    }\n    get noScrollbarClass() {\n        return this.scrollbarWidth === 0;\n    }\n    get detailTemplate() {\n        if (this._customDetailTemplate) {\n            return this._customDetailTemplate;\n        }\n        return this.detailTemplateChildren ? this.detailTemplateChildren.first : undefined;\n    }\n    set detailTemplate(detailTemplate) {\n        this._customDetailTemplate = detailTemplate;\n    }\n    get noRecordsTemplate() {\n        if (this._customNoRecordsTemplate) {\n            return this._customNoRecordsTemplate;\n        }\n        return this.noRecordsTemplateChildren ? this.noRecordsTemplateChildren.first : undefined;\n    }\n    set noRecordsTemplate(customNoRecordsTemplate) {\n        this._customNoRecordsTemplate = customNoRecordsTemplate;\n    }\n    get pagerTemplate() {\n        if (this._customPagerTemplate) {\n            return this._customPagerTemplate;\n        }\n        return this.pagerTemplateChildren ? this.pagerTemplateChildren.first : undefined;\n    }\n    set pagerTemplate(customPagerTemplate) {\n        this._customPagerTemplate = customPagerTemplate;\n    }\n    get toolbarTemplate() {\n        if (this._customToolbarTemplate) {\n            return this._customToolbarTemplate;\n        }\n        return this.toolbarTemplateChildren ? this.toolbarTemplateChildren.first : undefined;\n    }\n    set toolbarTemplate(customToolbarTemplate) {\n        this._customToolbarTemplate = customToolbarTemplate;\n    }\n    get scrollbarWidth() {\n        return this.supportService.scrollbarWidth;\n    }\n    get headerPadding() {\n        if (isUniversal()) {\n            return \"\";\n        }\n        const padding = Math.max(0, this.scrollbarWidth - 1) + 'px';\n        const right = this.rtl ? 0 : padding;\n        const left = this.rtl ? padding : 0;\n        return `0 ${right} 0 ${left}`;\n    }\n    get hasGroupFooters() {\n        return this.columnsContainer.hasGroupFooter;\n    }\n    get showFooter() {\n        return this.columnsContainer.hasFooter;\n    }\n    get showGroupFooters() {\n        return this.groupable && this.groupable.showFooter;\n    }\n    get ariaRowCount() {\n        return this.totalColumnLevels + 1 + this.view.total;\n    }\n    get ariaColCount() {\n        return this.columnsContainer.leafColumnsToRender.length;\n    }\n    get isVirtual() {\n        return this.scrollable === 'virtual';\n    }\n    get isScrollable() {\n        return this.scrollable !== 'none';\n    }\n    get visibleColumns() {\n        return this.columnsContainer.allColumns;\n    }\n    get lockedColumns() {\n        return this.columnsContainer.lockedColumns;\n    }\n    get nonLockedColumns() {\n        return this.columnsContainer.nonLockedColumns;\n    }\n    get lockedLeafColumns() {\n        return this.columnsContainer.lockedLeafColumns;\n    }\n    get nonLockedLeafColumns() {\n        return this.columnsContainer.nonLockedLeafColumns;\n    }\n    get leafColumns() {\n        return this.columnsContainer.leafColumns;\n    }\n    get totalColumnLevels() {\n        return this.columnsContainer.totalLevels;\n    }\n    get headerColumns() {\n        if (this.virtualColumns && !this.pdfService.exporting) {\n            return this.viewportColumns;\n        }\n        return this.nonLockedColumns;\n    }\n    get headerLeafColumns() {\n        if (this.virtualColumns && !this.pdfService.exporting) {\n            return this.leafViewportColumns;\n        }\n        return this.nonLockedLeafColumns;\n    }\n    get lockedWidth() {\n        const groupCellsWidth = this.group.length * GROUP_CELL_WIDTH;\n        return expandColumns(this.lockedLeafColumns.toArray()).reduce((prev, curr) => prev + (curr.width || 0), groupCellsWidth);\n    }\n    get nonLockedWidth() {\n        if ((!this.rtl && this.lockedLeafColumns.length) || this.virtualColumns) {\n            return !this.virtualColumns ? this.columnsContainer.unlockedWidth :\n                this.leafViewportColumns.reduce((acc, column) => acc + (column.width || 0), 0);\n        }\n        return undefined;\n    }\n    get selectableSettings() {\n        if (this.selectionService) {\n            return this.selectionService.options;\n        }\n        return undefined;\n    }\n    get columnMenuTemplate() {\n        const template = this.columnMenuTemplates.first;\n        return template ? template.templateRef : null;\n    }\n    get totalCount() {\n        if (this.isVirtual || !isPresent(this.pageSize)) {\n            return this.view.total;\n        }\n        return this.pageSize;\n    }\n    /**\n     * Expands the specified master row ([see example]({% slug hierarchy_grid %})).\n     *\n     * @param {number} index - The absolute index of the master row.\n     */\n    expandRow(index) {\n        if (!this.detailsService.isExpanded(index)) {\n            this.detailsService.toggleRow(index, null);\n        }\n    }\n    /**\n     * Collapses the specified master row.\n     *\n     * @param {number} index - The absolute index of the master row.\n     */\n    collapseRow(index) {\n        if (this.detailsService.isExpanded(index)) {\n            this.detailsService.toggleRow(index, null);\n        }\n    }\n    /**\n     * Expands a group header item for the given index. For example,\n     * `0_1` expands the second inner group of the first master group.\n     *\n     * > * When you use the [`kendoGridGroupBinding`]({% slug api_grid_groupbindingdirective %}) directive,\n     * > the `expandGroup` method is not supported.\n     * > * When a Grid is pageable, the indexes of the groups are offset by the current Grid [`skip`]({% slug api_grid_gridcomponent %}#toc-skip).\n     *\n     * @param {string} index - The underscore separated hierarchical index of the group.\n     */\n    expandGroup(index) {\n        if (!this.groupsService.isExpanded(index)) {\n            this.groupsService.toggleRow(index, null);\n        }\n    }\n    /**\n     * Collapses a group header item for the given index. For example,\n     * `0_1` collapses the second inner group of the first master group.\n     *\n     * > * When you use the [`kendoGridGroupBinding`]({% slug api_grid_groupbindingdirective %}) directive,\n     * > the `expandGroup` method is not supported.\n     * > * When a Grid is pageable, the indexes of the groups are offset by the current Grid [`skip`]({% slug api_grid_gridcomponent %}#toc-skip).\n     *\n     * @param {string} index - The underscore separated hierarchical index of the group.\n     */\n    collapseGroup(index) {\n        if (this.groupsService.isExpanded(index)) {\n            this.groupsService.toggleRow(index, null);\n        }\n    }\n    /**\n     * @hidden\n     */\n    resetGroupsState() {\n        this.groupsService.reset();\n    }\n    /**\n     * @hidden\n     */\n    expandGroupChildren(groupIndex) {\n        this.groupsService.expandChildren(groupIndex);\n    }\n    /**\n     * @hidden\n     */\n    onDataChange() {\n        this.autoGenerateColumns();\n        this.changeNotification.notify();\n        this.pdfService.dataChanged.emit();\n        if (isPresent(this.defaultSelection)) {\n            this.defaultSelection.reset();\n        }\n        this.initSelectionService();\n        this.updateNavigationMetadata();\n    }\n    ngOnChanges(changes) {\n        if (isChanged(\"data\", changes)) {\n            this.onDataChange();\n        }\n        if (this.lockedLeafColumns.length && anyChanged([\"pageSize\", \"skip\", \"sort\", \"group\"], changes)) {\n            this.changeNotification.notify();\n        }\n        if (anyChanged([\"pageSize\", \"scrollable\", 'virtualColumns'], changes)) {\n            this.updateNavigationMetadata();\n        }\n        if (isChanged(\"virtualColumns\", changes)) {\n            this.viewportColumns = this.leafViewportColumns = null;\n        }\n        if (isChanged(\"height\", changes, false)) {\n            this.renderer.setStyle(this.wrapper.nativeElement, 'height', `${this.height}px`);\n        }\n        if (isChanged(\"filterable\", changes) && this.lockedColumns.length) {\n            this.syncHeaderHeight(this.ngZone.onStable.asObservable().pipe(take(1)));\n        }\n        if (anyChanged([\"columnMenu\", \"sortable\", \"filterable\"], changes, false)) {\n            this.columnMenuOptions = this.columnMenu && Object.assign({\n                filter: Boolean(this.filterable),\n                sort: Boolean(this.sortable)\n            }, this.columnMenu); // tslint:disable-line:align\n        }\n        if (isChanged(\"scrollable\", changes) && this.isScrollable) {\n            this.ngZone.onStable.pipe(take(1)).subscribe(() => this.attachScrollSync());\n        }\n    }\n    ngAfterViewInit() {\n        this.attachScrollSync();\n        this.attachElementEventHandlers();\n        this.updateNavigationMetadata();\n        this.applyAutoSize();\n    }\n    ngAfterContentChecked() {\n        this.columnsContainer.refresh();\n        this.verifySettings();\n        this.initSelectionService();\n    }\n    ngAfterContentInit() {\n        this.shouldGenerateColumns = !this.columns.length;\n        this.autoGenerateColumns();\n        this.columnList = new ColumnList(this.columns);\n        this.columnsChangeSubscription = this.columns.changes.subscribe(() => this.verifySettings());\n    }\n    ngOnInit() {\n        if (this.navigable) {\n            this.navigationService.init(this.navigationMetadata());\n        }\n    }\n    ngOnDestroy() {\n        if (this.selectionSubscription) {\n            this.selectionSubscription.unsubscribe();\n        }\n        if (this.stateChangeSubscription) {\n            this.stateChangeSubscription.unsubscribe();\n        }\n        if (this.groupExpandCollapseSubscription) {\n            this.groupExpandCollapseSubscription.unsubscribe();\n        }\n        if (this.detailsServiceSubscription) {\n            this.detailsServiceSubscription.unsubscribe();\n        }\n        if (this.editServiceSubscription) {\n            this.editServiceSubscription.unsubscribe();\n        }\n        if (this.pdfSubscription) {\n            this.pdfSubscription.unsubscribe();\n        }\n        if (this.filterSubscription) {\n            this.filterSubscription.unsubscribe();\n        }\n        if (this.sortSubscription) {\n            this.sortSubscription.unsubscribe();\n        }\n        if (this.columnsChangeSubscription) {\n            this.columnsChangeSubscription.unsubscribe();\n        }\n        if (this.excelSubscription) {\n            this.excelSubscription.unsubscribe();\n        }\n        if (this.columnsContainerChangeSubscription) {\n            this.columnsContainerChangeSubscription.unsubscribe();\n        }\n        if (this.scrollSyncService) {\n            this.scrollSyncService.destroy();\n        }\n        if (this.detachElementEventHandlers) {\n            this.detachElementEventHandlers();\n        }\n        if (this.defaultSelection) {\n            this.defaultSelection.destroy();\n        }\n        if (this.cellClickSubscription) {\n            this.cellClickSubscription.unsubscribe();\n        }\n        if (this.footerChangeSubscription) {\n            this.footerChangeSubscription.unsubscribe();\n        }\n        this.ngZone = null;\n        if (this.columnResizingSubscription) {\n            this.columnResizingSubscription.unsubscribe();\n        }\n        if (this.columnReorderSubscription) {\n            this.columnReorderSubscription.unsubscribe();\n        }\n        if (this.localizationSubscription) {\n            this.localizationSubscription.unsubscribe();\n        }\n        if (this.columnVisibilityChangeSubscription) {\n            this.columnVisibilityChangeSubscription.unsubscribe();\n        }\n        if (this.columnLockedChangeSubscription) {\n            this.columnLockedChangeSubscription.unsubscribe();\n        }\n        if (this.focusElementSubscription) {\n            this.focusElementSubscription.unsubscribe();\n        }\n        this.columnRangeChangeSubscription.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n    attachScrollSync() {\n        if (isUniversal()) {\n            return;\n        }\n        if (this.header) {\n            this.scrollSyncService.registerEmitter(this.header.nativeElement, \"header\");\n        }\n        if (this.footer) {\n            this.footerChangeSubscription = observe(this.footer)\n                .subscribe(footers => footers\n                .map(footer => footer.nativeElement)\n                .filter(isPresent)\n                .forEach(element => this.scrollSyncService.registerEmitter(element, \"footer\")));\n        }\n    }\n    /**\n     * Switches the specified table row in the edit mode ([see example]({% slug editing_template_forms_grid %}#toc-editing-records)).\n     *\n     * @param index - The row index that will be switched in the edit mode.\n     * @param group - The [`FormGroup`]({{ site.data.urls.angular['formgroupapi'] }})\n     * that describes the edit form.\n     * @param options - Additional options. Use skipFocus to determine if the row's edit element should be focused. Defaults to `false`.\n     */\n    editRow(index, group, options) {\n        this.editService.editRow(index, group);\n        if (options && options.skipFocus) {\n            return;\n        }\n        this.focusEditElement(`tr[data-kendo-grid-item-index=\"${index}\"]`);\n    }\n    /**\n     * Closes the editor for a given row ([see example]({% slug editing_template_forms_grid %}#toc-cancelling-editing)).\n     *\n     * @param {number} index - The row index that will be switched out of the edit mode. If no index is provided, it is assumed\n     * that the new item editor will be closed.\n     */\n    closeRow(index) {\n        this.editService.close(index);\n    }\n    /**\n     * Creates a new row editor ([see example]({% slug editing_template_forms_grid %}#toc-adding-records)).\n     *\n     * @param {FormGroup} group - The [`FormGroup`]({{ site.data.urls.angular['formgroupapi'] }}) that describes\n     * the edit form. If called with a data item, it will build the `FormGroup` from the data item fields.\n     */\n    addRow(group) {\n        const isFormGroup = group instanceof FormGroup;\n        if (!isFormGroup) {\n            const fields = Object.keys(group).reduce(createControl(group), {}); // FormBuilder?\n            group = new FormGroup(fields);\n        }\n        this.editService.addRow(group);\n        this.focusEditElement('.k-grid-add-row');\n    }\n    /**\n     * Puts the cell that is specified by the table row and column in edit mode.\n     *\n     * @param {number} rowIndex - The data row index that will be switched in the edit mode.\n     * @param {number|string|any} column - The leaf column index, or the field name or the column instance that should be edited.\n     * @param {FormGroup} group - The [`FormGroup`]({{ site.data.urls.angular['formgroupapi'] }})\n     * that describes the edit form.\n     */\n    editCell(rowIndex, column, group) {\n        const instance = this.columnInstance(column);\n        this.editService.editCell(rowIndex, instance, group);\n        this.focusEditElement('.k-grid-edit-cell');\n    }\n    /**\n     * Closes the current cell in edit mode and fires\n     * the [`cellClose`]({% slug api_grid_gridcomponent %}#toc-cellclose) event.\n     *\n     * @return {boolean} Indicates whether the edited cell was closed.\n     * A `false` value indicates that the\n     * [`cellClose`]({% slug api_grid_gridcomponent %}#toc-cellclose) event was prevented.\n     */\n    closeCell() {\n        return !this.editService.closeCell();\n    }\n    /**\n     * Closes the current cell in edit mode.\n     */\n    cancelCell() {\n        this.editService.cancelCell();\n    }\n    /**\n     * Returns a flag which indicates if a row or a cell is currently edited.\n     *\n     * @return {boolean} A flag which indicates if a row or a cell is currently edited.\n     */\n    isEditing() {\n        return this.editService.isEditing();\n    }\n    /**\n     * Returns a flag which indicates if a cell is currently edited.\n     *\n     * @return {boolean} A flag which indicates if a cell is currently being edited.\n     */\n    isEditingCell() {\n        return this.editService.isEditingCell();\n    }\n    /**\n     * Initiates the PDF export ([see example]({% slug pdfexport_grid %})).\n     */\n    saveAsPDF() {\n        this.pdfService.save(this);\n    }\n    /**\n     * Exports the Grid element to a Drawing [`Group`]({% slug api_kendo-drawing_group %}) by using the `kendo-grid-pdf` component options.\n     * ([see example]({% slug pdfexport_grid %}#toc-exporting-multiple-grids-to-the-same-pdf)).\n     *\n     * @return {Promise} - A promise that will be resolved with the Drawing `Group`.\n     */\n    drawPDF() {\n        const promise = createPromise();\n        this.pdfService.draw(this, promise);\n        return promise;\n    }\n    /**\n     * Initiates the Excel export ([see example]({% slug excelexport_grid %})).\n     */\n    saveAsExcel() {\n        this.excelService.save(this);\n    }\n    /**\n     * Applies the minimum possible width for the specified column,\n     * so that the whole text fits without wrapping. This method expects the Grid\n     * to be resizable (set `resizable` to `true`).\n     * Makes sense to execute this method only\n     * after the Grid is already populated with data.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     *    selector: 'my-app',\n     *    template: `\n     *        <kendo-grid\n     *            #grid\n     *            [data]=\"gridData\"\n     *            [resizable]=\"true\"\n     *            style=\"height: 300px\">\n     *            <ng-template kendoGridToolbarTemplate>\n     *                 <button class=\"k-button\" (click)=\"grid.autoFitColumn(groupColumn)\">\n     *                     Auto-fit the group column\n     *                 </button>\n     *            </ng-template>\n     *            <kendo-grid-column-group #groupColumn title=\"Product Info\">\n     *                <kendo-grid-column\n     *                    field=\"ProductID\"\n     *                    [width]=\"50\"\n     *                    [minResizableWidth]=\"30\"\n     *                    title=\"ID\">\n     *                </kendo-grid-column>\n     *\n     *                <kendo-grid-column\n     *                    field=\"ProductName\"\n     *                    title=\"Product Name\">\n     *                </kendo-grid-column>\n     *            </kendo-grid-column-group>\n     *\n     *            <kendo-grid-column\n     *                field=\"UnitPrice\"\n     *                title=\"Unit Price\"\n     *                [width]=\"180\"\n     *                filter=\"numeric\"\n     *                format=\"{0:c}\">\n     *            </kendo-grid-column>\n     *        </kendo-grid>\n     *    `\n     * })\n     * class AppComponent {\n     *    public gridData: any[] = products;\n     * }\n     *\n     * const products = [{\n     *    \"ProductID\": 1,\n     *    \"ProductName\": \"Chai\",\n     *    \"UnitPrice\": 18.0000,\n     *    \"Discontinued\": true\n     *  }, {\n     *    \"ProductID\": 2,\n     *    \"ProductName\": \"Chang\",\n     *    \"UnitPrice\": 19.0000,\n     *    \"Discontinued\": false\n     *  }\n     * ];\n     * ```\n     */\n    autoFitColumn(column) {\n        this.columnResizingService.autoFit(column);\n    }\n    /**\n     * Adjusts the width of the specified columns to fit the entire content, including headers, without wrapping.\n     * If no columns are specified, `autoFitColumns` is applied to all columns.\n     *\n     * This method requires the Grid to be resizable (set `resizable` to `true`).\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     *    selector: 'my-app',\n     *    template: `\n     *      <kendo-grid\n     *          #grid\n     *          [data]=\"gridData\"\n     *          [resizable]=\"true\"\n     *          style=\"height: 300px\">\n     *          <ng-template kendoGridToolbarTemplate>\n     *              <button class=\"k-button\" (click)=\"grid.autoFitColumns([firstColumn, lastColumn])\">\n     *                  Auto-fit the first and last column\n     *              </button>\n     *              <button class=\"k-button\" (click)=\"grid.autoFitColumns()\">\n     *                  Auto-fit all columns\n     *              </button>\n     *          </ng-template>\n     *          <kendo-grid-column-group title=\"Product Info\">\n     *              <kendo-grid-column\n     *                  #firstColumn\n     *                  field=\"ProductID\"\n     *                  [width]=\"50\"\n     *                  [minResizableWidth]=\"30\"\n     *                  title=\"ID\">\n     *              </kendo-grid-column>\n     *\n     *              <kendo-grid-column\n     *                  field=\"ProductName\"\n     *                  title=\"Product Name\"\n     *                  >\n     *              </kendo-grid-column>\n     *          </kendo-grid-column-group>\n     *\n     *          <kendo-grid-column\n     *              #lastColumn\n     *              field=\"UnitPrice\"\n     *              title=\"Unit Price\"\n     *              [width]=\"180\"\n     *              filter=\"numeric\"\n     *              format=\"{0:c}\">\n     *          </kendo-grid-column>\n     *      </kendo-grid>\n     *    `\n     * })\n     * class AppComponent {\n     *    public gridData: any[] = products;\n     * }\n     *\n     * const products = [{\n     *    \"ProductID\": 1,\n     *    \"ProductName\": \"Chai\",\n     *    \"UnitPrice\": 18.0000,\n     *    \"Discontinued\": true\n     *  }, {\n     *    \"ProductID\": 2,\n     *    \"ProductName\": \"Chang\",\n     *    \"UnitPrice\": 19.0000,\n     *    \"Discontinued\": false\n     *  }\n     * ];\n     * ```\n     */\n    autoFitColumns(columns = this.columns) {\n        let cols;\n        if (columns instanceof QueryList) {\n            cols = columns.toArray();\n        }\n        else {\n            cols = columns;\n        }\n        this.columnResizingService.autoFit(...cols);\n    }\n    /**\n     * @hidden\n     */\n    notifyPageChange(source, event) {\n        if (source === \"list\" && !this.isVirtual) {\n            return;\n        }\n        this.pageChange.emit(event);\n    }\n    /**\n     * @hidden\n     */\n    notifyScrollBottom() {\n        if (this.scrollable === 'none') {\n            return;\n        }\n        if (hasObservers(this.scrollBottom)) {\n            this.ngZone.run(() => this.scrollBottom.emit({ sender: this }));\n        }\n    }\n    /**\n     * @hidden\n     */\n    focusEditElement(containerSelector) {\n        if (this.focusElementSubscription) {\n            this.focusElementSubscription.unsubscribe();\n        }\n        this.ngZone.runOutsideAngular(() => {\n            this.focusElementSubscription = this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {\n                const wrapper = this.wrapper.nativeElement;\n                if (!this.setEditFocus(wrapper.querySelector(containerSelector)) && this.isLocked) {\n                    this.setEditFocus(wrapper.querySelector(`.k-grid-content ${containerSelector}`));\n                }\n                this.focusElementSubscription = null;\n            });\n        });\n    }\n    /**\n     * Focuses the last active or the first cell of the Grid.\n     *\n     * @returns {NavigationCell} The focused cell.\n     */\n    focus() {\n        this.assertNavigable();\n        return this.navigationService.focusCell();\n    }\n    /**\n     * Focuses the cell with the specified row and column index.\n     *\n     * The row index is based on the logical structure of the Grid and does not correspond to the data item index:\n     * * Header rows are included, starting at index 0.\n     * * Group headers and footers are included.\n     * * The row indexing is absolute and does not change with paging.\n     *\n     * If the Grid is configured for scrolling, including virtual scrolling, the scroll position will be updated.\n     * If the row is not present on the current page, the method will have no effect.\n     *\n     * @param rowIndex - The logical row index to focus. The top header row has an index 0.\n     * @param colIndex - The column index to focus.\n     * @returns {NavigationCell} The focused cell.\n     *\n     */\n    focusCell(rowIndex, colIndex) {\n        this.assertNavigable();\n        return this.navigationService.focusCell(rowIndex, colIndex);\n    }\n    /**\n     * Focuses the next cell, optionally wrapping to the next row.\n     *\n     * @param wrap - A Boolean value which indicates if the focus will move to the next row. Defaults to `true`.\n     * @returns {NavigationCell} The focused cell. If the focus is already on the last cell, returns `null`.\n     */\n    focusNextCell(wrap = true) {\n        this.assertNavigable();\n        return this.navigationService.focusNextCell(wrap);\n    }\n    /**\n     * Focuses the previous cell. Optionally wraps to the previous row.\n     *\n     * @param wrap - A Boolean value which indicates if the focus will move to the next row. Defaults to `true`.\n     * @returns {NavigationCell} The focused cell. If the focus is already on the first cell, returns `null`.\n     */\n    focusPrevCell(wrap = true) {\n        this.assertNavigable();\n        return this.navigationService.focusPrevCell(wrap);\n    }\n    /**\n     * Scrolls to the specified row and column\n     */\n    scrollTo(request) {\n        this.scrollRequestService.scrollTo(request);\n    }\n    /**\n     * Changes the position of the specified column.\n     * The reordering of columns operates only on the level\n     * which is inferred by the source column.\n     * For the `reorderColumn` method to work properly,\n     * the `source` column has to be visible.\n     *\n     * @param {ColumnBase} source - The column whose position will be changed.\n     * @param {number} destIndex - The new position of the column.\n     * @param {ColumnReorderConfig} options - Additional options.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     *    selector: 'my-app',\n     *    template: `\n     *        <kendo-grid\n     *            #grid\n     *            [data]=\"gridData\"\n     *            [reorderable]=\"true\"\n     *            style=\"height: 300px\">\n     *            <ng-template kendoGridToolbarTemplate>\n     *                 <button class=\"k-button\"\n     *                     (click)=\"grid.reorderColumn(groupColumn, 2, { before: true })\">\n     *                     Move the group column before the last one.\n     *                 </button>\n     *            </ng-template>\n     *            <kendo-grid-column-group #groupColumn title=\"Product Info\">\n     *                <kendo-grid-column\n     *                    field=\"ProductID\"\n     *                    [width]=\"50\"\n     *                    title=\"ID\">\n     *                </kendo-grid-column>\n     *\n     *                <kendo-grid-column\n     *                    field=\"ProductName\"\n     *                    title=\"Product Name\">\n     *                </kendo-grid-column>\n     *            </kendo-grid-column-group>\n     *\n     *            <kendo-grid-column\n     *                field=\"UnitPrice\"\n     *                title=\"Unit Price\"\n     *                [width]=\"180\"\n     *                format=\"{0:c}\">\n     *            </kendo-grid-column>\n     *\n     *            <kendo-grid-column\n     *                field=\"Discontinued\"\n     *                title=\"Discontinued\"\n     *                [width]=\"100\">\n     *            </kendo-grid-column>\n     *        </kendo-grid>\n     *    `\n     * })\n     * class AppComponent {\n     *    public gridData: any[] = products;\n     * }\n     *\n     * const products = [{\n     *    \"ProductID\": 1,\n     *    \"ProductName\": \"Chai\",\n     *    \"UnitPrice\": 18.0000,\n     *    \"Discontinued\": true\n     *  }, {\n     *    \"ProductID\": 2,\n     *    \"ProductName\": \"Chang\",\n     *    \"UnitPrice\": 19.0000,\n     *    \"Discontinued\": false\n     *  }\n     * ];\n     * ```\n     */\n    reorderColumn(source, destIndex, options = { before: false }) {\n        const columnsForLevel = this.columnsForLevel(source.level);\n        let target = columnsForLevel[destIndex];\n        if (!target) {\n            return;\n        }\n        const lastNonLocked = target.isLocked &&\n            !source.isLocked &&\n            this.columnsContainer.nonLockedColumns.length === 1;\n        if (lastNonLocked) {\n            return;\n        }\n        if (isSpanColumnComponent(target) && !options.before) {\n            target = target.childColumns.last;\n        }\n        this.reorder({\n            before: options.before,\n            source: source,\n            target: target\n        });\n    }\n    /**\n     * @hidden\n     */\n    reorder({ target, source, before, changeContainer }) {\n        this.ngZone.run(() => {\n            const columnsForLevel = this.columnsForLevel(source.level);\n            let newIndex = columnsForLevel.indexOf(target);\n            if (target.parent && target.parent.isSpanColumn) {\n                newIndex = columnsForLevel.indexOf(target.parent);\n                if (before) {\n                    target = target.parent;\n                }\n            }\n            let oldIndex = columnsForLevel.indexOf(source);\n            if (changeContainer) {\n                if (before && 0 < newIndex && oldIndex < newIndex) { // dropped before the first not locked column\n                    newIndex--;\n                }\n                else if (!before && oldIndex > newIndex) { // dropped after the last locked column\n                    newIndex++;\n                }\n            }\n            const args = new ColumnReorderEvent({\n                column: source,\n                oldIndex: oldIndex,\n                newIndex: newIndex\n            });\n            this.columnReorder.emit(args);\n            if (args.isDefaultPrevented()) {\n                return;\n            }\n            if (changeContainer) {\n                this.columnLockedChange.emit(new ColumnLockedChangeEvent([source]));\n            }\n            this.updateColumnIndices({ source, target, before });\n            if (source.locked !== target.locked) {\n                source.locked = target.locked;\n            }\n            this.columnsContainer.refresh();\n            this.changeDetectorRef.markForCheck();\n        });\n    }\n    updateColumnIndices({ source, target, before }) {\n        const expandedColumns = expandColumnsWithSpan(this.columnsForLevel(source.level));\n        const sourceColumnIndex = expandedColumns.indexOf(source);\n        let nextSourceIndex = 0;\n        let nextIndex = 0;\n        let toSkip = 1;\n        // Possible only when called from the API.\n        if (source.isSpanColumn) {\n            toSkip += source.childColumns.length;\n        }\n        let i = 0;\n        while (i < expandedColumns.length) {\n            let column = expandedColumns[i];\n            if (column === target) {\n                nextSourceIndex = before ? nextIndex : nextIndex + 1;\n                nextIndex = before ? nextIndex + toSkip : nextIndex;\n                column.orderIndex = nextIndex;\n                if (nextSourceIndex === nextIndex + 1) {\n                    nextIndex += toSkip;\n                }\n            }\n            else if (column === source) {\n                i += toSkip;\n                continue;\n            }\n            else {\n                column.orderIndex = nextIndex;\n            }\n            nextIndex++;\n            i++;\n        }\n        for (i = sourceColumnIndex; i < sourceColumnIndex + toSkip; i++) {\n            expandedColumns[i].orderIndex = nextSourceIndex++;\n        }\n        this.updateIndicesForLevel(source.level + 1);\n    }\n    updateIndicesForLevel(level) {\n        const colsForParentLevel = this.columnsForLevel(level - 1);\n        const colsForLevel = [];\n        sortColumns(colsForParentLevel).forEach((c) => {\n            if (c.isColumnGroup) {\n                colsForLevel.push(...c.childrenArray.sort((a, b) => a.orderIndex - b.orderIndex));\n            }\n        });\n        expandColumnsWithSpan(colsForLevel).map((c, i) => c.orderIndex = i);\n        if (level < this.columnsContainer.totalLevels) {\n            this.updateIndicesForLevel(level + 1);\n        }\n    }\n    columnsForLevel(level) {\n        return this.columnsContainer\n            .allColumns.filter(column => column.level === level);\n    }\n    initSelectionService() {\n        if (!this.selectionDirective && !isPresent(this.defaultSelection)) {\n            this.defaultSelection = new Selection(this, this.changeDetectorRef);\n        }\n        this.selectionService.init({\n            rowSelected: this.rowSelected,\n            selectable: this.selectable,\n            view: this.view\n        });\n        if (!this.selectionDirective && !this.selectableSettings.enabled) {\n            this.defaultSelection.reset();\n        }\n    }\n    setEditFocus(element) {\n        if (element) {\n            return this.navigationService.tryFocus(element);\n        }\n    }\n    columnInstance(column) {\n        let instance;\n        if (typeof column === 'number') {\n            instance = this.columnsContainer.lockedLeafColumns.toArray()\n                .concat(this.columnsContainer.nonLockedLeafColumns.toArray())[column];\n        }\n        else if (typeof column === 'string') {\n            instance = this.columnList.filter((item) => item.field === column)[0];\n        }\n        else {\n            instance = column;\n        }\n        if (!instance && isDevMode()) {\n            throw new Error(`Invalid column ${column}`);\n        }\n        return instance;\n    }\n    verifySettings() {\n        if (isDevMode()) {\n            const locked = this.lockedLeafColumns.length || (this.columnMenu && this.columnMenu.lock);\n            if (locked && this.detailTemplate) {\n                throw new Error('Having both detail template and locked columns is not supported.');\n            }\n            if (this.lockedLeafColumns.length && !this.nonLockedLeafColumns.length) {\n                throw new Error('There should be at least one non-locked column');\n            }\n            if ((locked || this.virtualColumns) && expandColumns(this.columnList.toArray()).filter(column => !column.width && !isColumnGroupComponent(column)).length) {\n                throw new Error((locked ? 'Locked' : 'Virtual') + ' columns feature requires all columns to have set width.');\n            }\n            if (locked && !this.isScrollable) {\n                throw new Error('Locked columns are only supported when scrolling is enabled.');\n            }\n            if (this.columnList.filter(isColumnGroupComponent).filter((x) => !x.hasChildren).length) {\n                throw new Error('ColumnGroupComponent should contain ColumnComponent or CommandColumnComponent.');\n            }\n            if (this.columnList.filter(x => x.locked && x.parent && !x.parent.isLocked).length) {\n                throw new Error('Locked child columns require their parent columns to be locked.');\n            }\n            if ((this.rowHeight || this.detailRowHeight) && !this.isVirtual) {\n                throw new Error('Row height and detail row height settings require virtual scrolling mode to be enabled.');\n            }\n            validateColumnsField(this.columnList);\n        }\n    }\n    autoGenerateColumns() {\n        if (this.shouldGenerateColumns && !this.columns.length && this.view.length) {\n            this.columns.reset(Object.keys(this.view.at(0)).map(field => {\n                let column = new ColumnComponent();\n                column.field = field;\n                return column;\n            }));\n        }\n    }\n    attachStateChangesEmitter() {\n        this.stateChangeSubscription =\n            merge(this.pageChange.pipe(map(x => ({\n                filter: this.filter, group: this.group, skip: x.skip, sort: this.sort, take: x.take\n            }))), this.sortChange.pipe(map(sort => ({ filter: this.filter, group: this.group, skip: this.skip, sort: sort, take: this.pageSize }))), this.groupChange.pipe(map(group => ({\n                filter: this.filter, group: group, skip: this.skip, sort: this.sort, take: this.pageSize\n            }))), this.filterChange.pipe(map(filter$$1 => ({\n                filter: filter$$1, group: this.group, skip: 0, sort: this.sort, take: this.pageSize\n            }))))\n                .subscribe(x => {\n                this.closeCell();\n                this.cancelCell();\n                this.dataStateChange.emit(x);\n            });\n    }\n    attachEditHandlers() {\n        if (!this.editService) {\n            return;\n        }\n        this.editServiceSubscription = this.editService\n            .changes.subscribe(this.emitCRUDEvent.bind(this));\n    }\n    emitCRUDEvent(args) {\n        const { action, rowIndex, formGroup } = args;\n        let dataItem = this.view.at(rowIndex - this.skip);\n        if (action !== 'add' && !dataItem) {\n            dataItem = formGroup.value;\n        }\n        this.closeCell();\n        Object.assign(args, {\n            dataItem: dataItem,\n            sender: this\n        });\n        switch (action) {\n            case 'add':\n                this.add.emit(args);\n                break;\n            case 'cancel':\n                this.cancel.emit(args);\n                break;\n            case 'edit':\n                this.edit.emit(args);\n                break;\n            case 'remove':\n                this.remove.emit(args);\n                break;\n            case 'save':\n                this.save.emit(args);\n                break;\n            case 'cellClose':\n                this.cellClose.emit(args);\n                break;\n            default: break;\n        }\n    }\n    attachDomEventHandlers() {\n        this.cellClickSubscription = this.domEvents.cellClick.subscribe((args) => {\n            this.cellClick.emit(Object.assign({ sender: this }, args));\n        });\n    }\n    attachElementEventHandlers() {\n        if (isUniversal()) {\n            return;\n        }\n        const wrapper = this.wrapper.nativeElement;\n        const ariaRoot = this.ariaRoot.nativeElement;\n        this.ngZone.runOutsideAngular(() => {\n            const resizeCheck = this.resizeCheck.bind(this);\n            const resizeSubscription = this.renderer.listen('window', 'resize', resizeCheck);\n            const orientationSubscription = this.renderer.listen('window', 'orientationchange', resizeCheck);\n            const documentClickSubscription = this.renderer.listen('document', 'click', (args) => {\n                const activeElement = document.activeElement;\n                if (this.editService.shouldCloseCell() &&\n                    !closest(args.target, matchesClasses('k-animation-container k-grid-ignore-click')) &&\n                    !(activeElement &&\n                        (closest(activeElement, matchesClasses('k-animation-container')) ||\n                            isInEditedCell(activeElement, this.wrapper.nativeElement)))) {\n                    this.editService.closeCell(args);\n                }\n            });\n            const windowBlurSubscription = this.renderer.listen('window', 'blur', (args) => {\n                const activeElement = document.activeElement;\n                if (activeElement && !(matchesNodeName('input')(activeElement) && activeElement.type === 'file' &&\n                    isInEditedCell(activeElement, this.wrapper.nativeElement))) {\n                    this.editService.closeCell(args);\n                }\n                this.domEvents.windowBlur.emit(args);\n            });\n            const clickSubscription = this.renderer.listen(wrapper, 'click', (args) => {\n                this.domEvents.click.emit(args);\n            });\n            const keydownSubscription = this.renderer.listen(wrapper, 'keydown', (args) => {\n                this.domEvents.keydown.emit(args);\n            });\n            // focusIn and focusOut are relative to the element with ARIA role \"grid\"\n            let focused = false;\n            const focusInSubscription = this.renderer.listen(ariaRoot, 'focusin', (args) => {\n                this.domEvents.focus.emit(args);\n                if (!focused) {\n                    this.domEvents.focusIn.emit(args);\n                    focused = true;\n                }\n            });\n            const focusOutSubscription = this.renderer.listen(ariaRoot, 'focusout', (args) => {\n                const next = args.relatedTarget || document.activeElement;\n                const outside = !closest(next, (node) => node === ariaRoot);\n                if (outside) {\n                    this.domEvents.focusOut.emit(args);\n                    focused = false;\n                }\n            });\n            this.detachElementEventHandlers = () => {\n                resizeSubscription();\n                orientationSubscription();\n                documentClickSubscription();\n                windowBlurSubscription();\n                clickSubscription();\n                keydownSubscription();\n                focusInSubscription();\n                focusOutSubscription();\n            };\n        });\n    }\n    matchesMedia(c) {\n        return this.responsiveService.matchesMedia(c.media);\n    }\n    resizeCheck() {\n        if (window.innerWidth !== this.cachedWindowWidth) {\n            this.cachedWindowWidth = window.innerWidth;\n            let hasChanges = false;\n            this.columnList.filterHierarchy(column => {\n                const matchesMedia = this.matchesMedia(column);\n                if (column.matchesMedia !== matchesMedia) {\n                    hasChanges = true;\n                    column.matchesMedia = matchesMedia;\n                }\n                return column.isVisible;\n            });\n            if (hasChanges) {\n                this.ngZone.run(() => {\n                    this.changeDetectorRef.markForCheck();\n                });\n            }\n        }\n    }\n    emitPDFExportEvent() {\n        const args = new PDFExportEvent();\n        this.pdfExport.emit(args);\n        if (!args.isDefaultPrevented()) {\n            this.saveAsPDF();\n        }\n    }\n    syncHeaderHeight(observable) {\n        return observable\n            .pipe(filter(() => isPresent(this.lockedHeader)))\n            .subscribe(() => syncRowsHeight(this.lockedHeader.nativeElement.children[0], this.header.nativeElement.children[0]));\n    }\n    columnsContainerChange() {\n        this.columnsContainerChangeSubscription =\n            this.syncHeaderHeight(this.columnsContainer.changes.pipe(filter(() => this.lockedColumns.length > 0), switchMap(() => this.ngZone.onStable.asObservable().pipe(take(1)))));\n    }\n    handleColumnResize() {\n        const resizes = this.columnResizingService.changes;\n        this.columnResizingSubscription = resizes.pipe(tap(e => {\n            if (e.type === 'start') {\n                this.renderer.addClass(this.wrapper.nativeElement, 'k-grid-column-resizing');\n            }\n            else if (e.type === 'end') {\n                this.renderer.removeClass(this.wrapper.nativeElement, 'k-grid-column-resizing');\n            }\n        }), filter(e => e.type === 'start'), switchMap(() => resizes.pipe(\n        // tslint:disable-next-line: rxjs-no-unsafe-takeuntil\n        takeUntil(resizes.pipe(filter(e => e.type === 'triggerAutoFit'))), filter(e => e.type === 'end'))))\n            .subscribe(this.notifyResize.bind(this));\n    }\n    notifyResize(e) {\n        const args = e.resizedColumns\n            .filter(item => isTruthy(item.column.resizable) && !item.column.isColumnGroup)\n            .map(item => ({\n            column: item.column,\n            newWidth: item.column.width,\n            oldWidth: item.oldWidth\n        }));\n        this.columnResize.emit(args);\n    }\n    assertNavigable() {\n        if (isDevMode() && !this.navigable) {\n            throw new Error('The Grid should be configured as [navigable]=\"true\" to control focus');\n        }\n    }\n    navigationMetadata() {\n        const isVirtual = this.isVirtual;\n        const pageSize = this.pageSize;\n        const dataRows = isVirtual ? this.view.total : pageSize;\n        const addRowOffset = this.editService.hasNewItem ? 1 : 0;\n        const filterRowOffset = hasFilterRow(this.filterable) ? 1 : 0;\n        const headerRows = this.totalColumnLevels + 1 + filterRowOffset + addRowOffset;\n        return new NavigationMetadata(dataRows, headerRows, isVirtual, this.showPager, isPresent(this.detailTemplate), this.wrapper, this.virtualColumns, this.columnsContainer);\n    }\n    updateNavigationMetadata() {\n        this.navigationService.metadata = this.navigationMetadata();\n    }\n    applyAutoSize() {\n        const cols = this.columns.filter((c) => this.autoSize ? c.autoSize !== false : c.autoSize);\n        if (cols.length > 0) {\n            this.ngZone.onStable.pipe(take(1)).subscribe(_ => this.autoFitColumns(cols));\n        }\n    }\n    onColumnRangeChange(range) {\n        const viewportColumns = this.viewportColumns = [];\n        const leafViewportColumns = this.columnsContainer\n            .nonLockedLeafColumns.toArray().slice(range.start, range.end + 1);\n        for (let idx = 0; idx < leafViewportColumns.length; idx++) {\n            let column = leafViewportColumns[idx];\n            while (column.parent) {\n                column = column.parent;\n            }\n            const toAdd = [column];\n            while (toAdd.length) {\n                column = toAdd.shift();\n                viewportColumns.push(column);\n                if (column.isColumnGroup) {\n                    toAdd.unshift.apply(toAdd, column.childrenArray);\n                }\n            }\n            const lastFromGroup = viewportColumns[viewportColumns.length - 1];\n            column = leafViewportColumns[idx];\n            while (column !== lastFromGroup && idx < leafViewportColumns.length) {\n                idx++;\n                column = leafViewportColumns[idx];\n            }\n        }\n        if (range.start > 0) {\n            const first = leafViewportColumns[0];\n            let offset = range.offset;\n            let current = viewportColumns[0];\n            let index = 0;\n            while (current !== first) {\n                offset -= current.isColumnGroup ? 0 : current.width;\n                index++;\n                current = viewportColumns[index];\n            }\n            if (offset > 0) {\n                const totalLevels = this.columnsContainer.totalLevels;\n                let previous;\n                for (let idx = 0; idx <= totalLevels; idx++) {\n                    const offsetColumn = idx < totalLevels ? new ColumnGroupComponent(previous) : new ColumnBase$1(previous);\n                    previous = offsetColumn;\n                    offsetColumn.title = \"\\u00A0\";\n                    offsetColumn.width = offset;\n                    viewportColumns.unshift(offsetColumn);\n                }\n            }\n        }\n        this.leafViewportColumns = viewportColumns.filter(c => !c.isColumnGroup);\n    }\n}\nGridComponent.decorators = [\n    { type: Component, args: [{\n                encapsulation: ViewEncapsulation.None,\n                exportAs: 'kendoGrid',\n                providers: [\n                    BrowserSupportService,\n                    LocalizationService,\n                    ColumnInfoService,\n                    SelectionService,\n                    DetailsService,\n                    GroupsService,\n                    GroupInfoService,\n                    ChangeNotificationService,\n                    EditService,\n                    PDFService,\n                    SuspendService,\n                    {\n                        provide: CELL_CONTEXT,\n                        useValue: Éµ4$2\n                    },\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.grid'\n                    },\n                    FilterService,\n                    ResponsiveService,\n                    PagerContextService,\n                    ExcelService,\n                    ScrollSyncService,\n                    ResizeService,\n                    LocalDataChangesService,\n                    DomEventsService,\n                    ColumnResizingService,\n                    SinglePopupService,\n                    DragAndDropService,\n                    DragHintService,\n                    DropCueService,\n                    ColumnReorderService,\n                    NavigationService,\n                    FocusRoot,\n                    IdService,\n                    ScrollRequestService,\n                    SortService\n                ],\n                selector: 'kendo-grid',\n                styles: [\n                    // Styles for backwards compatibility with kendo-theme-default@v2.46.0 and earlier.\n                    `   .k-grid .k-grid-aria-root {\n            display: flex;\n            flex-direction: column;\n            flex: 1 1 auto;\n            overflow: hidden;\n        }\n\n        .k-grid .k-filter-row td {\n            white-space: nowrap;\n        }`\n                ],\n                template: `\n        <ng-container kendoGridLocalizedMessages\n            i18n-groupPanelEmpty=\"kendo.grid.groupPanelEmpty|The label visible in the Grid group panel when it is empty\"\n            groupPanelEmpty=\"Drag a column header and drop it here to group by that column\"\n\n            i18n-noRecords=\"kendo.grid.noRecords|The label visible in the Grid when there are no records\"\n            noRecords=\"No records available.\"\n\n            i18n-pagerFirstPage=\"kendo.grid.pagerFirstPage|The label for the first page button in Grid pager\"\n            pagerFirstPage=\"Go to the first page\"\n\n            i18n-pagerPreviousPage=\"kendo.grid.pagerPreviousPage|The label for the previous page button in Grid pager\"\n            pagerPreviousPage=\"Go to the previous page\"\n\n            i18n-pagerNextPage=\"kendo.grid.pagerNextPage|The label for the next page button in Grid pager\"\n            pagerNextPage=\"Go to the next page\"\n\n            i18n-pagerLastPage=\"kendo.grid.pagerLastPage|The label for the last page button in Grid pager\"\n            pagerLastPage=\"Go to the last page\"\n\n            i18n-pagerPage=\"kendo.grid.pagerPage|The label before the current page number in the Grid pager\"\n            pagerPage=\"Page\"\n\n            i18n-pagerOf=\"kendo.grid.pagerOf|The label before the total pages number in the Grid pager\"\n            pagerOf=\"of\"\n\n            i18n-pagerItems=\"kendo.grid.pagerItems|The label after the total pages number in the Grid pager\"\n            pagerItems=\"items\"\n\n            i18n-pagerItemsPerPage=\"kendo.grid.pagerItemsPerPage|The label for the page size chooser in the Grid pager\"\n            pagerItemsPerPage=\"items per page\"\n\n            i18n-filter=\"kendo.grid.filter|The label of the filter cell or icon\"\n            filter=\"Filter\"\n\n            i18n-filterEqOperator=\"kendo.grid.filterEqOperator|The text of the equal filter operator\"\n            filterEqOperator=\"Is equal to\"\n\n            i18n-filterNotEqOperator=\"kendo.grid.filterNotEqOperator|The text of the not equal filter operator\"\n            filterNotEqOperator=\"Is not equal to\"\n\n            i18n-filterIsNullOperator=\"kendo.grid.filterIsNullOperator|The text of the is null filter operator\"\n            filterIsNullOperator=\"Is null\"\n\n            i18n-filterIsNotNullOperator=\"kendo.grid.filterIsNotNullOperator|The text of the is not null filter operator\"\n            filterIsNotNullOperator=\"Is not null\"\n\n            i18n-filterIsEmptyOperator=\"kendo.grid.filterIsEmptyOperator|The text of the is empty filter operator\"\n            filterIsEmptyOperator=\"Is empty\"\n\n            i18n-filterIsNotEmptyOperator=\"kendo.grid.filterIsNotEmptyOperator|The text of the is not empty filter operator\"\n            filterIsNotEmptyOperator=\"Is not empty\"\n\n            i18n-filterStartsWithOperator=\"kendo.grid.filterStartsWithOperator|The text of the starts with filter operator\"\n            filterStartsWithOperator=\"Starts with\"\n\n            i18n-filterContainsOperator=\"kendo.grid.filterContainsOperator|The text of the contains filter operator\"\n            filterContainsOperator=\"Contains\"\n\n            i18n-filterNotContainsOperator=\"kendo.grid.filterNotContainsOperator|The text of the does not contain filter operator\"\n            filterNotContainsOperator=\"Does not contain\"\n\n            i18n-filterEndsWithOperator=\"kendo.grid.filterEndsWithOperator|The text of the ends with filter operator\"\n            filterEndsWithOperator=\"Ends with\"\n\n            i18n-filterGteOperator=\"kendo.grid.filterGteOperator|The text of the greater than or equal filter operator\"\n            filterGteOperator=\"Is greater than or equal to\"\n\n            i18n-filterGtOperator=\"kendo.grid.filterGtOperator|The text of the greater than filter operator\"\n            filterGtOperator=\"Is greater than\"\n\n            i18n-filterLteOperator=\"kendo.grid.filterLteOperator|The text of the less than or equal filter operator\"\n            filterLteOperator=\"Is less than or equal to\"\n\n            i18n-filterLtOperator=\"kendo.grid.filterLtOperator|The text of the less than filter operator\"\n            filterLtOperator=\"Is less than\"\n\n            i18n-filterIsTrue=\"kendo.grid.filterIsTrue|The text of the IsTrue boolean filter option\"\n            filterIsTrue=\"Is True\"\n\n            i18n-filterIsFalse=\"kendo.grid.filterIsFalse|The text of the IsFalse boolean filter option\"\n            filterIsFalse=\"Is False\"\n\n            i18n-filterBooleanAll=\"kendo.grid.filterBooleanAll|The text of the (All) boolean filter option\"\n            filterBooleanAll=\"(All)\"\n\n            i18n-filterAfterOrEqualOperator=\"kendo.grid.filterAfterOrEqualOperator|The text of the after or equal date filter operator\"\n            filterAfterOrEqualOperator=\"Is after or equal to\"\n\n            i18n-filterAfterOperator=\"kendo.grid.filterAfterOperator|The text of the after date filter operator\"\n            filterAfterOperator=\"Is after\"\n\n            i18n-filterBeforeOperator=\"kendo.grid.filterBeforeOperator|The text of the before date filter operator\"\n            filterBeforeOperator=\"Is before\"\n\n            i18n-filterBeforeOrEqualOperator=\"kendo.grid.filterBeforeOrEqualOperator|The text of the before or equal date filter operator\"\n            filterBeforeOrEqualOperator=\"Is before or equal to\"\n\n            i18n-filterFilterButton=\"kendo.grid.filterFilterButton|The text of the filter button\"\n            filterFilterButton=\"Filter\"\n\n            i18n-filterClearButton=\"kendo.grid.filterClearButton|The text of the clear filter button\"\n            filterClearButton=\"Clear\"\n\n            i18n-filterAndLogic=\"kendo.grid.filterAndLogic|The text of the And filter logic\"\n            filterAndLogic=\"And\"\n\n            i18n-filterOrLogic=\"kendo.grid.filterOrLogic|The text of the Or filter logic\"\n            filterOrLogic=\"Or\"\n\n            i18n-loading=\"kendo.grid.loading|The loading text\"\n            loading=\"Loading\"\n\n            i18n-columnMenu=\"kendo.grid.columnMenu|The title of the column menu icon\"\n            columnMenu=\"Column Menu\"\n\n            i18n-columns=\"kendo.grid.columns|The text shown in the column menu for the columns item\"\n            columns=\"Columns\"\n\n            i18n-lock=\"kendo.grid.lock|The text shown in the column menu for the lock item\"\n            lock=\"Lock\"\n\n            i18n-unlock=\"kendo.grid.unlock|The text shown in the column menu for the unlock item\"\n            unlock=\"Unlock\"\n\n            i18n-sortable=\"kendo.grid.sortable|The label of the sort icon\"\n            sortable=\"Sortable\"\n\n            i18n-sortAscending=\"kendo.grid.sortAscending|The text shown in the column menu for the sort ascending item\"\n            sortAscending=\"Sort Ascending\"\n\n            i18n-sortDescending=\"kendo.grid.sortDescending|The text shown in the column menu for the sort descending item\"\n            sortDescending=\"Sort Descending\"\n\n            i18n-sortedAscending=\"kendo.grid.sortedAscending|The status announcement when a column is sorted ascending\"\n            sortedAscending=\"Sorted Ascending\"\n\n            i18n-sortedDescending=\"kendo.grid.sortedDescending|The status announcement when a column is sorted descending\"\n            sortedDescending=\"Sorted Descending\"\n\n            i18n-sortedDefault=\"kendo.grid.sortedDefault|The status announcement when a column is no longer sorted\"\n            sortedDefault=\"Not Sorted\"\n\n            i18n-columnsApply=\"kendo.grid.columnsApply|The text shown in the column menu or column chooser for the columns apply button\"\n            columnsApply=\"Apply\"\n\n            i18n-columnsReset=\"kendo.grid.columnsReset|The text shown in the column menu or column chooser for the columns reset button\"\n            columnsReset=\"Reset\"\n\n            i18n-detailExpand=\"kendo.grid.detailExpand|The title of the expand icon of detail rows.\"\n            detailExpand=\"Expand Details\"\n\n            i18n-detailCollapse=\"kendo.grid.detailCollapse|The title of the collapse icon of detail rows.\"\n            detailCollapse=\"Collapse Details\"\n         >\n        </ng-container>\n        <kendo-grid-toolbar *ngIf=\"showTopToolbar\" position=\"top\"></kendo-grid-toolbar>\n        <kendo-grid-group-panel\n            *ngIf=\"showGroupPanel\"\n            [text]=\"groupableEmptyText\"\n            [groups]=\"group\"\n            (change)=\"groupChange.emit($event)\">\n        </kendo-grid-group-panel>\n        <div #ariaRoot\n            class=\"k-grid-aria-root\"\n            role=\"grid\"\n            [attr.aria-rowcount]=\"ariaRowCount\"\n            [attr.aria-colcount]=\"ariaColCount\">\n        <ng-template [ngIf]=\"isScrollable\">\n            <div *ngIf=\"!hideHeader\"\n                class=\"k-grid-header\"\n                role=\"presentation\"\n                [style.padding]=\"headerPadding\">\n                <div *ngIf=\"isLocked\"\n                     #lockedHeader\n                     role=\"presentation\"\n                     class=\"k-grid-header-locked\"\n                     [style.width.px]=\"lockedWidth\">\n                    <table [locked]=\"true\" role=\"presentation\" [style.width.px]=\"lockedWidth\">\n                        <colgroup kendoGridColGroup\n                            role=\"presentation\"\n                            [columns]=\"lockedLeafColumns\"\n                            [groups]=\"group\"\n                            [detailTemplate]=\"detailTemplate\">\n                        </colgroup>\n                        <thead kendoGridHeader\n                            [resizable]=\"resizable\"\n                            [scrollable]=\"true\"\n                            [columns]=\"lockedColumns\"\n                            [totalColumnLevels]=\"totalColumnLevels\"\n                            [sort]=\"sort\"\n                            [groups]=\"group\"\n                            [filter]=\"filter\"\n                            [filterable]=\"filterable\"\n                            [groupable]=\"showGroupPanel\"\n                            [reorderable]=\"reorderable\"\n                            [sortable]=\"sortable\"\n                            [columnMenu]=\"columnMenuOptions\"\n                            [columnMenuTemplate]=\"columnMenuTemplate\"\n                            [totalColumnsCount]=\"leafColumns.length\"\n                            [detailTemplate]=\"detailTemplate\">\n                        </thead>\n                    </table>\n                </div><div #header class=\"k-grid-header-wrap\" role=\"presentation\" data-scrollable\n                    [kendoGridResizableContainer]=\"lockedLeafColumns.length\"\n                    [lockedWidth]=\"lockedWidth + scrollbarWidth + 2\">\n                    <table role=\"presentation\" [style.width.px]=\"nonLockedWidth\" [virtualColumns]=\"virtualColumns\">\n                        <colgroup kendoGridColGroup\n                            role=\"presentation\"\n                            [columns]=\"headerLeafColumns\"\n                            [groups]=\"isLocked ? [] : group\"\n                            [detailTemplate]=\"detailTemplate\">\n                        </colgroup>\n                        <thead kendoGridHeader\n                            [resizable]=\"resizable\"\n                            role=\"presentation\"\n                            [scrollable]=\"true\"\n                            [columns]=\"headerColumns\"\n                            [totalColumnLevels]=\"totalColumnLevels\"\n                            [sort]=\"sort\"\n                            [filter]=\"filter\"\n                            [filterable]=\"filterable\"\n                            [groupable]=\"showGroupPanel\"\n                            [reorderable]=\"reorderable\"\n                            [groups]=\"isLocked ? [] : group\"\n                            [sortable]=\"sortable\"\n                            [columnMenu]=\"columnMenuOptions\"\n                            [columnMenuTemplate]=\"columnMenuTemplate\"\n                            [lockedColumnsCount]=\"lockedLeafColumns.length\"\n                            [totalColumnsCount]=\"leafColumns.length\"\n                            [detailTemplate]=\"detailTemplate\">\n                        </thead>\n                    </table>\n                    <div *ngIf=\"virtualColumns\" class=\"k-width-container\" role=\"presentation\">\n                        <div [style.width.px]=\"columnsContainer.unlockedWidth\"></div>\n                    </div>\n                </div>\n            </div>\n            <kendo-grid-list\n                [data]=\"view\"\n                [rowHeight]=\"rowHeight\"\n                [detailRowHeight]=\"detailRowHeight\"\n                [total]=\"totalCount\"\n                [take]=\"pageSize\"\n                [groups]=\"group\"\n                [groupable]=\"groupable\"\n                [skip]=\"skip\"\n                [trackBy]=\"trackBy\"\n                [columns]=\"columnsContainer\"\n                [selectable]=\"selectable\"\n                [filterable]=\"filterable\"\n                [detailTemplate]=\"detailTemplate\"\n                [noRecordsTemplate]=\"noRecordsTemplate\"\n                (pageChange)=\"notifyPageChange('list', $event)\"\n                [rowClass]=\"rowClass\"\n                [loading]=\"loading\"\n                [isVirtual]=\"isVirtual\"\n                [virtualColumns]=\"virtualColumns\"\n                (scrollBottom)=\"notifyScrollBottom()\"\n                (contentScroll)=\"contentScroll.emit($event)\"\n                >\n            </kendo-grid-list>\n            <div\n                *ngIf=\"showFooter\"\n                class=\"k-grid-footer\"\n                [style.padding]=\"headerPadding\">\n                <div\n                    *ngIf=\"lockedLeafColumns.length\"\n                    class=\"k-grid-footer-locked\"\n                    [style.width.px]=\"lockedWidth\">\n                    <table [locked]=\"true\" [style.width.px]=\"lockedWidth\">\n                        <colgroup kendoGridColGroup\n                            [columns]=\"lockedLeafColumns\"\n                            [groups]=\"group\"\n                            [detailTemplate]=\"detailTemplate\">\n                        </colgroup>\n                        <tfoot kendoGridFooter\n                            [scrollable]=\"true\"\n                            [groups]=\"group\"\n                            [columns]=\"lockedLeafColumns\"\n                            [detailTemplate]=\"detailTemplate\">\n                        </tfoot>\n                    </table>\n                </div><div #footer\n                    class=\"k-grid-footer-wrap\" data-scrollable\n                    [kendoGridResizableContainer]=\"lockedLeafColumns.length\"\n                    [lockedWidth]=\"lockedWidth + scrollbarWidth + 3\">\n                    <table [style.width.px]=\"nonLockedWidth\">\n                        <colgroup kendoGridColGroup\n                            [columns]=\"nonLockedLeafColumns\"\n                            [groups]=\"isLocked ? [] : group\"\n                            [detailTemplate]=\"detailTemplate\">\n                        </colgroup>\n                        <tfoot kendoGridFooter\n                            [scrollable]=\"true\"\n                            [groups]=\"isLocked ? [] : group\"\n                            [columns]=\"nonLockedLeafColumns\"\n                            [lockedColumnsCount]=\"lockedLeafColumns.length\"\n                            [detailTemplate]=\"detailTemplate\">\n                        </tfoot>\n                    </table>\n                </div>\n            </div>\n        </ng-template>\n        <ng-template [ngIf]=\"!isScrollable\">\n            <table [style.table-layout]=\"resizable ? 'fixed' : null\">\n                <colgroup kendoGridColGroup\n                    [columns]=\"leafColumns\"\n                    [groups]=\"group\"\n                    [detailTemplate]=\"detailTemplate\">\n                </colgroup>\n                <thead kendoGridHeader\n                    *ngIf=\"!hideHeader\"\n                    [resizable]=\"resizable\"\n                    [scrollable]=\"false\"\n                    [columns]=\"visibleColumns\"\n                    [totalColumnLevels]=\"totalColumnLevels\"\n                    [groups]=\"group\"\n                    [groupable]=\"showGroupPanel\"\n                    [reorderable]=\"reorderable\"\n                    [sort]=\"sort\"\n                    [sortable]=\"sortable\"\n                    [filter]=\"filter\"\n                    [filterable]=\"filterable\"\n                    [columnMenu]=\"columnMenuOptions\"\n                    [columnMenuTemplate]=\"columnMenuTemplate\"\n                    [detailTemplate]=\"detailTemplate\">\n                </thead>\n                <tbody kendoGridTableBody\n                    [groups]=\"group\"\n                    [data]=\"view\"\n                    [skip]=\"skip\"\n                    [columns]=\"leafColumns\"\n                    [selectable]=\"selectable\"\n                    [filterable]=\"filterable\"\n                    [noRecordsTemplate]=\"noRecordsTemplate\"\n                    [detailTemplate]=\"detailTemplate\"\n                    [showGroupFooters]=\"showGroupFooters\"\n                    [trackBy]=\"trackBy\"\n                    [rowClass]=\"rowClass\">\n                </tbody>\n                <tfoot kendoGridFooter\n                    *ngIf=\"showFooter\"\n                    [scrollable]=\"false\"\n                    [groups]=\"group\"\n                    [columns]=\"leafColumns\"\n                    [detailTemplate]=\"detailTemplate\">\n                </tfoot>\n            </table>\n            <div *ngIf=\"loading\" kendoGridLoading>\n            </div>\n        </ng-template>\n        </div>\n        <kendo-pager\n            *ngIf=\"showPager\"\n            [template]=\"pagerTemplate\"\n            [pageSize]=\"pageSize\"\n            [total]=\"view.total\"\n            [skip]=\"skip\"\n            [options]=\"pageable\"\n            (pageChange)=\"notifyPageChange('pager', $event)\">\n        </kendo-pager>\n        <kendo-grid-toolbar *ngIf=\"showBottomToolbar\" position=\"bottom\"></kendo-grid-toolbar>\n    `\n            },] },\n];\n/** @nocollapse */\nGridComponent.ctorParameters = () => [\n    { type: BrowserSupportService },\n    { type: SelectionService },\n    { type: ElementRef },\n    { type: GroupInfoService },\n    { type: GroupsService },\n    { type: ChangeNotificationService },\n    { type: DetailsService },\n    { type: EditService },\n    { type: FilterService },\n    { type: PDFService },\n    { type: ResponsiveService },\n    { type: Renderer2 },\n    { type: ExcelService },\n    { type: NgZone },\n    { type: ScrollSyncService },\n    { type: DomEventsService },\n    { type: ColumnResizingService },\n    { type: ChangeDetectorRef },\n    { type: ColumnReorderService },\n    { type: ColumnInfoService },\n    { type: NavigationService },\n    { type: SortService },\n    { type: ScrollRequestService },\n    { type: LocalizationService }\n];\nGridComponent.propDecorators = {\n    data: [{ type: Input }],\n    pageSize: [{ type: Input }],\n    height: [{ type: Input }],\n    rowHeight: [{ type: Input }],\n    detailRowHeight: [{ type: Input }],\n    skip: [{ type: Input }],\n    scrollable: [{ type: Input }],\n    selectable: [{ type: Input }],\n    sort: [{ type: Input }],\n    trackBy: [{ type: Input }],\n    filter: [{ type: Input }],\n    group: [{ type: Input }],\n    virtualColumns: [{ type: Input }],\n    filterable: [{ type: Input }],\n    sortable: [{ type: Input }],\n    pageable: [{ type: Input }],\n    groupable: [{ type: Input }],\n    navigable: [{ type: Input }],\n    navigatable: [{ type: Input }],\n    autoSize: [{ type: Input }],\n    rowClass: [{ type: Input }],\n    rowSelected: [{ type: Input }],\n    resizable: [{ type: Input }],\n    reorderable: [{ type: Input }],\n    loading: [{ type: Input }],\n    columnMenu: [{ type: Input }],\n    hideHeader: [{ type: Input }],\n    filterChange: [{ type: Output }],\n    pageChange: [{ type: Output }],\n    groupChange: [{ type: Output }],\n    sortChange: [{ type: Output }],\n    selectionChange: [{ type: Output }],\n    dataStateChange: [{ type: Output }],\n    groupExpand: [{ type: Output }],\n    groupCollapse: [{ type: Output }],\n    detailExpand: [{ type: Output }],\n    detailCollapse: [{ type: Output }],\n    edit: [{ type: Output }],\n    cancel: [{ type: Output }],\n    save: [{ type: Output }],\n    remove: [{ type: Output }],\n    add: [{ type: Output }],\n    cellClose: [{ type: Output }],\n    cellClick: [{ type: Output }],\n    pdfExport: [{ type: Output }],\n    excelExport: [{ type: Output }],\n    columnResize: [{ type: Output }],\n    columnReorder: [{ type: Output }],\n    columnVisibilityChange: [{ type: Output }],\n    columnLockedChange: [{ type: Output }],\n    scrollBottom: [{ type: Output }],\n    contentScroll: [{ type: Output }],\n    columns: [{ type: ContentChildren, args: [ColumnBase$1,] }],\n    dir: [{ type: HostBinding, args: ['attr.dir',] }],\n    hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-grid',] }],\n    lockedClasses: [{ type: HostBinding, args: ['class.k-grid-lockedcolumns',] }],\n    virtualClasses: [{ type: HostBinding, args: ['class.k-grid-virtual',] }],\n    noScrollbarClass: [{ type: HostBinding, args: ['class.k-grid-no-scrollbar',] }],\n    detailTemplateChildren: [{ type: ContentChildren, args: [DetailTemplateDirective,] }],\n    noRecordsTemplateChildren: [{ type: ContentChildren, args: [NoRecordsTemplateDirective,] }],\n    pagerTemplateChildren: [{ type: ContentChildren, args: [PagerTemplateDirective,] }],\n    toolbarTemplateChildren: [{ type: ContentChildren, args: [ToolbarTemplateDirective,] }],\n    columnMenuTemplates: [{ type: ContentChildren, args: [ColumnMenuTemplateDirective,] }],\n    lockedHeader: [{ type: ViewChild, args: [\"lockedHeader\",] }],\n    header: [{ type: ViewChild, args: [\"header\",] }],\n    footer: [{ type: ViewChildren, args: [\"footer\",] }],\n    ariaRoot: [{ type: ViewChild, args: ['ariaRoot',] }]\n};\n\n/**\n * @hidden\n */\nconst update = (arr, idx, value) => ([\n    ...arr.slice(0, idx + 1),\n    ...(arr.slice(idx + 1).map(x => x + value))\n]);\n/**\n * @hidden\n */\nclass RowHeightService {\n    constructor(total = 0, rowHeight, detailRowHeight) {\n        this.total = total;\n        this.rowHeight = rowHeight;\n        this.detailRowHeight = detailRowHeight;\n        this.offsets = [];\n        this.heights = [];\n        let agg = 0;\n        for (let idx = 0; idx < total; idx++) {\n            this.offsets.push(agg);\n            agg += rowHeight;\n            this.heights.push(rowHeight);\n        }\n    }\n    height(rowIndex) {\n        return this.heights[rowIndex];\n    }\n    expandDetail(rowIndex) {\n        if (this.height(rowIndex) === this.rowHeight) {\n            this.updateRowHeight(rowIndex, this.detailRowHeight);\n        }\n    }\n    collapseDetail(rowIndex) {\n        if (this.height(rowIndex) > this.rowHeight) {\n            this.updateRowHeight(rowIndex, this.detailRowHeight * -1);\n        }\n    }\n    isExpanded(rowIndex) {\n        return this.height(rowIndex) > this.rowHeight;\n    }\n    index(position) {\n        if (position < 0) {\n            return undefined;\n        }\n        const result = this.offsets.reduce((prev, current, idx) => {\n            if (prev !== undefined) {\n                return prev;\n            }\n            else if (current === position) {\n                return idx;\n            }\n            else if (current > position) {\n                return idx - 1;\n            }\n            return undefined;\n        }, undefined); // tslint:disable-line:align\n        return result === undefined ? this.total - 1 : result;\n    }\n    offset(rowIndex) {\n        return this.offsets[rowIndex];\n    }\n    totalHeight() {\n        return this.heights.reduce((prev, curr) => prev + curr, 0);\n    }\n    updateRowHeight(rowIndex, value) {\n        if (this.total > 0) {\n            this.heights[rowIndex] += value;\n            this.offsets = update(this.offsets, rowIndex, value);\n        }\n    }\n}\n\n/**\n * @hidden\n */\nclass ScrollAction {\n    constructor(offset) {\n        this.offset = offset;\n    }\n}\n/**\n * @hidden\n */\nclass PageAction {\n    constructor(skip, take$$1) {\n        this.skip = skip;\n        this.take = take$$1;\n    }\n}\n/**\n * @hidden\n */\nclass ScrollBottomAction {\n}\nconst SCROLL_BOTTOM_THRESHOLD = 1;\n/**\n * @hidden\n */\nclass ScrollerService {\n    constructor(scrollObservable) {\n        this.scrollObservable = scrollObservable;\n        this.firstLoaded = 0;\n    }\n    create(rowHeightService, skip, take$$1, total) {\n        this.rowHeightService = rowHeightService;\n        this.firstLoaded = skip;\n        this.lastLoaded = skip + take$$1;\n        this.take = take$$1;\n        this.total = total;\n        this.lastScrollTop = 0;\n        const subject = new BehaviorSubject(new ScrollAction(this.rowHeightService.offset(skip)));\n        this.subscription = Observable.create(observer => {\n            this.unsubscribe();\n            this.scrollSubscription = this.scrollObservable.subscribe(x => this.onScroll(x, observer));\n        }).subscribe(x => subject.next(x));\n        return subject;\n    }\n    destroy() {\n        this.unsubscribe();\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n        }\n    }\n    onScroll({ scrollTop, offsetHeight, scrollHeight, clientHeight }, observer) {\n        if (this.lastScrollTop === scrollTop) {\n            return;\n        }\n        const up = this.lastScrollTop >= scrollTop;\n        this.lastScrollTop = scrollTop;\n        let firstItemIndex = this.rowHeightService.index(scrollTop);\n        let firstItemOffset = this.rowHeightService.offset(firstItemIndex);\n        const lastItemIndex = this.rowHeightService.index(scrollTop + offsetHeight);\n        if (!up) {\n            if (lastItemIndex >= this.lastLoaded && this.lastLoaded < this.total) {\n                const overflow = (firstItemIndex + this.take) - this.total;\n                if (overflow > 0) {\n                    firstItemIndex = firstItemIndex - overflow;\n                    firstItemOffset = this.rowHeightService.offset(firstItemIndex);\n                }\n                this.firstLoaded = firstItemIndex;\n                observer.next(new ScrollAction(firstItemOffset));\n                let nextTake = this.firstLoaded + this.take;\n                this.lastLoaded = Math.min(nextTake, this.total);\n                nextTake = nextTake > this.total ? this.total - this.firstLoaded : this.take;\n                observer.next(new PageAction(this.firstLoaded, this.take));\n            }\n            else {\n                const atBottom = scrollHeight - clientHeight - scrollTop < SCROLL_BOTTOM_THRESHOLD;\n                if (atBottom) {\n                    observer.next(new ScrollBottomAction());\n                }\n            }\n        }\n        if (up && firstItemIndex < this.firstLoaded) {\n            const nonVisibleBuffer = Math.floor(this.take * 0.3);\n            this.firstLoaded = Math.max(firstItemIndex - nonVisibleBuffer, 0);\n            observer.next(new ScrollAction(this.rowHeightService.offset(this.firstLoaded)));\n            this.lastLoaded = Math.min(this.firstLoaded + this.take, this.total);\n            observer.next(new PageAction(this.firstLoaded, this.take));\n        }\n    }\n    unsubscribe() {\n        if (this.scrollSubscription) {\n            this.scrollSubscription.unsubscribe();\n            this.scrollSubscription = undefined;\n        }\n    }\n}\n\n/**\n * @hidden\n */\nconst NON_DATA_CELL_CLASSES = 'k-hierarchy-cell k-detail-cell k-group-cell';\n/**\n * @hidden\n */\nconst NON_DATA_ROW_CLASSES = 'k-grouping-row k-group-footer k-detail-row k-grid-norecords';\n/**\n * @hidden\n */\nconst IGNORE_TARGET_CLASSSES = 'k-icon';\n/**\n * @hidden\n */\nconst IGNORE_CONTAINER_CLASSES = 'k-widget k-grid-ignore-click';\n\nconst elementAt = (index, elements, elementOffset) => {\n    for (let idx = 0, elementIdx = 0; idx < elements.length; idx++) {\n        const offset = elementOffset(elements[idx]);\n        if (elementIdx <= index && index <= elementIdx + offset - 1) {\n            return elements[idx];\n        }\n        elementIdx += offset;\n    }\n};\nconst rowAt = (index, rows) => elementAt(index, rows, row => row.hasAttribute('data-kendo-grid-item-index') ? 1 : 0);\nconst cellAt = (index, cells) => elementAt(index, cells, cell => !hasClasses(cell, NON_DATA_CELL_CLASSES) ? parseInt(cell.getAttribute('colSpan'), 10) || 1 : 0);\nconst EMPTY_OBJECT = {};\n/**\n * @hidden\n */\nconst SCROLLER_FACTORY_TOKEN = new InjectionToken('grid-scroll-service-factory');\n/**\n * @hidden\n */\nfunction DEFAULT_SCROLLER_FACTORY(observable) {\n    return new ScrollerService(observable);\n}\nconst wheelDeltaY = (e) => {\n    const deltaY = e.wheelDeltaY;\n    if (e.wheelDelta && (deltaY === undefined || deltaY)) {\n        return e.wheelDelta;\n    }\n    else if (e.detail && e.axis === e.VERTICAL_AXIS) {\n        return (-e.detail) * 10;\n    }\n    return 0;\n};\nconst preventLockedScroll = (args, element) => {\n    const delta = wheelDeltaY(args);\n    const scrollTop = element.scrollTop;\n    const allowScroll = (scrollTop === 0 && 0 < delta) || (element.scrollHeight <= element.offsetHeight + scrollTop && delta < 0);\n    if (!allowScroll) {\n        event.preventDefault();\n    }\n};\nconst translateY = (renderer, value) => el => renderer.setStyle(el, \"transform\", `translateY(${value}px)`);\nconst maybeNativeElement = el => el ? el.nativeElement : null;\nconst hasScrollbar = (el, parent) => el.nativeElement.offsetWidth > parent.nativeElement.clientWidth;\nconst setHeight$1 = renderer => ({ el, height }) => renderer.setStyle(el, \"height\", `${height}px`);\nconst bufferSize = 1;\n/**\n * @hidden\n */\nclass ListComponent {\n    constructor(scrollerFactory, detailsService, changeNotification, suspendService, groupsService, ngZone, renderer, scrollSyncService, resizeService, editService, supportService, navigationService, scrollRequestService, localization, columnResizingService, changeDetector, pdfService, columnInfo) {\n        this.changeNotification = changeNotification;\n        this.suspendService = suspendService;\n        this.groupsService = groupsService;\n        this.ngZone = ngZone;\n        this.renderer = renderer;\n        this.scrollSyncService = scrollSyncService;\n        this.resizeService = resizeService;\n        this.editService = editService;\n        this.supportService = supportService;\n        this.navigationService = navigationService;\n        this.localization = localization;\n        this.columnResizingService = columnResizingService;\n        this.changeDetector = changeDetector;\n        this.pdfService = pdfService;\n        this.columnInfo = columnInfo;\n        this.groups = [];\n        this.skip = 0;\n        this.columns = new ColumnsContainer(() => []);\n        this.selectable = false;\n        this.groupable = false;\n        this.trackBy = defaultTrackBy;\n        this.contentScroll = new EventEmitter();\n        this.pageChange = new EventEmitter();\n        this.scrollBottom = new EventEmitter();\n        this.columnsStartIdx = 0;\n        this.resizeSensors = new QueryList();\n        this.dispatcher = new Subject();\n        this.containerScrollTop = 0;\n        this.scrollLeft = 0;\n        this.rtl = false;\n        this.scroller = scrollerFactory(this.dispatcher);\n        this.subscriptions =\n            detailsService.changes.subscribe(x => this.detailExpand(x)).add(scrollRequestService.requests.subscribe(x => this.scrollTo(x)));\n    }\n    get hostClass() {\n        return true;\n    }\n    get hostRole() {\n        return 'presentation';\n    }\n    get showFooter() {\n        return this.groupable && this.groupable.showFooter;\n    }\n    get totalWidth() {\n        if (this.virtualColumns && this.columns.unlockedWidth) {\n            return this.columns.unlockedWidth;\n        }\n    }\n    get lockedLeafColumns() {\n        return this.columns.lockedLeafColumns;\n    }\n    get nonLockedLeafColumns() {\n        return this.columns.nonLockedLeafColumns;\n    }\n    get nonLockedColumnsToRender() {\n        if (this.virtualColumns && !this.pdfService.exporting) {\n            return this.viewportColumns;\n        }\n        return this.nonLockedLeafColumns;\n    }\n    get leafColumns() {\n        return this.columns.leafColumnsToRender;\n    }\n    get lockedWidth() {\n        const groupCellsWidth = this.groups.length * GROUP_CELL_WIDTH;\n        return expandColumns(this.lockedLeafColumns.toArray()).reduce((prev, curr) => prev + (curr.width || 0), groupCellsWidth);\n    }\n    get nonLockedWidth() {\n        if ((!this.rtl && this.lockedLeafColumns.length) || this.virtualColumns) {\n            return sumColumnWidths(expandColumns(this.nonLockedColumnsToRender.toArray()));\n        }\n        return undefined;\n    }\n    get isLocked() {\n        return this.lockedLeafColumns.length > 0;\n    }\n    ngOnInit() {\n        this.init();\n        this.subscriptions.add(this.ngZone.runOutsideAngular(this.handleRowSync.bind(this)));\n        this.subscriptions.add(this.ngZone.runOutsideAngular(this.handleRowNavigationLocked.bind(this)));\n        this.subscriptions.add(merge(this.columns.changes, this.resizeService.changes).subscribe(() => {\n            if (this.virtualColumns) {\n                this.ngZone.run(() => {\n                    this.updateViewportColumns();\n                    this.changeDetector.markForCheck();\n                });\n            }\n        }));\n        this.subscriptions.add(this.localization.changes.subscribe(({ rtl }) => this.rtl = rtl));\n    }\n    ngOnChanges(changes) {\n        if (isChanged(\"skip\", changes) && !this.rebind) {\n            this.skipScroll = true;\n            this.container.nativeElement.scrollTop = this.rowHeightService.offset(this.skip);\n        }\n        if (anyChanged([\"total\", \"take\"], changes)) {\n            this.init();\n        }\n        this.rebind = false;\n    }\n    ngDoCheck() {\n        if (this.virtualColumns && (!this.viewportColumns || this.viewportWidthChange())) {\n            this.updateViewportColumns();\n        }\n    }\n    ngAfterViewInit() {\n        if (this.skip && this.isVirtual) {\n            this.container.nativeElement.scrollTop = this.rowHeightService.offset(this.skip);\n        }\n        this.resetNavigationViewport();\n        this.attachContainerScroll();\n        this.initResizeService();\n    }\n    ngAfterViewChecked() {\n        const isLocked = this.isLocked;\n        if (isLocked && !this.hasLockedContainer) {\n            this.syncRowsHeight();\n        }\n        this.hasLockedContainer = isLocked;\n    }\n    syncRowsHeight() {\n        if (this.lockedContainer) {\n            syncRowsHeight(this.lockedTable.nativeElement, this.table.nativeElement);\n        }\n    }\n    ngOnDestroy() {\n        if (this.subscriptions) {\n            this.subscriptions.unsubscribe();\n        }\n        if (this.resizeService) {\n            this.resizeService.destroy();\n        }\n        this.cleanupScroller();\n    }\n    init() {\n        if (this.suspendService.scroll) {\n            return;\n        }\n        this.rowHeightService = new RowHeightService(this.total, this.rowHeight, this.detailRowHeight);\n        this.totalHeight = this.rowHeightService.totalHeight();\n        if (!isUniversal()) {\n            this.ngZone.runOutsideAngular(this.createScroller.bind(this));\n        }\n    }\n    lockedScroll() {\n        if (!this.suspendService.scroll) {\n            const lockedScrollTop = this.lockedContainer.nativeElement.scrollTop;\n            if (lockedScrollTop !== this.containerScrollTop) {\n                this.container.nativeElement.scrollTop = this.containerScrollTop = lockedScrollTop;\n            }\n        }\n    }\n    lockedMousewheel(args) {\n        if (!args.ctrlKey) {\n            preventLockedScroll(args, this.container.nativeElement);\n            const scrollDelta = wheelDeltaY(args);\n            this.container.nativeElement.scrollTop -= scrollDelta;\n        }\n    }\n    lockedKeydown(args) {\n        if (args.keyCode === Keys.PageDown || args.keyCode === Keys.PageUp) {\n            const dir = args.keyCode === Keys.PageDown ? 1 : -1;\n            const element = this.container.nativeElement;\n            element.scrollTop += element.offsetHeight * dir * 0.8;\n            args.preventDefault();\n        }\n    }\n    detailExpand({ index, expand }) {\n        if (expand) {\n            this.rowHeightService.expandDetail(index);\n        }\n        else {\n            this.rowHeightService.collapseDetail(index);\n        }\n        this.totalHeight = this.rowHeightService.totalHeight();\n        this.resetNavigationViewport();\n    }\n    attachContainerScroll() {\n        if (isUniversal()) {\n            return;\n        }\n        this.ngZone.runOutsideAngular(() => {\n            this.subscriptions.add(fromEvent(this.container.nativeElement, 'scroll').pipe(map((event) => event.target), filter(() => !this.suspendService.scroll), tap((target) => {\n                this.onContainerScroll(target);\n                this.resetNavigationViewport();\n                if (this.virtualColumns) {\n                    this.handleColumnScroll();\n                }\n                const rowViewport = this.navigationService.viewport || EMPTY_OBJECT;\n                const columnViewport = this.navigationService.columnViewport || EMPTY_OBJECT;\n                this.contentScroll.emit({\n                    scrollLeft: target.scrollLeft,\n                    scrollTop: target.scrollTop,\n                    startRow: rowViewport.firstItemIndex,\n                    endRow: rowViewport.lastItemIndex,\n                    startColumn: columnViewport.firstItemIndex,\n                    endColumn: columnViewport.lastItemIndex\n                });\n            })).subscribe(this.dispatcher));\n        });\n        this.scrollSyncService.registerEmitter(this.container.nativeElement, \"body\");\n    }\n    createScroller() {\n        this.cleanupScroller();\n        const observable = this.scroller\n            .create(this.rowHeightService, this.skip, this.take, this.total);\n        this.skipScroll = false;\n        this.scrollerSubscription = observable.pipe(filter((x) => x instanceof PageAction), filter(() => {\n            const temp = this.skipScroll;\n            this.skipScroll = false;\n            return !temp;\n        }), tap(() => this.rebind = true))\n            .subscribe((x) => this.ngZone.run(() => this.pageChange.emit(x)));\n        this.scrollerSubscription.add(observable.pipe(filter((x) => x instanceof ScrollAction))\n            .subscribe(this.scroll.bind(this)));\n        this.scrollerSubscription.add(observable.pipe(filter((x) => x instanceof ScrollBottomAction))\n            .subscribe(() => this.scrollBottom.emit()));\n    }\n    scroll({ offset = 0 }) {\n        if (this.isVirtual) {\n            [\n                maybeNativeElement(this.table),\n                maybeNativeElement(this.lockedTable)\n            ].filter(isPresent).forEach(translateY(this.renderer, offset));\n        }\n        this.resetNavigationViewport();\n    }\n    onContainerScroll({ scrollTop }) {\n        this.containerScrollTop = scrollTop;\n        if (this.lockedContainer) {\n            this.lockedContainer.nativeElement.scrollTop = scrollTop;\n        }\n    }\n    handleRowSync() {\n        const isLocked = () => isPresent(this.lockedContainer);\n        const onStable = () => this.ngZone.onStable.asObservable().pipe(take(1));\n        return merge(this.changeNotification.changes, this.groupsService.changes\n            .pipe(filter(isLocked), switchMapTo(onStable())), this.editService.changed, this.resizeService.changes, this.columnResizingService.changes\n            .pipe(filter(change => change.type === 'end')), this.supportService.changes)\n            .pipe(tap(() => this.resetNavigationViewport()), filter(isLocked))\n            .subscribe(() => {\n            const scrollTop = this.container.nativeElement.scrollTop;\n            const scrollLeft = this.container.nativeElement.scrollLeft;\n            this.syncRowsHeight();\n            this.syncContainerHeight();\n            this.lockedContainer.nativeElement.scrollTop = this.container.nativeElement.scrollTop = scrollTop;\n            // fixes scroll left position in IE when editing\n            this.container.nativeElement.scrollLeft = scrollLeft;\n            this.resizeSensors.forEach(sensor => sensor.acceptSize());\n        });\n    }\n    handleRowNavigationLocked() {\n        return this.navigationService.changes.pipe(filter(() => isPresent(this.lockedContainer)), delay(10)).subscribe((args) => {\n            if (this.lockedLeafColumns.length <= args.prevColIndex && args.colIndex < this.lockedLeafColumns.length) {\n                const cell = this.navigationService.activeCell;\n                if (cell && cell.colIndex + cell.colSpan < args.prevColIndex) {\n                    this.container.nativeElement.scrollLeft = 0;\n                }\n            }\n        });\n    }\n    scrollToVirtualRow(itemIndex) {\n        if (isPresent(this.detailTemplate)) {\n            itemIndex = Math.floor(itemIndex / 2);\n        }\n        const offset = this.rowHeightService.offset(itemIndex);\n        this.container.nativeElement.scrollTop = offset;\n        this.resetNavigationViewport();\n    }\n    scrollTo({ row, column }) {\n        if (isNumber(row)) {\n            if (this.isVirtual) {\n                this.scrollToVirtualRow(row);\n            }\n            else {\n                const element = rowAt(row, this.table.nativeElement.rows);\n                if (element) {\n                    this.container.nativeElement.scrollTop = element.offsetTop;\n                }\n            }\n        }\n        if (isNumber(column)) {\n            column -= this.lockedLeafColumns.length;\n            if (this.virtualColumns) {\n                const columns = this.columns.leafColumnsToRender;\n                let offset = 0;\n                for (let idx = 0; idx < column; idx++) {\n                    offset += columns[idx].width || 0;\n                }\n                const startOffset = this.lockedLeafColumns.length ? 0 : this.groups.length * GROUP_CELL_WIDTH + (this.detailTemplate && column > 0 ? GROUP_CELL_WIDTH : 0);\n                this.container.nativeElement.scrollLeft = this.normalizeScrollLeft(offset + startOffset);\n            }\n            else if (column === 0 && this.detailTemplate) {\n                this.container.nativeElement.scrollLeft = this.normalizeScrollLeft(0);\n            }\n            else {\n                const firstRow = rowAt(0, this.table.nativeElement.rows);\n                if (firstRow) {\n                    const element = cellAt(column, firstRow.cells);\n                    if (element) {\n                        this.container.nativeElement.scrollLeft = this.elementScrollLeft(element);\n                    }\n                }\n            }\n        }\n    }\n    resetNavigationViewport() {\n        if (!this.container || !this.navigationService.enabled ||\n            !this.navigationService.needsViewport() || this.data.length === 0) {\n            return;\n        }\n        const { scrollTop, offsetHeight } = this.container.nativeElement;\n        const scrollBottom = scrollTop + offsetHeight;\n        const firstItemIndex = this.rowHeightService.index(scrollTop);\n        let lastItemIndex = this.rowHeightService.index(scrollBottom);\n        const lastItemOffset = this.rowHeightService.offset(lastItemIndex);\n        const lastItemOverflows = lastItemOffset + this.rowHeight > scrollBottom;\n        if (lastItemIndex > 0 && lastItemOverflows) {\n            lastItemIndex--;\n        }\n        let viewportStart = firstItemIndex;\n        let viewportEnd = lastItemIndex;\n        if (isPresent(this.detailTemplate)) {\n            viewportStart *= 2;\n            viewportEnd *= 2;\n            const firstItemHeight = this.rowHeightService.offset(firstItemIndex);\n            if (firstItemHeight + this.rowHeight < scrollTop) {\n                viewportStart++;\n            }\n            const lastItemHeight = this.rowHeightService.height(lastItemIndex);\n            const lastItemExpanded = this.rowHeightService.isExpanded(lastItemIndex);\n            const lastItemDetailOverflows = lastItemOffset + lastItemHeight > scrollBottom;\n            if (lastItemExpanded && !lastItemDetailOverflows) {\n                viewportEnd++;\n            }\n        }\n        this.navigationService.setViewport(viewportStart, viewportEnd);\n    }\n    cleanupScroller() {\n        if (this.scrollerSubscription) {\n            this.scrollerSubscription.unsubscribe();\n        }\n        if (this.scroller) {\n            this.scroller.destroy();\n        }\n    }\n    initResizeService() {\n        this.resizeService.connect(merge(...this.resizeSensors.map(sensor => sensor.resize)));\n    }\n    syncContainerHeight() {\n        [maybeNativeElement(this.lockedContainer)]\n            .filter(isPresent)\n            .map(el => {\n            el.style.height = '';\n            let height = this.container.nativeElement.offsetHeight;\n            if (hasScrollbar(this.table, this.container)) {\n                height -= this.supportService.scrollbarWidth;\n            }\n            return { el, height };\n        })\n            .forEach(setHeight$1(this.renderer));\n    }\n    updateViewportColumns(range) {\n        const columns = this.columns.nonLockedLeafColumns.toArray();\n        let { startIdx, endIdx, offset } = range || this.calculateViewportColumns();\n        const start = Math.max(0, startIdx - bufferSize);\n        const end = Math.min(endIdx + bufferSize, columns.length - 1);\n        if (start < startIdx) {\n            for (let idx = startIdx - 1; idx >= start; idx--) {\n                offset -= columns[idx].width;\n            }\n        }\n        let currentColumns = columns.slice(start, end + 1);\n        this.viewportColumnsWidth = currentColumns.reduce((total, column) => total + column.width, 0);\n        if (start > 0) {\n            const offsetColumn = new ColumnBase$1();\n            offsetColumn.width = offset;\n            currentColumns.unshift(offsetColumn);\n        }\n        this.viewportColumns = new QueryList();\n        this.viewportColumns.reset(currentColumns);\n        this.columnsStartIdx = start;\n        this.columnsEndIdx = end;\n        this.columnInfo.columnRangeChange.emit({ start, end, offset });\n        if (!range) {\n            this.updateColumnViewport(startIdx, endIdx);\n        }\n    }\n    handleColumnScroll() {\n        const container = this.container.nativeElement;\n        const scrollLeft = container.scrollLeft;\n        if (this.scrollLeft !== scrollLeft) {\n            this.scrollLeft = scrollLeft;\n            const range = this.calculateViewportColumns();\n            this.updateColumnViewport(range.startIdx, range.endIdx);\n            if (range.startIdx < this.columnsStartIdx || this.columnsEndIdx < range.endIdx) {\n                cancelAnimationFrame(this.columnUpdateFrame);\n                this.columnUpdateFrame = requestAnimationFrame(() => {\n                    this.ngZone.run(() => {\n                        this.updateViewportColumns(range);\n                        this.changeDetector.markForCheck();\n                    });\n                });\n            }\n        }\n    }\n    updateColumnViewport(startIdx, endIdx) {\n        const lockedCount = this.lockedLeafColumns.length;\n        const leafColumns$$1 = this.nonLockedLeafColumns.toArray();\n        const viewportStart = lockedCount + startIdx + (this.detailTemplate && startIdx > 0 ? 1 : 0);\n        let viewportEnd = lockedCount + endIdx + (this.detailTemplate ? 1 : 0);\n        for (let idx = 0; idx < leafColumns$$1.length; idx++) {\n            const column = leafColumns$$1[idx];\n            if (column.isSpanColumn) {\n                viewportEnd += column.childColumns.length;\n            }\n        }\n        this.navigationService.setColumnViewport(viewportStart, viewportEnd);\n    }\n    calculateViewportColumns() {\n        const { scrollLeft, clientWidth } = this.container.nativeElement;\n        const columns = this.columns.nonLockedLeafColumns.toArray();\n        const normalizedScrollLeft = this.normalizeScrollLeft(scrollLeft);\n        const viewportEnd = normalizedScrollLeft + clientWidth;\n        let startIdx;\n        let endIdx = 0;\n        let current = 0;\n        let offset = 0;\n        let idx;\n        for (idx = 0; idx < columns.length; idx++) {\n            const column = columns[idx];\n            current += column.width || 0;\n            if (startIdx === undefined && current > normalizedScrollLeft) {\n                startIdx = idx;\n                offset = current - (column.width || 0);\n            }\n            if (current >= viewportEnd) {\n                endIdx = idx;\n                break;\n            }\n        }\n        if (!endIdx && idx > 0) {\n            endIdx = columns.length - 1;\n        }\n        return { startIdx, endIdx, offset };\n    }\n    viewportWidthChange() {\n        const currentWidth = this.viewportColumns.toArray().reduce((total, column) => total + column.width, 0);\n        return currentWidth !== this.viewportColumnsWidth;\n    }\n    normalizeScrollLeft(position) {\n        return this.rtl ? rtlScrollPosition(position, this.container.nativeElement, this.supportService.rtlScrollLeft) : position;\n    }\n    elementScrollLeft(element) {\n        if (this.rtl) {\n            return this.normalizeScrollLeft(this.container.nativeElement.scrollWidth - element.offsetLeft - element.offsetWidth);\n        }\n        return element.offsetLeft;\n    }\n}\nListComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: SCROLLER_FACTORY_TOKEN,\n                        useValue: DEFAULT_SCROLLER_FACTORY\n                    }\n                ],\n                selector: 'kendo-grid-list',\n                template: `\n    <div #lockedContainer class=\"k-grid-content-locked\" role=\"presentation\"\n        *ngIf=\"isLocked\" [style.width.px]=\"lockedWidth\"\n        [kendoEventsOutsideAngular]=\"{\n            keydown: lockedKeydown,\n            scroll: lockedScroll,\n            mousewheel: lockedMousewheel,\n            DOMMouseScroll: lockedMousewheel\n        }\"\n        [scope]=\"this\"\n        >\n        <div role=\"presentation\" class=\"k-grid-table-wrap\">\n            <table [locked]=\"true\" #lockedTable class=\"k-grid-table\" role=\"presentation\" [style.width.px]=\"lockedWidth\">\n                <colgroup kendoGridColGroup\n                    role=\"presentation\"\n                    [groups]=\"groups\"\n                    [columns]=\"lockedLeafColumns\"\n                    [detailTemplate]=\"detailTemplate\">\n                </colgroup>\n                <tbody kendoGridTableBody\n                    role=\"presentation\"\n                    [groups]=\"groups\"\n                    [isLocked]=\"true\"\n                    [data]=\"data\"\n                    [noRecordsText]=\"''\"\n                    [columns]=\"lockedLeafColumns\"\n                    [totalColumnsCount]=\"leafColumns.length\"\n                    [detailTemplate]=\"detailTemplate\"\n                    [showGroupFooters]=\"showFooter\"\n                    [skip]=\"skip\"\n                    [selectable]=\"selectable\"\n                    [trackBy]=\"trackBy\"\n                    [filterable]=\"filterable\"\n                    [rowClass]=\"rowClass\">\n                </tbody>\n            </table>\n            <kendo-resize-sensor></kendo-resize-sensor>\n        </div>\n        <div class=\"k-height-container\" role=\"presentation\">\n            <div [style.height.px]=\"totalHeight\"></div>\n        </div>\n    </div><div #container\n               class=\"k-grid-content k-virtual-content\"\n               role=\"presentation\" tabindex=\"-1\"\n               [kendoGridResizableContainer]=\"lockedLeafColumns.length\"\n               [lockedWidth]=\"lockedWidth + 1\">\n        <div role=\"presentation\" class=\"k-grid-table-wrap\">\n            <table [style.width.px]=\"nonLockedWidth\" #table [virtualColumns]=\"virtualColumns\"\n              class=\"k-grid-table\" role=\"presentation\">\n                <colgroup kendoGridColGroup\n                    role=\"presentation\"\n                    [groups]=\"isLocked ? [] : groups\"\n                    [columns]=\"nonLockedColumnsToRender\"\n                    [detailTemplate]=\"detailTemplate\">\n                </colgroup>\n                <tbody kendoGridTableBody\n                    role=\"presentation\"\n                    [skipGroupDecoration]=\"isLocked\"\n                    [data]=\"data\"\n                    [groups]=\"groups\"\n                    [showGroupFooters]=\"showFooter\"\n                    [columns]=\"nonLockedColumnsToRender\"\n                    [allColumns]=\"nonLockedLeafColumns\"\n                    [detailTemplate]=\"detailTemplate\"\n                    [noRecordsTemplate]=\"noRecordsTemplate\"\n                    [lockedColumnsCount]=\"lockedLeafColumns.length\"\n                    [totalColumnsCount]=\"leafColumns.length\"\n                    [skip]=\"skip\"\n                    [selectable]=\"selectable\"\n                    [trackBy]=\"trackBy\"\n                    [filterable]=\"filterable\"\n                    [rowClass]=\"rowClass\"\n                    [virtualColumns]=\"virtualColumns\">\n                </tbody>\n            </table>\n            <kendo-resize-sensor *ngIf=\"isLocked\"></kendo-resize-sensor>\n        </div>\n        <kendo-resize-sensor *ngIf=\"isLocked || virtualColumns\"></kendo-resize-sensor>\n        <div class=\"k-height-container\" role=\"presentation\">\n            <div [style.height.px]=\"totalHeight\"></div>\n        </div>\n        <div *ngIf=\"virtualColumns\" class=\"k-width-container\" role=\"presentation\">\n            <div [style.width.px]=\"totalWidth\"></div>\n        </div>\n    </div>\n    <div *ngIf=\"loading\" kendoGridLoading>\n    </div>\n    `\n            },] },\n];\n/** @nocollapse */\nListComponent.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [SCROLLER_FACTORY_TOKEN,] }] },\n    { type: DetailsService },\n    { type: ChangeNotificationService },\n    { type: SuspendService },\n    { type: GroupsService },\n    { type: NgZone },\n    { type: Renderer2 },\n    { type: ScrollSyncService },\n    { type: ResizeService },\n    { type: EditService },\n    { type: BrowserSupportService },\n    { type: NavigationService },\n    { type: ScrollRequestService },\n    { type: LocalizationService },\n    { type: ColumnResizingService },\n    { type: ChangeDetectorRef },\n    { type: PDFService },\n    { type: ColumnInfoService }\n];\nListComponent.propDecorators = {\n    hostClass: [{ type: HostBinding, args: [\"class.k-grid-container\",] }],\n    hostRole: [{ type: HostBinding, args: [\"attr.role\",] }],\n    data: [{ type: Input }],\n    groups: [{ type: Input }],\n    total: [{ type: Input }],\n    rowHeight: [{ type: Input }],\n    detailRowHeight: [{ type: Input }],\n    take: [{ type: Input }],\n    skip: [{ type: Input }],\n    columns: [{ type: Input }],\n    detailTemplate: [{ type: Input }],\n    noRecordsTemplate: [{ type: Input }],\n    selectable: [{ type: Input }],\n    groupable: [{ type: Input }],\n    filterable: [{ type: Input }],\n    rowClass: [{ type: Input }],\n    loading: [{ type: Input }],\n    trackBy: [{ type: Input }],\n    virtualColumns: [{ type: Input }],\n    isVirtual: [{ type: Input }],\n    contentScroll: [{ type: Output }],\n    pageChange: [{ type: Output }],\n    scrollBottom: [{ type: Output }],\n    container: [{ type: ViewChild, args: [\"container\", { static: true },] }],\n    lockedContainer: [{ type: ViewChild, args: [\"lockedContainer\",] }],\n    lockedTable: [{ type: ViewChild, args: [\"lockedTable\",] }],\n    table: [{ type: ViewChild, args: [\"table\",] }],\n    resizeSensors: [{ type: ViewChildren, args: [ResizeSensorComponent,] }]\n};\n\n/**\n * A directive which encapsulates the in-memory handling of data operations such as [paging]({% slug paging_grid %}),\n * [sorting]({% slug sorting_grid %}), and [grouping]({% slug groupingbasics_grid %})\n * ([more information and examples]({% slug automaticoperations_grid %})).\n */\nclass DataBindingDirective {\n    constructor(grid, changeDetector, localDataChangesService) {\n        this.grid = grid;\n        this.changeDetector = changeDetector;\n        this.localDataChangesService = localDataChangesService;\n        this.state = {\n            skip: 0\n        };\n        this.originalData = [];\n        if (localDataChangesService) {\n            this.dataChangedSubscription = this.localDataChangesService.changes.subscribe(this.rebind.bind(this));\n        }\n    }\n    /**\n     * Defines the number of records that will be skipped by the pager.\n     */\n    set skip(value) {\n        if (!isPresent(value)) {\n            value = 0;\n        }\n        this.grid.skip = this.state.skip = value;\n    }\n    /**\n     * Defines the descriptors by which the data will be sorted.\n     */\n    set sort(value) {\n        this.grid.sort = this.state.sort = value;\n    }\n    /**\n     * Defines the descriptor by which the data will be filtered.\n     */\n    set filter(value) {\n        this.grid.filter = this.state.filter = value;\n    }\n    /**\n     * Defines the page size used by the Grid pager.\n     */\n    set pageSize(value) {\n        this.grid.pageSize = this.state.take = value;\n    }\n    /**\n     * The descriptors by which the data will be grouped.\n     */\n    set group(value) {\n        this.grid.group = this.state.group = value;\n    }\n    /**\n     * The array of data which will be used to populate the Grid.\n     */\n    set data(value) {\n        this.originalData = value || [];\n        if (this.localDataChangesService) {\n            this.localDataChangesService.data = value;\n        }\n        this.dataChanged = true;\n    }\n    /**\n     * @hidden\n     */\n    ngOnInit() {\n        this.applyState(this.state);\n        this.stateChangeSubscription = this.grid\n            .dataStateChange\n            .subscribe(this.onStateChange.bind(this));\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n        if (this.stateChangeSubscription) {\n            this.stateChangeSubscription.unsubscribe();\n        }\n        if (this.dataChangedSubscription) {\n            this.dataChangedSubscription.unsubscribe();\n        }\n    }\n    /**\n     * @hidden\n     */\n    ngOnChanges(changes) {\n        if (anyChanged([\"pageSize\", \"skip\", \"sort\", \"group\", \"filter\"], changes)) {\n            this.rebind();\n        }\n    }\n    ngDoCheck() {\n        if (this.dataChanged) {\n            this.updateGridData();\n        }\n    }\n    /**\n     * @hidden\n     */\n    onStateChange(state$$1) {\n        this.applyState(state$$1);\n        this.rebind();\n    }\n    /**\n     * @hidden\n     */\n    rebind() {\n        this.data = this.originalData;\n        this.updateGridData();\n        this.notifyDataChange();\n    }\n    /**\n     * Notifies the Grid that its data has changed.\n     */\n    notifyDataChange() {\n        this.grid.onDataChange();\n        if (this.changeDetector) {\n            this.changeDetector.markForCheck();\n        }\n    }\n    process(state$$1) {\n        return process(this.originalData, state$$1);\n    }\n    applyState({ skip, take: take$$1, sort, group, filter: filter$$1 }) {\n        this.skip = skip;\n        this.pageSize = take$$1;\n        this.sort = sort;\n        this.group = group;\n        this.filter = filter$$1;\n    }\n    updateGridData() {\n        this.grid.data = this.process(this.state);\n        this.dataChanged = false;\n    }\n}\nDataBindingDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridBinding]'\n            },] },\n];\n/** @nocollapse */\nDataBindingDirective.ctorParameters = () => [\n    { type: GridComponent },\n    { type: ChangeDetectorRef },\n    { type: LocalDataChangesService }\n];\nDataBindingDirective.propDecorators = {\n    skip: [{ type: Input }],\n    sort: [{ type: Input }],\n    filter: [{ type: Input }],\n    pageSize: [{ type: Input }],\n    group: [{ type: Input }],\n    data: [{ type: Input, args: [\"kendoGridBinding\",] }]\n};\n\n/**\n * A directive which stores the row selection state of the Grid in memory\n * ([see example]({% slug selection_grid %}#toc-during-data-operations)).\n */\nclass SelectionDirective extends Selection {\n    constructor(grid, cd) {\n        super(grid, cd);\n        this.grid = grid;\n    }\n    /**\n     * @hidden\n     */\n    ngOnInit() {\n        if (this.grid.selectable === false) {\n            this.grid.selectable = true;\n        }\n        this.grid.selectionDirective = true;\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n        super.destroy();\n    }\n}\nSelectionDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridSelectBy]'\n            },] },\n];\n/** @nocollapse */\nSelectionDirective.ctorParameters = () => [\n    { type: GridComponent },\n    { type: ChangeDetectorRef }\n];\n\n/**\n * @hidden\n */\nclass Messages extends ComponentMessages {\n}\nMessages.propDecorators = {\n    groupPanelEmpty: [{ type: Input }],\n    noRecords: [{ type: Input }],\n    pagerFirstPage: [{ type: Input }],\n    pagerLastPage: [{ type: Input }],\n    pagerPreviousPage: [{ type: Input }],\n    pagerNextPage: [{ type: Input }],\n    pagerPage: [{ type: Input }],\n    pagerItemsPerPage: [{ type: Input }],\n    pagerOf: [{ type: Input }],\n    pagerItems: [{ type: Input }],\n    filter: [{ type: Input }],\n    filterEqOperator: [{ type: Input }],\n    filterNotEqOperator: [{ type: Input }],\n    filterIsNullOperator: [{ type: Input }],\n    filterIsNotNullOperator: [{ type: Input }],\n    filterIsEmptyOperator: [{ type: Input }],\n    filterIsNotEmptyOperator: [{ type: Input }],\n    filterStartsWithOperator: [{ type: Input }],\n    filterContainsOperator: [{ type: Input }],\n    filterNotContainsOperator: [{ type: Input }],\n    filterEndsWithOperator: [{ type: Input }],\n    filterGteOperator: [{ type: Input }],\n    filterGtOperator: [{ type: Input }],\n    filterLteOperator: [{ type: Input }],\n    filterLtOperator: [{ type: Input }],\n    filterIsTrue: [{ type: Input }],\n    filterIsFalse: [{ type: Input }],\n    filterBooleanAll: [{ type: Input }],\n    filterAfterOrEqualOperator: [{ type: Input }],\n    filterAfterOperator: [{ type: Input }],\n    filterBeforeOperator: [{ type: Input }],\n    filterBeforeOrEqualOperator: [{ type: Input }],\n    filterFilterButton: [{ type: Input }],\n    filterClearButton: [{ type: Input }],\n    filterAndLogic: [{ type: Input }],\n    filterOrLogic: [{ type: Input }],\n    loading: [{ type: Input }],\n    columnMenu: [{ type: Input }],\n    columns: [{ type: Input }],\n    lock: [{ type: Input }],\n    unlock: [{ type: Input }],\n    sortable: [{ type: Input }],\n    sortAscending: [{ type: Input }],\n    sortDescending: [{ type: Input }],\n    sortedAscending: [{ type: Input }],\n    sortedDescending: [{ type: Input }],\n    sortedDefault: [{ type: Input }],\n    columnsApply: [{ type: Input }],\n    columnsReset: [{ type: Input }],\n    detailExpand: [{ type: Input }],\n    detailCollapse: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nclass LocalizedMessagesDirective extends Messages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n}\nLocalizedMessagesDirective.decorators = [\n    { type: Directive, args: [{\n                providers: [\n                    {\n                        provide: Messages,\n                        useExisting: forwardRef(() => LocalizedMessagesDirective)\n                    }\n                ],\n                selector: '[kendoGridLocalizedMessages]'\n            },] },\n];\n/** @nocollapse */\nLocalizedMessagesDirective.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * Custom component messages override default component messages\n * ([see example]({% slug globalization_grid %}#toc-localization)).\n */\nclass CustomMessagesComponent extends Messages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n    get override() {\n        return true;\n    }\n}\nCustomMessagesComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: Messages,\n                        useExisting: forwardRef(() => CustomMessagesComponent)\n                    }\n                ],\n                selector: 'kendo-grid-messages',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nCustomMessagesComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * @hidden\n */\nclass FilterRowComponent {\n    constructor(localization) {\n        this.localization = localization;\n        this.columns = [];\n        this.groups = [];\n        this.filterRowClass = true;\n        this.filterLabel = this.localization.get('filter');\n    }\n}\nFilterRowComponent.decorators = [\n    { type: Component, args: [{\n                selector: '[kendoGridFilterRow]',\n                template: `\n      <td\n         [class.k-group-cell]=\"true\"\n         *ngFor=\"let g of groups\"\n         role=\"presentation\">\n      </td>\n      <td\n         [class.k-hierarchy-cell]=\"true\"\n         *ngIf=\"detailTemplate?.templateRef\"\n         role=\"presentation\">\n      </td>\n      <td *ngFor=\"let column of columns; let columnIndex = index\"\n          [attr.aria-label]=\"filterLabel\"\n          kendoGridFilterCell\n            [column]=\"column\"\n            [filter]=\"filter\"\n          kendoGridLogicalCell\n            [logicalRowIndex]=\"logicalRowIndex\"\n            [logicalColIndex]=\"lockedColumnsCount + columnIndex\"\n      ></td>\n    `\n            },] },\n];\n/** @nocollapse */\nFilterRowComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\nFilterRowComponent.propDecorators = {\n    columns: [{ type: Input }],\n    filter: [{ type: Input }],\n    groups: [{ type: Input }],\n    detailTemplate: [{ type: Input }],\n    logicalRowIndex: [{ type: Input }],\n    lockedColumnsCount: [{ type: Input }],\n    filterRowClass: [{ type: HostBinding, args: ['class.k-filter-row',] }]\n};\n\nconst areDifferent = (a, b) => a.field !== b.field || a.operator !== b.operator || a.value !== b.value;\nconst isChanged$1 = (a, b) => {\n    if (a.length !== b.length) {\n        return true;\n    }\n    for (let idx = 0, len = a.length; idx < len; idx++) {\n        const prev = a[idx];\n        const curr = b[idx];\n        if (isCompositeFilterDescriptor(prev)) {\n            // tslint:disable-next-line:no-use-before-declare\n            if (diffFilters(prev, curr[idx])) {\n                return true;\n            }\n        }\n        else if (areDifferent(prev, curr)) {\n            return true;\n        }\n    }\n    return false;\n};\nconst copyObject = (obj) => {\n    const result = {};\n    Object.assign(result, obj);\n    if (obj.constructor !== Object) {\n        const proto = obj.constructor.prototype;\n        Object.getOwnPropertyNames(proto).forEach((property) => {\n            if (property !== 'constructor' && proto.hasOwnProperty(property)) {\n                result[property] = obj[property];\n            }\n        });\n    }\n    return result;\n};\nconst cloneFilter = (filter$$1) => copyObject(filter$$1);\n/**\n * @hidden\n */\nconst cloneFilters = (filter$$1) => {\n    if (!filter$$1) {\n        return;\n    }\n    if (isCompositeFilterDescriptor(filter$$1)) {\n        return {\n            filters: cloneFilters(filter$$1.filters),\n            logic: filter$$1.logic\n        };\n    }\n    else if (Array.isArray(filter$$1)) {\n        return filter$$1.map(cloneFilters);\n    }\n    return cloneFilter(filter$$1);\n};\n/**\n * @hidden\n */\nconst diffFilters = (a, b) => {\n    if (isPresent(a) && !isPresent(b)) {\n        return true;\n    }\n    if (!isPresent(a) && isPresent(b)) {\n        return true;\n    }\n    return isPresent(a) && isPresent(b) && isChanged$1(a.filters, b.filters);\n};\n\n/**\n * @hidden\n */\nclass FilterCellComponent {\n    constructor() {\n        this._templateContext = {};\n    }\n    get filter() {\n        return this._filter;\n    }\n    set filter(value) {\n        this._filter = cloneFilters(value);\n    }\n    get templateContext() {\n        this._templateContext.column = this.column;\n        this._templateContext.filter = this.filter;\n        // tslint:disable-next-line:no-string-literal\n        this._templateContext[\"$implicit\"] = this.filter;\n        return this._templateContext;\n    }\n    get hasTemplate() {\n        return isPresent(this.column.filterCellTemplateRef);\n    }\n    get isFilterable() {\n        return isPresent(this.column) && !isNullOrEmptyString(this.column.field) && this.column.filterable;\n    }\n}\nFilterCellComponent.decorators = [\n    { type: Component, args: [{\n                selector: '[kendoGridFilterCell]',\n                template: `\n        <ng-template [ngIf]=\"isFilterable\">\n            <ng-container [ngSwitch]=\"hasTemplate\">\n                <ng-container *ngSwitchCase=\"false\">\n                    <ng-container kendoFilterCellHost [column]=\"column\" [filter]=\"filter\"></ng-container>\n                </ng-container>\n                <ng-container *ngSwitchCase=\"true\">\n                    <ng-template\n                        *ngIf=\"column.filterCellTemplateRef\"\n                        [ngTemplateOutlet]=\"column.filterCellTemplateRef\"\n                        [ngTemplateOutletContext]=\"templateContext\">\n                    </ng-template>\n                </ng-container>\n            </ng-container>\n        </ng-template>\n    `\n            },] },\n];\nFilterCellComponent.propDecorators = {\n    column: [{ type: Input }],\n    filter: [{ type: Input }]\n};\n\nconst localizeOperators = operators => localization => Object.keys(operators).reduce((acc, key) => {\n    acc[operators[key]] = localization.get(key);\n    return acc;\n}, {}); // tslint:disable-line:align\nconst operatorTexts = localizeOperators({\n    \"filterEqOperator\": \"eq\",\n    \"filterNotEqOperator\": \"neq\",\n    // tslint:disable-next-line:object-literal-sort-keys\n    \"filterGteOperator\": \"gte\",\n    \"filterGtOperator\": \"gt\",\n    \"filterLteOperator\": \"lte\",\n    \"filterLtOperator\": \"lt\",\n    \"filterIsNullOperator\": \"isnull\",\n    \"filterIsNotNullOperator\": \"isnotnull\",\n    \"filterIsEmptyOperator\": \"isempty\",\n    \"filterIsNotEmptyOperator\": \"isnotempty\",\n    \"filterContainsOperator\": \"contains\",\n    \"filterNotContainsOperator\": \"doesnotcontain\",\n    \"filterStartsWithOperator\": \"startswith\",\n    \"filterEndsWithOperator\": \"endswith\",\n    \"filterAfterOrEqualOperator\": \"after-eq\",\n    \"filterAfterOperator\": \"after\",\n    \"filterBeforeOrEqualOperator\": \"before-eq\",\n    \"filterBeforeOperator\": \"before\"\n});\n/**\n * @hidden\n */\nconst toJSON = (xs) => xs.map(x => x.toJSON());\n/**\n * @hidden\n */\nclass FilterOperatorBase {\n    constructor(operator, localization) {\n        this.operator = operator;\n        this.localization = localization;\n        this.messages = operatorTexts(this.localization);\n        this._text = this.messages[this.operator];\n        this.localization.changes.subscribe(this.refreshText.bind(this));\n    }\n    /**\n     * The text that will be displayed in the drop-down list.\n     * @readonly\n     * @type {string}\n     * @memberOf FilterOperatorBase\n     */\n    get text() {\n        return this._text;\n    }\n    /**\n     *\n     */\n    set text(value) {\n        this._text = isNullOrEmptyString(value) ? this.messages[this.operator] : value;\n    }\n    /**\n     * @hidden\n     */\n    toJSON() {\n        return {\n            text: this.text,\n            value: this.operator\n        };\n    }\n    refreshText() {\n        const update = this._text === this.messages[this.operator];\n        this.messages = operatorTexts(this.localization);\n        if (update) {\n            this._text = this.messages[this.operator];\n        }\n    }\n}\nFilterOperatorBase.propDecorators = {\n    text: [{ type: Input }]\n};\n\nconst insertDefaultFilter = (index, rootFilter, filter$$1) => {\n    rootFilter = (rootFilter || { filters: [], logic: \"and\" });\n    rootFilter.filters[index] = filter$$1;\n    return filter$$1;\n};\n/**\n * @hidden\n */\nconst setFilter = (index, filter$$1, field, defaultOperator) => {\n    if (isPresent(filter$$1) && isPresent(filter$$1.filters) && filter$$1.filters.length > index) {\n        return filter$$1.filters[index];\n    }\n    else {\n        return insertDefaultFilter(index, filter$$1, {\n            field,\n            operator: defaultOperator\n        });\n    }\n};\n/**\n * @hidden\n */\nconst logicOperators = (localization) => [\n    { text: localization.get(\"filterAndLogic\"), value: \"and\" },\n    { text: localization.get(\"filterOrLogic\"), value: \"or\" }\n];\n/**\n * @hidden\n */\nconst flatten = (filter$$1) => {\n    if (isPresent(filter$$1.filters)) {\n        return filter$$1.filters.reduce((acc, curr) => acc.concat(isCompositeFilterDescriptor(curr) ? flatten(curr) : [curr]), []);\n    }\n    return [];\n};\nconst trimFilterByField = (filter$$1, field) => {\n    if (isPresent(filter$$1) && isPresent(filter$$1.filters)) {\n        filter$$1.filters = filter$$1.filters.filter(x => {\n            if (isCompositeFilterDescriptor(x)) {\n                trimFilterByField(x, field);\n                return x.filters.length;\n            }\n            else {\n                return x.field !== field;\n            }\n        });\n    }\n};\n/**\n * @hidden\n */\nconst filtersByField = (filter$$1, field) => flatten(filter$$1 || {}).filter(x => x.field === field);\n/**\n * @hidden\n */\nconst filterByField = (filter$$1, field) => {\n    let [currentFilter] = filtersByField(filter$$1, field);\n    return currentFilter;\n};\n/**\n * @hidden\n */\nconst removeFilter = (filter$$1, field) => {\n    trimFilterByField(filter$$1, field);\n    return filter$$1;\n};\n/**\n * @hidden\n */\nconst localizeOperators$1 = operators => localization => Object.keys(operators).map(key => ({\n    text: localization.get(key),\n    value: operators[key]\n}));\n/**\n * An abstract base class for the filter-cell component ([see example]({% slug reusablecustomfilters_grid %}#toc-filter-row)).\n */\nclass BaseFilterCellComponent {\n    constructor(filterService) {\n        this.filterService = filterService;\n        this.operatorList = new QueryList();\n    }\n    /**\n     * @hidden\n     */\n    get hostClasses() {\n        return true;\n    }\n    get operators() {\n        return this._operators.length ? this._operators : this.defaultOperators;\n    }\n    set operators(values) {\n        this._operators = values;\n    }\n    /**\n     * @hidden\n     */\n    ngAfterContentInit() {\n        this.operationListSubscription = observe(this.operatorList)\n            .pipe(map(q => q.toArray()), map(toJSON))\n            .subscribe(x => {\n            this.operators = x;\n        });\n    }\n    ngOnDestroy() {\n        if (this.operationListSubscription) {\n            this.operationListSubscription.unsubscribe();\n        }\n    }\n    filterByField(field) {\n        return filterByField(this.filter, field);\n    }\n    filtersByField(field) {\n        return filtersByField(this.filter, field);\n    }\n    removeFilter(field) {\n        return removeFilter(this.filter, field);\n    }\n    updateFilter(filter$$1) {\n        const root = this.filter || {\n            filters: [],\n            logic: \"and\"\n        };\n        let [currentFilter] = flatten(root).filter(x => x.field === filter$$1.field);\n        if (!isPresent(currentFilter)) {\n            root.filters.push(filter$$1);\n        }\n        else {\n            Object.assign(currentFilter, filter$$1);\n        }\n        return root;\n    }\n    applyFilter(filter$$1) {\n        this.filterService.filter(filter$$1);\n    }\n}\nBaseFilterCellComponent.propDecorators = {\n    hostClasses: [{ type: HostBinding, args: ['class.k-filtercell',] }],\n    operatorList: [{ type: ContentChildren, args: [FilterOperatorBase,] }]\n};\n\n// tslint:disable:no-access-missing-member\nconst numericOperators = localizeOperators$1({\n    \"filterEqOperator\": \"eq\",\n    \"filterNotEqOperator\": \"neq\",\n    // tslint:disable-next-line:object-literal-sort-keys\n    \"filterGteOperator\": \"gte\",\n    \"filterGtOperator\": \"gt\",\n    \"filterLteOperator\": \"lte\",\n    \"filterLtOperator\": \"lt\",\n    \"filterIsNullOperator\": \"isnull\",\n    \"filterIsNotNullOperator\": \"isnotnull\"\n});\n/**\n * Represents a base numeric filter component.\n */\nclass NumericFilterComponent extends BaseFilterCellComponent {\n    constructor(filterService, localization) {\n        super(filterService);\n        this.localization = localization;\n        /**\n         * The default filter operator. Defaults to `eq`.\n         * @type {string}\n         */\n        this.operator = \"eq\";\n        /**\n         * Specifies the value that is used to increment or decrement the component value.\n         * @type {numeric}\n         */\n        this.step = 1;\n        /**\n         * Specifies whether the **Up** and **Down** spin buttons will be rendered.\n         * @type {boolean}\n         */\n        this.spinners = true;\n        this.defaultOperators = numericOperators(this.localization);\n    }\n    /**\n     * Specifies the number format used when the component is not focused.\n     * By default, the `column.format` value is used (if set).\n     */\n    set format(value) {\n        this._format = value;\n    }\n    /**\n     * Specifies the number format used when the component is not focused.\n     * By default, the `column.format` value is used (if set).\n     *\n     * @readonly\n     * @type {string}\n     */\n    get format() {\n        return !isNullOrEmptyString(this._format) ? this._format : this.columnFormat;\n    }\n    /**\n     * The current filter for the associated column field.\n     * @readonly\n     * @type {FilterDescriptor}\n     */\n    get currentFilter() {\n        return this.filterByField(this.column.field);\n    }\n    /**\n     * The current filter operator for the associated column field.\n     * @readonly\n     * @type {string}\n     */\n    get currentOperator() {\n        return this.currentFilter ? this.currentFilter.operator : this.operator;\n    }\n    get columnFormat() {\n        return this.column && !isNullOrEmptyString(this.column.format) ?\n            extractFormat(this.column.format) : \"n2\";\n    }\n    ngOnInit() {\n        this.subscription = this.localization.changes.subscribe(this.localizationChange.bind(this));\n    }\n    ngOnDestroy() {\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n        }\n        super.ngOnDestroy();\n    }\n    localizationChange() {\n        this.defaultOperators = numericOperators(this.localization);\n        if (this.operatorList.length) {\n            this.operators = toJSON(this.operatorList.toArray());\n        }\n    }\n}\nNumericFilterComponent.propDecorators = {\n    column: [{ type: Input }],\n    filter: [{ type: Input }],\n    operator: [{ type: Input }],\n    step: [{ type: Input }],\n    min: [{ type: Input }],\n    max: [{ type: Input }],\n    spinners: [{ type: Input }],\n    decimals: [{ type: Input }],\n    format: [{ type: Input }]\n};\n\n/**\n * Represents a numeric filter cell.\n *\n * @example\n *  ```html-no-run\n *      <kendo-grid-column field=\"ProductName\" title=\"Product Name\">\n *          <ng-template kendoGridFilterCellTemplate let-filter let-column=\"column\">\n *          <kendo-grid-numeric-filter-cell\n *              [column]=\"column\"\n *              [filter]=\"filter\">\n *          </kendo-grid-numeric-filter-cell>\n *          </ng-template>\n *      </kendo-grid-column>\n *   ```\n */\nclass NumericFilterCellComponent extends NumericFilterComponent {\n    constructor(filterService, localization) {\n        super(filterService, localization);\n        this.localization = localization;\n        /**\n         * Determines the delay time (in milliseconds) before the filter value is submitted.\n         * A value of `0` indicates no delay. The default value is `500`.\n         * @type {boolean}\n         */\n        this.filterDelay = 500;\n        /**\n         * Determines if the drop-down filter operators will be displayed.\n         * The default value is `true`.\n         * @type {boolean}\n         */\n        this.showOperators = true;\n    }\n}\nNumericFilterCellComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-grid-numeric-filter-cell',\n                template: `\n        <kendo-grid-filter-wrapper-cell\n            [column]=\"column\"\n            [filter]=\"filter\"\n            [operators]=\"operators\"\n            [defaultOperator]=\"operator\"\n            [showOperators]=\"showOperators\">\n            <kendo-numerictextbox\n                kendoGridFocusable\n                kendoFilterInput\n                [filterDelay]=\"filterDelay\"\n                [autoCorrect]=\"true\"\n                [value]=\"currentFilter?.value\"\n                [format]=\"format\"\n                [decimals]=\"decimals\"\n                [spinners]=\"spinners\"\n                [min]=\"min\"\n                [max]=\"max\"\n                [step]=\"step\">\n            </kendo-numerictextbox>\n        </kendo-grid-filter-wrapper-cell>\n    `\n            },] },\n];\n/** @nocollapse */\nNumericFilterCellComponent.ctorParameters = () => [\n    { type: FilterService },\n    { type: LocalizationService }\n];\nNumericFilterCellComponent.propDecorators = {\n    filterDelay: [{ type: Input }],\n    showOperators: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nclass FilterInputDirective {\n    constructor(valueAccessors, ngZone, element, renderer) {\n        this.change = new EventEmitter();\n        this.composing = false;\n        this.filterDelay = 500;\n        this.changeRequests = new Subject();\n        this.accessor = valueAccessors[0];\n        ngZone.runOutsideAngular(() => {\n            const unsubscribeStart = renderer.listen(element.nativeElement, 'compositionstart', () => this.composing = true);\n            const unsubscribeEnd = renderer.listen(element.nativeElement, 'compositionend', () => this.composing = false);\n            this.unsubscribeEvents = () => {\n                unsubscribeStart();\n                unsubscribeEnd();\n            };\n        });\n    }\n    set value(value) {\n        this.accessor.writeValue(value);\n    }\n    set disabled(value) {\n        this.accessor.setDisabledState(value);\n    }\n    ngAfterViewInit() {\n        this.accessor.registerOnChange(x => this.filterDelay > 0 ?\n            this.changeRequests.next(x) :\n            this.change.emit(x));\n        this.subscribeChanges();\n    }\n    ngOnChanges(changes) {\n        if (isChanged('filterDelay', changes)) {\n            this.unsubscribeChanges();\n            this.subscribeChanges();\n        }\n    }\n    ngOnDestroy() {\n        this.unsubscribeChanges();\n        this.unsubscribeEvents();\n    }\n    subscribeChanges() {\n        this.changeRequestsSubscription = this.changeRequests\n            .pipe(debounceTime(this.filterDelay), filter(() => !this.composing))\n            .subscribe(x => this.change.emit(x));\n    }\n    unsubscribeChanges() {\n        if (this.changeRequestsSubscription) {\n            this.changeRequestsSubscription.unsubscribe();\n        }\n    }\n}\nFilterInputDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoFilterInput]'\n            },] },\n];\n/** @nocollapse */\nFilterInputDirective.ctorParameters = () => [\n    { type: Array, decorators: [{ type: Self }, { type: Inject, args: [NG_VALUE_ACCESSOR,] }] },\n    { type: NgZone },\n    { type: ElementRef },\n    { type: Renderer2 }\n];\nFilterInputDirective.propDecorators = {\n    filterDelay: [{ type: Input }],\n    value: [{ type: Input }]\n};\n\nconst EMPTY_VALUE_OPERATORS = new Set(['isnull', 'isnotnull', 'isempty', 'isnotempty']);\nconst isEmptyValueOperator = (operator) => EMPTY_VALUE_OPERATORS.has(operator);\n/**\n * @hidden\n */\nclass FilterInputWrapperComponent extends BaseFilterCellComponent {\n    constructor(filterService) {\n        super(filterService);\n        this.operators = [];\n    }\n    get currentFilter() {\n        return this.filterByField(this.column.field);\n    }\n    get currentOperator() {\n        const filter$$1 = this.currentFilter;\n        if (!this._operator) {\n            this._operator = filter$$1 ? filter$$1.operator : this.defaultOperator;\n        }\n        return this._operator;\n    }\n    set currentOperator(value) {\n        this._operator = value;\n        const emptyValueOperator = isEmptyValueOperator(value);\n        this.filterInputDisabled = emptyValueOperator;\n        if (emptyValueOperator) {\n            this.applyNoValueFilter(value);\n        }\n        else if (!isBlank(value) && isPresent(this.currentFilter)) {\n            this.onChange(this.currentFilter.value);\n        }\n    }\n    get defaultOperator() {\n        if (!isNullOrEmptyString(this._defaultOperator)) {\n            return this._defaultOperator;\n        }\n        else if (this.operators && this.operators.length) {\n            return this.operators[0].value;\n        }\n        return \"eq\";\n    }\n    set defaultOperator(value) {\n        this._defaultOperator = value;\n    }\n    set filterInputDisabled(disabled) {\n        if (!this.input) {\n            return;\n        }\n        this.input.disabled = disabled;\n    }\n    ngAfterContentInit() {\n        if (isPresent(this.input)) {\n            this.changeSubscription = this.input.change.subscribe(this.onChange.bind(this));\n            this.filterInputDisabled = isEmptyValueOperator(this.currentOperator);\n        }\n    }\n    ngOnDestroy() {\n        super.ngOnDestroy();\n        if (this.changeSubscription) {\n            this.changeSubscription.unsubscribe();\n        }\n    }\n    onChange(value) {\n        if (!isNullOrEmptyString(value) || this.filterByField(this.column.field)) {\n            this.filterChange(isNullOrEmptyString(value) ?\n                this.removeFilter(this.column.field) :\n                this.updateFilter({\n                    field: this.column.field,\n                    operator: this.currentOperator,\n                    value: value\n                }));\n        }\n    }\n    onClear() {\n        this.onChange(null);\n        this.filterInputDisabled = isEmptyValueOperator(this.defaultOperator);\n    }\n    applyNoValueFilter(operator) {\n        this.filterChange(this.updateFilter({\n            field: this.column.field,\n            operator: operator,\n            value: null\n        }));\n    }\n    ngOnChanges(changes) {\n        if (isChanged(\"filter\", changes, false)) {\n            this._operator = null;\n            this.filterInputDisabled = isEmptyValueOperator(this.currentOperator);\n        }\n    }\n}\nFilterInputWrapperComponent.propDecorators = {\n    operators: [{ type: Input }],\n    column: [{ type: Input }],\n    filter: [{ type: Input }],\n    input: [{ type: ContentChild, args: [FilterInputDirective,] }],\n    defaultOperator: [{ type: Input }]\n};\n\nconst EMPTY_FILTER_OPERATORS = ['isnull', 'isnotnull', 'isempty', 'isnotempty'];\n/**\n * @hidden\n */\nclass FilterCellWrapperComponent extends FilterInputWrapperComponent {\n    constructor(filterService) {\n        super(filterService);\n        this.showOperators = true;\n    }\n    get hostClasses() {\n        return true;\n    }\n    get overrideBaseClasses() {\n        return false;\n    }\n    get showButton() {\n        const filter$$1 = this.currentFilter;\n        return isPresent(filter$$1) && (!isNullOrEmptyString(filter$$1.value) ||\n            EMPTY_FILTER_OPERATORS.indexOf(String(filter$$1.operator)) >= 0);\n    }\n    filterChange(filter$$1) {\n        this.applyFilter(filter$$1);\n    }\n}\nFilterCellWrapperComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-grid-filter-wrapper-cell',\n                template: `\n        <ng-content></ng-content>\n        <kendo-grid-filter-cell-operators\n            [showOperators]=\"showOperators\"\n            [operators]=\"operators\"\n            (clear)=\"onClear()\"\n            [showButton]=\"showButton\"\n            [(value)]=\"currentOperator\">\n        </kendo-grid-filter-cell-operators>\n    `\n            },] },\n];\n/** @nocollapse */\nFilterCellWrapperComponent.ctorParameters = () => [\n    { type: FilterService }\n];\nFilterCellWrapperComponent.propDecorators = {\n    hostClasses: [{ type: HostBinding, args: ['class.k-filtercell-wrapper',] }],\n    overrideBaseClasses: [{ type: HostBinding, args: ['class.k-filtercell',] }],\n    showOperators: [{ type: Input }]\n};\n\n// tslint:disable:no-access-missing-member\nconst stringOperators = localizeOperators$1({\n    \"filterEqOperator\": \"eq\",\n    \"filterNotEqOperator\": \"neq\",\n    // tslint:disable-next-line:object-literal-sort-keys\n    \"filterContainsOperator\": \"contains\",\n    \"filterNotContainsOperator\": \"doesnotcontain\",\n    \"filterStartsWithOperator\": \"startswith\",\n    \"filterEndsWithOperator\": \"endswith\",\n    \"filterIsNullOperator\": \"isnull\",\n    \"filterIsNotNullOperator\": \"isnotnull\",\n    \"filterIsEmptyOperator\": \"isempty\",\n    \"filterIsNotEmptyOperator\": \"isnotempty\"\n});\n/**\n * Represents a base string filter component.\n */\nclass StringFilterComponent extends BaseFilterCellComponent {\n    constructor(filterService, localization) {\n        super(filterService);\n        this.localization = localization;\n        /**\n         * The default filter operator. Defaults to `contains`.\n         * @type {string}\n         */\n        this.operator = \"contains\";\n    }\n    /**\n     * The current filter for the associated column field.\n     * @readonly\n     * @type {FilterDescriptor}\n     */\n    get currentFilter() {\n        return this.filterByField((this.column || {}).field);\n    }\n    /**\n     * The current filter operator for the associated column field.\n     * @readonly\n     * @type {string}\n     */\n    get currentOperator() {\n        return this.currentFilter ? this.currentFilter.operator : this.operator;\n    }\n    ngOnInit() {\n        this.subscription = this.localization.changes.subscribe(this.localizationChange.bind(this));\n    }\n    ngOnDestroy() {\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n        }\n        super.ngOnDestroy();\n    }\n    localizationChange() {\n        this.defaultOperators = stringOperators(this.localization);\n        if (this.operatorList.length) {\n            this.operators = toJSON(this.operatorList.toArray());\n        }\n    }\n}\nStringFilterComponent.propDecorators = {\n    column: [{ type: Input }],\n    filter: [{ type: Input }],\n    operator: [{ type: Input }]\n};\n\n/**\n * Represents a string-filter cell component\n * ([see example]({% slug builtinfiltertemplate_grid %}#toc-configuration-components-for-filter-templates)).\n *\n * @example\n *\n *  ```html-no-run\n *      <kendo-grid-column field=\"ProductName\" title=\"Product Name\">\n *          <ng-template kendoGridFilterCellTemplate let-filter let-column=\"column\">\n *          <kendo-grid-string-filter-cell\n *              [showOperators]=\"false\"\n *              [column]=\"column\"\n *              [filter]=\"filter\">\n *          </kendo-grid-string-filter-cell>\n *          </ng-template>\n *      </kendo-grid-column>\n *   ```\n */\nclass StringFilterCellComponent extends StringFilterComponent {\n    constructor(filterService, localization) {\n        super(filterService, localization);\n        /**\n         * Determines the delay time (in milliseconds) before the filter value is submitted.\n         * A value of `0` indicates no delay. The default value is `500`.\n         * @type {boolean}\n         */\n        this.filterDelay = 500;\n        /**\n         * Determines if the drop-down filter operators will be displayed.\n         * The default value is `true`.\n         * @type {boolean}\n         */\n        this.showOperators = true;\n    }\n}\nStringFilterCellComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-grid-string-filter-cell',\n                template: `\n        <kendo-grid-filter-wrapper-cell\n            [column]=\"column\"\n            [filter]=\"filter\"\n            [operators]=\"operators\"\n            [defaultOperator]=\"operator\"\n            [showOperators]=\"showOperators\">\n            <input\n                class=\"k-textbox\"\n                kendoGridFocusable\n                kendoFilterInput\n                [filterDelay]=\"filterDelay\"\n                [ngModel]=\"currentFilter?.value\" />\n        </kendo-grid-filter-wrapper-cell>\n    `\n            },] },\n];\n/** @nocollapse */\nStringFilterCellComponent.ctorParameters = () => [\n    { type: FilterService },\n    { type: LocalizationService }\n];\nStringFilterCellComponent.propDecorators = {\n    filterDelay: [{ type: Input }],\n    showOperators: [{ type: Input }]\n};\n\n/**\n * Represents a component which accommodates the filter operators.\n */\nclass FilterCellOperatorsComponent {\n    constructor(localization) {\n        this.localization = localization;\n        this.clearText = 'Clear';\n        /**\n         * The filter operators that will be displayed.\n         */\n        this.operators = [];\n        /**\n         * Determines if the list of operators will be displayed.\n         * @type {boolean}\n         */\n        this.showOperators = true;\n        /**\n         * Fires when the operator is selected.\n         * @type {EventEmitter<string>}\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * Fires when the **Clear** button is clicked.\n         * @type {EventEmitter<{}>}\n         */\n        this.clear = new EventEmitter();\n    }\n    /**\n     * @hidden\n     */\n    get hostClasses() {\n        return true;\n    }\n    /**\n     * @hidden\n     */\n    onChange(dataItem) {\n        this.valueChange.emit(dataItem);\n    }\n    /**\n     * @hidden\n     */\n    clearClick() {\n        this.clear.emit();\n        return false;\n    }\n    /**\n     * @hidden\n     */\n    clearKeydown(args) {\n        if (args.keyCode === Keys.Enter || args.keyCode === Keys.Space) {\n            this.clear.emit();\n        }\n    }\n    /**\n     * @hidden\n     */\n    dropdownKeydown(args) {\n        if (args.defaultPrevented) {\n            return;\n        }\n        if (args.keyCode === Keys.Enter && !this.dropdown.isOpen) {\n            this.dropdown.toggle(true);\n            args.preventDefault();\n        }\n    }\n    ngOnInit() {\n        this.localization.changes.subscribe(() => this.clearText = this.localization.get(\"filterClearButton\"));\n    }\n}\nFilterCellOperatorsComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-grid-filter-cell-operators',\n                template: `\n        <kendo-dropdownlist\n            #dropdown\n            *ngIf=\"showOperators\"\n            kendoGridFocusable\n            [data]=\"operators\"\n            class=\"k-dropdown-operator\"\n            (valueChange)=\"onChange($event)\"\n            [value]=\"value\"\n            iconClass=\"k-i-filter\"\n            [valuePrimitive]=\"true\"\n            textField=\"text\"\n            [popupSettings]=\"{ width: 'auto' }\"\n            valueField=\"value\"\n            (keydown)=\"dropdownKeydown($event)\">\n        </kendo-dropdownlist>\n        <button type=\"button\"\n            kendoGridFocusable\n            [ngClass]=\"{'k-clear-button-visible': showButton}\"\n            class=\"k-button k-button-icon\"\n            [title]=\"clearText\"\n            (click)=\"clearClick()\"\n            (keydown)=\"clearKeydown($event)\">\n                <span class=\"k-icon k-i-filter-clear\"></span>\n        </button>\n    `\n            },] },\n];\n/** @nocollapse */\nFilterCellOperatorsComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\nFilterCellOperatorsComponent.propDecorators = {\n    hostClasses: [{ type: HostBinding, args: ['class.k-filtercell-operator',] }],\n    dropdown: [{ type: ViewChild, args: ['dropdown',] }],\n    operators: [{ type: Input }],\n    showButton: [{ type: Input }],\n    showOperators: [{ type: Input }],\n    value: [{ type: Input }],\n    valueChange: [{ type: Output }],\n    clear: [{ type: Output }]\n};\n\n// tslint:disable:no-access-missing-member\nconst stringOperators$1 = localizeOperators$1({\n    \"filterContainsOperator\": \"contains\",\n    \"filterNotContainsOperator\": \"doesnotcontain\",\n    // tslint:disable-next-line:object-literal-sort-keys\n    \"filterEqOperator\": \"eq\",\n    \"filterNotEqOperator\": \"neq\",\n    \"filterStartsWithOperator\": \"startswith\",\n    \"filterEndsWithOperator\": \"endswith\",\n    \"filterIsNullOperator\": \"isnull\",\n    \"filterIsNotNullOperator\": \"isnotnull\",\n    \"filterIsEmptyOperator\": \"isempty\",\n    \"filterIsNotEmptyOperator\": \"isnotempty\"\n});\n/**\n * @hidden\n */\nclass AutoCompleteFilterCellComponent extends BaseFilterCellComponent {\n    constructor(filterService, column, localization) {\n        super(filterService);\n        this.localization = localization;\n        this.showOperators = true;\n        this.defaultOperators = stringOperators$1(this.localization);\n        this.column = column;\n    }\n    set valueField(value) {\n        this._valueField = value;\n    }\n    get valueField() {\n        return this._valueField ? this._valueField : this.column.field;\n    }\n    get currentFilter() {\n        return this.filterByField(this.column.field);\n    }\n    get currentOperator() {\n        return this.currentFilter ? this.currentFilter.operator : \"contains\";\n    }\n}\nAutoCompleteFilterCellComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-grid-autocomplete-filter-cell',\n                template: `\n        <kendo-grid-filter-wrapper-cell\n            [column]=\"column\"\n            [filter]=\"filter\"\n            [operators]=\"operators\"\n            [showOperators]=\"showOperators\">\n            <kendo-autocomplete\n                kendoFilterInput\n                [data]=\"data\"\n                [valueField]=\"valueField\"\n                [value]=\"currentFilter?.value\">\n            </kendo-autocomplete>\n        </kendo-grid-filter-wrapper-cell>\n    `\n            },] },\n];\n/** @nocollapse */\nAutoCompleteFilterCellComponent.ctorParameters = () => [\n    { type: FilterService },\n    { type: ColumnComponent },\n    { type: LocalizationService }\n];\nAutoCompleteFilterCellComponent.propDecorators = {\n    showOperators: [{ type: Input }],\n    column: [{ type: Input }],\n    filter: [{ type: Input }],\n    data: [{ type: Input }],\n    valueField: [{ type: Input }]\n};\n\n// tslint:disable:no-access-missing-member\n/**\n * @hidden\n */\nclass BooleanFilterComponent extends BaseFilterCellComponent {\n    constructor(filterService, localization) {\n        super(filterService);\n        this.localization = localization;\n        /**\n         * @hidden\n         */\n        this.operator = \"eq\";\n        /**\n         * @hidden\n         */\n        this.items = [\n            { text: this.localization.get(\"filterIsTrue\"), value: true },\n            { text: this.localization.get(\"filterIsFalse\"), value: false }\n        ];\n        /**\n         * @hidden\n         */\n        this.defaultItem = { text: this.localization.get(\"filterBooleanAll\"), value: null };\n    }\n    /**\n     * @hidden\n     */\n    get hostClasses() {\n        return true;\n    }\n    /**\n     * The current filter for the associated column field.\n     * @readonly\n     * @type {FilterDescriptor}\n     */\n    get currentFilter() {\n        return this.filterByField(this.column.field);\n    }\n    /**\n     * The current filter operator for the associated column field.\n     * @readonly\n     * @type {string}\n     */\n    get currentOperator() {\n        return this.currentFilter ? this.currentFilter.operator : this.operator;\n    }\n    ngOnInit() {\n        this.subscription = this.localization.changes.subscribe(this.localizationChange.bind(this));\n    }\n    ngOnDestroy() {\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n        }\n        super.ngOnDestroy();\n    }\n    localizationChange() {\n        this.items = [\n            { text: this.localization.get(\"filterIsTrue\"), value: true },\n            { text: this.localization.get(\"filterIsFalse\"), value: false }\n        ];\n        this.defaultItem = { text: this.localization.get(\"filterBooleanAll\"), value: null };\n    }\n}\nBooleanFilterComponent.propDecorators = {\n    hostClasses: [{ type: HostBinding, args: ['class.k-filtercell-boolean',] }],\n    column: [{ type: Input }],\n    filter: [{ type: Input }]\n};\n\n/**\n * Represents a Boolean filter-cell component.\n *\n * @example\n *\n *  ```html-no-run\n *      <kendo-grid-column field=\"ProductName\" title=\"Product Name\">\n *          <ng-template kendoGridFilterCellTemplate let-filter let-column=\"column\">\n *          <kendo-grid-boolean-filter-cell\n *              [column]=\"column\"\n *              [filter]=\"filter\">\n *          </kendo-grid-boolean-filter-cell>\n *          </ng-template>\n *      </kendo-grid-column>\n *   ```\n */\nclass BooleanFilterCellComponent extends BooleanFilterComponent {\n    constructor(filterService, localization, cd) {\n        super(filterService, localization);\n        this.cd = cd;\n    }\n    localizationChange() {\n        super.localizationChange();\n        this.cd.markForCheck();\n    }\n}\nBooleanFilterCellComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-grid-boolean-filter-cell',\n                template: `\n        <kendo-grid-filter-wrapper-cell\n            [column]=\"column\"\n            [filter]=\"filter\"\n            [showOperators]=\"false\"\n            [defaultOperator]=\"operator\">\n            <kendo-dropdownlist\n                kendoFilterInput\n                [defaultItem]=\"defaultItem\"\n                [data]=\"items\"\n                textField=\"text\"\n                valueField=\"value\"\n                [popupSettings]=\"{ width: 'auto' }\"\n                [valuePrimitive]=\"true\"\n                [value]=\"currentFilter?.value\">\n            </kendo-dropdownlist>\n        </kendo-grid-filter-wrapper-cell>\n    `\n            },] },\n];\n/** @nocollapse */\nBooleanFilterCellComponent.ctorParameters = () => [\n    { type: FilterService },\n    { type: LocalizationService },\n    { type: ChangeDetectorRef }\n];\n\n// tslint:disable:no-access-missing-member\nconst dateOperators = localizeOperators$1({\n    \"filterEqOperator\": \"eq\",\n    \"filterNotEqOperator\": \"neq\",\n    // tslint:disable-next-line:object-literal-sort-keys\n    \"filterAfterOrEqualOperator\": \"gte\",\n    \"filterAfterOperator\": \"gt\",\n    \"filterBeforeOrEqualOperator\": \"lte\",\n    \"filterBeforeOperator\": \"lt\",\n    \"filterIsNullOperator\": \"isnull\",\n    \"filterIsNotNullOperator\": \"isnotnull\"\n});\n/**\n * @hidden\n */\nclass DateFilterComponent extends BaseFilterCellComponent {\n    constructor(filterService, localization) {\n        super(filterService);\n        this.localization = localization;\n        /**\n         * The default filter operator. Defaults to `contains`.\n         * @type {string}\n         */\n        this.operator = \"gte\";\n        /**\n         * Defines the active view that the calendar initially renders.\n         * By default, the active view is `month`.\n         *\n         * > You have to set `activeView` within the `topView`-`bottomView` range.\n         */\n        this.activeView = \"month\";\n        /**\n         * Defines the bottommost calendar view, to which the user can navigate.\n         */\n        this.bottomView = \"month\";\n        /**\n         * Defines the topmost calendar view, to which the user can navigate.\n         */\n        this.topView = \"century\";\n        /**\n         * Determines whether to display a week number column in the `month` view of the Calendar.\n         */\n        this.weekNumber = false;\n        this.defaultOperators = dateOperators(this.localization);\n    }\n    /**\n     * The current filter for the associated column field.\n     * @readonly\n     * @type {FilterDescriptor}\n     */\n    get currentFilter() {\n        return this.filterByField(this.column.field);\n    }\n    /**\n     * Specifies the date format that is used when the component is not focused.\n     * By default, the `column.format` value is used (if set).\n     */\n    set format(value) {\n        this._format = value;\n    }\n    /**\n     * Specifies the date format that is used when the component is not focused.\n     * By default, the `column.format` value is used (if set).\n     *\n     * @readonly\n     * @type {string}\n     */\n    get format() {\n        return !isNullOrEmptyString(this._format) ? this._format : this.columnFormat;\n    }\n    get columnFormat() {\n        return this.column && !isNullOrEmptyString(this.column.format) ?\n            extractFormat(this.column.format) : \"d\";\n    }\n    /**\n     * The current filter operator for the associated column field.\n     * @readonly\n     * @type {string}\n     */\n    get currentOperator() {\n        return this.currentFilter ? this.currentFilter.operator : this.operator;\n    }\n    ngOnInit() {\n        this.subscription = this.localization.changes.subscribe(this.localizationChange.bind(this));\n    }\n    ngOnDestroy() {\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n        }\n        super.ngOnDestroy();\n    }\n    localizationChange() {\n        this.defaultOperators = dateOperators(this.localization);\n        if (this.operatorList.length) {\n            this.operators = toJSON(this.operatorList.toArray());\n        }\n    }\n}\nDateFilterComponent.propDecorators = {\n    column: [{ type: Input }],\n    filter: [{ type: Input }],\n    operator: [{ type: Input }],\n    format: [{ type: Input }],\n    min: [{ type: Input }],\n    max: [{ type: Input }],\n    formatPlaceholder: [{ type: Input }],\n    placeholder: [{ type: Input }],\n    activeView: [{ type: Input }],\n    bottomView: [{ type: Input }],\n    topView: [{ type: Input }],\n    weekNumber: [{ type: Input }]\n};\n\n/**\n * Represents a date-filter cell component.\n *\n * @example\n *\n *  ```html-no-run\n *      <kendo-grid-column field=\"OrderDate\" title=\"Order Date\">\n *          <ng-template kendoGridFilterCellTemplate let-filter let-column=\"column\">\n *          <kendo-grid-date-filter-cell\n *              [showOperators]=\"false\"\n *              [column]=\"column\"\n *              [filter]=\"filter\">\n *          </kendo-grid-date-filter-cell>\n *          </ng-template>\n *      </kendo-grid-column>\n *   ```\n */\nclass DateFilterCellComponent extends DateFilterComponent {\n    constructor(filterService, localization) {\n        super(filterService, localization);\n        this.localization = localization;\n        /**\n         * Determines if the drop-down filter operators will be displayed. The default value is `true`.\n         * @type {boolean}\n         */\n        this.showOperators = true;\n    }\n}\nDateFilterCellComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-grid-date-filter-cell',\n                template: `\n        <kendo-grid-filter-wrapper-cell\n            [column]=\"column\"\n            [filter]=\"filter\"\n            [operators]=\"operators\"\n            [defaultOperator]=\"operator\"\n            [showOperators]=\"showOperators\"\n            >\n            <kendo-datepicker\n                kendoFilterInput\n                [value]=\"currentFilter?.value\"\n                [format]=\"format\"\n                [formatPlaceholder]=\"formatPlaceholder\"\n                [placeholder]=\"placeholder\"\n                [activeView]=\"activeView\"\n                [bottomView]=\"bottomView\"\n                [topView]=\"topView\"\n                [min]=\"min\"\n                [max]=\"max\"\n                [weekNumber]=\"weekNumber\"\n                >\n            </kendo-datepicker>\n        </kendo-grid-filter-wrapper-cell>\n    `\n            },] },\n];\n/** @nocollapse */\nDateFilterCellComponent.ctorParameters = () => [\n    { type: FilterService },\n    { type: LocalizationService }\n];\nDateFilterCellComponent.propDecorators = {\n    showOperators: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nclass ColGroupComponent {\n    constructor() {\n        this.columns = [];\n        this.groups = [];\n    }\n    get columnsToRender() {\n        return columnsToRender(this.columns);\n    }\n    trackBy(index, _item) {\n        return index;\n    }\n}\nColGroupComponent.decorators = [\n    { type: Component, args: [{\n                selector: '[kendoGridColGroup]',\n                template: `\n    <ng-template [ngIf]=\"true\">\n        <col [class.k-group-col]=\"true\" *ngFor=\"let g of groups\" />\n        <col [class.k-hierarchy-col]=\"true\" *ngIf=\"detailTemplate?.templateRef\"/>\n        <col *ngFor=\"let column of columnsToRender; trackBy: trackBy;\" [style.width.px]=\"column.width\"/>\n    </ng-template>\n    `\n            },] },\n];\nColGroupComponent.propDecorators = {\n    columns: [{ type: Input }],\n    groups: [{ type: Input }],\n    detailTemplate: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nclass LoadingComponent {\n    constructor(localization) {\n        this.localization = localization;\n        this.hostClass = true;\n    }\n    get loadingText() {\n        return this.localization.get('loading');\n    }\n}\nLoadingComponent.decorators = [\n    { type: Component, args: [{\n                selector: '[kendoGridLoading]',\n                template: `\n        <span class=\"k-loading-text\">{{ loadingText }}</span>\n        <div class=\"k-loading-image\"></div>\n        <div class=\"k-loading-color\"></div>\n    `\n            },] },\n];\n/** @nocollapse */\nLoadingComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\nLoadingComponent.propDecorators = {\n    hostClass: [{ type: HostBinding, args: ['class.k-loading-mask',] }]\n};\n\n/**\n * @hidden\n */\nclass ResizableContainerDirective {\n    constructor(el, renderer, resizeService, grid) {\n        this.el = el;\n        this.renderer = renderer;\n        this.resizeService = resizeService;\n        this.grid = grid;\n        this.enabled = false;\n    }\n    set lockedWidth(value) {\n        this._lockedWidth = value;\n        if (this.enabled) {\n            this.attachResize();\n            this.resize();\n        }\n    }\n    set kendoGridResizableContainer(enabled) {\n        const refresh = enabled !== this.enabled;\n        this.enabled = enabled;\n        if (refresh) {\n            this.attachResize();\n            this.resize();\n        }\n    }\n    ngOnDestroy() {\n        if (this.resizeSubscription) {\n            this.resizeSubscription.unsubscribe();\n        }\n    }\n    attachResize() {\n        if (this.resizeSubscription && !this.enabled) {\n            this.resizeSubscription.unsubscribe();\n            this.resizeSubscription = null;\n        }\n        if (!this.resizeSubscription && this.enabled) {\n            this.resizeSubscription = this.resizeService.changes.subscribe(this.resize.bind(this));\n        }\n    }\n    resize() {\n        if (this.grid && this.grid.wrapper) {\n            const containerElement = this.grid.wrapper.nativeElement;\n            const width = Math.max(containerElement.clientWidth - this._lockedWidth, 0);\n            if (this.enabled && width > 0) {\n                this.renderer.setStyle(this.el.nativeElement, \"width\", width + \"px\");\n            }\n            else {\n                this.renderer.setStyle(this.el.nativeElement, \"width\", \"\");\n            }\n        }\n    }\n}\nResizableContainerDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridResizableContainer]'\n            },] },\n];\n/** @nocollapse */\nResizableContainerDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: ResizeService },\n    { type: GridComponent, decorators: [{ type: Optional }] }\n];\nResizableContainerDirective.propDecorators = {\n    lockedWidth: [{ type: Input, args: ['lockedWidth',] }],\n    kendoGridResizableContainer: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nclass TemplateContextDirective {\n    constructor(viewContainerRef) {\n        this.viewContainerRef = viewContainerRef;\n    }\n    set templateContext(context) {\n        this.removeView();\n        if (context.templateRef) {\n            this.insertedViewRef = this.viewContainerRef.createEmbeddedView(context.templateRef, context);\n        }\n    }\n    ngOnDestroy() {\n        this.removeView();\n    }\n    removeView() {\n        if (this.insertedViewRef) {\n            this.viewContainerRef.remove(this.viewContainerRef.indexOf(this.insertedViewRef));\n            this.insertedViewRef = undefined;\n        }\n    }\n}\nTemplateContextDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[templateContext]' // tslint:disable-line:directive-selector\n            },] },\n];\n/** @nocollapse */\nTemplateContextDirective.ctorParameters = () => [\n    { type: ViewContainerRef }\n];\nTemplateContextDirective.propDecorators = {\n    templateContext: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nclass FocusGroup {\n    constructor(root) {\n        this.root = root;\n        this.active = true;\n        this.children = [];\n        this.root.registerGroup(this);\n    }\n    get focusableChildren() {\n        return this.children.filter(el => el.canFocus());\n    }\n    get isActive() {\n        return this.active;\n    }\n    ngOnDestroy() {\n        this.root.unregisterGroup(this);\n    }\n    registerElement(element) {\n        this.unregisterElement(element);\n        this.children.push(element);\n    }\n    unregisterElement(element) {\n        this.children = this.children.filter(f => f !== element);\n    }\n    /**\n     * Returns a Boolean value which indicates if the group will receive focus when the cell is focused.\n     * Requires a single \"simple\" focusable element such as a button or a checkbox.\n     */\n    isNavigable() {\n        const focusable = this.focusableChildren;\n        return focusable.length === 1 && focusable[0].isNavigable();\n    }\n    canFocus() {\n        return this.focusableChildren.length > 0;\n    }\n    focus() {\n        if (this.canFocus() && !this.hasFocus()) {\n            this.focusableChildren[0].focus();\n        }\n    }\n    activate() {\n        this.toggleState(true);\n    }\n    deactivate() {\n        this.toggleState(false);\n    }\n    hasFocus() {\n        return this.children.reduce((focused, element) => focused || element.hasFocus(), false);\n    }\n    toggleState(active) {\n        if (this.active !== active) {\n            this.active = active;\n            this.children.forEach(f => f.toggle(active));\n        }\n    }\n}\nFocusGroup.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nFocusGroup.ctorParameters = () => [\n    { type: FocusRoot }\n];\n\nlet id = 0;\nfunction nextId() {\n    return id++;\n}\n/**\n * @hidden\n */\nclass LogicalCellDirective {\n    constructor(focusGroup, element, columnInfoService, idService, navigationService, renderer, zone, cellContext) {\n        this.focusGroup = focusGroup;\n        this.element = element;\n        this.columnInfoService = columnInfoService;\n        this.idService = idService;\n        this.navigationService = navigationService;\n        this.renderer = renderer;\n        this.zone = zone;\n        this.cellContext = cellContext;\n        this.logicalSlaveCell = false;\n        this.colSpan = 1;\n        this.rowSpan = 1;\n        this.dataRowIndex = -1;\n        this.detailExpandCell = false;\n        this.uid = nextId();\n    }\n    get id() {\n        if (!this.logicalSlaveCell && this.columnInfoService.isLocked) {\n            return this.idService.cellId(this.logicalRowIndex, this.logicalColIndex);\n        }\n    }\n    get ariaColIndex() {\n        if (this.logicalSlaveCell || this.logicalColIndex === -1) {\n            return undefined;\n        }\n        return this.logicalColIndex + 1;\n    }\n    ngOnInit() {\n        if (!this.navigationService.enabled) {\n            return;\n        }\n        this.navigationChange = this.navigationService.changes.subscribe((e) => this.onNavigationChange(e));\n    }\n    ngDoCheck() {\n        if (!this.navigationService.enabled || this.logicalColIndex === -1) {\n            return;\n        }\n        if (this.cellContext) {\n            this.cellContext.focusGroup = this.focusGroup;\n        }\n        this.registerNoChanges();\n    }\n    ngOnChanges(changes) {\n        if (!this.navigationService.enabled) {\n            return;\n        }\n        const keys = Object.keys(changes);\n        if ((keys.length === 1 && keys[0] === 'groupItem') || this.logicalColIndex === -1) {\n            // Ignore groupItem changes as the reference is not stable\n            return;\n        }\n        const indexChange = changes.logicalColIndex;\n        const rowIndexChange = changes.logicalRowIndex;\n        const index = indexChange && !indexChange.isFirstChange() ? indexChange.previousValue : this.logicalColIndex;\n        const rowIndex = rowIndexChange && !rowIndexChange.isFirstChange() ? rowIndexChange.previousValue : this.logicalRowIndex;\n        this.navigationService.unregisterCell(index, rowIndex, this);\n        this.registerChanges();\n        this.updateElement();\n    }\n    ngOnDestroy() {\n        if (this.navigationChange) {\n            this.navigationChange.unsubscribe();\n        }\n        this.navigationService.unregisterCell(this.logicalColIndex, this.logicalRowIndex, this);\n    }\n    onNavigationChange(e) {\n        const active = this.logicalColIndex === e.colIndex && this.logicalRowIndex === e.rowIndex;\n        const wasActive = this.logicalColIndex === e.prevColIndex && this.logicalRowIndex === e.prevRowIndex;\n        if (active || wasActive) {\n            this.updateElement();\n        }\n    }\n    updateElement() {\n        const el = this.element.nativeElement;\n        this.renderer.setAttribute(el, 'tabIndex', this.isFocusable() && !this.logicalSlaveCell ? '0' : '-1');\n        if (this.isFocused()) {\n            if (this.focusGroup.isNavigable()) {\n                this.focusGroup.focus();\n            }\n            else {\n                if (!this.logicalSlaveCell && this.navigationService.autoFocusCell(this.logicalColIndex, this.logicalColIndex + this.colSpan - 1)) {\n                    this.microtask(() => this.isFocused() && el.focus());\n                }\n                this.renderer.addClass(el, 'k-state-focused');\n            }\n        }\n        else {\n            this.renderer.removeClass(el, 'k-state-focused');\n        }\n    }\n    microtask(callback) {\n        this.zone.runOutsideAngular(() => Promise.resolve(null).then(callback));\n    }\n    registerChanges() {\n        if (!this.logicalSlaveCell) {\n            this.navigationService.registerCell(this);\n        }\n    }\n    registerNoChanges() {\n        if (!this.logicalSlaveCell) {\n            this.navigationService.registerCellOnCurrentRow(this);\n        }\n    }\n    isFocusable() {\n        return this.navigationService.isCellFocusable(this);\n    }\n    isFocused() {\n        return this.navigationService.isCellFocused(this);\n    }\n}\nLogicalCellDirective.decorators = [\n    { type: Directive, args: [{\n                providers: [{\n                        provide: FocusGroup,\n                        deps: [FocusRoot],\n                        useClass: FocusGroup\n                    }],\n                selector: '[kendoGridLogicalCell]'\n            },] },\n];\n/** @nocollapse */\nLogicalCellDirective.ctorParameters = () => [\n    { type: FocusGroup },\n    { type: ElementRef },\n    { type: ColumnInfoService },\n    { type: IdService },\n    { type: NavigationService },\n    { type: Renderer2 },\n    { type: NgZone },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CELL_CONTEXT,] }] }\n];\nLogicalCellDirective.propDecorators = {\n    logicalColIndex: [{ type: Input }],\n    logicalRowIndex: [{ type: Input }],\n    logicalSlaveCell: [{ type: Input }],\n    colIndex: [{ type: Input }],\n    colSpan: [{ type: Input }],\n    rowSpan: [{ type: Input }],\n    groupItem: [{ type: Input }],\n    dataRowIndex: [{ type: Input }],\n    dataItem: [{ type: Input }],\n    detailExpandCell: [{ type: Input }],\n    id: [{ type: HostBinding, args: ['attr.id',] }],\n    ariaColIndex: [{ type: HostBinding, args: ['attr.aria-colindex',] }]\n};\n\nlet id$1 = 0;\nfunction nextId$1() {\n    return id$1++;\n}\n/**\n * @hidden\n */\nclass LogicalRowDirective {\n    constructor(idService, navigation) {\n        this.idService = idService;\n        this.navigation = navigation;\n        this.logicalSlaveRow = false;\n        this.logicalSlaveCellsCount = 0;\n        this.dataRowIndex = -1;\n        this.uid = nextId$1();\n    }\n    get hostRole() {\n        return this.logicalSlaveRow ? 'presentation' : 'row';\n    }\n    get ariaRowIndex() {\n        if (this.navigation.enabled) {\n            return this.logicalRowIndex + 1;\n        }\n    }\n    get ariaOwns() {\n        if (!this.navigation.enabled || this.logicalSlaveRow || this.logicalSlaveCellsCount === 0) {\n            return undefined;\n        }\n        const ids = [];\n        const total = this.logicalCellsCount + this.logicalSlaveCellsCount;\n        for (let cellIndex = this.logicalCellsCount; cellIndex < total; cellIndex++) {\n            ids.push(this.idService.cellId(this.logicalRowIndex, cellIndex));\n        }\n        return ids.join(' ');\n    }\n    ngOnChanges(changes) {\n        if (!this.navigation.enabled || this.logicalSlaveRow) {\n            return;\n        }\n        const indexChange = changes.logicalRowIndex;\n        const logicalSlaveRowChange = changes.logicalSlaveRow;\n        if (indexChange || logicalSlaveRowChange) {\n            const index = indexChange && !indexChange.isFirstChange() ? indexChange.previousValue : this.logicalRowIndex;\n            this.navigation.unregisterRow(index, this);\n            this.navigation.registerRow(this);\n        }\n        else if (anyChanged(['dataRowIndex', 'dataItem'], changes)) {\n            this.navigation.updateRow(this);\n        }\n    }\n    ngOnDestroy() {\n        this.navigation.unregisterRow(this.logicalRowIndex, this);\n    }\n}\nLogicalRowDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridLogicalRow]'\n            },] },\n];\n/** @nocollapse */\nLogicalRowDirective.ctorParameters = () => [\n    { type: IdService },\n    { type: NavigationService }\n];\nLogicalRowDirective.propDecorators = {\n    logicalRowIndex: [{ type: Input }],\n    logicalSlaveRow: [{ type: Input }],\n    logicalCellsCount: [{ type: Input }],\n    logicalSlaveCellsCount: [{ type: Input }],\n    dataRowIndex: [{ type: Input }],\n    dataItem: [{ type: Input }],\n    hostRole: [{ type: HostBinding, args: ['attr.role',] }],\n    ariaRowIndex: [{ type: HostBinding, args: ['attr.aria-rowindex',] }],\n    ariaOwns: [{ type: HostBinding, args: ['attr.aria-owns',] }]\n};\n\n/* tslint:disable:pipe-naming */\nconst FORMAT_REGEX = /\\{\\d+:?/;\n/**\n * @hidden\n */\nclass FieldAccessorPipe {\n    constructor(intlService) {\n        this.intlService = intlService;\n    }\n    transform(dataItem, fieldName, format) {\n        if (!isNullOrEmptyString(fieldName)) {\n            const value = getter(fieldName)(dataItem);\n            if (!isNullOrEmptyString(format)) {\n                return this.formatValue(format, value);\n            }\n            return value;\n        }\n        return dataItem;\n    }\n    formatValue(format, value) {\n        const intl = this.intlService;\n        if (isString(format) && format.match(FORMAT_REGEX)) {\n            return intl.format(format, value);\n        }\n        return intl.toString(value, format);\n    }\n}\nFieldAccessorPipe.decorators = [\n    { type: Pipe, args: [{\n                name: 'valueOf',\n                pure: false\n            },] },\n];\n/** @nocollapse */\nFieldAccessorPipe.ctorParameters = () => [\n    { type: IntlService }\n];\n\n/**\n * @hidden\n */\nconst columnsToResize = ({ columns }) => Math.max(1, resizableColumns(columns).length);\n/**\n * @hidden\n */\nconst row = selector => element => element.querySelector(selector);\n/**\n * @hidden\n */\nconst headerRow = index => element => element.querySelectorAll('thead>tr')[index];\n/**\n * @hidden\n */\nconst cell = (index, selector = 'td') => element => element.querySelectorAll(`${selector}:not(.k-group-cell):not(.k-hierarchy-cell)`)[index];\n/**\n * @hidden\n */\nconst offsetWidth = element => element.offsetWidth;\n/**\n * @hidden\n */\nconst pipe = (...fns) => data => fns.reduce((state$$1, fn) => state$$1 ? fn(state$$1) : 0, data);\n/**\n * @hidden\n */\nclass TableDirective {\n    constructor(element, renderer, service, zone, cdr) {\n        this.element = element;\n        this.renderer = renderer;\n        this.service = service;\n        this.zone = zone;\n        this.cdr = cdr;\n        this.locked = false;\n        this.firstResize = false;\n    }\n    get minWidth() {\n        return this.firstResize ? 0 : null;\n    }\n    ngOnInit() {\n        const obs = this.service\n            .changes.pipe(filter(e => this.locked === e.locked));\n        this.subscription = obs.pipe(filter(e => e.type === 'start'), tap(this.initState.bind(this)), map(columnsToResize), switchMap((take$$1) => obs.pipe(filter(e => e.type === 'resizeTable'), map(e => e.delta), bufferCount(take$$1)))).subscribe(this.resize.bind(this));\n        this.autoFitSubscription = this.service\n            .registerTable({\n            autoFit: this.autoFitObservable.bind(this),\n            locked: this.locked\n        });\n    }\n    ngOnDestroy() {\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n        }\n        if (this.autoFitSubscription) {\n            this.autoFitSubscription();\n            this.autoFitSubscription = null;\n        }\n    }\n    initState() {\n        this.firstResize = true;\n        if (!this.virtualColumns || this.locked) {\n            this.originalWidth = offsetWidth(this.element.nativeElement);\n        }\n    }\n    resize(deltas) {\n        if (!this.virtualColumns || this.locked) {\n            const delta = deltas.reduce((sum, item) => sum + item, 0);\n            const width = this.originalWidth + delta;\n            this.renderer.setStyle(this.element.nativeElement, 'width', width + 'px');\n        }\n        this.cdr.detectChanges();\n    }\n    autoFitObservable(columnInfo) {\n        return Observable.create(observer => {\n            this.zone.runOutsideAngular(() => {\n                this.renderer.addClass(this.element.nativeElement, 'k-autofitting');\n                this.cdr.detectChanges();\n                const widths = columnInfo.map(this.measureColumn.bind(this));\n                this.renderer.removeClass(this.element.nativeElement, 'k-autofitting');\n                observer.next(widths);\n            });\n        });\n    }\n    measureColumn(info) {\n        const dom = this.element.nativeElement;\n        const header = pipe(headerRow(info.level), cell(info.headerIndex, 'th'), offsetWidth)(dom);\n        let data = 0;\n        if (!info.isParentSpan || (info.isParentSpan && info.isLastInSpan)) {\n            data = pipe(row('tbody>tr:not(.k-grouping-row):not(.k-grid-norecords)'), cell(info.index), offsetWidth)(dom);\n        }\n        const footer = pipe(row('tfoot>tr'), cell(info.index), offsetWidth)(dom);\n        return Math.max(header, data, footer);\n    }\n}\nTableDirective.decorators = [\n    { type: Directive, args: [{\n                selector: 'table' // tslint:disable-line:directive-selector\n            },] },\n];\n/** @nocollapse */\nTableDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: ColumnResizingService },\n    { type: NgZone },\n    { type: ChangeDetectorRef }\n];\nTableDirective.propDecorators = {\n    locked: [{ type: Input }],\n    virtualColumns: [{ type: Input }],\n    minWidth: [{ type: HostBinding, args: ['style.min-width',] }]\n};\n\nconst exportedModules = [\n    ColumnComponent,\n    ColumnGroupComponent,\n    LogicalCellDirective,\n    LogicalRowDirective,\n    FocusableDirective,\n    FooterTemplateDirective,\n    ColGroupComponent,\n    ResizableContainerDirective,\n    TemplateContextDirective,\n    FieldAccessorPipe,\n    DetailTemplateDirective,\n    SpanColumnComponent,\n    TableDirective,\n    LoadingComponent\n];\n/**\n * @hidden\n */\nclass SharedModule {\n    static exports() {\n        return [\n            ColumnComponent,\n            SpanColumnComponent,\n            ColumnGroupComponent,\n            FooterTemplateDirective,\n            DetailTemplateDirective,\n            FocusableDirective\n        ];\n    }\n}\nSharedModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [exportedModules],\n                exports: [exportedModules, DraggableModule, EventsModule],\n                imports: [CommonModule]\n            },] },\n];\n\n/**\n * Represents the `Contains` (**Contains**) filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\nclass ContainsFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) { super(\"contains\", localization); }\n}\nContainsFilterOperatorComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: FilterOperatorBase,\n                        useExisting: forwardRef(() => ContainsFilterOperatorComponent)\n                    }\n                ],\n                selector: 'kendo-filter-contains-operator',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nContainsFilterOperatorComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * Represents the `DoesNotContain` (**Does not contain**) filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\nclass DoesNotContainFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) { super(\"doesnotcontain\", localization); }\n}\nDoesNotContainFilterOperatorComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: FilterOperatorBase,\n                        useExisting: forwardRef(() => DoesNotContainFilterOperatorComponent)\n                    }\n                ],\n                selector: 'kendo-filter-not-contains-operator',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nDoesNotContainFilterOperatorComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * Represents the `EndsWith` (**Ends with**) string filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\nclass EndsWithFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) { super(\"endswith\", localization); }\n}\nEndsWithFilterOperatorComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: FilterOperatorBase,\n                        useExisting: forwardRef(() => EndsWithFilterOperatorComponent)\n                    }\n                ],\n                selector: 'kendo-filter-endswith-operator',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nEndsWithFilterOperatorComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * Represents the `Equal` (**Is equal to**) filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\nclass EqualFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) { super(\"eq\", localization); }\n}\nEqualFilterOperatorComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: FilterOperatorBase,\n                        useExisting: forwardRef(() => EqualFilterOperatorComponent)\n                    }\n                ],\n                selector: 'kendo-filter-eq-operator',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nEqualFilterOperatorComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * Represents the `IsEmpty` (**Is empty**) filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\nclass IsEmptyFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) { super(\"isempty\", localization); }\n}\nIsEmptyFilterOperatorComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: FilterOperatorBase,\n                        useExisting: forwardRef(() => IsEmptyFilterOperatorComponent)\n                    }\n                ],\n                selector: 'kendo-filter-isempty-operator',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nIsEmptyFilterOperatorComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * Represents the `IsNotEmpty` (**Is not empty**) filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\nclass IsNotEmptyFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) { super(\"isnotempty\", localization); }\n}\nIsNotEmptyFilterOperatorComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: FilterOperatorBase,\n                        useExisting: forwardRef(() => IsNotEmptyFilterOperatorComponent)\n                    }\n                ],\n                selector: 'kendo-filter-isnotempty-operator',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nIsNotEmptyFilterOperatorComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * Represents the `IsNotNull` (**Is not null**) filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\nclass IsNotNullFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) { super(\"isnotnull\", localization); }\n}\nIsNotNullFilterOperatorComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: FilterOperatorBase,\n                        useExisting: forwardRef(() => IsNotNullFilterOperatorComponent)\n                    }\n                ],\n                selector: 'kendo-filter-isnotnull-operator',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nIsNotNullFilterOperatorComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * Represents the `IsNull` (**Is null**) filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\nclass IsNullFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) { super(\"isnull\", localization); }\n}\nIsNullFilterOperatorComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: FilterOperatorBase,\n                        useExisting: forwardRef(() => IsNullFilterOperatorComponent)\n                    }\n                ],\n                selector: 'kendo-filter-isnull-operator',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nIsNullFilterOperatorComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * Represents the `NotEqual` (**Is not equal to**) filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\nclass NotEqualFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) { super(\"neq\", localization); }\n}\nNotEqualFilterOperatorComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: FilterOperatorBase,\n                        useExisting: forwardRef(() => NotEqualFilterOperatorComponent)\n                    }\n                ],\n                selector: 'kendo-filter-neq-operator',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nNotEqualFilterOperatorComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * Represents the `StartsWith` (**Starts with**) filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\nclass StartsWithFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) { super(\"startswith\", localization); }\n}\nStartsWithFilterOperatorComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: FilterOperatorBase,\n                        useExisting: forwardRef(() => StartsWithFilterOperatorComponent)\n                    }\n                ],\n                selector: 'kendo-filter-startswith-operator',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nStartsWithFilterOperatorComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/*\n * Represents the `Greater` (**Is greater than**) numeric filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\nclass GreaterFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) { super(\"gt\", localization); }\n}\nGreaterFilterOperatorComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: FilterOperatorBase,\n                        useExisting: forwardRef(() => GreaterFilterOperatorComponent)\n                    }\n                ],\n                selector: 'kendo-filter-gt-operator',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nGreaterFilterOperatorComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * Represents the `GreaterOrEqualTo` (**Is greater than or equal to**) numeric filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\nclass GreaterOrEqualToFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) { super(\"gte\", localization); }\n}\nGreaterOrEqualToFilterOperatorComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: FilterOperatorBase,\n                        useExisting: forwardRef(() => GreaterOrEqualToFilterOperatorComponent)\n                    }\n                ],\n                selector: 'kendo-filter-gte-operator',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nGreaterOrEqualToFilterOperatorComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/*\n * Represents the `Less` (**Is less than**) numeric filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\nclass LessFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) { super(\"lt\", localization); }\n}\nLessFilterOperatorComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: FilterOperatorBase,\n                        useExisting: forwardRef(() => LessFilterOperatorComponent)\n                    }\n                ],\n                selector: 'kendo-filter-lt-operator',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nLessFilterOperatorComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/*\n * Represents the `LessOrEqualTo` (**Is less than or equal to**) numeric filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\nclass LessOrEqualToFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) { super(\"lte\", localization); }\n}\nLessOrEqualToFilterOperatorComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: FilterOperatorBase,\n                        useExisting: forwardRef(() => LessOrEqualToFilterOperatorComponent)\n                    }\n                ],\n                selector: 'kendo-filter-lte-operator',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nLessOrEqualToFilterOperatorComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/*\n * Represents the `Greater` (**Is after**) date filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\nclass AfterFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) { super(\"after\", localization); }\n    /**\n     * @hidden\n     */\n    toJSON() {\n        return {\n            text: this.text,\n            value: \"gt\"\n        };\n    }\n}\nAfterFilterOperatorComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: FilterOperatorBase,\n                        useExisting: forwardRef(() => AfterFilterOperatorComponent)\n                    }\n                ],\n                selector: 'kendo-filter-after-operator',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nAfterFilterOperatorComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/*\n * Represents the `GreaterOrEqualTo` (**Is after or equal to**) date filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\nclass AfterEqFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) { super(\"after-eq\", localization); }\n    /**\n     * @hidden\n     */\n    toJSON() {\n        return {\n            text: this.text,\n            value: \"gte\"\n        };\n    }\n}\nAfterEqFilterOperatorComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: FilterOperatorBase,\n                        useExisting: forwardRef(() => AfterEqFilterOperatorComponent)\n                    }\n                ],\n                selector: 'kendo-filter-after-eq-operator',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nAfterEqFilterOperatorComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/*\n * Represents the `LessOrEqualTo` (**Is before or equal to**) date filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\nclass BeforeEqFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) { super(\"before-eq\", localization); }\n    /**\n     * @hidden\n     */\n    toJSON() {\n        return {\n            text: this.text,\n            value: \"lte\"\n        };\n    }\n}\nBeforeEqFilterOperatorComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: FilterOperatorBase,\n                        useExisting: forwardRef(() => BeforeEqFilterOperatorComponent)\n                    }\n                ],\n                selector: 'kendo-filter-before-eq-operator',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nBeforeEqFilterOperatorComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/*\n * Represents the `Less then` (**Is before**) date filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\nclass BeforeFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) { super(\"before\", localization); }\n    /**\n     * @hidden\n     */\n    toJSON() {\n        return {\n            text: this.text,\n            value: \"lt\"\n        };\n    }\n}\nBeforeFilterOperatorComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: FilterOperatorBase,\n                        useExisting: forwardRef(() => BeforeFilterOperatorComponent)\n                    }\n                ],\n                selector: 'kendo-filter-before-operator',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nBeforeFilterOperatorComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\nconst FILTER_OPERATORS = [\n    FilterCellOperatorsComponent,\n    ContainsFilterOperatorComponent,\n    DoesNotContainFilterOperatorComponent,\n    EndsWithFilterOperatorComponent,\n    EqualFilterOperatorComponent,\n    IsEmptyFilterOperatorComponent,\n    IsNotEmptyFilterOperatorComponent,\n    IsNotNullFilterOperatorComponent,\n    IsNullFilterOperatorComponent,\n    NotEqualFilterOperatorComponent,\n    StartsWithFilterOperatorComponent,\n    GreaterFilterOperatorComponent,\n    GreaterOrEqualToFilterOperatorComponent,\n    LessFilterOperatorComponent,\n    LessOrEqualToFilterOperatorComponent,\n    AfterFilterOperatorComponent,\n    AfterEqFilterOperatorComponent,\n    BeforeEqFilterOperatorComponent,\n    BeforeFilterOperatorComponent\n];\nconst importedModules = [\n    CommonModule,\n    ReactiveFormsModule,\n    FormsModule,\n    DropDownListModule,\n    AutoCompleteModule,\n    InputsModule,\n    DatePickerModule,\n    PopupModule,\n    SharedModule\n];\nconst COMPONENTS = [\n    FilterInputDirective\n];\n/**\n * @hidden\n */\nclass SharedFilterModule {\n    static exports() {\n        return [\n            ...FILTER_OPERATORS\n        ];\n    }\n}\nSharedFilterModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [FILTER_OPERATORS, COMPONENTS],\n                exports: [FILTER_OPERATORS, importedModules, COMPONENTS],\n                imports: [...importedModules]\n            },] },\n];\n\n/**\n * @hidden\n */\nclass FilterHostDirective {\n    constructor(host, resolver) {\n        this.host = host;\n        this.resolver = resolver;\n    }\n    ngOnInit() {\n        this.component = this.host.createComponent(this.resolver.resolveComponentFactory(this.componentType()));\n        this.initComponent({\n            column: this.column,\n            filter: this.filter\n        });\n    }\n    ngOnDestroy() {\n        if (this.component) {\n            this.component.destroy();\n            this.component = null;\n        }\n    }\n    ngOnChanges(changes) {\n        if (anyChanged([\"column\", \"filter\"], changes)) {\n            this.initComponent({\n                column: this.column,\n                filter: this.filter\n            });\n        }\n    }\n    initComponent({ column, filter: filter$$1 }) {\n        const instance = this.component.instance;\n        instance.column = column;\n        instance.filter = filter$$1;\n    }\n}\nFilterHostDirective.propDecorators = {\n    column: [{ type: Input }],\n    filter: [{ type: Input }]\n};\n\n/**\n * @hidden\n *\n * > List the following components in the GridModule as `entryComponents`.\n */\nconst filterComponentFactory = (type) => ({\n    \"boolean\": BooleanFilterCellComponent,\n    \"date\": DateFilterCellComponent,\n    \"numeric\": NumericFilterCellComponent,\n    \"text\": StringFilterCellComponent\n}[type]);\n\n/**\n * @hidden\n */\nclass FilterCellHostDirective extends FilterHostDirective {\n    constructor(host, resolver) {\n        super(host, resolver);\n    }\n    componentType() {\n        if (!isNullOrEmptyString(this.column.filter)) {\n            return filterComponentFactory(this.column.filter);\n        }\n        return StringFilterCellComponent;\n    }\n}\nFilterCellHostDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoFilterCellHost]'\n            },] },\n];\n/** @nocollapse */\nFilterCellHostDirective.ctorParameters = () => [\n    { type: ViewContainerRef },\n    { type: ComponentFactoryResolver }\n];\n\nconst INTERNAL_COMPONENTS = [\n    FilterRowComponent,\n    FilterCellComponent,\n    FilterCellTemplateDirective,\n    StringFilterCellComponent,\n    NumericFilterCellComponent,\n    AutoCompleteFilterCellComponent,\n    BooleanFilterCellComponent,\n    FilterCellHostDirective,\n    FilterCellWrapperComponent,\n    DateFilterCellComponent\n];\nconst ENTRY_COMPONENTS = [\n    StringFilterCellComponent,\n    NumericFilterCellComponent,\n    BooleanFilterCellComponent,\n    DateFilterCellComponent\n];\n/**\n * @hidden\n */\nclass RowFilterModule {\n    static exports() {\n        return [\n            FilterRowComponent,\n            FilterCellComponent,\n            FilterCellTemplateDirective,\n            FilterCellOperatorsComponent,\n            StringFilterCellComponent,\n            NumericFilterCellComponent,\n            AutoCompleteFilterCellComponent,\n            BooleanFilterCellComponent,\n            DateFilterCellComponent,\n            SharedFilterModule.exports()\n        ];\n    }\n}\nRowFilterModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [INTERNAL_COMPONENTS],\n                entryComponents: ENTRY_COMPONENTS,\n                exports: [INTERNAL_COMPONENTS, SharedFilterModule],\n                imports: [SharedFilterModule]\n            },] },\n];\n\n/**\n * @hidden\n */\nconst normalizeSettings = ({ buttonCount = 10, info = true, type = 'numeric', pageSizes = false, previousNext = true }) => ({\n    buttonCount,\n    info,\n    pageSizes: pageSizes === true ? [5, 10, 20] : pageSizes,\n    previousNext,\n    type\n});\n/**\n * @hidden\n */\nconst normalize = (settings) => normalizeSettings(settings === true ? {} : settings);\n\n/**\n * @hidden\n */\nclass PagerComponent {\n    constructor(pagerContext) {\n        this.pagerContext = pagerContext;\n        this.total = 0;\n        this.skip = 1;\n        this.pageChange = new EventEmitter();\n        this.settings = normalize({});\n        this._templateContext = {};\n    }\n    set options(value) {\n        this.settings = normalize(value);\n    }\n    get pagerWrapClass() {\n        return true;\n    }\n    get gridPagerClass() {\n        return true;\n    }\n    get widgetClass() {\n        return true;\n    }\n    get totalPages() {\n        return Math.ceil((this.total || 0) / this.pageSize);\n    }\n    get currentPage() {\n        return Math.floor((this.skip || 0) / this.pageSize) + 1;\n    }\n    get templateContext() {\n        const context = this._templateContext;\n        context.totalPages = this.totalPages;\n        context.total = this.total;\n        context.skip = this.skip;\n        context.pageSize = this.pageSize;\n        context.currentPage = this.currentPage;\n        return context;\n    }\n    ngOnInit() {\n        this.pageChangeSubscription = this.pagerContext.pageChange.subscribe(this.changePage.bind(this));\n    }\n    ngOnChanges(changes) {\n        if (anyChanged([\"pageSize\", \"skip\", \"total\"], changes, false)) {\n            this.pagerContext.notifyChanges({\n                pageSize: this.pageSize,\n                skip: this.skip,\n                total: this.total\n            });\n        }\n    }\n    ngOnDestroy() {\n        if (this.pageChangeSubscription) {\n            this.pageChangeSubscription.unsubscribe();\n        }\n    }\n    changePage(event) {\n        this.pageChange.emit(event);\n    }\n}\nPagerComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-pager',\n                template: `\n        <ng-container\n            *ngIf=\"template?.templateRef\"\n            [ngTemplateOutlet]=\"template.templateRef\"\n            [ngTemplateOutletContext]=\"templateContext\">\n        </ng-container>\n        <ng-container *ngIf=\"!template?.templateRef\">\n            <kendo-pager-prev-buttons *ngIf=\"settings.previousNext\"></kendo-pager-prev-buttons>\n            <kendo-pager-numeric-buttons\n                *ngIf=\"settings.type === 'numeric'\"\n                [buttonCount]=\"settings.buttonCount\">\n            </kendo-pager-numeric-buttons>\n            <kendo-pager-input *ngIf=\"settings.type === 'input'\"></kendo-pager-input>\n            <kendo-pager-next-buttons *ngIf=\"settings.previousNext\"></kendo-pager-next-buttons>\n            <kendo-pager-info *ngIf='settings.info'></kendo-pager-info>\n            <kendo-pager-page-sizes *ngIf=\"settings.pageSizes\" [pageSizes]=\"settings.pageSizes\"></kendo-pager-page-sizes>\n        </ng-container>\n  `\n            },] },\n];\n/** @nocollapse */\nPagerComponent.ctorParameters = () => [\n    { type: PagerContextService }\n];\nPagerComponent.propDecorators = {\n    total: [{ type: Input }],\n    skip: [{ type: Input }],\n    pageSize: [{ type: Input }],\n    options: [{ type: Input }],\n    template: [{ type: Input }],\n    pageChange: [{ type: Output }],\n    pagerWrapClass: [{ type: HostBinding, args: ['class.k-pager-wrap',] }],\n    gridPagerClass: [{ type: HostBinding, args: ['class.k-grid-pager',] }],\n    widgetClass: [{ type: HostBinding, args: ['class.k-widget',] }]\n};\n\n/**\n * @hidden\n */\nclass PagerElementComponent {\n    constructor(localization, pagerContext, cd) {\n        this.localization = localization;\n        this.pagerContext = pagerContext;\n        this.cd = cd;\n        this.total = this.pagerContext.total;\n        this.skip = this.pagerContext.skip;\n        this.pageSize = this.pagerContext.pageSize;\n    }\n    /**\n     * @hidden\n     *\n     * @readonly\n     * @type {number}\n     * @memberOf PagerElementComponent\n     */\n    get currentPage() {\n        return Math.floor((this.skip || 0) / this.pageSize) + 1;\n    }\n    /**\n     * @hidden\n     *\n     * @readonly\n     * @type {number}\n     * @memberOf PagerElementComponent\n     */\n    get totalPages() {\n        return Math.ceil((this.total || 0) / this.pageSize);\n    }\n    /**\n     * @hidden\n     *\n     * @param {string} key\n     * @returns {string}\n     *\n     * @memberOf PagerElementComponent\n     */\n    textFor(key) {\n        return this.localization.get(key);\n    }\n    /**\n     * @hidden\n     *\n     * @param {number} page\n     *\n     * @memberOf PagerElementComponent\n     */\n    changePage(page) {\n        this.pagerContext.changePage(page);\n        return false;\n    }\n    /**\n     * @hidden\n     *\n     * @memberOf PagerElementComponent\n     */\n    ngOnInit() {\n        this.subscriptions = this.pagerContext.changes.subscribe(this.onChanges.bind(this));\n        this.subscriptions.add(this.localization.changes.subscribe(() => this.cd.markForCheck()));\n    }\n    ngOnDestroy() {\n        if (this.subscriptions) {\n            this.subscriptions.unsubscribe();\n        }\n    }\n}\n\n// tslint:disable:no-access-missing-member\n/**\n * Displays buttons for navigating to the first and to the previous page ([see example]({% slug paging_grid %}#toc-pager-templates)).\n */\nclass PagerPrevButtonsComponent extends PagerElementComponent {\n    constructor(localization, pagerContext, cd) {\n        super(localization, pagerContext, cd);\n    }\n    /**\n     * @hidden\n     *\n     * @readonly\n     * @type {boolean}\n     * @memberOf PagerPrevButtonsComponent\n     */\n    get disabled() {\n        return this.currentPage === 1 || !this.total;\n    }\n    onChanges({ total, skip, pageSize }) {\n        this.total = total;\n        this.skip = skip;\n        this.pageSize = pageSize;\n        this.cd.markForCheck();\n    }\n}\nPagerPrevButtonsComponent.decorators = [\n    { type: Component, args: [{\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                selector: 'kendo-pager-prev-buttons',\n                template: `\n        <a  href=\"#\"\n            tabindex=\"-1\"\n            [title]=\"textFor('pagerFirstPage')\"\n            (click)=\"currentPage !== 1 ? changePage(0) : false\"\n            [ngClass]=\"{\n                'k-link': true,\n                'k-pager-nav': true,\n                'k-state-disabled': disabled,\n                'k-pager-first': true\n            }\">\n            <span [attr.aria-label]=\"textFor('pagerFirstPage')\"\n                [ngClass]=\"{\n                    'k-icon':true,\n                    'k-i-seek-w': true\n                }\">\n            </span>\n        </a>\n        <a  href=\"#\"\n            tabindex=\"-1\"\n            [title]=\"textFor('pagerPreviousPage')\"\n            (click)=\"currentPage !== 1 ? changePage(currentPage-2) : false\"\n            [ngClass]=\"{\n                'k-link': true,\n                'k-pager-nav': true,\n                'k-state-disabled': disabled,\n                '': true\n            }\">\n            <span [attr.aria-label]=\"textFor('pagerPreviousPage')\"\n                [ngClass]=\"{\n                    'k-icon':true,\n                    'k-i-arrow-w': true\n                }\">\n            </span>\n        </a>\n    `\n            },] },\n];\n/** @nocollapse */\nPagerPrevButtonsComponent.ctorParameters = () => [\n    { type: LocalizationService },\n    { type: PagerContextService },\n    { type: ChangeDetectorRef }\n];\n\n// tslint:disable: no-access-missing-member\n/**\n * Displays buttons for navigating to the next and to the last page ([see example]({% slug paging_grid %}#toc-pager-templates)).\n */\nclass PagerNextButtonsComponent extends PagerElementComponent {\n    constructor(localization, pagerContext, cd) {\n        super(localization, pagerContext, cd);\n    }\n    /**\n     * @hidden\n     *\n     * @readonly\n     * @type {boolean}\n     * @memberOf PagerNextButtonsComponent\n     */\n    get disabled() {\n        return this.currentPage === this.totalPages || !this.total;\n    }\n    onChanges({ total, skip, pageSize }) {\n        this.total = total;\n        this.skip = skip;\n        this.pageSize = pageSize;\n        this.cd.markForCheck();\n    }\n}\nPagerNextButtonsComponent.decorators = [\n    { type: Component, args: [{\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                selector: 'kendo-pager-next-buttons',\n                template: `\n        <a  href=\"#\"\n            tabindex=\"-1\"\n            [title]=\"textFor('pagerNextPage')\"\n            (click)=\"currentPage !== totalPages ? changePage(currentPage) : false\"\n            [ngClass]=\"{\n                'k-link': true,\n                'k-pager-nav': true,\n                'k-state-disabled': disabled,\n                '': true\n            }\">\n            <span [attr.aria-label]=\"textFor('pagerNextPage')\"\n                [ngClass]=\"{\n                    'k-icon':true,\n                    'k-i-arrow-e': true\n                }\">\n            </span>\n        </a>\n        <a  href=\"#\"\n            tabindex=\"-1\"\n            [title]=\"textFor('pagerLastPage')\"\n            (click)=\"currentPage !== totalPages ? changePage(totalPages-1) : false\"\n            [ngClass]=\"{\n                'k-link': true,\n                'k-pager-nav': true,\n                'k-state-disabled': disabled,\n                'k-pager-last': true\n            }\">\n            <span [attr.aria-label]=\"textFor('pagerLastPage')\"\n                [ngClass]=\"{\n                    'k-icon':true,\n                    'k-i-seek-e': true\n                }\">\n            </span>\n        </a>\n    `\n            },] },\n];\n/** @nocollapse */\nPagerNextButtonsComponent.ctorParameters = () => [\n    { type: LocalizationService },\n    { type: PagerContextService },\n    { type: ChangeDetectorRef }\n];\n\n/**\n * Displays numeric buttons to enable navigation between the pages.\n */\nclass PagerNumericButtonsComponent extends PagerElementComponent {\n    constructor(localization, cd, pagerContext) {\n        super(localization, pagerContext, cd);\n        this.pagerContext = pagerContext;\n    }\n    /**\n     * @hidden\n     *\n     * @readonly\n     * @type {number[]}\n     * @memberOf PagerNumericButtonsComponent\n     */\n    get buttons() {\n        let result = [];\n        for (let idx = this.start; idx <= this.end; idx++) {\n            result.push(idx);\n        }\n        return result;\n    }\n    /**\n     * @hidden\n     */\n    get end() {\n        return Math.min((this.start + this.buttonCount) - 1, this.totalPages);\n    }\n    /**\n     * @hidden\n     */\n    get start() {\n        const page = this.currentPage;\n        const buttonCount = this.buttonCount;\n        if (page > buttonCount) {\n            const reminder = (page % buttonCount);\n            return (reminder === 0) ? (page - buttonCount) + 1 : (page - reminder) + 1;\n        }\n        return 1;\n    }\n    /**\n     * @hidden\n     */\n    pageLabel(num) {\n        const pageText = this.textFor('pagerPage');\n        if (pageText) {\n            return pageText + ' ' + num;\n        }\n        return num.toString();\n    }\n    onChanges({ total, skip, pageSize }) {\n        this.total = total;\n        this.skip = skip;\n        this.pageSize = pageSize;\n        this.cd.markForCheck();\n    }\n}\nPagerNumericButtonsComponent.decorators = [\n    { type: Component, args: [{\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                selector: 'kendo-pager-numeric-buttons',\n                template: `\n       <ul [ngClass]=\"{'k-pager-numbers': true, 'k-reset': true}\">\n            <li *ngIf=\"start > 1\">\n                <a  class=\"k-link\"\n                    [attr.aria-label]=\"pageLabel(start - 1)\"\n                    href=\"#\"\n                    tabindex=\"-1\"\n                    (click)=\"changePage(start - 2)\">...</a>\n            </li>\n            <li *ngFor=\"let num of buttons\">\n                <a  href=\"#\"\n                    [attr.aria-label]=\"pageLabel(num)\"\n                    tabindex=\"-1\"\n                    [ngClass]=\"{'k-link': true, 'k-state-selected':currentPage == num}\"\n                    (click)=\"changePage(num - 1)\">\n                    {{num}}\n                </a>\n            </li>\n            <li *ngIf=\"end < totalPages\">\n                <a  class=\"k-link\"\n                    [attr.aria-label]=\"pageLabel(end + 1)\"\n                    href=\"#\"\n                    tabindex=\"-1\"\n                    (click)=\"changePage(end)\">...</a>\n            </li>\n        </ul>\n    `\n            },] },\n];\n/** @nocollapse */\nPagerNumericButtonsComponent.ctorParameters = () => [\n    { type: LocalizationService },\n    { type: ChangeDetectorRef },\n    { type: PagerContextService }\n];\nPagerNumericButtonsComponent.propDecorators = {\n    buttonCount: [{ type: Input }]\n};\n\n/**\n * Displays an input element which allows the typing and rendering of page numbers.\n */\nclass PagerInputComponent extends PagerElementComponent {\n    constructor(localization, pagerContext, zone, cd) {\n        super(localization, pagerContext, cd);\n        this.pagerContext = pagerContext;\n        this.zone = zone;\n        /**\n         * @hidden\n         *\n         * @param {string} value\n         *\n         * @memberOf PagerInputComponent\n         */\n        this.handleKeyDown = (event) => {\n            let incomingValue = this.numericInput.value || this.current;\n            if (event.keyCode === Keys.Enter) {\n                event.preventDefault();\n                if (incomingValue !== this.current) {\n                    this.zone.run(() => {\n                        this.changePage(incomingValue - 1);\n                    });\n                }\n            }\n        };\n        /**\n         * @hidden\n         *\n         * @param {string} value\n         *\n         * @memberOf PagerInputComponent\n         */\n        this.handleBlur = () => {\n            const inputValue = this.numericInput.value;\n            if (!inputValue) {\n                this.numericInput.writeValue(this.current);\n                return;\n            }\n            if (inputValue !== this.current) {\n                this.zone.run(() => {\n                    this.changePage(inputValue - 1);\n                });\n            }\n        };\n    }\n    /**\n     * @hidden\n     */\n    get current() {\n        return this.hasPages ? this.currentPage : 0;\n    }\n    get hasPages() {\n        return this.totalPages !== 0;\n    }\n    onChanges({ total, skip, pageSize }) {\n        this.total = total;\n        this.skip = skip;\n        this.pageSize = pageSize;\n        this.cd.markForCheck();\n    }\n}\nPagerInputComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-pager-input',\n                template: `\n     <span [ngClass]=\"{'k-pager-input': true, 'k-label': true}\">\n        {{textFor('pagerPage')}}\n        <kendo-numerictextbox\n            [spinners]=\"false\"\n            [decimals]=\"0\"\n            format=\"n0\"\n            [disabled]=\"!hasPages\"\n            [value]=\"current\"\n            [min]=\"hasPages ? 1 : 0\"\n            [max]=\"totalPages\"\n            [autoCorrect]=\"true\"\n            [kendoEventsOutsideAngular]=\"{\n                keydown: handleKeyDown,\n                focusout: handleBlur\n            }\"></kendo-numerictextbox>\n        {{textFor('pagerOf')}} {{totalPages}}\n     </span>\n    `\n            },] },\n];\n/** @nocollapse */\nPagerInputComponent.ctorParameters = () => [\n    { type: LocalizationService },\n    { type: PagerContextService },\n    { type: NgZone },\n    { type: ChangeDetectorRef }\n];\nPagerInputComponent.propDecorators = {\n    numericInput: [{ type: ViewChild, args: [NumericTextBoxComponent,] }]\n};\n\n// tslint:disable:no-access-missing-member\n/**\n * Displays information about the current page and the total number of records ([see example]({% slug paging_grid %}#toc-pager-templates)).\n */\nclass PagerInfoComponent extends PagerElementComponent {\n    constructor(localization, cd, pagerContext) {\n        super(localization, pagerContext, cd);\n        this.pagerContext = pagerContext;\n    }\n    /**\n     * @hidden\n     *\n     * @readonly\n     * @type {number}\n     * @memberOf PagerInfoComponent\n     */\n    get maxItems() {\n        return Math.min(this.currentPage * this.pageSize, this.total);\n    }\n    /**\n     * @hidden\n     *\n     * @readonly\n     * @type {number}\n     * @memberOf PagerInfoComponent\n     */\n    get currentPageText() {\n        return this.total ?\n            (this.currentPage - 1) * this.pageSize + 1 :\n            0;\n    }\n    /**\n     * @hidden\n     *\n     * @readonly\n     * @type {boolean}\n     * @memberOf PagerInfoComponent\n     */\n    get classes() {\n        return true;\n    }\n    onChanges({ total, skip, pageSize }) {\n        this.total = total;\n        this.skip = skip;\n        this.pageSize = pageSize;\n        this.cd.markForCheck();\n    }\n}\nPagerInfoComponent.decorators = [\n    { type: Component, args: [{\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                selector: 'kendo-pager-info',\n                template: `{{currentPageText}} - {{maxItems}} {{textFor('pagerOf')}} {{total}} {{textFor('pagerItems')}}`\n            },] },\n];\n/** @nocollapse */\nPagerInfoComponent.ctorParameters = () => [\n    { type: LocalizationService },\n    { type: ChangeDetectorRef },\n    { type: PagerContextService }\n];\nPagerInfoComponent.propDecorators = {\n    classes: [{ type: HostBinding, args: [\"class.k-pager-info\",] }, { type: HostBinding, args: [\"class.k-label\",] }]\n};\n\n// tslint:disable:no-access-missing-member\n/**\n * Displays a drop-down list for the page size selection ([see example]({% slug paging_grid %}#toc-pager-templates)).\n */\nclass PagerPageSizesComponent extends PagerElementComponent {\n    constructor(localization, cd, pagerContext) {\n        super(localization, pagerContext, cd);\n        this.pagerContext = pagerContext;\n        this._pageSizes = [];\n    }\n    get pageSizes() {\n        return this._pageSizes;\n    }\n    /**\n     * The page sizes collection. Can be an Array of numbers and/or PageSizeItem objects.\n     *\n     * @example\n     * ```ts-preview\n     * _@Component({\n     *    selector: 'my-app',\n     *    template: `\n     *        <kendo-grid [kendoGridBinding]=\"gridData\" [height]=\"200\"\n     *           [pageable]=\"true\"\n     *            [pageSize]=\"pageSize\">\n     *            <ng-template kendoPagerTemplate let-totalPages=\"totalPages\" let-currentPage=\"currentPage\">\n     *                <kendo-pager-page-sizes [pageSizes]=\"pagesizes\"></kendo-pager-page-sizes>\n     *            </ng-template>\n     *        </kendo-grid>\n     *    `\n     * })\n     * class AppComponent {\n     *    public gridData: any[] = products;\n     *    public pageSize = 2;\n     *    public pagesizes = [{text: 'One', value: 1}, {text: 'Two', value: 2}, {text: 'All', value : 'all'}];\n     * }\n     *\n     * const products = [{\n     *   'ProductID' : 1,\n     *   'ProductName' : \"Chai\",\n     *   'SupplierID' : 1,\n     *   'CategoryID' : 1,\n     *   'QuantityPerUnit' : \"10 boxes x 20 bags\",\n     *   'UnitPrice' : 18.0000,\n     *   'UnitsInStock' : 39,\n     *   'UnitsOnOrder' : 0,\n     *   'ReorderLevel' : 10,\n     *   'Discontinued' : false\n     *\n     * }, {\n     *   'ProductID' : 2,\n     *   'ProductName' : \"Chang\",\n     *   'SupplierID' : 1,\n     *   'CategoryID' : 1,\n     *   'QuantityPerUnit' : \"24 - 12 oz bottles\",\n     *   'UnitPrice' : 19.0000,\n     *   'UnitsInStock' : 17,\n     *   'UnitsOnOrder' : 40,\n     *   'ReorderLevel' : 25,\n     *   'Discontinued' : false\n     * }, {\n     *   'ProductID' : 3,\n     *   'ProductName' : \"Aniseed Syrup\",\n     *   'SupplierID' : 1,\n     *   'CategoryID' : 2,\n     *   'QuantityPerUnit' : \"12 - 550 ml bottles\",\n     *   'UnitPrice' : 10.0000,\n     *   'UnitsInStock' : 13,\n     *   'UnitsOnOrder' : 70,\n     *   'ReorderLevel' : 25,\n     *   'Discontinued' : false\n     * }, {\n     *   'ProductID' : 4,\n     *   'ProductName' : \"Chef Anton\\'s Cajun Seasoning\",\n     *   'SupplierID' : 2,\n     *  'CategoryID' : 2,\n     *   'QuantityPerUnit' : \"48 - 6 oz jars\",\n     *   'UnitPrice' : 22.0000,\n     *   'UnitsInStock' : 53,\n     *   'UnitsOnOrder' : 0,\n     *   'ReorderLevel' : 0,\n     *   'Discontinued' : false\n     * }, {\n     *   'ProductID' : 5,\n     *   'ProductName' : \"Chef Anton\\'s Gumbo Mix\",\n     *   'SupplierID' : 2,\n     *   'CategoryID' : 2,\n     *   'QuantityPerUnit' : \"36 boxes\",\n     *   'UnitPrice' : 21.3500,\n     *   'UnitsInStock' : 0,\n     *   'UnitsOnOrder' : 0,\n     *   'ReorderLevel' : 0,\n     *   'Discontinued' : true\n     * }, {\n     *   'ProductID' : 6,\n     *   'ProductName' : \"Grandma\\'s Boysenberry Spread\",\n     *   'SupplierID' : 3,\n     *   'CategoryID' : 2,\n     *   'QuantityPerUnit' : \"12 - 8 oz jars\",\n     *   'UnitPrice' : 25.0000,\n     *   'UnitsInStock' : 120,\n     *   'UnitsOnOrder' : 0,\n     *   'ReorderLevel' : 25,\n     *   'Discontinued' : false\n     * }];\n     * ```\n     */\n    set pageSizes(pageSizes) {\n        const normalizedItems = [];\n        pageSizes.forEach(item => {\n            if (typeof item === 'number') {\n                normalizedItems.push({\n                    text: item.toString(),\n                    value: item\n                });\n            }\n            else {\n                normalizedItems.push(item);\n            }\n        });\n        this._pageSizes = normalizedItems;\n    }\n    /**\n     * @hidden\n     *\n     * @readonly\n     */\n    get classes() {\n        return true;\n    }\n    /**\n     * @hidden\n     *\n     * @readonly\n     */\n    get showInitialPageSize() {\n        return this.pageSizes\n            .filter(item => {\n            if (typeof item.value === 'number') {\n                return item.value === Number(this.pageSize);\n            }\n            return this.total === Number(this.pageSize);\n        })\n            .length === 0;\n    }\n    /**\n     * @hidden\n     */\n    pageSizeChange(value) {\n        this.pageSize = parseInt(value, 10);\n        this.pagerContext.changePageSize(this.pageSize);\n    }\n    /**\n     * @hidden\n     */\n    getValue(page) {\n        return typeof page.value === 'number' ? page.value : this.total;\n    }\n    /**\n     * @hidden\n     */\n    getSelectedState(page) {\n        if (typeof page.value === 'number') {\n            return page.value === this.pageSize ? true : undefined;\n        }\n        return this.pageSize === this.total;\n    }\n    onChanges({ total, skip, pageSize }) {\n        this.total = total;\n        this.skip = skip;\n        this.pageSize = typeof pageSize === 'number' ? pageSize : this.total;\n        this.cd.markForCheck();\n    }\n}\nPagerPageSizesComponent.decorators = [\n    { type: Component, args: [{\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                selector: 'kendo-pager-page-sizes',\n                template: `\n        <select #select\n            (change)=\"pageSizeChange(select.value)\"\n            [attr.aria-label]=\"textFor('pagerItemsPerPage')\">\n            <option *ngIf=\"showInitialPageSize\" [value]=\"pageSize\">{{pageSize}}</option>\n            <option *ngFor=\"let page of pageSizes\" [value]=\"getValue(page)\" [selected]=\"getSelectedState(page)\">\n                {{page['text']}}\n            </option>\n        </select>\n        {{ textFor('pagerItemsPerPage') }}\n    `\n            },] },\n];\n/** @nocollapse */\nPagerPageSizesComponent.ctorParameters = () => [\n    { type: LocalizationService },\n    { type: ChangeDetectorRef },\n    { type: PagerContextService }\n];\nPagerPageSizesComponent.propDecorators = {\n    pageSizes: [{ type: Input }],\n    classes: [{ type: HostBinding, args: [\"class.k-pager-sizes\",] }, { type: HostBinding, args: [\"class.k-label\",] }]\n};\n\nconst importedModules$1 = [\n    CommonModule,\n    InputsModule,\n    SharedModule\n];\nconst INTERNAL_COMPONENTS$1 = [\n    PagerComponent,\n    PagerPrevButtonsComponent,\n    PagerNextButtonsComponent,\n    PagerNumericButtonsComponent,\n    PagerInputComponent,\n    PagerInfoComponent,\n    PagerPageSizesComponent,\n    PagerTemplateDirective\n];\n/**\n * @hidden\n */\nclass PagerModule {\n    static exports() {\n        return [\n            PagerComponent,\n            PagerPrevButtonsComponent,\n            PagerNextButtonsComponent,\n            PagerNumericButtonsComponent,\n            PagerInputComponent,\n            PagerInfoComponent,\n            PagerPageSizesComponent,\n            PagerTemplateDirective\n        ];\n    }\n}\nPagerModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [INTERNAL_COMPONENTS$1],\n                exports: [INTERNAL_COMPONENTS$1],\n                imports: [...importedModules$1]\n            },] },\n];\n\n/**\n * @hidden\n */\nclass GroupHeaderComponent {\n    constructor(groupsService, groupInfoService) {\n        this.groupsService = groupsService;\n        this.groupInfoService = groupInfoService;\n        this.skipGroupDecoration = false;\n        this.hasDetails = false;\n        this.totalColumnsCount = 0;\n        this.groups = [];\n        this.isExpanded = false;\n    }\n    get groupItemClass() {\n        return true;\n    }\n    ngDoCheck() {\n        this.isExpanded = this.groupsService.isExpanded(this.item.index);\n    }\n    prefixGroupCell(item) {\n        return new Array(item.level);\n    }\n    toggleGroup(item) {\n        this.groupsService.toggleRow(item.index, item.data);\n        return false;\n    }\n    groupSpan(item) {\n        const groupCount = (this.groups || []).length;\n        const detailOffset = this.hasDetails ? 1 : 0;\n        if (this.hasGroupHeaderColumn) {\n            return groupCount + 1 + detailOffset - item.level;\n        }\n        let columnCount = columnsSpan(this.columns);\n        if (this.skipGroupDecoration) {\n            return columnCount;\n        }\n        return groupCount + columnCount + detailOffset - item.level;\n    }\n    logicalColSpan() {\n        return this.skipGroupDecoration ? 1 : this.totalColumnsCount;\n    }\n    ariaRole() {\n        if (this.skipGroupDecoration) {\n            return 'presentation';\n        }\n        return 'gridcell';\n    }\n    formatForGroup(item) {\n        return this.groupInfoService.formatForGroup(item);\n    }\n    groupTitle(item) {\n        return this.groupInfoService.groupTitle(item);\n    }\n    groupHeaderTemplate(item) {\n        return this.groupInfoService.groupHeaderTemplate(item);\n    }\n}\nGroupHeaderComponent.decorators = [\n    { type: Component, args: [{\n                selector: '[kendoGridGroupHeader]',\n                template: `\n        <ng-template [ngIf]=\"!skipGroupDecoration\">\n            <td class=\"k-group-cell\"\n                role=\"presentation\"\n                *ngFor=\"let g of prefixGroupCell(item)\"></td>\n        </ng-template>\n        <td [attr.colspan]=\"groupSpan(item)\" *ngIf=\"!(skipGroupDecoration && hasGroupHeaderColumn)\"\n            [attr.role]=\"ariaRole()\"\n            aria-selected=\"false\"\n            [attr.aria-expanded]=\"isExpanded\"\n            kendoGridLogicalCell\n            [logicalRowIndex]=\"logicalRowIndex\"\n            [logicalColIndex]=\"0\"\n            [logicalSlaveCell]=\"skipGroupDecoration\"\n            [groupItem]=\"item\"\n            [colSpan]=\"logicalColSpan()\">\n            <p class=\"k-reset\">\n                <ng-template [ngIf]=\"!skipGroupDecoration\">\n                    <a href=\"#\" tabindex=\"-1\" (click)=\"toggleGroup(item)\"\n                        class=\"k-icon\"\n                        [ngClass]=\"{ 'k-i-collapse': isExpanded, 'k-i-expand': !isExpanded }\" role=\"presentation\">\n                    </a>\n                    <ng-template [ngIf]=\"!groupHeaderTemplate(item)\">\n                    {{groupTitle(item)}}: {{item.data | valueOf:\"value\": formatForGroup(item)}}\n                    </ng-template>\n                    <ng-template\n                        [templateContext]=\"{\n                            templateRef: groupHeaderTemplate(item),\n                            group: item.data,\n                            aggregates: item.data?.aggregates,\n                            value: item.data?.value,\n                            field: item.data?.field,\n                            index: item.index,\n                            expanded: isExpanded,\n                            $implicit: item.data\n                            }\">\n                    </ng-template>\n                </ng-template>\n            </p>\n        </td>\n        <ng-container *ngIf=\"hasGroupHeaderColumn\">\n            <td *ngFor=\"let column of groupHeaderColumns; let index = index\"\n                role=\"gridcell\"\n                aria-selected=\"false\"\n                kendoGridLogicalCell\n                [logicalRowIndex]=\"logicalRowIndex\"\n                [logicalColIndex]=\"index + 1\"\n                [logicalSlaveCell]=\"false\"\n                [groupItem]=\"item\"\n                [colSpan]=\"1\"\n            >\n                <ng-container *ngIf=\"column.groupHeaderColumnTemplateRef\" [ngTemplateOutlet]=\"column.groupHeaderColumnTemplateRef\"\n                    [ngTemplateOutletContext]=\"{\n                        group: item.data,\n                        aggregates: item.data?.aggregates,\n                        value: item.data?.value,\n                        field: item.data?.field,\n                        index: item.index,\n                        $implicit: item.data\n                        }\">\n                </ng-container>\n            </td>\n        </ng-container>\n    `\n            },] },\n];\n/** @nocollapse */\nGroupHeaderComponent.ctorParameters = () => [\n    { type: GroupsService },\n    { type: GroupInfoService }\n];\nGroupHeaderComponent.propDecorators = {\n    rowIndex: [{ type: Input }],\n    logicalRowIndex: [{ type: Input }],\n    item: [{ type: Input }],\n    skipGroupDecoration: [{ type: Input }],\n    hasDetails: [{ type: Input }],\n    totalColumnsCount: [{ type: Input }],\n    hasGroupHeaderColumn: [{ type: Input }],\n    groupHeaderColumns: [{ type: Input }],\n    columns: [{ type: Input }],\n    groups: [{ type: Input }],\n    groupItemClass: [{ type: HostBinding, args: ['class.k-grouping-row',] }]\n};\n\n/**\n * @hidden\n */\nclass DropTargetDirective {\n    constructor(element, service) {\n        this.element = element;\n        this.service = service;\n        this.context = {};\n        this.enter = new EventEmitter();\n        this.leave = new EventEmitter();\n        this.drop = new EventEmitter();\n        this.subscriptions = new Subscription();\n    }\n    ngOnInit() {\n        this.service.add(this);\n        const changes = this.service.changes.pipe(filter(({ target }) => target === this));\n        this.subscriptions.add(changes.pipe(filter(({ type }) => type === 'leave'))\n            .subscribe(e => {\n            this.leave.next(this.eventArgs(e));\n        }));\n        this.subscriptions.add(changes.pipe(filter(({ type }) => type === 'enter'))\n            .subscribe(e => {\n            this.enter.next(this.eventArgs(e));\n        }));\n        this.subscriptions.add(changes.pipe(filter(({ type }) => type === 'drop'))\n            .subscribe(e => {\n            this.drop.next(this.eventArgs(e));\n        }));\n    }\n    ngOnDestroy() {\n        if (this.subscriptions) {\n            this.subscriptions.unsubscribe();\n        }\n    }\n    eventArgs(e) {\n        return {\n            target: this,\n            mouseEvent: e.mouseEvent,\n            draggable: e.draggable\n        };\n    }\n}\nDropTargetDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoDropTarget]'\n            },] },\n];\n/** @nocollapse */\nDropTargetDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: DragAndDropService }\n];\nDropTargetDirective.propDecorators = {\n    context: [{ type: Input }],\n    enter: [{ type: Output }],\n    leave: [{ type: Output }],\n    drop: [{ type: Output }]\n};\n\nconst withoutField = ({ field }) => isNullOrEmptyString(field);\nconst alreadyGrouped = ({ groups, field }) => groups.some(group => group.field === field);\nconst overSameTarget = ({ target, field }) => target.field === field;\nconst overLastTarget = ({ target }) => target.lastTarget;\nconst isLastGroup = ({ groups, field }) => groups.map(group => group.field).indexOf(field) === groups.length - 1;\nconst isNotGroupable = (groupsService) => ({ field }) => !groupsService.isGroupable(field);\nconst columnRules = (groupService) => or(withoutField, alreadyGrouped, isNotGroupable(groupService));\nconst indicatorRules = or(overSameTarget, and(overLastTarget, isLastGroup));\n/**\n * @hidden\n */\nclass GroupPanelComponent {\n    constructor(hint, cue, groupInfoService, localization, cd) {\n        this.hint = hint;\n        this.cue = cue;\n        this.groupInfoService = groupInfoService;\n        this.localization = localization;\n        this.cd = cd;\n        this.change = new EventEmitter();\n        this.groups = [];\n        this.dropTargets = new QueryList();\n        this.groupTitles = [];\n        this.subscription = new Subscription();\n    }\n    get groupHeaderClass() {\n        return true;\n    }\n    set text(value) {\n        this.emptyText = value;\n    }\n    get text() {\n        return this.emptyText ? this.emptyText : this.localization.get('groupPanelEmpty');\n    }\n    ngAfterViewInit() {\n        this.subscription.add(observe(this.dropTargets)\n            .subscribe(this.attachTargets.bind(this)));\n    }\n    ngOnInit() {\n        this.subscription.add(this.localization.changes.subscribe(() => this.cd.markForCheck()));\n    }\n    ngDoCheck() {\n        const currentTitles = this.groups.map(group => this.groupInfoService.groupTitle(group));\n        if (currentTitles.length !== this.groupTitles.length || currentTitles.some((current, idx) => current !== this.groupTitles[idx])) {\n            this.groupTitles = currentTitles;\n            this.cd.markForCheck();\n        }\n    }\n    ngOnDestroy() {\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n        }\n        if (this.targetSubscription) {\n            this.targetSubscription.unsubscribe();\n        }\n    }\n    directionChange(group) {\n        const index = this.groups.findIndex(x => x.field === group.field);\n        const groups = [...this.groups.slice(0, index), group, ...this.groups.slice(index + 1)];\n        this.change.emit(groups);\n    }\n    insert(field, index) {\n        const groups = this.groups.filter(x => x.field !== field);\n        if (groups.length || this.groups.length === 0) {\n            this.change.emit([...groups.slice(0, index), { field: field }, ...groups.slice(index)]);\n        }\n    }\n    remove(group) {\n        this.change.emit(this.groups.filter(x => x.field !== group.field));\n    }\n    canDrop(draggable, target) {\n        const isIndicator = draggable.type === 'groupIndicator';\n        const rules = isIndicator\n            ? indicatorRules\n            : columnRules(this.groupInfoService);\n        return !rules({\n            field: draggable.field,\n            groups: this.groups,\n            target\n        });\n    }\n    attachTargets() {\n        if (this.targetSubscription) {\n            this.targetSubscription.unsubscribe();\n        }\n        this.targetSubscription = new Subscription();\n        const enterStream = this.dropTargets\n            .reduce((acc, target) => merge(acc, target.enter), from([]));\n        const leaveStream = this.dropTargets\n            .reduce((acc, target) => merge(acc, target.leave), from([]));\n        const dropStream = this.dropTargets\n            .reduce((acc, target) => merge(acc, target.drop), from([]));\n        this.targetSubscription.add(enterStream.pipe(tap(_ => this.hint.removeLock()), filter(({ draggable, target }) => this.canDrop(draggable.context, target.context)), tap(this.enter.bind(this)), switchMapTo(dropStream.pipe(takeUntil(leaveStream.pipe(tap(this.leave.bind(this))))))).subscribe(this.drop.bind(this)));\n    }\n    enter({ draggable, target }) {\n        this.hint.enable();\n        let before = target.context.lastTarget || isTargetBefore(draggable.element.nativeElement, target.element.nativeElement);\n        if (this.localization.rtl) {\n            before = !before;\n        }\n        this.cue.position(position(target.element.nativeElement, before));\n    }\n    leave() {\n        this.hint.disable();\n        this.cue.hide();\n    }\n    drop({ target, draggable }) {\n        const field = draggable.context.field;\n        const index = this.dropTargets.toArray().indexOf(target);\n        this.insert(field, index);\n    }\n}\nGroupPanelComponent.decorators = [\n    { type: Component, args: [{\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                selector: 'kendo-grid-group-panel',\n                template: `\n        <ng-template [ngIf]=\"groups.length === 0\">\n            <div\n                class=\"k-indicator-container\"\n                [context]=\"{\n                    lastTarget: true\n                }\"\n                kendoDropTarget>\n                {{ text }}\n            </div>\n        </ng-template>\n        <div *ngFor=\"let group of groups; let index = index;\"\n            class=\"k-indicator-container\"\n            [context]=\"{\n                field: group.field\n            }\"\n            kendoDropTarget>\n            <div\n                kendoDraggableColumn\n                [enableDrag]=\"true\"\n                [context]=\"{\n                    field: group.field,\n                    type: 'groupIndicator',\n                    hint:  groupTitles[index]\n                }\"\n                kendoGroupIndicator\n                kendoDraggable\n                [group]=\"group\"\n                [groupTitle]=\"groupTitles[index]\"\n                (directionChange)=\"directionChange($event)\"\n                (remove)=\"remove($event)\">\n            </div>\n        </div>\n        <div class=\"k-indicator-container\"\n            *ngIf=\"groups.length !== 0\"\n            [context]=\"{\n                lastTarget: true\n            }\"\n            kendoDropTarget>&nbsp;</div>\n    `\n            },] },\n];\n/** @nocollapse */\nGroupPanelComponent.ctorParameters = () => [\n    { type: DragHintService },\n    { type: DropCueService },\n    { type: GroupInfoService },\n    { type: LocalizationService },\n    { type: ChangeDetectorRef }\n];\nGroupPanelComponent.propDecorators = {\n    change: [{ type: Output }],\n    groupHeaderClass: [{ type: HostBinding, args: [\"class.k-grouping-header\",] }, { type: HostBinding, args: [\"class.k-grouping-header-flex\",] }],\n    text: [{ type: Input }],\n    groups: [{ type: Input }],\n    dropTargets: [{ type: ViewChildren, args: [DropTargetDirective,] }]\n};\n\n/**\n * @hidden\n */\nclass GroupIndicatorComponent {\n    constructor() {\n        this.directionChange = new EventEmitter();\n        this.remove = new EventEmitter();\n    }\n    get groupIndicatorClass() {\n        return true;\n    }\n    get dir() {\n        return this.group.dir ? this.group.dir : \"asc\";\n    }\n    toggleDirection() {\n        this.directionChange.emit({\n            dir: this.dir === \"asc\" ? \"desc\" : \"asc\",\n            field: this.group.field\n        });\n        return false;\n    }\n    removeDescriptor() {\n        this.remove.emit({\n            dir: this.group.dir,\n            field: this.group.field\n        });\n        return false;\n    }\n}\nGroupIndicatorComponent.decorators = [\n    { type: Component, args: [{\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                selector: '[kendoGroupIndicator]',\n                template: `\n        <a href=\"#\" class=\"k-link\" tabindex=\"-1\" (click)=\"toggleDirection()\">\n            <span class=\"k-icon\"\n                [class.k-i-sort-asc-sm]=\"dir === 'asc'\"\n                [class.k-i-sort-desc-sm]=\"dir === 'desc'\"></span>\n            {{groupTitle}}</a>\n        <a class=\"k-button k-button-icon k-bare\" tabindex=\"-1\" (click)=\"removeDescriptor()\">\n            <span class=\"k-icon k-i-group-delete\"></span>\n        </a>\n    `\n            },] },\n];\nGroupIndicatorComponent.propDecorators = {\n    directionChange: [{ type: Output }],\n    remove: [{ type: Output }],\n    group: [{ type: Input }],\n    groupTitle: [{ type: Input }],\n    groupIndicatorClass: [{ type: HostBinding, args: [\"class.k-group-indicator\",] }]\n};\n\n// TODO\n// tslint:disable:rxjs-no-unsafe-takeuntil\n/**\n * @hidden\n */\nconst preventOnDblClick = release => mouseDown => of(mouseDown).pipe(delay(150), takeUntil(release));\nconst hasClass = className => el => new RegExp(`(^| )${className}( |$)`).test(el.className);\nconst isDeleteButton = or(hasClass(\"k-i-group-delete\"), hasClass(\"k-button-icon\"));\nconst isSortIcon = or(hasClass(\"k-i-sort-asc-sm\"), hasClass(\"k-i-sort-desc-sm\"));\nconst skipButtons = and(not(isDeleteButton), not(isSortIcon), not(isFocusableWithTabKey), not(matchesNodeName(\"label\")));\nconst elementUnderCursor = ({ clientX, clientY }) => document.elementFromPoint(clientX, clientY);\nconst hideThenShow = (element, cont) => {\n    element.style.display = 'none';\n    const result = cont();\n    element.style.display = 'block';\n    return result;\n};\n/**\n * @hidden\n */\nclass DraggableColumnDirective {\n    constructor(draggable, element, zone, service, hint, cue, nav, renderer) {\n        this.draggable = draggable;\n        this.element = element;\n        this.zone = zone;\n        this.service = service;\n        this.hint = hint;\n        this.cue = cue;\n        this.nav = nav;\n        this.renderer = renderer;\n        this.context = {};\n        this.drag = new EventEmitter();\n        this.subscriptions = new Subscription();\n    }\n    set enableDrag(enabled) {\n        this.enabled = enabled;\n        this.updateTouchAction();\n    }\n    get hostClass() {\n        return this.enabled;\n    }\n    ngOnInit() {\n        this.subscriptions.add(this.zone.runOutsideAngular(() => this.draggable.kendoPress.pipe(filter(_ => this.enabled), filter(({ originalEvent: { target } }) => target === this.element.nativeElement || skipButtons(target)), tap((e) => {\n            const originalEvent = e.originalEvent;\n            if (!e.isTouch) {\n                originalEvent.preventDefault();\n            }\n            this.nav.navigateTo(originalEvent.target);\n        }), switchMap(preventOnDblClick(this.draggable.kendoRelease)), tap(down => {\n            this.hint.create(down, this.element.nativeElement, this.context.hint);\n            this.cue.create();\n        }), switchMap(down => this.draggable.kendoDrag.pipe(tap((e) => {\n            if (e.isTouch) {\n                e.originalEvent.preventDefault();\n            }\n        }), tap(this.hint.attach()), tap(this.cue.attach()), takeUntil(this.draggable.kendoRelease), map(move => ({ move, down })))), tap(this.performDrag.bind(this)), switchMapTo(this.draggable.kendoRelease)).subscribe(this.drop.bind(this))));\n    }\n    ngOnDestroy() {\n        if (this.subscriptions) {\n            this.subscriptions.unsubscribe();\n        }\n    }\n    drop(upEvent) {\n        this.hint.remove();\n        this.cue.remove();\n        this.service.notifyDrop(this, upEvent);\n    }\n    performDrag({ move }) {\n        this.hint.move(move);\n        const cursorElement = this.elementUnderCursor(move);\n        if (cursorElement) {\n            this.service.notifyDrag(this, cursorElement, move);\n        }\n        this.drag.emit({\n            draggable: this,\n            mouseEvent: move\n        });\n    }\n    elementUnderCursor(mouseEvent) {\n        this.hint.hide();\n        let target = elementUnderCursor(mouseEvent);\n        if (target && /k-grouping-dropclue/.test(target.className)) {\n            target = hideThenShow(target, elementUnderCursor.bind(this, mouseEvent));\n        }\n        this.hint.show();\n        return target;\n    }\n    updateTouchAction() {\n        if (!this.element) {\n            return;\n        }\n        this.renderer.setStyle(this.element.nativeElement, 'touch-action', this.enabled ? 'none' : '');\n    }\n}\nDraggableColumnDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoDraggableColumn]'\n            },] },\n];\n/** @nocollapse */\nDraggableColumnDirective.ctorParameters = () => [\n    { type: DraggableDirective, decorators: [{ type: Host }] },\n    { type: ElementRef },\n    { type: NgZone },\n    { type: DragAndDropService },\n    { type: DragHintService },\n    { type: DropCueService },\n    { type: NavigationService },\n    { type: Renderer2 }\n];\nDraggableColumnDirective.propDecorators = {\n    context: [{ type: Input }],\n    enableDrag: [{ type: Input }],\n    drag: [{ type: Output }],\n    hostClass: [{ type: HostBinding, args: ['class.k-grid-draggable-header',] }]\n};\n\nconst exported = [\n    DraggableColumnDirective,\n    DropTargetDirective\n];\n/**\n * @hidden\n */\nclass DragAndDropModule {\n}\nDragAndDropModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [exported],\n                exports: [exported]\n            },] },\n];\n\nconst exportedModules$1 = [\n    GroupHeaderTemplateDirective,\n    GroupHeaderColumnTemplateDirective,\n    GroupFooterTemplateDirective,\n    GroupHeaderComponent,\n    GroupPanelComponent,\n    GroupIndicatorComponent\n];\n/**\n * @hidden\n */\nclass GroupModule {\n    static exports() {\n        return [\n            GroupHeaderTemplateDirective,\n            GroupHeaderColumnTemplateDirective,\n            GroupFooterTemplateDirective\n        ];\n    }\n}\nGroupModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [exportedModules$1],\n                exports: [exportedModules$1],\n                imports: [CommonModule, SharedModule, DragAndDropModule]\n            },] },\n];\n\n/**\n * @hidden\n */\nconst DEFAULTS = {\n    allowUnsort: true,\n    mode: 'single',\n    showIndexes: true,\n    initialDirection: 'asc'\n};\n/**\n * @hidden\n */\nconst normalize$1 = (...settings) => Object.assign({}, DEFAULTS, ...settings);\n\n/**\n * @hidden\n */\nconst hasFilter = (settings, column) => settings.filter !== false && column.field && column.filterable;\n/**\n * @hidden\n */\nconst hasSort = (settings, column) => settings.sort !== false && column.field && column.sortable;\n/**\n * @hidden\n */\nconst hasLock = (settings, column) => settings.lock && column.lockable && !(column.parent && !column.parent.isSpanColumn);\n/**\n * @hidden\n */\nconst hasColumnChooser = (settings) => settings.columnChooser !== false;\n/**\n * @hidden\n */\nconst hasItems = (settings, column) => hasColumnChooser(settings) || hasLock(settings, column) || hasSort(settings, column) || hasFilter(settings, column);\n\nconst mergeObjects = (...args) => Object.assign.apply(null, [{}].concat(args));\nconst directions = initialDirection => initialDirection === \"asc\" ? [\"asc\", \"desc\"] : [\"desc\", \"asc\"];\n/**\n * @hidden\n */\nconst isRootLevel = ({ parent }) => !isTruthy(parent);\nconst ofColumnType = ({ draggable }) => ['column', 'columnGroup']\n    .indexOf(draggable.context.type) >= 0;\nconst notSameElement = ({ draggable, target }) => draggable.element.nativeElement !== target.element.nativeElement;\nconst inSameParent = (x, y) => x.parent === y.parent ||\n    (isInSpanColumn(y) && inSameParent(x, y.parent));\nconst sameParent = ({ draggable, target }) => inSameParent(draggable.context.column, target.context.column);\nconst lastNonLocked = ({ draggable }) => !isTruthy(draggable.context.column.locked) &&\n    isRootLevel(draggable.context.column) &&\n    draggable.context.lastColumn;\nconst notInSpanColumn = ({ draggable }) => !isInSpanColumn(draggable.context.column);\nconst reorderable = ({ draggable }) => draggable.context.column.reorderable;\nconst lockable = ({ draggable, target }) => draggable.context.column.lockable !== false ||\n    draggable.context.column.isLocked === target.context.column.isLocked;\nconst rules = and(ofColumnType, reorderable, notInSpanColumn, notSameElement, sameParent, not(lastNonLocked), lockable);\n/**\n * @hidden\n */\nclass HeaderComponent {\n    constructor(popupService, hint, cue, reorderService, idService, sortService, localization, cd) {\n        this.popupService = popupService;\n        this.hint = hint;\n        this.cue = cue;\n        this.reorderService = reorderService;\n        this.idService = idService;\n        this.sortService = sortService;\n        this.localization = localization;\n        this.cd = cd;\n        this.columns = [];\n        this.groups = [];\n        this.sort = new Array();\n        this.sortable = false;\n        this.groupable = false;\n        this.lockedColumnsCount = 0;\n        this.resizable = false;\n        this.reorderable = false;\n        this.columnMenu = false;\n        this.totalColumnsCount = 0;\n        this.sortedFields = {};\n        this.dropTargets = new QueryList();\n        this.subscription = new Subscription();\n    }\n    get headerClass() {\n        return !this.scrollable;\n    }\n    get sortableLabel() {\n        return this.localization.get('sortable');\n    }\n    // Number of unlocked columns in the next table, if any\n    get unlockedColumnsCount() {\n        return this.totalColumnsCount - this.lockedColumnsCount - this.columns.length;\n    }\n    sortColumn(column, event, link) {\n        const target = event ? event.target : null;\n        if (column.headerTemplateRef && target !== link) {\n            const hasFocusableParent = Boolean(closestInScope(target, isFocusable, link));\n            if (hasFocusableParent) {\n                return target.type === 'checkbox'; // prevent navigation only if the element is not checkbox\n            }\n        }\n        this.sortService.sort(this.toggleSort(column));\n        // Prevent navigation\n        return false;\n    }\n    onHeaderKeydown(column, args) {\n        if (!this.sortable || args.defaultPrevented || column.sortable === false) {\n            return;\n        }\n        if (args.keyCode === Keys.Enter) {\n            this.sortService.sort(this.toggleSort(column));\n        }\n    }\n    showSortNumbering(column) {\n        const { showIndexes } = normalize$1(this.sortable);\n        return showIndexes\n            && this.sort\n            && this.sort.filter(({ dir }) => isPresent(dir)).length > 1\n            && this.sortOrder(column.field) > 0;\n    }\n    sortOrder(field) {\n        return this.sort\n            .filter(({ dir }) => isPresent(dir))\n            .findIndex(x => x.field === field)\n            + 1;\n    }\n    sortIcon(field) {\n        const state$$1 = this.sortDescriptor(field);\n        return {\n            'k-icon': isPresent(state$$1.dir),\n            'k-i-sort-desc-sm': state$$1.dir === \"desc\",\n            'k-i-sort-asc-sm': state$$1.dir === \"asc\"\n        };\n    }\n    sortState(column) {\n        if (!this.isSortable(column)) {\n            return;\n        }\n        const state$$1 = this.sortDescriptor(column.field);\n        if (state$$1.dir === 'asc') {\n            return 'ascending';\n        }\n        if (state$$1.dir === 'desc') {\n            return 'descending';\n        }\n    }\n    sortStatus(column) {\n        if (!this.sortedFields[column.field] || !this.isSortable(column)) {\n            return;\n        }\n        let msg = 'sortedDefault';\n        const state$$1 = this.sortDescriptor(column.field);\n        if (state$$1.dir === 'asc') {\n            msg = 'sortedAscending';\n        }\n        else if (state$$1.dir === 'desc') {\n            msg = 'sortedDescending';\n        }\n        return this.localization.get(msg);\n    }\n    toggleSort(column) {\n        const { allowUnsort, mode, initialDirection } = normalize$1(this.sortable, column.sortable);\n        const descriptor = this.toggleDirection(column.field, allowUnsort, initialDirection);\n        if (mode === 'single') {\n            return [descriptor];\n        }\n        return [...this.sort.filter(desc => desc.field !== column.field), descriptor];\n    }\n    ngAfterViewInit() {\n        this.subscription.add(observe(this.dropTargets)\n            .subscribe(this.attachTargets.bind(this)));\n    }\n    ngDoCheck() {\n        this._leafColumns = columnsToRender(this.columns || []).filter(x => !isColumnGroupComponent(x));\n    }\n    ngOnChanges(changes) {\n        const sortChange = changes.sort;\n        if (sortChange && !sortChange.isFirstChange()) {\n            sortChange.currentValue.forEach(change => {\n                this.sortedFields[change.field] = true;\n            });\n        }\n    }\n    ngOnInit() {\n        this.subscription.add(this.localization.changes\n            .subscribe(() => this.cd.markForCheck()));\n    }\n    ngOnDestroy() {\n        if (this.targetSubscription) {\n            this.targetSubscription.unsubscribe();\n        }\n        if (this.popupService) {\n            this.popupService.destroy();\n        }\n        this.subscription.unsubscribe();\n    }\n    selectAllCheckboxId() {\n        return this.idService.selectAllCheckboxId();\n    }\n    isFirstOnRow(column, index) {\n        const isTailing = (c) => c &&\n            (this.columnsForLevel(c.level).indexOf(c) > 0 || isTailing(c.parent));\n        return index === 0 && !this.groups.length && !this.detailTemplate && isTailing(column.parent);\n    }\n    logicalColumnIndex(column) {\n        const index = column.leafIndex;\n        if (isPresent(index)) {\n            return index + (isPresent(this.detailTemplate) ? 1 : 0);\n        }\n        return -1;\n    }\n    get showFilterMenu() {\n        return !this.columnMenu && hasFilterMenu(this.filterable);\n    }\n    get showFilterRow() {\n        return hasFilterRow(this.filterable);\n    }\n    showColumnMenu(column) {\n        return this.columnMenu && column.columnMenu &&\n            (this.columnMenuTemplate || column.columnMenuTemplates.length || hasItems(this.columnMenu, column));\n    }\n    isFilterable(column) {\n        return !isNullOrEmptyString(column.field) && column.filterable === true;\n    }\n    canDrop(draggable, target) {\n        return this.reorderable && rules({ draggable, target });\n    }\n    shouldActivate(column) {\n        const canReorder = this.reorderable && column.reorderable;\n        if (!canReorder && !isColumnComponent(column)) {\n            return false;\n        }\n        const groupable = this.groupable && isColumnComponent(column) && column.groupable !== false;\n        return groupable || canReorder;\n    }\n    isSortable(column) {\n        return !isNullOrEmptyString(column.field)\n            && isTruthy(this.sortable) && isTruthy(column.sortable);\n    }\n    isCheckboxColumn(column) {\n        return isCheckboxColumn(column) && !column.templateRef;\n    }\n    trackByIndex(index, _item) {\n        return index;\n    }\n    toggleDirection(field, allowUnsort, initialDirection) {\n        const descriptor = this.sortDescriptor(field);\n        const [first, second] = directions(initialDirection);\n        let dir = first;\n        if (descriptor.dir === first) {\n            dir = second;\n        }\n        else if (descriptor.dir === second && allowUnsort) {\n            dir = undefined;\n        }\n        return { dir, field };\n    }\n    columnsForLevel(level) {\n        const columns = this.columns ? this.columns.filter(column => column.level === level) : [];\n        return sortColumns(columnsToRender(columns));\n    }\n    isColumnGroupComponent(column) {\n        return isColumnGroupComponent(column);\n    }\n    get columnLevels() {\n        return new Array((this.totalColumnLevels || 0) + 1);\n    }\n    sortDescriptor(field) {\n        return this.sort.find(item => item.field === field) || { field };\n    }\n    get leafColumns() {\n        return this._leafColumns;\n    }\n    attachTargets() {\n        if (this.targetSubscription) {\n            this.targetSubscription.unsubscribe();\n        }\n        this.targetSubscription = new Subscription();\n        const enterStream = merge(...this.dropTargets.map(target => target.enter));\n        const leaveStream = merge(...this.dropTargets.map(target => target.leave));\n        const dropStream = merge(...this.dropTargets.map(target => target.drop));\n        this.targetSubscription.add(enterStream.pipe(tap(({ target, draggable }) => {\n            if (draggable.context.type === 'groupIndicator') {\n                return;\n            }\n            const targetLocked = isTruthy(target.context.column.isLocked);\n            const draggableLocked = isTruthy(draggable.context.column.isLocked);\n            if (this.lockedColumnsCount > 0 || targetLocked || draggableLocked) {\n                this.hint.toggleLock(targetLocked);\n            }\n        }), filter(({ draggable, target }) => this.canDrop(draggable, target)), switchMap(this.trackMove.bind(this, leaveStream, dropStream)), map((e) => mergeObjects(e, { before: this.calculateBefore(e), changeContainer: e.changeContainer })), map(this.normalizeTarget.bind(this)), tap(this.enter.bind(this)), switchMap((args) => dropStream.pipe(map(() => args), takeUntil(leaveStream.pipe(tap(this.leave.bind(this)))))))\n            .subscribe(this.drop.bind(this)));\n    }\n    normalizeTarget(e) {\n        let target = e.target;\n        const parent = target.context.column.parent;\n        if (parent && parent.isSpanColumn) {\n            const arr = this.dropTargets.toArray();\n            const firstSpan = arr.find(t => t.context.column.parent === parent);\n            const index = arr.indexOf(firstSpan);\n            const adjust = e.before ? 0 : parent.childColumns.length - 1;\n            target = arr[index + adjust];\n        }\n        return mergeObjects(e, { target });\n    }\n    trackMove(leaveStream, dropStream, e) {\n        const column = e.target.context.column;\n        const levelColumns = this.columnsForLevel(column.level);\n        const index = levelColumns.indexOf(column);\n        const isFirst = (column.locked ? index === levelColumns.length - 1 : index === 0);\n        const changed = e.draggable.context.column.isLocked !== column.isLocked;\n        if (changed && isFirst) {\n            return e.draggable.drag\n                .pipe(takeUntil(leaveStream), takeUntil(dropStream), map(({ mouseEvent }) => mergeObjects({ changeContainer: true }, e, { mouseEvent })));\n        }\n        return of(mergeObjects({ changeContainer: changed }, e));\n    }\n    calculateBefore({ draggable, target, mouseEvent, changeContainer = false }) {\n        const targetElement = target.element.nativeElement;\n        let before = false;\n        if (changeContainer) {\n            const { left } = offset(targetElement);\n            const halfWidth = targetElement.offsetWidth / 2;\n            const middle = left + halfWidth;\n            before = middle > mouseEvent.pageX;\n            if (this.localization.rtl) {\n                before = !before;\n            }\n        }\n        else {\n            before = isTargetBefore(draggable.element.nativeElement, targetElement);\n        }\n        return before;\n    }\n    enter({ target, before }) {\n        this.hint.enable();\n        if (this.localization.rtl) {\n            before = !before;\n        }\n        this.cue.position(position(target.element.nativeElement, before));\n    }\n    leave() {\n        this.hint.disable();\n        this.cue.hide();\n    }\n    drop({ draggable, target, before, changeContainer }) {\n        this.reorderService.reorder({\n            before,\n            changeContainer,\n            source: draggable.context.column,\n            target: target.context.column\n        });\n    }\n}\nHeaderComponent.decorators = [\n    { type: Component, args: [{\n                selector: '[kendoGridHeader]',\n                styles: [`\n        .k-column-resizer {\n            cursor: col-resize;\n            display: block;\n            height: 1000%;\n            position: absolute;\n            top: 0;\n            width: .5em;\n        }\n    `],\n                template: `\n    <ng-template [ngIf]=\"true\">\n        <tr *ngFor=\"let i of columnLevels; let levelIndex = index\"\n            kendoGridLogicalRow\n                [logicalRowIndex]=\"levelIndex\"\n                [logicalSlaveRow]=\"lockedColumnsCount > 0\"\n                [logicalCellsCount]=\"columns.length\"\n                [logicalSlaveCellsCount]=\"unlockedColumnsCount\">\n            <th\n                class=\"k-group-cell k-header\"\n                role=\"presentation\"\n                *ngFor=\"let g of groups\">\n            </th>\n            <th class=\"k-hierarchy-cell k-header\"\n                role=\"presentation\"\n                *ngIf=\"detailTemplate?.templateRef\"\n                kendoGridLogicalCell\n                    [logicalRowIndex]=\"levelIndex\"\n                    [logicalColIndex]=\"0\"\n                    aria-selected=\"false\"\n            >\n            </th>\n            <ng-template ngFor let-column [ngForOf]=\"columnsForLevel(levelIndex)\" [ngForTrackBy]=\"trackByIndex\" let-columnIndex=\"index\" let-last=\"last\">\n                <th *ngIf=\"!isColumnGroupComponent(column)\"\n                    kendoGridLogicalCell [logicalRowIndex]=\"levelIndex\"\n                                         [logicalColIndex]=\"logicalColumnIndex(column)\"\n                                         [colSpan]=\"column.colspan\"\n                                         [rowSpan]=\"column.rowspan(totalColumnLevels)\"\n                                         role=\"columnheader\"\n                                         aria-selected=\"false\"\n                                         [attr.aria-sort]=\"sortState(column)\"\n                                         (keydown)=\"onHeaderKeydown(column, $event)\"\n                    kendoDropTarget\n                    kendoDraggable\n                    kendoDraggableColumn\n                    [enableDrag]=\"shouldActivate(column)\"\n                    [context]=\"{\n                        field: column.field,\n                        type: 'column',\n                        column: column,\n                        hint: column.title || column.field,\n                        lastColumn: last && columnIndex === 0\n                    }\"\n                    class=\"k-header\"\n                    [class.k-filterable]=\"(showFilterMenu && isFilterable(column)) || showColumnMenu(column)\"\n                    [class.k-first]=\"isFirstOnRow(column, columnIndex)\"\n                    [ngClass]=\"column.headerClass\"\n                    [ngStyle]=\"column.headerStyle\"\n                    [attr.rowspan]=\"column.rowspan(totalColumnLevels)\"\n                    [attr.colspan]=\"column.colspan\">\n                    <kendo-grid-filter-menu\n                        *ngIf=\"showFilterMenu && isFilterable(column)\"\n                        [column]=\"column\"\n                        [filter]=\"filter\">\n                    </kendo-grid-filter-menu>\n                    <kendo-grid-column-menu *ngIf=\"showColumnMenu(column)\"\n                        [standalone]=\"false\"\n                        [settings]=\"columnMenu\"\n                        [column]=\"column\"\n                        [columnMenuTemplate]=\"columnMenuTemplate\"\n                        [sort]=\"sort\"\n                        [filter]=\"filter\"\n                        [sortable]=\"sortable\">\n                    </kendo-grid-column-menu>\n                    <ng-template [ngIf]=\"!isSortable(column)\">\n                        <ng-template\n                            [templateContext]=\"{\n                                templateRef: column.headerTemplateRef,\n                                columnIndex: column.leafIndex,\n                                column: column,\n                                $implicit: column\n                            }\">\n                        </ng-template>\n                        <ng-template [ngIf]=\"!column.headerTemplateRef\">{{column.displayTitle}}</ng-template>\n                    </ng-template>\n                    <ng-template [ngIf]=\"isSortable(column)\">\n                        <a #link href=\"#\" tabindex=\"-1\" class=\"k-link\" (click)=\"sortColumn(column, $event, link)\">\n                            <ng-template\n                                [templateContext]=\"{\n                                    templateRef: column.headerTemplateRef,\n                                    columnIndex: column.leafIndex,\n                                    column: column,\n                                    $implicit: column\n                                }\">\n                            </ng-template>\n                            <ng-template [ngIf]=\"!column.headerTemplateRef\">{{column.displayTitle}}</ng-template>\n                            <span [attr.aria-label]=\"sortableLabel\" [ngClass]=\"sortIcon(column.field)\"></span>\n                            <span *ngIf=\"showSortNumbering(column)\" class=\"k-sort-order\">{{sortOrder(column.field)}}</span>\n                        </a>\n                        <span role=\"status\"\n                              class=\"k-sort-status\"\n                              style=\"position: absolute; left: -10000px;\"\n                              [innerHtml]=\"sortStatus(column)\">\n                        </span>\n                    </ng-template>\n                    <ng-template [ngIf]=\"isCheckboxColumn(column) && !column.headerTemplateRef && column.showSelectAll\">\n                        <input\n                            class=\"k-checkbox\"\n                            [attr.id]=\"selectAllCheckboxId()\"\n                            kendoGridSelectAllCheckbox\n                            kendoGridFocusable>\n                        <label class=\"k-checkbox-label\" [attr.for]=\"selectAllCheckboxId()\"></label>\n                    </ng-template>\n                    <span kendoGridColumnHandle\n                        kendoDraggable\n                        class=\"k-column-resizer\"\n                        *ngIf=\"resizable\"\n                        [column]=\"column\"\n                        [columns]=\"columns\">\n                    </span>\n                </th>\n                <th *ngIf=\"isColumnGroupComponent(column)\"\n                    kendoGridLogicalCell [logicalRowIndex]=\"levelIndex\"\n                                         [logicalColIndex]=\"logicalColumnIndex(column)\"\n                                         [rowSpan]=\"column.rowspan(totalColumnLevels)\"\n                                         [colSpan]=\"column.colspan\"\n                    kendoDropTarget\n                    kendoDraggable\n                    kendoDraggableColumn\n                    [enableDrag]=\"shouldActivate(column)\"\n                    [context]=\"{\n                        type: 'columnGroup',\n                        column: column,\n                        hint: column.title,\n                        lastColumn: last && columnIndex === 0\n                    }\"\n                    class=\"k-header\"\n                    [class.k-first]=\"isFirstOnRow(column, columnIndex)\"\n                    [class.k-filterable]=\"showColumnMenu(column)\"\n                    [ngClass]=\"column.headerClass\"\n                    [ngStyle]=\"column.headerStyle\"\n                    [attr.rowspan]=\"column.rowspan(totalColumnLevels)\"\n                    [attr.colspan]=\"column.colspan\">\n                        <kendo-grid-column-menu *ngIf=\"showColumnMenu(column)\"\n                            [standalone]=\"false\"\n                            [settings]=\"columnMenu\"\n                            [column]=\"column\"\n                            [columnMenuTemplate]=\"columnMenuTemplate\">\n                        </kendo-grid-column-menu>\n                        <ng-template\n                            [templateContext]=\"{\n                                templateRef: column.headerTemplateRef,\n                                columnIndex: lockedColumnsCount + columnIndex,\n                                column: column,\n                                $implicit: column\n                            }\">\n                        </ng-template>\n                        <ng-template [ngIf]=\"!column.headerTemplateRef\">{{column.displayTitle}}</ng-template>\n                        <span kendoGridColumnHandle\n                            kendoDraggable\n                            class=\"k-column-resizer\"\n                            *ngIf=\"resizable\"\n                            [column]=\"column\"\n                            [columns]=\"columns\">\n                        </span>\n                </th>\n            </ng-template>\n        </tr>\n        <tr *ngIf=\"showFilterRow\"\n            kendoGridFilterRow\n                [columns]=\"leafColumns\"\n                [filter]=\"filter\"\n                [groups]=\"groups\"\n                [detailTemplate]=\"detailTemplate\"\n                [lockedColumnsCount]=\"lockedColumnsCount\"\n            kendoGridLogicalRow\n                [logicalRowIndex]=\"totalColumnLevels + 1\"\n                [logicalSlaveRow]=\"lockedColumnsCount > 0\"\n                [logicalCellsCount]=\"columns.length\"\n                [logicalSlaveCellsCount]=\"unlockedColumnsCount\"\n        ></tr>\n    </ng-template>\n    `\n            },] },\n];\n/** @nocollapse */\nHeaderComponent.ctorParameters = () => [\n    { type: SinglePopupService },\n    { type: DragHintService },\n    { type: DropCueService },\n    { type: ColumnReorderService },\n    { type: IdService },\n    { type: SortService },\n    { type: LocalizationService },\n    { type: ChangeDetectorRef }\n];\nHeaderComponent.propDecorators = {\n    totalColumnLevels: [{ type: Input }],\n    columns: [{ type: Input }],\n    groups: [{ type: Input }],\n    detailTemplate: [{ type: Input }],\n    scrollable: [{ type: Input }],\n    filterable: [{ type: Input }],\n    sort: [{ type: Input }],\n    filter: [{ type: Input }],\n    sortable: [{ type: Input }],\n    groupable: [{ type: Input }],\n    lockedColumnsCount: [{ type: Input }],\n    resizable: [{ type: Input }],\n    reorderable: [{ type: Input }],\n    columnMenu: [{ type: Input }],\n    columnMenuTemplate: [{ type: Input }],\n    totalColumnsCount: [{ type: Input }],\n    headerClass: [{ type: HostBinding, args: ['class.k-grid-header',] }],\n    dropTargets: [{ type: ViewChildren, args: [DropTargetDirective,] }]\n};\n\n// TODO\n// tslint:disable:rxjs-no-unsafe-takeuntil\n/**\n * @hidden\n */\nconst fromPercentage = (value, percent) => {\n    const sign = percent < 0 ? -1 : 1;\n    return Math.ceil((Math.abs(percent) / 100) * value) * sign;\n};\n/**\n * @hidden\n */\nconst toPercentage = (value, whole) => (value / whole) * 100;\n/**\n * @hidden\n */\nconst headerWidth = (handle) => handle.nativeElement.parentElement.offsetWidth;\n/**\n * @hidden\n */\nconst allLeafColumns = columns => expandColumns(columns)\n    .filter(c => !c.isColumnGroup);\n/**\n * @hidden\n */\nconst stopPropagation = ({ originalEvent: event }) => {\n    event.stopPropagation();\n    event.preventDefault();\n};\n/**\n * @hidden\n */\nconst createMoveStream = (service, draggable) => mouseDown => draggable.kendoDrag.pipe(takeUntil(draggable.kendoRelease.pipe(tap(() => service.end()))), map(({ pageX }) => ({\n    originalX: mouseDown.pageX,\n    pageX\n})));\n/**\n * @hidden\n */\nconst preventOnDblClick$1 = release => mouseDown => of(mouseDown).pipe(delay(150), takeUntil(release));\n/**\n * @hidden\n */\nconst isInSpanColumn$1 = column => !!(column.parent && column.parent.isSpanColumn);\n/**\n * @hidden\n *\n * Calculates the column index. If the column is stated in `SpanColumn`,\n * the index for all child columns equals the index of the first child.\n */\nconst indexOf = (target, list) => {\n    let index = 0;\n    let ignore = 0;\n    let skip = 0;\n    while (index < list.length) {\n        const current = list[index];\n        const isParentSpanColumn = isInSpanColumn$1(current);\n        if (current === target) {\n            break;\n        }\n        if ((ignore-- <= 0) && isParentSpanColumn) {\n            ignore = current.parent.childColumns.length - 1;\n            skip += ignore;\n        }\n        index++;\n    }\n    return index - skip;\n};\n/**\n * @hidden\n */\nclass ColumnHandleDirective {\n    constructor(draggable, element, service, zone, cdr, localization) {\n        this.draggable = draggable;\n        this.element = element;\n        this.service = service;\n        this.zone = zone;\n        this.cdr = cdr;\n        this.localization = localization;\n        this.columns = [];\n        this.subscriptions = new Subscription();\n        this.rtl = false;\n    }\n    get visible() {\n        return this.column.resizable ? 'block' : 'none';\n    }\n    get leftStyle() {\n        return isTruthy(this.rtl) ? 0 : null;\n    }\n    get rightStyle() {\n        return isTruthy(this.rtl) ? null : 0;\n    }\n    autoFit() {\n        const allLeafs = allLeafColumns(this.columns);\n        const currentLeafs = leafColumns([this.column]).filter(column => isTruthy(column.resizable));\n        const columnInfo = currentLeafs.map(column => {\n            const isParentSpan = isInSpanColumn$1(column);\n            const isLastInSpan = isParentSpan ? column.parent.childColumns.last === column : false;\n            const index = indexOf(column, allLeafs);\n            return {\n                column,\n                headerIndex: this.columnsForLevel(column.level).indexOf(column),\n                index,\n                isLastInSpan,\n                isParentSpan,\n                level: column.level\n            };\n        });\n        currentLeafs.forEach(column => column.width = 0);\n        this.service.measureColumns(columnInfo);\n    }\n    ngOnInit() {\n        const service = this.service.changes.pipe(filter(() => this.column.resizable), filter(e => isPresent(e.columns.find(column => column === this.column))));\n        this.subscriptions.add(service.pipe(filter(e => e.type === 'start'))\n            .subscribe(this.initState.bind(this)));\n        this.subscriptions.add(service.pipe(filter(e => e.type === 'resizeColumn'))\n            .subscribe(this.resize.bind(this)));\n        this.subscriptions.add(this.service.changes.pipe(filter(e => e.type === 'start'), filter(this.shouldUpdate.bind(this)), take(1) //on first resize only\n        ).subscribe(this.initColumnWidth.bind(this)));\n        this.subscriptions.add(this.zone.runOutsideAngular(() => this.draggable.kendoPress.pipe(tap(stopPropagation), tap(() => this.service.start(this.column)), switchMap(preventOnDblClick$1(this.draggable.kendoRelease)), switchMap(createMoveStream(this.service, this.draggable)))\n            .subscribe(({ pageX, originalX }) => {\n            const delta = pageX - originalX;\n            const percent = toPercentage(delta, this.column.resizeStartWidth || this.column.width);\n            this.service.resizeColumns(percent);\n        })));\n        this.subscriptions.add(service.pipe(filter(e => e.type === 'autoFitComplete'))\n            .subscribe(this.sizeToFit.bind(this)));\n        this.subscriptions.add(service.pipe(filter(e => e.type === 'triggerAutoFit'))\n            .subscribe(this.autoFit.bind(this)));\n        this.subscriptions.add(this.localization.changes.subscribe(({ rtl }) => this.rtl = rtl));\n    }\n    ngOnDestroy() {\n        if (this.subscriptions) {\n            this.subscriptions.unsubscribe();\n        }\n    }\n    shouldUpdate() {\n        return !allLeafColumns(this.columns)\n            .map(column => column.width)\n            .some(isBlank);\n    }\n    initColumnWidth() {\n        this.column.width = headerWidth(this.element);\n    }\n    initState() {\n        this.column.resizeStartWidth = headerWidth(this.element);\n        this.service.resizedColumn({\n            column: this.column,\n            oldWidth: this.column.resizeStartWidth\n        });\n    }\n    resize({ deltaPercent }) {\n        let delta = fromPercentage(this.column.resizeStartWidth, deltaPercent);\n        if (isTruthy(this.rtl)) {\n            delta *= -1;\n        }\n        const newWidth = Math.max(this.column.resizeStartWidth + delta, this.column.minResizableWidth);\n        const tableDelta = newWidth > this.column.minResizableWidth ?\n            delta : this.column.minResizableWidth - this.column.resizeStartWidth;\n        this.updateWidth(this.column, newWidth);\n        this.service.resizeTable(this.column, tableDelta);\n    }\n    sizeToFit({ columns, widths }) {\n        const index = columns.indexOf(this.column);\n        const width = Math.max(...widths.map(w => w[index])) + 1; //add 1px for IE\n        const tableDelta = width - this.column.resizeStartWidth;\n        this.updateWidth(this.column, width);\n        this.service.resizeTable(this.column, tableDelta);\n    }\n    updateWidth(column, width) {\n        column.width = width;\n        this.cdr.markForCheck(); //force CD cycle\n    }\n    columnsForLevel(level) {\n        return columnsToRender(this.columns ? this.columns.filter(column => column.level === level) : []);\n    }\n}\nColumnHandleDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridColumnHandle]'\n            },] },\n];\n/** @nocollapse */\nColumnHandleDirective.ctorParameters = () => [\n    { type: DraggableDirective, decorators: [{ type: Host }] },\n    { type: ElementRef },\n    { type: ColumnResizingService },\n    { type: NgZone },\n    { type: ChangeDetectorRef },\n    { type: LocalizationService }\n];\nColumnHandleDirective.propDecorators = {\n    columns: [{ type: Input }],\n    column: [{ type: Input }],\n    visible: [{ type: HostBinding, args: ['style.display',] }],\n    leftStyle: [{ type: HostBinding, args: ['style.left',] }],\n    rightStyle: [{ type: HostBinding, args: ['style.right',] }],\n    autoFit: [{ type: HostListener, args: ['dblclick',] }]\n};\n\n/**\n * Represents the select-all checkbox feature of the Grid ([see example]({% slug selection_grid %}#toc-select-all-feature)).\n */\nclass SelectAllCheckboxDirective {\n    constructor(selectionService, el, renderer, ngZone) {\n        this.selectionService = selectionService;\n        this.el = el;\n        this.renderer = renderer;\n        this.ngZone = ngZone;\n        /**\n         * Fires when the user clicks the `kendoGridSelectAllCheckbox` select-all checkbox\n         * ([see example]({% slug selection_grid %}#toc-select-all-feature)).\n         */\n        this.selectAllChange = new EventEmitter();\n        this.type = \"checkbox\";\n        this.stateSet = false;\n        this.ngZone.runOutsideAngular(() => {\n            this.destroyClick = this.renderer.listen(this.el.nativeElement, \"click\", this.onClick.bind(this));\n        });\n    }\n    ngAfterContentChecked() {\n        this.setState();\n    }\n    ngOnChanges() {\n        this.stateSet = true;\n    }\n    ngOnDestroy() {\n        if (this.destroyClick) {\n            this.destroyClick();\n        }\n    }\n    /**\n     * @hidden\n     */\n    onClick() {\n        const isChecked = this.el.nativeElement.checked;\n        const options = this.selectionService.options;\n        this.selectAllChange.emit(isChecked ? \"checked\" : \"unchecked\");\n        if (options.enabled && options.mode === \"multiple\") {\n            this.ngZone.run(() => {\n                this.selectionService.updateAll(isChecked);\n            });\n        }\n    }\n    /**\n     * @hidden\n     */\n    setState() {\n        const state$$1 = this.stateSet ? this.stateToBool() : this.selectionService.selectAllState;\n        const elem = this.el.nativeElement;\n        this.renderer.setProperty(elem, \"indeterminate\", !isPresent(state$$1));\n        this.renderer.setProperty(elem, \"checked\", isPresent(state$$1) ? state$$1 : false);\n    }\n    /**\n     * @hidden\n     */\n    stateToBool() {\n        switch (this.state) {\n            case \"checked\":\n                return true;\n            case \"unchecked\":\n                return false;\n            default:\n                return undefined;\n        }\n    }\n}\nSelectAllCheckboxDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridSelectAllCheckbox]'\n            },] },\n];\n/** @nocollapse */\nSelectAllCheckboxDirective.ctorParameters = () => [\n    { type: SelectionService },\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: NgZone }\n];\nSelectAllCheckboxDirective.propDecorators = {\n    state: [{ type: Input }],\n    selectAllChange: [{ type: Output }],\n    type: [{ type: HostBinding, args: ['attr.type',] }]\n};\n\n/**\n * @hidden\n */\nclass FilterMenuComponent {\n    constructor(filterService, popupService, localization) {\n        this.filterService = filterService;\n        this.popupService = popupService;\n        this.localization = localization;\n        /**\n         * @hidden\n         */\n        this.filterLabel = this.localization.get('filter');\n    }\n    get hasFilters() {\n        return filtersByField(this.filter, (this.column || {}).field).length > 0;\n    }\n    toggle(anchor, template) {\n        this.popupRef = this.popupService.open(anchor, template, this.popupRef);\n        return false;\n    }\n    close() {\n        this.popupService.destroy();\n    }\n}\nFilterMenuComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-grid-filter-menu',\n                template: `\n        <a #anchor\n            [ngClass]=\"{'k-grid-filter':true, 'k-state-active': hasFilters}\"\n            (click)=\"toggle(anchor, template)\"\n            href=\"#\"\n            [attr.title]=\"filterLabel\">\n            <span class=\"k-icon k-i-filter\"></span>\n        </a>\n        <ng-template #template>\n            <kendo-grid-filter-menu-container\n                [column]=\"column\"\n                [filter]=\"filter\"\n                (close)=\"close()\"\n                >\n            </kendo-grid-filter-menu-container>\n        </ng-template>\n    `\n            },] },\n];\n/** @nocollapse */\nFilterMenuComponent.ctorParameters = () => [\n    { type: FilterService },\n    { type: SinglePopupService },\n    { type: LocalizationService }\n];\nFilterMenuComponent.propDecorators = {\n    column: [{ type: Input }],\n    filter: [{ type: Input }]\n};\n\nconst isNoValueOperator = operator => (operator === \"isnull\"\n    || operator === \"isnotnull\"\n    || operator === \"isempty\"\n    || operator === \"isnotempty\");\nconst validFilters = ({ value, operator }) => !isNullOrEmptyString(value) || isNoValueOperator(operator);\nconst trimFilters = filter$$1 => {\n    filter$$1.filters = filter$$1.filters.filter(validFilters);\n    return filter$$1;\n};\nconst findParent = (filters, field, parent) => {\n    return filters.reduce((acc, filter$$1) => {\n        if (acc) {\n            return acc;\n        }\n        if (filter$$1.filters) {\n            return findParent(filter$$1.filters, field, filter$$1);\n        }\n        else if (filter$$1.field === field) {\n            return parent;\n        }\n        return acc;\n    }, undefined); // tslint:disable-line:align\n};\nconst parentLogicOfDefault = (filter$$1, field, def = \"and\") => {\n    const parent = findParent(((filter$$1 || {}).filters || []), field);\n    return isPresent(parent) ? parent.logic : def;\n};\n/**\n * @hidden\n */\nclass FilterMenuContainerComponent {\n    constructor(parentService, childService, localization, cd) {\n        this.parentService = parentService;\n        this.childService = childService;\n        this.localization = localization;\n        this.cd = cd;\n        this.close = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.actionsClass = 'k-action-buttons k-button-group';\n        this._templateContext = {};\n    }\n    get filter() {\n        return this._filter;\n    }\n    /**\n     * The current root filter.\n     * @type {CompositeFilterDescriptor}\n     */\n    set filter(value) {\n        this._filter = cloneFilters(value);\n    }\n    get childFilter() {\n        if (!isPresent(this._childFilter)) {\n            this._childFilter = {\n                filters: filtersByField(this.filter, (this.column || {}).field),\n                logic: parentLogicOfDefault(this.filter, (this.column || {}).field)\n            };\n        }\n        return this._childFilter;\n    }\n    ngOnInit() {\n        this.subscription = this.childService.changes.subscribe(filter$$1 => this._childFilter = filter$$1);\n        this.subscription.add(this.localization.changes.subscribe(() => this.cd.markForCheck()));\n    }\n    ngOnDestroy() {\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n        }\n    }\n    get disabled() {\n        return !this.childFilter.filters.some(validFilters);\n    }\n    get templateContext() {\n        this._templateContext.column = this.column;\n        this._templateContext.filter = this.childFilter;\n        this._templateContext.filterService = this.childService;\n        // tslint:disable-next-line:no-string-literal\n        this._templateContext[\"$implicit\"] = this.childFilter;\n        return this._templateContext;\n    }\n    get hasTemplate() {\n        return isPresent(this.column) && isPresent(this.column.filterMenuTemplateRef);\n    }\n    submit() {\n        const filter$$1 = trimFilters(this.childFilter);\n        if (filter$$1.filters.length) {\n            const root = this.filter || {\n                filters: [],\n                logic: \"and\"\n            };\n            removeFilter(root, this.column.field);\n            root.filters.push(filter$$1);\n            this.parentService.filter(root);\n        }\n        this.close.emit();\n        return false;\n    }\n    reset() {\n        const root = this.filter || {\n            filters: [],\n            logic: \"and\"\n        };\n        removeFilter(root, this.column.field);\n        this.parentService.filter(root);\n        this.close.emit();\n    }\n    get clearText() {\n        return this.localization.get(\"filterClearButton\");\n    }\n    get filterText() {\n        return this.localization.get(\"filterFilterButton\");\n    }\n}\nFilterMenuContainerComponent.decorators = [\n    { type: Component, args: [{\n                providers: [FilterService],\n                selector: 'kendo-grid-filter-menu-container',\n                template: `\n        <form (submit)=\"submit()\" (reset)=\"reset()\"\n            class=\"k-filter-menu k-group k-reset k-state-border-up\">\n            <div class=\"k-filter-menu-container\">\n                <ng-container [ngSwitch]=\"hasTemplate\">\n                    <ng-container *ngSwitchCase=\"false\">\n                        <ng-container\n                            kendoFilterMenuHost\n                            [filterService]=\"childService\"\n                            [column]=\"column\"\n                            [filter]=\"childFilter\">\n                        </ng-container>\n                    </ng-container>\n                    <ng-container *ngSwitchCase=\"true\">\n                        <ng-template\n                            *ngIf=\"column.filterMenuTemplateRef\"\n                            [ngTemplateOutlet]=\"column.filterMenuTemplateRef\"\n                            [ngTemplateOutletContext]=\"templateContext\"\n                            >\n                        </ng-template>\n                    </ng-container>\n                </ng-container>\n                <div [ngClass]=\"actionsClass\">\n                    <button type=\"reset\" class=\"k-button\">{{clearText}}</button>\n                    <button type=\"submit\" class=\"k-button k-primary\" [disabled]=\"disabled\">{{filterText}}</button>\n                </div>\n            </div>\n        </form>\n    `\n            },] },\n];\n/** @nocollapse */\nFilterMenuContainerComponent.ctorParameters = () => [\n    { type: FilterService, decorators: [{ type: SkipSelf }] },\n    { type: FilterService },\n    { type: LocalizationService },\n    { type: ChangeDetectorRef }\n];\nFilterMenuContainerComponent.propDecorators = {\n    close: [{ type: Output }],\n    column: [{ type: Input }],\n    filter: [{ type: Input }],\n    actionsClass: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nclass FilterMenuInputWrapperComponent extends FilterInputWrapperComponent {\n    constructor() {\n        super(null);\n    }\n    /**\n     * @hidden\n     */\n    get hostClasses() {\n        return false;\n    }\n    operatorChange(dataItem) {\n        this.currentOperator = dataItem;\n    }\n    filterChange(filter$$1) {\n        this.applyFilter(filter$$1);\n    }\n    /**\n     * The current filter for the associated column field.\n     * @readonly\n     * @type {FilterDescriptor}\n     */\n    get currentFilter() {\n        return this._currentFilter;\n    }\n    /**\n     * The current filter for the associated column field.\n     * @readonly\n     * @type {FilterDescriptor}\n     */\n    set currentFilter(value) {\n        this._currentFilter = value;\n    }\n    updateFilter(filter$$1) {\n        Object.assign(this.currentFilter, filter$$1);\n        return this.filter;\n    }\n    onChange(value) {\n        this.filterChange(this.updateFilter({\n            field: this.column.field,\n            operator: this.currentOperator,\n            value: value\n        }));\n    }\n}\nFilterMenuInputWrapperComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-grid-filter-menu-input-wrapper',\n                template: `\n        <kendo-dropdownlist\n            [data]=\"operators\"\n            (valueChange)=\"operatorChange($event)\"\n            [value]=\"currentOperator\"\n            [valuePrimitive]=\"true\"\n            textField=\"text\"\n            valueField=\"value\">\n        </kendo-dropdownlist>\n        <ng-content></ng-content>\n    `\n            },] },\n];\n/** @nocollapse */\nFilterMenuInputWrapperComponent.ctorParameters = () => [];\nFilterMenuInputWrapperComponent.propDecorators = {\n    filterService: [{ type: Input }],\n    currentFilter: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nclass StringFilterMenuInputComponent {\n    constructor() {\n        this.operators = [];\n    }\n}\nStringFilterMenuInputComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-grid-string-filter-menu-input',\n                template: `\n        <kendo-grid-filter-menu-input-wrapper\n            [column]=\"column\"\n            [filter]=\"filter\"\n            [operators]=\"operators\"\n            [defaultOperator]=\"operator\"\n            [currentFilter]=\"currentFilter\"\n            [filterService]=\"filterService\"\n            >\n            <input class=\"k-textbox\" kendoFilterInput [filterDelay]=\"0\" [ngModel]=\"currentFilter?.value\" />\n        </kendo-grid-filter-menu-input-wrapper>\n    `\n            },] },\n];\nStringFilterMenuInputComponent.propDecorators = {\n    operators: [{ type: Input }],\n    column: [{ type: Input }],\n    filter: [{ type: Input }],\n    operator: [{ type: Input }],\n    currentFilter: [{ type: Input }],\n    filterService: [{ type: Input }]\n};\n\n/**\n * Represents a string-filter menu component.\n * ([see example]({% slug builtinfiltertemplate_grid %}#toc-configuration-components-for-filter-templates)).\n */\nclass StringFilterMenuComponent extends StringFilterComponent {\n    constructor(localization) {\n        super(null, localization);\n        this.logicOperators = logicOperators(this.localization);\n        /**\n         * The current menu filter.\n         * @type {CompositeFilterDescriptor}\n         */\n        this.filter = { filters: [], logic: \"and\" };\n        /**\n         * Determines if the inputs of second criteria will displayed.\n         */\n        this.extra = true;\n    }\n    /**\n     * @hidden\n     */\n    get hostClasses() {\n        return false;\n    }\n    get firstFilter() {\n        return setFilter(0, this.filter, (this.column || {}).field, this.operator);\n    }\n    get secondFilter() {\n        return setFilter(1, this.filter, (this.column || {}).field, this.operator);\n    }\n    logicChange(value) {\n        this.filter.logic = value;\n    }\n    localizationChange() {\n        this.logicOperators = logicOperators(this.localization);\n        super.localizationChange();\n    }\n}\nStringFilterMenuComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-grid-string-filter-menu',\n                template: `\n        <kendo-grid-string-filter-menu-input\n            [currentFilter]=\"firstFilter\"\n            [operators]=\"operators\"\n            [filterService]=\"filterService\"\n            [column]=\"column\"\n            [filter]=\"filter\">\n        </kendo-grid-string-filter-menu-input>\n        <kendo-dropdownlist\n            *ngIf=\"extra\"\n            class=\"k-filter-and\"\n            [data]=\"logicOperators\"\n            [valuePrimitive]=\"true\" (valueChange)=\"logicChange($event)\"\n            [value]=\"filter?.logic\"\n            textField=\"text\"\n            valueField=\"value\">\n        </kendo-dropdownlist>\n        <kendo-grid-string-filter-menu-input\n            *ngIf=\"extra\"\n            [operators]=\"operators\"\n            [currentFilter]=\"secondFilter\"\n            [filterService]=\"filterService\"\n            [column]=\"column\"\n            [filter]=\"filter\">\n        </kendo-grid-string-filter-menu-input>\n    `\n            },] },\n];\n/** @nocollapse */\nStringFilterMenuComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\nStringFilterMenuComponent.propDecorators = {\n    hostClasses: [{ type: HostBinding, args: ['class.k-filtercell',] }],\n    column: [{ type: Input }],\n    filter: [{ type: Input }],\n    extra: [{ type: Input }],\n    filterService: [{ type: Input }]\n};\n\n/**\n * Represents a numeric-filter menu component.\n *\n * @example\n *  ```html-no-run\n *      <kendo-grid-column field=\"UnitPrice\" title=\"Unit Price\">\n *          <ng-template kendoGridFilterMenuTemplate let-filter let-column=\"column\" let-filterService=\"filterService\">\n *          <kendo-grid-numeric-filter-menu\n *              [column]=\"column\"\n *              [filter]=\"filter\"\n *              [filterService]=\"filterService\"\n *              >\n *          </kendo-grid-numeric-filter-menu>\n *          </ng-template>\n *      </kendo-grid-column>\n *   ```\n */\nclass NumericFilterMenuComponent extends NumericFilterComponent {\n    constructor(localization) {\n        super(null, localization);\n        this.logicOperators = logicOperators(this.localization);\n        /**\n         * The current menu filter.\n         * @type {CompositeFilterDescriptor}\n         */\n        this.filter = { filters: [], logic: \"and\" };\n        /**\n         * Determines if the inputs of second criteria will displayed.\n         */\n        this.extra = true;\n    }\n    /**\n     * @hidden\n     */\n    get hostClasses() {\n        return false;\n    }\n    get firstFilter() {\n        return setFilter(0, this.filter, (this.column || {}).field, this.operator);\n    }\n    get secondFilter() {\n        return setFilter(1, this.filter, (this.column || {}).field, this.operator);\n    }\n    logicChange(value) {\n        this.filter.logic = value;\n    }\n    localizationChange() {\n        this.logicOperators = logicOperators(this.localization);\n        super.localizationChange();\n    }\n}\nNumericFilterMenuComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-grid-numeric-filter-menu',\n                template: `\n        <kendo-grid-numeric-filter-menu-input\n            [currentFilter]=\"firstFilter\"\n            [operators]=\"operators\"\n            [filterService]=\"filterService\"\n            [column]=\"column\"\n            [filter]=\"filter\"\n            [format]=\"format\"\n            [decimals]=\"decimals\"\n            [spinners]=\"spinners\"\n            [min]=\"min\"\n            [max]=\"max\"\n            [step]=\"step\"\n            >\n        </kendo-grid-numeric-filter-menu-input>\n        <kendo-dropdownlist\n            *ngIf=\"extra\"\n            class=\"k-filter-and\"\n            [data]=\"logicOperators\"\n            [valuePrimitive]=\"true\"\n            (valueChange)=\"logicChange($event)\"\n            [value]=\"filter?.logic\"\n            textField=\"text\"\n            valueField=\"value\">\n        </kendo-dropdownlist>\n        <kendo-grid-numeric-filter-menu-input\n            *ngIf=\"extra\"\n            [operators]=\"operators\"\n            [currentFilter]=\"secondFilter\"\n            [filterService]=\"filterService\"\n            [column]=\"column\"\n            [filter]=\"filter\"\n            [format]=\"format\"\n            [decimals]=\"decimals\"\n            [spinners]=\"spinners\"\n            [min]=\"min\"\n            [max]=\"max\"\n            [step]=\"step\"\n            >\n        </kendo-grid-numeric-filter-menu-input>\n    `\n            },] },\n];\n/** @nocollapse */\nNumericFilterMenuComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\nNumericFilterMenuComponent.propDecorators = {\n    hostClasses: [{ type: HostBinding, args: ['class.k-filtercell',] }],\n    column: [{ type: Input }],\n    filter: [{ type: Input }],\n    extra: [{ type: Input }],\n    filterService: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nclass NumericFilterMenuInputComponent {\n    constructor() {\n        this.operators = [];\n        /**\n         * Specifies the value which is used to increment or decrement the component value.\n         * @type {numeric}\n         */\n        this.step = 1;\n        /**\n         * Specifies whether the **Up** and **Down** spin buttons will be rendered.\n         * @type {boolean}\n         */\n        this.spinners = true;\n    }\n}\nNumericFilterMenuInputComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-grid-numeric-filter-menu-input',\n                template: `\n        <kendo-grid-filter-menu-input-wrapper\n            [column]=\"column\"\n            [filter]=\"filter\"\n            [operators]=\"operators\"\n            [defaultOperator]=\"operator\"\n            [currentFilter]=\"currentFilter\"\n            [filterService]=\"filterService\"\n            >\n            <kendo-numerictextbox\n                kendoFilterInput\n                [filterDelay]=\"0\"\n                [autoCorrect]=\"true\"\n                [value]=\"currentFilter?.value\"\n                [format]=\"format\"\n                [decimals]=\"decimals\"\n                [spinners]=\"spinners\"\n                [min]=\"min\"\n                [max]=\"max\"\n                [step]=\"step\">\n            </kendo-numerictextbox>\n        </kendo-grid-filter-menu-input-wrapper>\n    `\n            },] },\n];\nNumericFilterMenuInputComponent.propDecorators = {\n    operators: [{ type: Input }],\n    column: [{ type: Input }],\n    filter: [{ type: Input }],\n    operator: [{ type: Input }],\n    currentFilter: [{ type: Input }],\n    filterService: [{ type: Input }],\n    step: [{ type: Input }],\n    min: [{ type: Input }],\n    max: [{ type: Input }],\n    spinners: [{ type: Input }],\n    decimals: [{ type: Input }],\n    format: [{ type: Input }]\n};\n\n/**\n * Represents a date-filter menu component.\n *\n * @example\n *  ```html-no-run\n *      <kendo-grid-column field=\"OrderDate\" title=\"Order Date\">\n *          <ng-template kendoGridFilterMenuTemplate let-filter let-column=\"column\" let-filterService=\"filterService\">\n *            <kendo-grid-date-filter-menu\n *                [column]=\"column\"\n *                [filter]=\"filter\"\n *                [filterService]=\"filterService\"\n *                >\n *            </kendo-grid-date-filter-menu>\n *          </ng-template>\n *      </kendo-grid-column>\n *   ```\n */\nclass DateFilterMenuComponent extends DateFilterComponent {\n    constructor(localization) {\n        super(null, localization);\n        this.logicOperators = logicOperators(this.localization);\n        /**\n         * The current menu filter.\n         * @type {CompositeFilterDescriptor}\n         */\n        this.filter = { filters: [], logic: \"and\" };\n        /**\n         * Determines if the inputs of second criteria will be displayed.\n         */\n        this.extra = true;\n    }\n    /**\n     * @hidden\n     */\n    get hostClasses() {\n        return false;\n    }\n    get firstFilter() {\n        return setFilter(0, this.filter, (this.column || {}).field, this.operator);\n    }\n    get secondFilter() {\n        return setFilter(1, this.filter, (this.column || {}).field, this.operator);\n    }\n    logicChange(value) {\n        this.filter.logic = value;\n    }\n    localizationChange() {\n        this.logicOperators = logicOperators(this.localization);\n        super.localizationChange();\n    }\n}\nDateFilterMenuComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-grid-date-filter-menu',\n                template: `\n        <kendo-grid-date-filter-menu-input\n            [currentFilter]=\"firstFilter\"\n            [operators]=\"operators\"\n            [filterService]=\"filterService\"\n            [column]=\"column\"\n            [filter]=\"filter\"\n            [activeView]=\"activeView\"\n            [bottomView]=\"bottomView\"\n            [topView]=\"topView\"\n            [format]=\"format\"\n            [formatPlaceholder]=\"formatPlaceholder\"\n            [placeholder]=\"placeholder\"\n            [min]=\"min\"\n            [max]=\"max\"\n            [weekNumber]=\"weekNumber\"\n            >\n        </kendo-grid-date-filter-menu-input>\n        <kendo-dropdownlist\n            *ngIf=\"extra\"\n            class=\"k-filter-and\"\n            [data]=\"logicOperators\"\n            [valuePrimitive]=\"true\"\n            (valueChange)=\"logicChange($event)\"\n            [value]=\"filter?.logic\"\n            textField=\"text\"\n            valueField=\"value\">\n        </kendo-dropdownlist>\n        <kendo-grid-date-filter-menu-input\n            *ngIf=\"extra\"\n            [operators]=\"operators\"\n            [currentFilter]=\"secondFilter\"\n            [filterService]=\"filterService\"\n            [column]=\"column\"\n            [filter]=\"filter\"\n            [activeView]=\"activeView\"\n            [bottomView]=\"bottomView\"\n            [topView]=\"topView\"\n            [format]=\"format\"\n            [formatPlaceholder]=\"formatPlaceholder\"\n            [placeholder]=\"placeholder\"\n            [min]=\"min\"\n            [max]=\"max\"\n            [weekNumber]=\"weekNumber\"\n            >\n        </kendo-grid-date-filter-menu-input>\n    `\n            },] },\n];\n/** @nocollapse */\nDateFilterMenuComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\nDateFilterMenuComponent.propDecorators = {\n    hostClasses: [{ type: HostBinding, args: ['class.k-filtercell',] }],\n    column: [{ type: Input }],\n    filter: [{ type: Input }],\n    extra: [{ type: Input }],\n    filterService: [{ type: Input }]\n};\n\n/**\n * Represents a Boolean-filter menu component.\n *\n * @example\n *  ```html-no-run\n *      <kendo-grid-column field=\"Discontinued\" title=\"Discontinued\">\n *          <ng-template kendoGridFilterMenuTemplate let-filter let-column=\"column\" let-filterService=\"filterService\">\n *            <kendo-grid-boolean-filter-menu\n *                [column]=\"column\"\n *                [filter]=\"filter\"\n *                [filterService]=\"filterService\"\n *                >\n *            </kendo-grid-boolean-filter-menu>\n *          </ng-template>\n *      </kendo-grid-column>\n *   ```\n */\nclass BooleanFilterMenuComponent extends BooleanFilterComponent {\n    constructor(localization) {\n        super(null, localization);\n        /**\n         * The current menu filter.\n         * @type {CompositeFilterDescriptor}\n         */\n        this.filter = { filters: [], logic: \"and\" };\n        this.idPrefix = guid();\n    }\n    /**\n     * @hidden\n     */\n    get hostClasses() {\n        return false;\n    }\n    /**\n     * @hidden\n     */\n    radioId(value) {\n        return `${this.idPrefix}_${value}`;\n    }\n    /**\n     * @hidden\n     */\n    onChange(value) {\n        this.applyFilter(this.updateFilter({\n            field: this.column.field,\n            operator: \"eq\",\n            value: value\n        }));\n    }\n    /**\n     * @hidden\n     */\n    isSelected(radioValue) {\n        return this.filtersByField(this.column.field).some(({ value }) => value === radioValue);\n    }\n}\nBooleanFilterMenuComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-grid-boolean-filter-menu',\n                template: `\n        <ul class=\"k-radio-list k-reset\">\n            <li *ngFor=\"let item of items\">\n                <input type=\"radio\"\n                    [name]=\"idPrefix\"\n                    class=\"k-radio\"\n                    [checked]=\"isSelected(item.value)\"\n                    [attr.id]=\"radioId(item.value)\"\n                    (change)=\"onChange(item.value)\"\n                />\n                <label class=\"k-radio-label\" [attr.for]=\"radioId(item.value)\">{{item.text}}</label>\n            </li>\n        </ul>\n    `\n            },] },\n];\n/** @nocollapse */\nBooleanFilterMenuComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\nBooleanFilterMenuComponent.propDecorators = {\n    hostClasses: [{ type: HostBinding, args: ['class.k-filtercell',] }],\n    filter: [{ type: Input }],\n    filterService: [{ type: Input }]\n};\n\n/**\n * @hidden\n *\n * > List the following components as `entryComponents` in the GridModule.\n */\nconst filterMenuComponentFactory = (type) => ({\n    \"boolean\": BooleanFilterMenuComponent,\n    \"date\": DateFilterMenuComponent,\n    \"numeric\": NumericFilterMenuComponent,\n    \"text\": StringFilterMenuComponent\n}[type]);\n\n/**\n * @hidden\n */\nclass FilterMenuHostDirective extends FilterHostDirective {\n    constructor(host, resolver) {\n        super(host, resolver);\n    }\n    componentType() {\n        if (isPresent(this.column) && !isNullOrEmptyString(this.column.filter)) {\n            return filterMenuComponentFactory(this.column.filter);\n        }\n        return StringFilterMenuComponent;\n    }\n    initComponent(ctx) {\n        super.initComponent(ctx);\n        this.component.instance.filterService = this.filterService;\n    }\n}\nFilterMenuHostDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoFilterMenuHost]'\n            },] },\n];\n/** @nocollapse */\nFilterMenuHostDirective.ctorParameters = () => [\n    { type: ViewContainerRef },\n    { type: ComponentFactoryResolver }\n];\nFilterMenuHostDirective.propDecorators = {\n    filterService: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nclass DateFilterMenuInputComponent {\n    constructor(popupService) {\n        this.popupService = popupService;\n        this.operators = [];\n    }\n    open(picker) {\n        this.subscription = this.popupService.onClose\n            .pipe(filter(() => picker.isActive))\n            .subscribe(e => e.preventDefault());\n    }\n    ngOnDestroy() {\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n        }\n    }\n}\nDateFilterMenuInputComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-grid-date-filter-menu-input',\n                template: `\n        <kendo-grid-filter-menu-input-wrapper\n            [column]=\"column\"\n            [filter]=\"filter\"\n            [operators]=\"operators\"\n            [defaultOperator]=\"operator\"\n            [currentFilter]=\"currentFilter\"\n            [filterService]=\"filterService\"\n            >\n            <kendo-datepicker\n                #picker\n                kendoFilterInput\n                [filterDelay]=\"0\"\n                (open)=\"open(picker)\"\n                [value]=\"currentFilter?.value\"\n                [placeholder]=\"placeholder\"\n                [formatPlaceholder]=\"formatPlaceholder\"\n                [format]=\"format\"\n                [min]=\"min\"\n                [max]=\"max\"\n                [activeView]=\"activeView\"\n                [bottomView]=\"bottomView\"\n                [topView]=\"topView\"\n                [weekNumber]=\"weekNumber\"\n                >\n            </kendo-datepicker>\n        </kendo-grid-filter-menu-input-wrapper>\n    `\n            },] },\n];\n/** @nocollapse */\nDateFilterMenuInputComponent.ctorParameters = () => [\n    { type: SinglePopupService }\n];\nDateFilterMenuInputComponent.propDecorators = {\n    operators: [{ type: Input }],\n    column: [{ type: Input }],\n    filter: [{ type: Input }],\n    operator: [{ type: Input }],\n    currentFilter: [{ type: Input }],\n    filterService: [{ type: Input }],\n    format: [{ type: Input }],\n    formatPlaceholder: [{ type: Input }],\n    placeholder: [{ type: Input }],\n    min: [{ type: Input }],\n    max: [{ type: Input }],\n    activeView: [{ type: Input }],\n    bottomView: [{ type: Input }],\n    topView: [{ type: Input }],\n    weekNumber: [{ type: Input }]\n};\n\nconst INTERNAL_COMPONENTS$2 = [\n    FilterMenuComponent,\n    FilterMenuContainerComponent,\n    FilterMenuInputWrapperComponent,\n    StringFilterMenuInputComponent,\n    StringFilterMenuComponent,\n    FilterMenuTemplateDirective,\n    NumericFilterMenuComponent,\n    NumericFilterMenuInputComponent,\n    DateFilterMenuInputComponent,\n    DateFilterMenuComponent,\n    FilterMenuHostDirective,\n    BooleanFilterMenuComponent\n];\nconst ENTRY_COMPONENTS$1 = [\n    StringFilterMenuComponent,\n    NumericFilterMenuComponent,\n    DateFilterMenuComponent,\n    BooleanFilterMenuComponent\n];\n/**\n * @hidden\n */\nclass FilterMenuModule {\n    static exports() {\n        return [\n            StringFilterMenuComponent,\n            FilterMenuTemplateDirective,\n            NumericFilterMenuComponent,\n            DateFilterMenuComponent,\n            BooleanFilterMenuComponent,\n            SharedFilterModule.exports()\n        ];\n    }\n}\nFilterMenuModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [INTERNAL_COMPONENTS$2],\n                entryComponents: ENTRY_COMPONENTS$1,\n                exports: [INTERNAL_COMPONENTS$2, SharedFilterModule],\n                imports: [SharedFilterModule]\n            },] },\n];\n\n/**\n * @hidden\n */\nclass ColumnListComponent {\n    constructor(element, ngZone, renderer) {\n        this.element = element;\n        this.ngZone = ngZone;\n        this.renderer = renderer;\n        this.reset = new EventEmitter();\n        this.apply = new EventEmitter();\n        this.columnChange = new EventEmitter();\n        this.autoSync = true;\n        this.allowHideAll = false;\n        this.actionsClass = 'k-action-buttons';\n        this.unlockedCount = 0;\n    }\n    get className() {\n        return true;\n    }\n    set columns(value) {\n        this._columns = value.filter(column => column.includeInChooser !== false);\n        this.allColumns = value;\n        this.updateColumnState();\n    }\n    get columns() {\n        return this._columns;\n    }\n    isDisabled(column) {\n        return !(this.allowHideAll || this.hasFiltered || column.hidden || this.columns.find(current => current !== column && !current.hidden)) ||\n            (this.hasVisibleLocked && !this.hasUnlockedFiltered && this.unlockedCount === 1 && !column.locked && !column.hidden);\n    }\n    ngOnInit() {\n        if (!this.element) {\n            return;\n        }\n        this.ngZone.runOutsideAngular(() => {\n            this.domSubscriptions = this.renderer.listen(this.element.nativeElement, 'click', (e) => {\n                if (hasClasses(e.target, 'k-checkbox')) {\n                    if (this.autoSync) {\n                        const index = parseInt(e.target.getAttribute('data-index'), 10);\n                        const column = this.columns[index];\n                        const hidden = !e.target.checked;\n                        if (Boolean(column.hidden) !== hidden) {\n                            this.ngZone.run(() => {\n                                column.hidden = hidden;\n                                this.columnChange.emit([column]);\n                            });\n                        }\n                    }\n                    else {\n                        this.updateDisabled();\n                    }\n                }\n            });\n        });\n    }\n    ngOnDestroy() {\n        if (this.domSubscriptions) {\n            this.domSubscriptions();\n        }\n    }\n    cancelChanges() {\n        this.forEachCheckBox((element, index) => {\n            element.checked = !this.columns[index].hidden;\n        });\n        this.updateDisabled();\n        this.reset.emit();\n    }\n    applyChanges() {\n        const changed = [];\n        this.forEachCheckBox((element, index) => {\n            const column = this.columns[index];\n            const hidden = !element.checked;\n            if (Boolean(column.hidden) !== hidden) {\n                column.hidden = hidden;\n                changed.push(column);\n            }\n        });\n        this.updateDisabled();\n        this.apply.emit(changed);\n    }\n    forEachCheckBox(callback) {\n        const checkboxes = this.element.nativeElement.getElementsByClassName('k-checkbox');\n        const length = checkboxes.length;\n        for (let idx = 0; idx < length; idx++) {\n            callback(checkboxes[idx], idx);\n        }\n    }\n    updateDisabled() {\n        if (this.allowHideAll && !this.hasLocked) {\n            return;\n        }\n        const checkedItems = [];\n        this.forEachCheckBox((checkbox, index) => {\n            if (checkbox.checked) {\n                checkedItems.push({ checkbox, index });\n            }\n            checkbox.disabled = false;\n        });\n        if (!this.allowHideAll && checkedItems.length === 1 && !this.hasFiltered) {\n            checkedItems[0].checkbox.disabled = true;\n        }\n        else if (this.hasLocked && !this.hasUnlockedFiltered) {\n            const columns = this.columns;\n            const checkedUnlocked = checkedItems.filter(item => !columns[item.index].locked);\n            if (checkedUnlocked.length === 1) {\n                checkedUnlocked[0].checkbox.disabled = true;\n            }\n        }\n    }\n    updateColumnState() {\n        this.hasLocked = this.allColumns.filter(column => column.locked && (!column.hidden || column.includeInChooser !== false)).length > 0;\n        this.hasVisibleLocked = this.allColumns.filter(column => column.locked && !column.hidden).length > 0;\n        this.unlockedCount = this.columns.filter(column => !column.locked && !column.hidden).length;\n        const filteredColumns = this.allColumns.filter(column => column.includeInChooser === false && !column.hidden);\n        if (filteredColumns.length) {\n            this.hasFiltered = filteredColumns.length > 0;\n            this.hasUnlockedFiltered = filteredColumns.filter(column => !column.locked).length > 0;\n        }\n        else {\n            this.hasFiltered = false;\n            this.hasUnlockedFiltered = false;\n        }\n    }\n}\nColumnListComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-grid-columnlist',\n                template: `\n        <div class=\"k-column-list\">\n            <label *ngFor=\"let column of columns; let index = index;\" class='k-column-list-item'>\n                <input class=\"k-checkbox\" type=\"checkbox\" [attr.data-index]=\"index\" [checked]=\"!column.hidden\" [disabled]=\"isDisabled(column)\" /><span class=\"k-checkbox-label\">{{ column.displayTitle }}</span>\n            </label>\n        </div>\n        <div [ngClass]=\"actionsClass\" *ngIf=\"!autoSync\">\n            <button type=\"button\" class=\"k-button\" (click)=\"cancelChanges()\">{{ resetText }}</button>\n            <button type=\"button\" class=\"k-button k-primary\" (click)=\"applyChanges()\">{{ applyText }}</button>\n        </div>\n    `\n            },] },\n];\n/** @nocollapse */\nColumnListComponent.ctorParameters = () => [\n    { type: ElementRef },\n    { type: NgZone },\n    { type: Renderer2 }\n];\nColumnListComponent.propDecorators = {\n    className: [{ type: HostBinding, args: [\"class.k-column-list-wrapper\",] }],\n    reset: [{ type: Output }],\n    apply: [{ type: Output }],\n    columnChange: [{ type: Output }],\n    columns: [{ type: Input }],\n    autoSync: [{ type: Input }],\n    allowHideAll: [{ type: Input }],\n    applyText: [{ type: Input }],\n    resetText: [{ type: Input }],\n    actionsClass: [{ type: Input }]\n};\n\n/**\n * Represents the component for selecting columns in the Grid. To enable the user to show or hide columns,\n * add the component inside a [`ToolbarTemplate`]({% slug api_grid_toolbartemplatedirective %}) directive.\n *\n * @example\n * {% meta height:300 %}\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *       <kendo-grid [data]=\"data\">\n *          <ng-template kendoGridToolbarTemplate>\n *             <kendo-grid-column-chooser></kendo-grid-column-chooser>\n *          </ng-template>\n *          <kendo-grid-column field=\"Field1\"></kendo-grid-column>\n *          <kendo-grid-column field=\"Field2\" [hidden]=\"true\"></kendo-grid-column>\n *       </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }];\n * }\n *\n * ```\n * {% endmeta %}\n */\nclass ColumnChooserComponent {\n    constructor(localization, columnInfoService, popupService, ngZone, renderer, changeDetector) {\n        this.localization = localization;\n        this.columnInfoService = columnInfoService;\n        this.popupService = popupService;\n        this.ngZone = ngZone;\n        this.renderer = renderer;\n        this.changeDetector = changeDetector;\n        /**\n         * Specifies if the changes in the visibility of the column will be immediately applied.\n         */\n        this.autoSync = false;\n        /**\n         * Specifies if all columns can be hidden.\n         */\n        this.allowHideAll = true;\n    }\n    get columns() {\n        return this.columnInfoService.leafNamedColumns;\n    }\n    ngOnDestroy() {\n        this.close();\n    }\n    /**\n     * @hidden\n     */\n    toggle(anchor, template) {\n        if (!this.popupRef) {\n            const direction = this.localization.rtl ? 'right' : 'left';\n            this.popupRef = this.popupService.open({\n                anchor: anchor,\n                content: template,\n                positionMode: 'absolute',\n                anchorAlign: { vertical: 'bottom', horizontal: direction },\n                popupAlign: { vertical: 'top', horizontal: direction }\n            });\n            this.renderer.setAttribute(this.popupRef.popupElement, 'dir', this.localization.rtl ? 'rtl' : 'ltr');\n            this.ngZone.runOutsideAngular(() => this.closeClick = this.renderer.listen(\"document\", \"click\", ({ target }) => {\n                if (!closest(target, node => node === this.popupRef.popupElement || node === anchor)) {\n                    this.close();\n                }\n            }));\n        }\n        else {\n            this.close();\n        }\n    }\n    /**\n     * @hidden\n     */\n    onApply(changed) {\n        this.close();\n        if (changed.length) {\n            this.changeDetector.markForCheck();\n            this.columnInfoService.changeVisibility(changed);\n        }\n    }\n    /**\n     * @hidden\n     */\n    onChange(changed) {\n        this.changeDetector.markForCheck();\n        this.columnInfoService.changeVisibility(changed);\n    }\n    close() {\n        if (this.popupRef) {\n            this.popupRef.close();\n            this.popupRef = null;\n        }\n        this.detachClose();\n    }\n    detachClose() {\n        if (this.closeClick) {\n            this.closeClick();\n            this.closeClick = null;\n        }\n    }\n}\nColumnChooserComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-grid-column-chooser',\n                template: `\n        <button #anchor\n            type=\"button\"\n            (click)=\"toggle(anchor, template)\"\n            class=\"k-button k-bare k-button-icon\"\n            [attr.title]=\"localization.get('columns')\">\n            <span class=\"k-icon k-i-columns\"></span>\n        </button>\n        <ng-template #template>\n            <span class='k-column-chooser-title'>{{ localization.get('columns') }}</span>\n            <kendo-grid-columnlist\n                [columns]=\"columns\"\n                [applyText]=\"localization.get('columnsApply')\"\n                [resetText]=\"localization.get('columnsReset')\"\n                [autoSync]=\"autoSync\"\n                [allowHideAll]=\"allowHideAll\"\n                (apply)=\"onApply($event)\"\n                (columnChange)=\"onChange($event)\">\n            </kendo-grid-columnlist>\n        </ng-template>\n    `\n            },] },\n];\n/** @nocollapse */\nColumnChooserComponent.ctorParameters = () => [\n    { type: LocalizationService },\n    { type: ColumnInfoService },\n    { type: PopupService },\n    { type: NgZone },\n    { type: Renderer2 },\n    { type: ChangeDetectorRef }\n];\nColumnChooserComponent.propDecorators = {\n    autoSync: [{ type: Input }],\n    allowHideAll: [{ type: Input }]\n};\n\n/**\n * Represents the service that is passed to the\n * [`ColumnMenuTemplate`]({% slug api_grid_columnmenutemplatedirective %}) directive.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *       <kendo-grid [data]=\"data\" [columnMenu]=\"true\">\n *          <ng-template kendoGridColumnMenuTemplate let-service=\"service\">\n *              <span class=\"k-icon k-i-close\" (click)=\"service.close()\"\n *                  style=\"position: absolute; right: 5px; top: 5px;cursor: pointer;\"></span>\n *              <kendo-grid-columnmenu-sort [service]=\"service\">\n *              </kendo-grid-columnmenu-sort>\n *          </ng-template>\n *          <kendo-grid-column field=\"Field1\"></kendo-grid-column>\n *          <kendo-grid-column field=\"Field2\"></kendo-grid-column>\n *       </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }];\n * }\n *\n * ```\n */\nclass ColumnMenuService {\n    constructor() {\n        /**\n         * @hidden\n         */\n        this.closeMenu = new EventEmitter();\n    }\n    /**\n     * Closes the column menu.\n     */\n    close() {\n        this.closeMenu.emit();\n    }\n}\nColumnMenuService.decorators = [\n    { type: Injectable },\n];\n\n/**\n * @hidden\n */\nclass ColumnMenuItemBase {\n    constructor() {\n        this.hostClass = true;\n    }\n    ngOnInit() {\n        if (isDevMode() && !this.service) {\n            throw new Error('The service input of the predefined column menu components is mandatory.');\n        }\n    }\n    /**\n     * @hidden\n     */\n    close() {\n        this.service.close();\n    }\n}\nColumnMenuItemBase.propDecorators = {\n    service: [{ type: Input }],\n    hostClass: [{ type: HostBinding, args: ['class.k-columnmenu-item-wrapper',] }]\n};\n\n/* tslint:disable:max-line-length */\n/**\n * Represents the component for selecting columns in the Grid that can be placed\n * inside a [`ColumnMenuTemplate`]({% slug api_grid_columnmenutemplatedirective %}) directive.\n *\n * > You have to set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by\n * > the template to the service input of the `kendo-grid-columnmenu-chooser` component.\n *\n * @example\n * {% meta height:300 %}\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *       <kendo-grid [data]=\"data\" [columnMenu]=\"true\">\n *          <ng-template kendoGridColumnMenuTemplate let-service=\"service\">\n *              <kendo-grid-columnmenu-chooser [service]=\"service\">\n *              </kendo-grid-columnmenu-chooser>\n *          </ng-template>\n *          <kendo-grid-column field=\"Field1\"></kendo-grid-column>\n *          <kendo-grid-column field=\"Field2\" [hidden]=\"true\"></kendo-grid-column>\n *       </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }];\n * }\n *\n * ```\n * {% endmeta %}\n */\nclass ColumnMenuChooserComponent extends ColumnMenuItemBase {\n    constructor(localization, columnInfoService, changeDetector) {\n        super();\n        this.localization = localization;\n        this.columnInfoService = columnInfoService;\n        this.changeDetector = changeDetector;\n        /**\n         * Fires when the content is expanded.\n         */\n        this.expand = new EventEmitter();\n        /**\n         * Fires when the content is collapsed.\n         */\n        this.collapse = new EventEmitter();\n        /**\n         * Specifies if the content is expanded.\n         */\n        this.expanded = false;\n        /**\n         * @hidden\n         */\n        this.actionsClass = 'k-columnmenu-actions';\n    }\n    get columns() {\n        return this.columnInfoService.leafNamedColumns;\n    }\n    /**\n     * @hidden\n     */\n    onApply(changed) {\n        this.close();\n        if (changed.length) {\n            this.changeDetector.markForCheck();\n            this.columnInfoService.changeVisibility(changed);\n        }\n    }\n}\nColumnMenuChooserComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-grid-columnmenu-chooser',\n                template: `\n        <kendo-grid-columnmenu-item [text]=\"localization.get('columns')\"\n            icon=\"columns\" [expanded]=\"expanded\" (collapse)=\"collapse.emit()\" (expand)=\"expand.emit()\">\n            <ng-template kendoGridColumnMenuItemContentTemplate>\n                <kendo-grid-columnlist\n                    [applyText]=\"localization.get('columnsApply')\"\n                    [resetText]=\"localization.get('columnsReset')\"\n                    [columns]=\"columns\"\n                    [autoSync]=\"false\"\n                    [allowHideAll]=\"false\"\n                    [actionsClass]=\"actionsClass\"\n                    (apply)=\"onApply($event)\">\n                </kendo-grid-columnlist>\n            </ng-template>\n        </kendo-grid-columnmenu-item>\n    `\n            },] },\n];\n/** @nocollapse */\nColumnMenuChooserComponent.ctorParameters = () => [\n    { type: LocalizationService },\n    { type: ColumnInfoService },\n    { type: ChangeDetectorRef }\n];\nColumnMenuChooserComponent.propDecorators = {\n    expand: [{ type: Output }],\n    collapse: [{ type: Output }],\n    expanded: [{ type: Input }]\n};\n\n/* tslint:disable:max-line-length */\n/**\n * Represents the component for editing column filters in the Grid that can be placed\n * inside a [`ColumnMenuTemplate`]({% slug api_grid_columnmenutemplatedirective %}) directive.\n *\n * > You have to set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by\n * > the template to the service input of the `kendo-grid-columnmenu-filter` component.\n *\n * @example\n * {% meta height:400 %}\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *       <kendo-grid [kendoGridBinding]=\"data\" [columnMenu]=\"true\">\n *          <ng-template kendoGridColumnMenuTemplate let-service=\"service\">\n *              <kendo-grid-columnmenu-filter [service]=\"service\">\n *              </kendo-grid-columnmenu-filter>\n *          </ng-template>\n *          <kendo-grid-column field=\"Field1\"></kendo-grid-column>\n *          <kendo-grid-column field=\"Field2\"></kendo-grid-column>\n *       </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }];\n * }\n *\n * ```\n * {% endmeta %}\n */\nclass ColumnMenuFilterComponent extends ColumnMenuItemBase {\n    constructor(localization) {\n        super();\n        this.localization = localization;\n        /**\n         * Fires when the content is expanded.\n         */\n        this.expand = new EventEmitter();\n        /**\n         * Fires when the content is collapsed.\n         */\n        this.collapse = new EventEmitter();\n        /**\n         * Specifies if the content is expanded.\n         */\n        this.expanded = false;\n        /**\n         * @hidden\n         */\n        this.actionsClass = 'k-columnmenu-actions';\n    }\n}\nColumnMenuFilterComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-grid-columnmenu-filter',\n                template: `\n        <kendo-grid-columnmenu-item [text]=\"localization.get('filter')\" icon=\"filter\"\n            [expanded]=\"expanded\" (collapse)=\"collapse.emit()\" (expand)=\"expand.emit()\">\n            <ng-template kendoGridColumnMenuItemContentTemplate>\n                    <kendo-grid-filter-menu-container\n                        [column]=\"service.column\"\n                        [filter]=\"service.filter\"\n                        [actionsClass]=\"actionsClass\"\n                        (close)=\"close()\">\n                    </kendo-grid-filter-menu-container>\n                </ng-template>\n        </kendo-grid-columnmenu-item>\n    `\n            },] },\n];\n/** @nocollapse */\nColumnMenuFilterComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\nColumnMenuFilterComponent.propDecorators = {\n    expand: [{ type: Output }],\n    collapse: [{ type: Output }],\n    expanded: [{ type: Input }]\n};\n\n/* tslint:disable:max-line-length */\n/**\n * Represents the content template of the\n * [`kendo-grid-columnmenu-item`]({% slug api_grid_columnmenuitemcomponent %}) component.\n * Provides an option for specifying the content of a column item.\n * To define the content template, nest an `<ng-template>` tag with the\n * `kendoGridColumnMenuItemContentTemplate` directive inside a `<kendo-grid-columnmenu-item>`.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *       <kendo-grid [data]=\"data\" [columnMenu]=\"true\">\n *          <ng-template kendoGridColumnMenuTemplate>\n *              <kendo-grid-columnmenu-item text=\"Item Text\" [expanded]=\"true\">\n *                  <ng-template kendoGridColumnMenuItemContentTemplate>\n *                      Item Content\n *                  </ng-template>\n *              </kendo-grid-columnmenu-item>\n *          </ng-template>\n *          <kendo-grid-column field=\"Field1\"></kendo-grid-column>\n *          <kendo-grid-column field=\"Field2\"></kendo-grid-column>\n *       </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }];\n * }\n *\n * ```\n */\nclass ColumnMenuItemContentTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nColumnMenuItemContentTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridColumnMenuItemContentTemplate]'\n            },] },\n];\n/** @nocollapse */\nColumnMenuItemContentTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef, decorators: [{ type: Optional }] }\n];\n\n/**\n * Represents an item that can be placed inside a\n * [`ColumnMenuTemplate`]({% slug api_grid_columnmenutemplatedirective %}) directive.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *       <kendo-grid [data]=\"data\" [columnMenu]=\"true\" [resizable]=\"true\" #grid>\n *          <ng-template kendoGridColumnMenuTemplate let-service=\"service\" let-column=\"column\">\n *              <kendo-grid-columnmenu-item icon=\"arrows-resizing\" text=\"Fit column\"\n *                  (itemClick)=\"grid.autoFitColumn(column); service.close()\">\n *              </kendo-grid-columnmenu-item>\n *          </ng-template>\n *          <kendo-grid-column field=\"Field1\"></kendo-grid-column>\n *          <kendo-grid-column field=\"Field2\"></kendo-grid-column>\n *       </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }];\n * }\n *\n * ```\n */\nclass ColumnMenuItemComponent {\n    constructor() {\n        /**\n         * Fires when the item is clicked.\n         */\n        this.itemClick = new EventEmitter();\n        /**\n         * Fires when the content is expanded.\n         */\n        this.expand = new EventEmitter();\n        /**\n         * Fires when the content is collapsed.\n         */\n        this.collapse = new EventEmitter();\n        this.contentState = 'collapsed';\n    }\n    get iconClass() {\n        return `k-i-${this.icon}`;\n    }\n    ngOnChanges(changes) {\n        if (changes.expanded) {\n            this.updateContentState();\n        }\n    }\n    /**\n     * @hidden\n     */\n    onClick(e) {\n        this.itemClick.emit(e);\n        if (this.contentTemplate) {\n            this.expanded = !this.expanded;\n            this.updateContentState();\n            if (this.expanded) {\n                this.expand.emit();\n            }\n            else {\n                this.collapse.emit();\n            }\n        }\n    }\n    updateContentState() {\n        this.contentState = this.expanded ? 'expanded' : 'collapsed';\n    }\n}\nColumnMenuItemComponent.decorators = [\n    { type: Component, args: [{\n                animations: [\n                    trigger('state', [\n                        state('collapsed', style({ display: 'none' })),\n                        state('expanded', style({ display: 'block' })),\n                        transition('collapsed => expanded', [\n                            style({\n                                height: '0px',\n                                display: 'block'\n                            }),\n                            animate('100ms ease-in', style({\n                                height: '*'\n                            }))\n                        ]),\n                        transition('expanded => collapsed', [\n                            style({\n                                height: '*'\n                            }),\n                            animate('100ms ease-in', style({\n                                height: '0px'\n                            }))\n                        ])\n                    ])\n                ],\n                selector: 'kendo-grid-columnmenu-item',\n                template: `\n        <div class=\"k-columnmenu-item\" (click)=\"onClick($event)\" [class.k-state-selected]=\"selected\" [class.k-state-disabled]=\"disabled\">\n           <span *ngIf=\"icon\" class=\"k-icon\" [ngClass]=\"iconClass\">\n           </span>\n           {{ text }}\n        </div>\n        <div *ngIf=\"contentTemplate\" [@state]=\"contentState\" style=\"overflow:hidden;\" class=\"k-columnmenu-item-content\">\n            <ng-container [ngTemplateOutlet]=\"contentTemplate.templateRef\">\n            </ng-container>\n        <div>\n    `\n            },] },\n];\nColumnMenuItemComponent.propDecorators = {\n    itemClick: [{ type: Output }],\n    expand: [{ type: Output }],\n    collapse: [{ type: Output }],\n    icon: [{ type: Input }],\n    text: [{ type: Input }],\n    selected: [{ type: Input }],\n    disabled: [{ type: Input }],\n    expanded: [{ type: Input }],\n    contentTemplate: [{ type: ContentChild, args: [ColumnMenuItemContentTemplateDirective,] }]\n};\n\n/* tslint:disable:max-line-length */\n/**\n * Represents a column-menu item for sorting Grid columns that can be placed inside a\n * [`ColumnMenuTemplate`]({% slug api_grid_columnmenutemplatedirective %}) directive.\n * Allows the user to sort the column.\n *\n * > You have to set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by\n * > the template to the service input of the `kendo-grid-columnmenu-sort` component.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *       <kendo-grid [kendoGridBinding]=\"data\" [sortable]=\"true\" [columnMenu]=\"true\">\n *          <ng-template kendoGridColumnMenuTemplate let-service=\"service\">\n *              <kendo-grid-columnmenu-sort [service]=\"service\">\n *              </kendo-grid-columnmenu-sort>\n *          </ng-template>\n *          <kendo-grid-column field=\"Field1\" [width]=\"100\"></kendo-grid-column>\n *          <kendo-grid-column field=\"Field2\" [width]=\"100\"></kendo-grid-column>\n *       </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }, { Field1: 'Foo1', Field2: 'Bar1' }];\n * }\n *\n * ```\n */\nclass ColumnMenuSortComponent extends ColumnMenuItemBase {\n    constructor(localization, sortService) {\n        super();\n        this.localization = localization;\n        this.sortService = sortService;\n    }\n    get sortedAsc() {\n        const descriptor = this.descriptor;\n        return descriptor && (!descriptor.dir || descriptor.dir === 'asc');\n    }\n    get sortedDesc() {\n        const descriptor = this.descriptor;\n        return descriptor && descriptor.dir === 'desc';\n    }\n    /**\n     * @hidden\n     */\n    toggleSort(dir) {\n        const field = this.service.column.field;\n        const { mode, allowUnsort } = normalize$1(this.service.sortable);\n        const descriptor = this.descriptor;\n        const sort = mode === 'multiple' ? this.service.sort.filter(s => s.field !== field) : [];\n        if (descriptor && descriptor.dir === dir) {\n            if (!allowUnsort) {\n                return;\n            }\n        }\n        else {\n            sort.push({ field, dir });\n        }\n        this.sortService.sort(sort);\n        this.close();\n    }\n    get descriptor() {\n        return [].concat(this.service.sort || []).find(s => s.field === this.service.column.field);\n    }\n}\nColumnMenuSortComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-grid-columnmenu-sort',\n                template: `\n        <kendo-grid-columnmenu-item [text]=\"localization.get('sortAscending')\"\n            icon=\"sort-asc-sm\" (itemClick)=\"toggleSort('asc')\" [selected]=\"sortedAsc\">\n        </kendo-grid-columnmenu-item>\n        <kendo-grid-columnmenu-item [text]=\"localization.get('sortDescending')\"\n            icon=\"sort-desc-sm\" (itemClick)=\"toggleSort('desc')\" [selected]=\"sortedDesc\">\n        </kendo-grid-columnmenu-item>\n    `\n            },] },\n];\n/** @nocollapse */\nColumnMenuSortComponent.ctorParameters = () => [\n    { type: LocalizationService },\n    { type: SortService }\n];\n\nconst POPUP_CLASS = 'k-grid-columnmenu-popup';\n/**\n * Represents the [column menu]({% slug columnmenu_grid %}) component.\n */\nclass ColumnMenuComponent {\n    constructor(popupService, localization, service) {\n        this.popupService = popupService;\n        this.localization = localization;\n        this.service = service;\n        /**\n         * @hidden\n         */\n        this.standalone = true;\n        /**\n         * The settings for the Column Menu.\n         */\n        this.settings = {};\n        /**\n         * @hidden\n         */\n        this.sortable = true;\n        /**\n         * @hidden\n         */\n        this.expandedFilter = false;\n        /**\n         * @hidden\n         */\n        this.expandedColumns = false;\n        this.closeSubscription = service.closeMenu.subscribe(this.close.bind(this));\n    }\n    /**\n     * @hidden\n     */\n    get isActive() {\n        return (this.hasFilter && filtersByField(this.filter, this.column.field).length > 0) ||\n            (!this.sortable && this.hasSort && this.sort.find(descriptor => descriptor.field === this.column.field));\n    }\n    /**\n     * @hidden\n     */\n    get hasFilter() {\n        return hasFilter(this.settings, this.column);\n    }\n    /**\n     * @hidden\n     */\n    get hasSort() {\n        return hasSort(this.settings, this.column);\n    }\n    /**\n     * @hidden\n     */\n    get hasColumnChooser() {\n        return hasColumnChooser(this.settings);\n    }\n    /**\n     * @hidden\n     */\n    get hasLock() {\n        return hasLock(this.settings, this.column);\n    }\n    ngOnChanges() {\n        this.service.column = this.column;\n        this.service.sort = this.sort;\n        this.service.filter = this.filter;\n        this.service.sortable = this.sortable;\n    }\n    ngOnDestroy() {\n        this.close();\n        this.closeSubscription.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n    toggle(e, anchor, template) {\n        e.preventDefault();\n        this.expandedFilter = !this.hasColumnChooser;\n        this.expandedColumns = !this.hasFilter;\n        this.popupRef = this.popupService.open(anchor, template, this.popupRef, POPUP_CLASS);\n    }\n    /**\n     * @hidden\n     */\n    close() {\n        this.popupService.destroy();\n        this.popupRef = null;\n    }\n    /**\n     * @hidden\n     */\n    onColumnsExpand() {\n        this.expandedColumns = true;\n        this.expandedFilter = false;\n    }\n    /**\n     * @hidden\n     */\n    onFilterExpand() {\n        this.expandedFilter = true;\n        this.expandedColumns = false;\n    }\n}\nColumnMenuComponent.decorators = [\n    { type: Component, args: [{\n                providers: [ColumnMenuService],\n                selector: 'kendo-grid-column-menu',\n                template: `\n        <a #anchor\n            class=\"k-grid-column-menu k-grid-filter\"\n            [ngClass]=\"{ 'k-state-active': isActive }\"\n            (click)=\"toggle($event, anchor, template)\"\n            href=\"#\"\n            tabindex=\"-1\"\n            [attr.title]=\"localization.get('columnMenu')\">\n            <span class=\"k-icon k-i-more-vertical\"></span>\n        </a>\n        <ng-template #template>\n            <ng-container [ngTemplateOutlet]=\"column.columnMenuTemplateRef || columnMenuTemplate || defaultTemplate\"\n                          [ngTemplateOutletContext]=\"{ service: service, column: column }\">\n            </ng-container>\n        </ng-template>\n        <ng-template #defaultTemplate>\n            <kendo-grid-columnmenu-sort *ngIf=\"hasSort\" [service]=\"service\">\n            </kendo-grid-columnmenu-sort>\n            <kendo-grid-columnmenu-lock *ngIf=\"hasLock\" [service]=\"service\">\n            </kendo-grid-columnmenu-lock>\n            <kendo-grid-columnmenu-chooser *ngIf=\"hasColumnChooser\" [service]=\"service\"\n                [expanded]=\"expandedColumns\" (expand)=\"onColumnsExpand()\">\n            </kendo-grid-columnmenu-chooser>\n            <kendo-grid-columnmenu-filter *ngIf=\"hasFilter\" [service]=\"service\"\n                [expanded]=\"expandedFilter\" (expand)=\"onFilterExpand()\">\n            </kendo-grid-columnmenu-filter>\n        </ng-template>\n    `\n            },] },\n];\n/** @nocollapse */\nColumnMenuComponent.ctorParameters = () => [\n    { type: SinglePopupService },\n    { type: LocalizationService },\n    { type: ColumnMenuService }\n];\nColumnMenuComponent.propDecorators = {\n    standalone: [{ type: HostBinding, args: ['class.k-grid-column-menu-standalone',] }, { type: Input }],\n    column: [{ type: Input }],\n    settings: [{ type: Input }],\n    sort: [{ type: Input }],\n    filter: [{ type: Input }],\n    sortable: [{ type: Input }],\n    columnMenuTemplate: [{ type: Input }]\n};\n\n/* tslint:disable:max-line-length */\n/**\n * Represents a column-menu item that can be placed inside a\n * [`ColumnMenuTemplate`]({% slug api_grid_columnmenutemplatedirective %}) directive.\n * Allows the user to lock or unlock the columns.\n *\n * > You have to set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by\n * > the template to the service input of the `kendo-grid-columnmenu-lock` component.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *       <kendo-grid [data]=\"data\" [columnMenu]=\"true\">\n *          <ng-template kendoGridColumnMenuTemplate let-service=\"service\">\n *              <kendo-grid-columnmenu-lock [service]=\"service\">\n *              </kendo-grid-columnmenu-lock>\n *          </ng-template>\n *          <kendo-grid-column field=\"Field1\" [width]=\"100\"></kendo-grid-column>\n *          <kendo-grid-column field=\"Field2\" [width]=\"100\"></kendo-grid-column>\n *       </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }];\n * }\n *\n * ```\n */\nclass ColumnMenuLockComponent extends ColumnMenuItemBase {\n    constructor(localization, columnInfoService, changeDetector) {\n        super();\n        this.localization = localization;\n        this.columnInfoService = columnInfoService;\n        this.changeDetector = changeDetector;\n    }\n    get text() {\n        return this.localization.get(this.locked ? 'unlock' : 'lock');\n    }\n    get icon() {\n        return this.locked ? 'unlock' : 'lock';\n    }\n    get disabled() {\n        return !this.locked && this.columnInfoService.unlockedRootCount < 2;\n    }\n    /**\n     * @hidden\n     */\n    toggleColumn() {\n        this.toggleHierarchy(!this.locked);\n        this.close();\n        this.changeDetector.markForCheck();\n    }\n    toggleHierarchy(locked) {\n        let root = this.service.column;\n        while (root.parent) {\n            root = root.parent;\n        }\n        const columns = [root];\n        const allChanged = [];\n        while (columns.length) {\n            const column = columns.shift();\n            column.locked = locked;\n            allChanged.push(column);\n            if (column.hasChildren) {\n                columns.push(...column.childrenArray);\n            }\n        }\n        this.columnInfoService.changeLocked(allChanged);\n    }\n    get locked() {\n        return this.service.column.locked;\n    }\n}\nColumnMenuLockComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-grid-columnmenu-lock',\n                template: `\n       <kendo-grid-columnmenu-item [text]=\"text\" [icon]=\"icon\" (itemClick)=\"toggleColumn()\" [disabled]=\"disabled\">\n       </kendo-grid-columnmenu-item>\n    `\n            },] },\n];\n/** @nocollapse */\nColumnMenuLockComponent.ctorParameters = () => [\n    { type: LocalizationService },\n    { type: ColumnInfoService },\n    { type: ChangeDetectorRef }\n];\n\nconst COMPONENTS$1 = [\n    ColumnListComponent,\n    ColumnChooserComponent,\n    ColumnMenuChooserComponent,\n    ColumnMenuFilterComponent,\n    ColumnMenuItemComponent,\n    ColumnMenuItemContentTemplateDirective,\n    ColumnMenuSortComponent,\n    ColumnMenuComponent,\n    ColumnMenuLockComponent,\n    ColumnMenuTemplateDirective\n];\n/**\n * @hidden\n */\nclass ColumnMenuModule {\n    static exports() {\n        return [\n            ColumnChooserComponent,\n            ColumnMenuFilterComponent,\n            ColumnMenuItemComponent,\n            ColumnMenuItemContentTemplateDirective,\n            ColumnMenuSortComponent,\n            ColumnMenuLockComponent,\n            ColumnMenuChooserComponent,\n            ColumnMenuTemplateDirective,\n            ColumnMenuComponent\n        ];\n    }\n}\nColumnMenuModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [COMPONENTS$1],\n                imports: [CommonModule, FilterMenuModule],\n                exports: [COMPONENTS$1]\n            },] },\n];\n\nconst exportedModules$2 = [\n    HeaderComponent,\n    HeaderTemplateDirective,\n    ColumnHandleDirective,\n    SelectAllCheckboxDirective\n];\nconst importedModules$2 = [\n    CommonModule,\n    GroupModule,\n    RowFilterModule,\n    FilterMenuModule,\n    SharedModule,\n    DragAndDropModule,\n    ColumnMenuModule\n];\n/**\n * @hidden\n */\nclass HeaderModule {\n    static exports() {\n        return [\n            HeaderTemplateDirective,\n            SelectAllCheckboxDirective\n        ];\n    }\n}\nHeaderModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [exportedModules$2],\n                exports: [exportedModules$2],\n                imports: [...importedModules$2]\n            },] },\n];\n\n/**\n * Represents the command columns of the Grid. You have to define the content of the\n * column inside an `<ng-template>` tag. The template context is set to the current\n * data item. For more information and examples on using the passed fields\n * and the command directives, refer to the article on\n * [editing the Grid in Angular Reactive Forms]({% slug editing_reactive_forms_grid %}).\n *\n * The following additional fields are passed:\n * - `columnIndex`&mdash;The current column index.\n * - `rowIndex`&mdash;The current data row index. If inside a new item row, `rowIndex`is `-1`.\n * - `dataItem`&mdash;The current data item.\n * - `column`&mdash;The current column instance.\n * - `isNew`&mdash;The state of the current item.\n *\n * Usually, the template contains CRUD command directives such as:\n * - [`EditCommandDirective`]({% slug api_grid_editcommanddirective %})\n * - [`RemoveCommandDirective`]({% slug api_grid_removecommanddirective %})\n * - [`CancelCommandDirective`]({% slug api_grid_cancelcommanddirective %})\n * - [`SaveCommandDirective`]({% slug api_grid_savecommanddirective %})\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-grid [data]=\"gridData\">\n *          <kendo-grid-column field=\"ProductID\" title=\"Product ID\" width=\"120\">\n *          </kendo-grid-column>\n *          <kendo-grid-column field=\"ProductName\" title=\"Product Name\">\n *          </kendo-grid-column>\n *          <kendo-grid-column field=\"UnitPrice\" title=\"Unit Price\" width=\"230\">\n *          </kendo-grid-column>\n *          <kendo-grid-command-column title=\"command\" width=\"220\">\n *               <ng-template kendoGridCellTemplate>\n *                   <button kendoGridEditCommand class=\"k-primary\">Edit</button>\n *                   <button kendoGridRemoveCommand>Remove</button>\n *               </ng-template>\n *           </kendo-grid-command-column>\n *        </kendo-grid>\n *    `\n * })\n *\n * class AppComponent {\n *    public gridData: any[];\n *\n *    constructor() {\n *        this.gridData = products;\n *    }\n * }\n *\n * const products = [{\n *    \"ProductID\": 1,\n *    \"ProductName\": \"Chai\",\n *    \"UnitPrice\": 18.0000,\n *    \"Discontinued\": true\n *  }, {\n *    \"ProductID\": 2,\n *    \"ProductName\": \"Chang\",\n *    \"UnitPrice\": 19.0000,\n *    \"Discontinued\": false\n *  }\n * ];\n *\n * ```\n */\nclass CommandColumnComponent extends ColumnBase$1 {\n    constructor(parent) {\n        super(parent);\n        this.parent = parent;\n    }\n    get templateRef() {\n        return this.template ? this.template.templateRef : undefined;\n    }\n}\nCommandColumnComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: ColumnBase$1,\n                        useExisting: forwardRef(() => CommandColumnComponent)\n                    }\n                ],\n                selector: 'kendo-grid-command-column',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nCommandColumnComponent.ctorParameters = () => [\n    { type: ColumnBase$1, decorators: [{ type: SkipSelf }, { type: Host }, { type: Optional }] }\n];\nCommandColumnComponent.propDecorators = {\n    template: [{ type: ContentChild, args: [CellTemplateDirective,] }]\n};\n\n/**\n * Represents the checkbox for selecting columns in the Grid. If the column is\n * defined as empty, it renders a default checkbox for row selection.\n * You can also define the content of the column inside an `<ng-template>` tag.\n * The input requires you to include the `SelectionCheckbox` option.\n *\n * The template context is set to the current data item and the following additional fields are passed:\n * - `columnIndex`&mdash;The current column index.\n * - `rowIndex`&mdash;The current data row index. If inside a new item row, it will be `-1`.\n * - `dataItem`&mdash;The current data item.\n * - `column`&mdash;The current column instance.\n * - `isNew`&mdash;The state of the current item.\n *\n * For more examples, refer to:\n * - [Selecting or deselecting all items on a page]({% slug selection_grid %}#toc-select-all-feature)\n * - [Persisting the selection]({% slug selection_grid %}#toc-in-combination-with-the-select-all-feature)\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-grid [data]=\"gridData\" [selectable]=\"{enabled: true, checkboxOnly: true}\">\n *          <kendo-grid-column field=\"ProductID\" title=\"Product ID\" width=\"120\">\n *          </kendo-grid-column>\n *          <kendo-grid-column field=\"ProductName\" title=\"Product Name\">\n *          </kendo-grid-column>\n *          <kendo-grid-checkbox-column title=\"Default checkbox\">\n *          </kendo-grid-checkbox-column>\n *          <kendo-grid-checkbox-column title=\"Custom checkbox\">\n *            <ng-template kendoGridCellTemplate let-idx=\"rowIndex\">\n *              Select row <input [kendoGridSelectionCheckbox]=\"idx\" />\n *            </ng-template>\n *          </kendo-grid-checkbox-column>\n *        </kendo-grid>\n *    `\n * })\n *\n * class AppComponent {\n *    public gridData: any[];\n *\n *    constructor() {\n *        this.gridData = products;\n *    }\n * }\n *\n * const products = [{\n *    \"ProductID\": 1,\n *    \"ProductName\": \"Chai\",\n *    \"UnitPrice\": 18.0000,\n *    \"Discontinued\": true\n *  }, {\n *    \"ProductID\": 2,\n *    \"ProductName\": \"Chang\",\n *    \"UnitPrice\": 19.0000,\n *    \"Discontinued\": false\n *  }\n * ];\n *\n * ```\n */\nclass CheckboxColumnComponent extends ColumnBase$1 {\n    constructor(parent) {\n        super(parent);\n        this.parent = parent;\n        /*\n         * @hidden\n         */\n        this.isCheckboxColumn = true;\n    }\n    get templateRef() {\n        return this.template ? this.template.templateRef : undefined;\n    }\n}\nCheckboxColumnComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: ColumnBase$1,\n                        useExisting: forwardRef(() => CheckboxColumnComponent)\n                    }\n                ],\n                selector: 'kendo-grid-checkbox-column',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nCheckboxColumnComponent.ctorParameters = () => [\n    { type: ColumnBase$1, decorators: [{ type: SkipSelf }, { type: Host }, { type: Optional }] }\n];\nCheckboxColumnComponent.propDecorators = {\n    showSelectAll: [{ type: Input }],\n    template: [{ type: ContentChild, args: [CellTemplateDirective,] }]\n};\n\n/* tslint:disable:no-input-rename */\n/**\n * Represents the row-selection checkbox of the Grid. The directive expects the\n * index of the current row as an input parameter. Inside the\n * [`CheckboxColumnComponent`]({% slug api_grid_checkboxcolumncomponent %}), apply the\n * directive to an `input` element. When the user clicks the checkbox that is associated\n * with the directive, a [`selectionChange`]({% slug api_grid_gridcomponent %}#toc-selectionChange)\n * event is triggered.\n *\n * @example\n * ```html-no-run\n * <kendo-grid>\n *   <kendo-grid-checkbox-column title=\"Custom checkbox\">\n *     <ng-template kendoGridCellTemplate let-idx=\"rowIndex\">\n *       <input [kendoGridSelectionCheckbox]=\"idx\" />\n *     </ng-template>\n *   </kendo-grid-checkbox-column>\n * </kendo-grid>\n * ```\n */\nclass SelectionCheckboxDirective {\n    constructor(selectionService, el, renderer, ngZone) {\n        this.selectionService = selectionService;\n        this.el = el;\n        this.renderer = renderer;\n        this.ngZone = ngZone;\n        this.type = \"checkbox\";\n        this.ngZone.runOutsideAngular(() => {\n            this.destroyClick = this.renderer.listen(this.el.nativeElement, \"click\", this.onClick.bind(this));\n            this.destroyKeyDown = this.renderer.listen(this.el.nativeElement, \"keydown\", this.onKeyDown.bind(this));\n        });\n    }\n    ngAfterContentChecked() {\n        this.setCheckedState();\n    }\n    ngOnDestroy() {\n        if (this.destroyClick) {\n            this.destroyClick();\n        }\n        if (this.destroyKeyDown) {\n            this.destroyKeyDown();\n        }\n    }\n    onClick() {\n        if (this.selectionService.options.enabled) {\n            this.ngZone.run(() => {\n                const ev = this.selectionService.toggleByIndex(this.itemIndex);\n                ev.ctrlKey = true;\n                ev.shiftKey = false;\n                this.selectionService.changes.emit(ev);\n            });\n        }\n    }\n    onKeyDown(e) {\n        if (e.keyCode === Keys.Enter) {\n            this.onClick();\n        }\n    }\n    /*\n     * @hidden\n     */\n    setCheckedState() {\n        this.renderer.setProperty(this.el.nativeElement, \"checked\", this.selectionService.isSelected(this.itemIndex));\n    }\n}\nSelectionCheckboxDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridSelectionCheckbox]'\n            },] },\n];\n/** @nocollapse */\nSelectionCheckboxDirective.ctorParameters = () => [\n    { type: SelectionService },\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: NgZone }\n];\nSelectionCheckboxDirective.propDecorators = {\n    itemIndex: [{ type: Input, args: [\"kendoGridSelectionCheckbox\",] }],\n    type: [{ type: HostBinding, args: ['attr.type',] }]\n};\n\nconst columnCellIndex = (cell, cells) => {\n    let cellIndex = 0;\n    for (let idx = 0; idx < cells.length; idx++) {\n        if (cells[idx] === cell) {\n            return cellIndex;\n        }\n        if (!hasClasses(cells[idx], 'k-hierarchy-cell k-group-cell')) {\n            cellIndex++;\n        }\n    }\n};\n/**\n * @hidden\n */\nclass TableBodyComponent {\n    constructor(detailsService, groupsService, changeNotification, editService, localization, ngZone, renderer, element, domEvents, selectionService, columnInfoService, navigationService) {\n        this.detailsService = detailsService;\n        this.groupsService = groupsService;\n        this.changeNotification = changeNotification;\n        this.editService = editService;\n        this.localization = localization;\n        this.ngZone = ngZone;\n        this.renderer = renderer;\n        this.element = element;\n        this.domEvents = domEvents;\n        this.selectionService = selectionService;\n        this.columnInfoService = columnInfoService;\n        this.navigationService = navigationService;\n        this.columns = [];\n        this.groups = [];\n        this.skip = 0;\n        this.noRecordsText = this.localization.get('noRecords');\n        this.isLocked = false;\n        this.skipGroupDecoration = false;\n        this.showGroupFooters = false;\n        this.lockedColumnsCount = 0;\n        this.totalColumnsCount = 0;\n        this.trackBy = defaultTrackBy;\n        this.rowClass = () => null;\n        this.cellKeydownSubscription = this.navigationService.cellKeydown.subscribe((args) => this.cellKeydownHandler(args));\n        this.trackByWrapper = this.trackByWrapper.bind(this);\n        this.trackByColumns = this.trackByColumns.bind(this);\n    }\n    get newDataItem() {\n        return this.editService.newDataItem;\n    }\n    // Number of unlocked columns in the next table, if any\n    get unlockedColumnsCount() {\n        return this.totalColumnsCount - this.lockedColumnsCount - (this.allColumns || this.columns).length;\n    }\n    toggleRow(index, dataItem) {\n        this.detailsService.toggleRow(index, dataItem);\n        return false;\n    }\n    isExpanded(index) {\n        return this.detailsService.isExpanded(index);\n    }\n    detailButtonStyles(index) {\n        return this.isExpanded(index) ? 'k-minus' : 'k-plus';\n    }\n    detailButtonTitle(index) {\n        const messageKey = this.isExpanded(index) ? 'detailCollapse' : 'detailExpand';\n        return this.localization.get(messageKey);\n    }\n    isGroup(item) {\n        return item.type === 'group';\n    }\n    isDataItem(item) {\n        return !this.isGroup(item) && !this.isFooter(item);\n    }\n    isFooter(item) {\n        return item.type === 'footer';\n    }\n    isInExpandedGroup(item) {\n        return this.groupsService.isInExpandedGroup(item.groupIndex, false);\n    }\n    isParentGroupExpanded(item) {\n        return this.groupsService.isInExpandedGroup(item.index || item.groupIndex);\n    }\n    isOdd(item) {\n        return item.index % 2 !== 0;\n    }\n    isSelectable() {\n        return this.selectable && this.selectable.enabled !== false;\n    }\n    isRowSelected(item) {\n        return this.selectionService.isSelected(item.index);\n    }\n    trackByWrapper(index, item) {\n        if (item.type === 'data') {\n            item.isEditing = this.editService.hasEdited(item.index);\n        }\n        return this.trackBy(index, item);\n    }\n    trackByColumns(index, item) {\n        return this.virtualColumns ? index : item;\n    }\n    ngDoCheck() {\n        if (this.hasGroupHeaderColumn) {\n            this.groupHeaderColumns = columnsToRender(this.skipGroupDecoration ? this.columns : this.columns.toArray().slice(1));\n        }\n        else {\n            this.groupHeaderColumns = [];\n        }\n        if (this.isLocked) {\n            this.groupHeaderSlaveCellsCount =\n                this.hasGroupHeaderColumn ? this.columnsContainer.nonLockedColumnsToRender.length : 1;\n        }\n        else {\n            this.groupHeaderSlaveCellsCount = 0;\n        }\n    }\n    ngOnChanges(changes) {\n        if (isChanged(\"columns\", changes, false)) {\n            this.changeNotification.notify();\n        }\n    }\n    logicalRowIndex(rowIndex) {\n        let pos = this.skip + rowIndex;\n        if (this.hasDetailTemplate) {\n            pos *= 2;\n        }\n        const absoluteRowIndex = 1 + pos;\n        const addRowOffset = this.editService.hasNewItem ? 1 : 0;\n        const filterRowOffset = hasFilterRow(this.filterable) ? 1 : 0;\n        const headerRowCount = this.columnInfoService.totalLevels + filterRowOffset + addRowOffset;\n        return absoluteRowIndex + headerRowCount;\n    }\n    addRowLogicalIndex() {\n        return this.columnInfoService.totalLevels + 1;\n    }\n    logicalColIndex(column) {\n        if (!isPresent(column.leafIndex)) {\n            return -1;\n        }\n        return column.leafIndex + (this.hasDetailTemplate ? 1 : 0);\n    }\n    ngOnInit() {\n        this.ngZone.runOutsideAngular(() => {\n            const clickHandler = this.clickHandler.bind(this);\n            const mousedownSubscription = this.renderer.listen(this.element.nativeElement, 'mousedown', clickHandler);\n            const clickSubscription = this.renderer.listen(this.element.nativeElement, 'click', clickHandler);\n            const contextmenuSubscription = this.renderer.listen(this.element.nativeElement, 'contextmenu', clickHandler);\n            this.clickSubscription = () => {\n                mousedownSubscription();\n                clickSubscription();\n                contextmenuSubscription();\n            };\n        });\n        let originalNoRecordText = this.localization.get('noRecords');\n        this.localization.changes.subscribe(() => {\n            if (this.noRecordsText === originalNoRecordText) {\n                this.noRecordsText = this.localization.get('noRecords');\n                originalNoRecordText = this.noRecordsText;\n            }\n        });\n    }\n    ngOnDestroy() {\n        if (this.clickSubscription) {\n            this.clickSubscription();\n        }\n        this.cellKeydownSubscription.unsubscribe();\n        clearTimeout(this.clickTimeout);\n    }\n    isEditingCell(index, column) {\n        return this.editService.isEditing() && this.editService.isEditedColumn(index, column);\n    }\n    isEditingRow(index) {\n        return this.editService.isEditing() && this.editService.hasEdited(index);\n    }\n    get hasGroupHeaderColumn() {\n        return this.columnsContainer.hasGroupHeaderColumn;\n    }\n    get columnsContainer() {\n        return this.columnInfoService.columnsContainer;\n    }\n    get columnsSpan() {\n        return columnsSpan(this.columns);\n    }\n    get allColumnsSpan() {\n        return columnsSpan(this.allColumns || this.columns);\n    }\n    get colSpan() {\n        return this.columnsSpan + this.groups.length + (this.hasDetailTemplate ? 1 : 0);\n    }\n    get footerColumns() {\n        return this.isLocked ? this.columnsContainer.lockedColumnsToRender : this.columnsContainer.nonLockedColumnsToRender;\n    }\n    showGroupHeader(item) {\n        return !item.data.skipHeader;\n    }\n    get hasDetailTemplate() {\n        return isPresent(this.detailTemplate);\n    }\n    clickHandler(eventArg) {\n        const element = this.element.nativeElement;\n        const target = eventArg.target;\n        let cell, row, body, gridElement;\n        let currentTarget = target;\n        do {\n            cell = closest(currentTarget, matchesNodeName('td'));\n            row = closest(cell, matchesNodeName('tr'));\n            body = closest(row, matchesNodeName('tbody'));\n            currentTarget = body;\n            gridElement = closestInScope(currentTarget, matchesClasses('k-grid'), element);\n        } while (body && body !== element && !gridElement);\n        if (cell && !hasClasses(cell, NON_DATA_CELL_CLASSES) &&\n            !hasClasses(row, NON_DATA_ROW_CLASSES) &&\n            body === element && !gridElement) {\n            this.editService.preventCellClose();\n            const focusable = target !== cell && isFocusableWithTabKey(target, false);\n            if (!focusable && !matchesNodeName('label')(target) && !hasClasses(target, IGNORE_TARGET_CLASSSES) &&\n                !closestInScope(target, matchesClasses(IGNORE_CONTAINER_CLASSES), cell)) {\n                const args = this.cellClickArgs(cell, row, eventArg);\n                if (eventArg.type === 'mousedown') {\n                    this.domEvents.cellMousedown.emit(args);\n                }\n                else {\n                    if (args.isEditedColumn || !this.editService.closeCell(eventArg)) {\n                        if (eventArg.type === 'click') {\n                            this.clickTimeout = setTimeout(() => {\n                                this.emitCellClick(args);\n                            }, 0);\n                        }\n                        else {\n                            this.emitCellClick(args);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    emitCellClick(args) {\n        this.domEvents.cellClick.emit(Object.assign(args, {\n            isEdited: args.isEditedRow || args.isEditedColumn\n        }));\n    }\n    cellKeydownHandler(args) {\n        if (args.keyCode === Keys.Enter) {\n            this.clickHandler(args);\n        }\n    }\n    cellClickArgs(cell, row, eventArg) {\n        const index = columnCellIndex(cell, row.cells);\n        const column = this.columns.toArray()[index];\n        const columnIndex = this.lockedColumnsCount + index;\n        let rowIndex = row.getAttribute('data-kendo-grid-item-index');\n        rowIndex = rowIndex ? parseInt(rowIndex, 10) : -1;\n        const dataItem = rowIndex === -1 ? this.editService.newDataItem : this.data.at(rowIndex - this.skip);\n        const isEditedColumn = this.editService.isEditedColumn(rowIndex, column);\n        const isEditedRow = this.editService.isEdited(rowIndex);\n        const type = eventArg.type === 'keydown' ? 'click' : eventArg.type;\n        return {\n            column: column,\n            columnIndex: columnIndex,\n            dataItem: dataItem,\n            isEditedColumn: isEditedColumn,\n            isEditedRow: isEditedRow,\n            originalEvent: eventArg,\n            rowIndex: rowIndex,\n            type: type\n        };\n    }\n}\nTableBodyComponent.decorators = [\n    { type: Component, args: [{\n                selector: '[kendoGridTableBody]',\n                template: `\n    <ng-template [ngIf]=\"editService.hasNewItem\">\n        <tr class=\"k-grid-add-row k-grid-edit-row\"\n            kendoGridLogicalRow\n                [logicalRowIndex]=\"addRowLogicalIndex()\"\n                [logicalSlaveRow]=\"lockedColumnsCount > 0\"\n                [logicalCellsCount]=\"columns.length\"\n                [logicalSlaveCellsCount]=\"unlockedColumnsCount\">\n            <ng-template [ngIf]=\"!skipGroupDecoration\">\n                <td class=\"k-group-cell\" *ngFor=\"let g of groups\" role=\"presentation\"></td>\n            </ng-template>\n            <td class=\"k-hierarchy-cell\"\n                *ngIf=\"detailTemplate?.templateRef\"\n                kendoGridLogicalCell\n                    [logicalRowIndex]=\"addRowLogicalIndex()\"\n                    [logicalColIndex]=\"0\"\n                    aria-selected=\"false\"\n                >\n            </td>\n            <td *ngFor=\"let column of columns; let columnIndex = index; trackBy: trackByColumns;\"\n                kendoGridCell\n                    [rowIndex]=\"-1\"\n                    [columnIndex]=\"lockedColumnsCount + columnIndex\"\n                    [isNew]=\"true\"\n                    [column]=\"column\"\n                    [dataItem]=\"newDataItem\"\n                [ngClass]=\"column.cssClass\"\n                [ngStyle]=\"column.style\"\n                [attr.colspan]=\"column.colspan\"\n                kendoGridLogicalCell\n                    [logicalRowIndex]=\"addRowLogicalIndex()\"\n                    [logicalColIndex]=\"logicalColIndex(column)\"\n                    [colSpan]=\"column.colspan\"\n                role=\"gridcell\">\n            </td>\n        </tr>\n    </ng-template>\n    <tr *ngIf=\"data?.length === 0 || data == null\" class=\"k-grid-norecords\">\n        <td [attr.colspan]=\"colSpan\">\n            <ng-template\n                [ngIf]=\"noRecordsTemplate?.templateRef\"\n                [templateContext]=\"{\n                    templateRef: noRecordsTemplate?.templateRef\n                 }\">\n            </ng-template>\n            <ng-container *ngIf=\"!noRecordsTemplate?.templateRef\">\n                {{noRecordsText}}\n            </ng-container>\n        </td>\n    </tr>\n    <ng-template ngFor\n        [ngForOf]=\"data\"\n        [ngForTrackBy]=\"trackByWrapper\"\n        let-item\n        let-rowIndex=\"index\">\n        <tr *ngIf=\"isGroup(item) && isParentGroupExpanded(item) && showGroupHeader(item)\"\n            kendoGridGroupHeader\n                [columns]=\"columns\"\n                [groups]=\"groups\"\n                [item]=\"item\"\n                [hasDetails]=\"detailTemplate?.templateRef\"\n                [skipGroupDecoration]=\"skipGroupDecoration\"\n                [hasGroupHeaderColumn]=\"hasGroupHeaderColumn\"\n                [groupHeaderColumns]=\"groupHeaderColumns\"\n                [rowIndex]=\"rowIndex + 1\"\n                [totalColumnsCount]=\"totalColumnsCount\"\n            kendoGridLogicalRow\n                [logicalRowIndex]=\"logicalRowIndex(rowIndex)\"\n                [logicalSlaveRow]=\"lockedColumnsCount > 0\"\n                [logicalCellsCount]=\"columns.length\"\n                [logicalSlaveCellsCount]=\"groupHeaderSlaveCellsCount\">\n        </tr>\n        <tr\n            *ngIf=\"isDataItem(item) && isInExpandedGroup(item)\"\n            kendoGridLogicalRow\n                [dataRowIndex]=\"item.index\"\n                [dataItem]=\"item.data\"\n                [logicalRowIndex]=\"logicalRowIndex(rowIndex)\"\n                [logicalSlaveRow]=\"lockedColumnsCount > 0\"\n                [logicalCellsCount]=\"columns.length\"\n                [logicalSlaveCellsCount]=\"unlockedColumnsCount\"\n            [ngClass]=\"rowClass({ dataItem: item.data, index: item.index })\"\n            [class.k-alt]=\"isOdd(item)\"\n            [class.k-master-row]=\"detailTemplate?.templateRef\"\n            [class.k-grid-edit-row]=\"isEditingRow(item.index)\"\n            [attr.data-kendo-grid-item-index]=\"item.index\"\n            [class.k-state-selected]=\"isSelectable() && isRowSelected(item)\">\n            <ng-template [ngIf]=\"!skipGroupDecoration\">\n                <td class=\"k-group-cell\" *ngFor=\"let g of groups\" role=\"presentation\"></td>\n            </ng-template>\n            <td class=\"k-hierarchy-cell\"\n                *ngIf=\"detailTemplate?.templateRef\"\n                kendoGridLogicalCell\n                    [logicalRowIndex]=\"logicalRowIndex(rowIndex)\"\n                    [logicalColIndex]=\"0\"\n                    [dataRowIndex]=\"item.index\"\n                    [dataItem]=\"item.data\"\n                    [detailExpandCell]=\"true\"\n                    aria-selected=\"false\"\n                >\n                <a class=\"k-icon\"\n                    *ngIf=\"detailTemplate.showIf(item.data, item.index)\"\n                    [ngClass]=\"detailButtonStyles(item.index)\"\n                    [attr.title]=\"detailButtonTitle(item.index)\"\n                    href=\"#\" tabindex=\"-1\" (click)=\"toggleRow(item.index, item.data)\"></a>\n            </td>\n            <td\n                kendoGridCell\n                    [rowIndex]=\"item.index\"\n                    [columnIndex]=\"lockedColumnsCount + columnIndex\"\n                    [column]=\"column\"\n                    [dataItem]=\"item.data\"\n                kendoGridLogicalCell\n                    [logicalRowIndex]=\"logicalRowIndex(rowIndex)\"\n                    [logicalColIndex]=\"logicalColIndex(column)\"\n                    [dataRowIndex]=\"item.index\"\n                    [dataItem]=\"item.data\"\n                    [colIndex]=\"columnIndex\"\n                    [colSpan]=\"column.colspan\"\n                    role=\"gridcell\" aria-selected=\"false\"\n                [ngClass]=\"column.cssClass\"\n                [class.k-grid-edit-cell]=\"isEditingCell(item.index, column)\"\n                [ngStyle]=\"column.style\"\n                [attr.colspan]=\"column.colspan\"\n                *ngFor=\"let column of columns; let columnIndex = index; trackBy: trackByColumns;\">\n            </td>\n        </tr>\n        <tr *ngIf=\"isDataItem(item) && isInExpandedGroup(item) && detailTemplate?.templateRef &&\n            detailTemplate.showIf(item.data, item.index) && isExpanded(item.index)\"\n            class=\"k-detail-row\"\n            [class.k-alt]=\"isOdd(item)\"\n            kendoGridLogicalRow\n                [dataRowIndex]=\"item.index\"\n                [dataItem]=\"item.data\"\n                [logicalRowIndex]=\"logicalRowIndex(rowIndex) + 1\"\n                [logicalSlaveRow]=\"false\"\n                [logicalCellsCount]=\"1\"\n            >\n            <td class=\"k-group-cell\" *ngFor=\"let g of groups\"></td>\n            <td class=\"k-hierarchy-cell\"></td>\n            <td class=\"k-detail-cell\"\n                [attr.colspan]=\"columnsSpan\"\n                kendoGridLogicalCell\n                    [logicalRowIndex]=\"logicalRowIndex(rowIndex) + 1\"\n                    [logicalColIndex]=\"0\"\n                    [dataRowIndex]=\"item.index\"\n                    [dataItem]=\"item.data\"\n                    [colIndex]=\"0\"\n                    [colSpan]=\"allColumnsSpan + 1\"\n                    role=\"gridcell\" aria-selected=\"false\"\n                >\n                <ng-template\n                    [templateContext]=\"{\n                        templateRef: detailTemplate?.templateRef,\n                        dataItem: item.data,\n                        rowIndex: item.index,\n                        $implicit: item.data\n                        }\">\n                </ng-template>\n            </td>\n        </tr>\n        <tr *ngIf=\"isFooter(item) && (isInExpandedGroup(item) || (showGroupFooters && isParentGroupExpanded(item)))\n            && !item.data.hideFooter\"\n            class=\"k-group-footer\"\n            kendoGridLogicalRow\n                [logicalRowIndex]=\"logicalRowIndex(rowIndex)\"\n                [logicalSlaveRow]=\"lockedColumnsCount > 0\"\n                [logicalCellsCount]=\"columns.length\"\n                [logicalSlaveCellsCount]=\"unlockedColumnsCount\">\n            <ng-template [ngIf]=\"!skipGroupDecoration\">\n                <td class=\"k-group-cell\" *ngFor=\"let g of groups\"></td>\n            </ng-template>\n            <td class=\"k-hierarchy-cell\"\n                *ngIf=\"detailTemplate?.templateRef\"\n                kendoGridLogicalCell\n                    [logicalRowIndex]=\"logicalRowIndex(rowIndex)\"\n                    [logicalColIndex]=\"0\"\n                    aria-selected=\"false\"\n                >\n            </td>\n            <td kendoGridLogicalCell\n                    [logicalRowIndex]=\"logicalRowIndex(rowIndex)\"\n                    [logicalColIndex]=\"logicalColIndex(column)\"\n                [attr.data-skip]=\"skipGroupDecoration\"\n                *ngFor=\"let column of footerColumns; let columnIndex = index; trackBy: trackByColumns;\">\n                <ng-template\n                    [templateContext]=\"{\n                        templateRef: column.groupFooterTemplateRef,\n                        group: item.data,\n                        field: column.field,\n                        column: column,\n                        aggregates: item.data?.aggregates,\n                        $implicit: item.data?.aggregates\n                    }\">\n                </ng-template>\n           </td>\n        </tr>\n    </ng-template>\n    `\n            },] },\n];\n/** @nocollapse */\nTableBodyComponent.ctorParameters = () => [\n    { type: DetailsService },\n    { type: GroupsService },\n    { type: ChangeNotificationService },\n    { type: EditService },\n    { type: LocalizationService },\n    { type: NgZone },\n    { type: Renderer2 },\n    { type: ElementRef },\n    { type: DomEventsService },\n    { type: SelectionService },\n    { type: ColumnInfoService },\n    { type: NavigationService }\n];\nTableBodyComponent.propDecorators = {\n    columns: [{ type: Input }],\n    allColumns: [{ type: Input }],\n    groups: [{ type: Input }],\n    detailTemplate: [{ type: Input }],\n    noRecordsTemplate: [{ type: Input }],\n    data: [{ type: Input }],\n    skip: [{ type: Input }],\n    selectable: [{ type: Input }],\n    filterable: [{ type: Input }],\n    noRecordsText: [{ type: Input }],\n    isLocked: [{ type: Input }],\n    skipGroupDecoration: [{ type: Input }],\n    showGroupFooters: [{ type: Input }],\n    lockedColumnsCount: [{ type: Input }],\n    totalColumnsCount: [{ type: Input }],\n    virtualColumns: [{ type: Input }],\n    trackBy: [{ type: Input }],\n    rowClass: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nclass CellComponent {\n    constructor(editService, idService, cellContext) {\n        this.editService = editService;\n        this.idService = idService;\n        this.cellContext = cellContext;\n        this.isNew = false;\n        this._templateContext = {};\n        this._editTemplateContext = {};\n    }\n    get commandCellClass() {\n        return this.isCommand(this.column);\n    }\n    set rowIndex(index) {\n        this._rowIndex = index;\n        this.updateCellContext();\n    }\n    get rowIndex() {\n        return this._rowIndex;\n    }\n    get isEdited() {\n        if (!(this.editService.isEditing() || this.isNew) || !this.isColumnEditable) {\n            return false;\n        }\n        const editContext = this.editService.columnContext(this.rowIndex, this.column);\n        return this.isFieldEditable(editContext, this.column);\n    }\n    get formGroup() {\n        return this.editService.context(this.rowIndex).group;\n    }\n    get templateContext() {\n        return this._templateContext;\n    }\n    get editTemplateContext() {\n        this._editTemplateContext.$implicit = this.formGroup;\n        this._editTemplateContext.isNew = this.isNew;\n        this._editTemplateContext.column = this.column;\n        this._editTemplateContext.dataItem = this.dataItem;\n        this._editTemplateContext.formGroup = this.formGroup;\n        this._editTemplateContext.rowIndex = this.rowIndex;\n        return this._editTemplateContext;\n    }\n    get format() {\n        if (isColumnComponent(this.column) && !isNullOrEmptyString(this.column.format)) {\n            return extractFormat(this.column.format);\n        }\n        return undefined;\n    }\n    get isBoundColumn() {\n        return this.column.field && !this.column.templateRef;\n    }\n    get isCheckboxColumn() {\n        return isCheckboxColumn(this.column) && !this.column.templateRef;\n    }\n    get selectionCheckboxId() {\n        return this.idService.selectionCheckboxId(this.rowIndex);\n    }\n    get isSpanColumn() {\n        return isSpanColumn(this.column) && !this.column.templateRef;\n    }\n    get childColumns() {\n        return columnsToRender([this.column]);\n    }\n    get isColumnEditable() {\n        if (!this.column || this.isCommand(this.column)) {\n            return false;\n        }\n        return this.column.editable !== false;\n    }\n    ngDoCheck() {\n        this.updateCellContext();\n    }\n    ngOnChanges(_changes) {\n        this.updateTemplateContext();\n    }\n    isCommand(column) {\n        return column instanceof CommandColumnComponent;\n    }\n    isFieldEditable(editContext, column) {\n        if (!isPresent(editContext)) {\n            return false;\n        }\n        if (isPresent(column.editTemplate)) {\n            return true;\n        }\n        return isPresent(editContext.group) && isPresent(editContext.group.get(column.field));\n    }\n    updateCellContext() {\n        if (this.cellContext) {\n            this.cellContext.rowIndex = this._rowIndex;\n        }\n    }\n    updateTemplateContext() {\n        if (!this.column.templateRef) {\n            return;\n        }\n        const context = this._templateContext;\n        context.isNew = this.isNew;\n        context.column = this.column;\n        context.dataItem = this.dataItem;\n        context.rowIndex = this.rowIndex;\n        context.columnIndex = this.columnIndex;\n        context.$implicit = this.dataItem;\n    }\n}\nCellComponent.decorators = [\n    { type: Component, args: [{\n                selector: '[kendoGridCell]',\n                template: `\n        <ng-container [ngSwitch]=\"isEdited\">\n            <ng-container *ngSwitchCase=\"false\">\n                <ng-template [ngIf]=\"column.templateRef\"\n                    [ngTemplateOutlet]=\"column.templateRef\"\n                    [ngTemplateOutletContext]=\"templateContext\">\n                </ng-template>\n                <ng-template [ngIf]=\"isSpanColumn\">\n                    <ng-template ngFor let-childColumn [ngForOf]=\"childColumns\">\n                        {{ dataItem | valueOf: childColumn.field: childColumn.format}}\n                    </ng-template>\n                </ng-template>\n                <ng-template [ngIf]=\"isBoundColumn\">{{ dataItem | valueOf: column.field: column.format}}</ng-template>\n                <ng-template [ngIf]=\"isCheckboxColumn && !isNew\">\n                    <input class=\"k-checkbox\" [kendoGridSelectionCheckbox]=\"rowIndex\" [attr.id]=\"selectionCheckboxId\"><label class=\"k-checkbox-label\" [attr.for]=\"selectionCheckboxId\"></label>\n                </ng-template>\n            </ng-container>\n            <ng-container *ngSwitchCase=\"true\">\n                <ng-template\n                    *ngIf=\"column.editTemplateRef\"\n                    [ngTemplateOutlet]=\"column.editTemplateRef\"\n                    [ngTemplateOutletContext]=\"editTemplateContext\">\n                </ng-template>\n                <ng-container [ngSwitch]=\"column.editor\" *ngIf=\"!column.editTemplateRef\">\n                    <kendo-numerictextbox\n                        *ngSwitchCase=\"'numeric'\"\n                        [format]=\"format\"\n                        [formControl]=\"formGroup.get(column.field)\"\n                        kendoGridFocusable\n                    ></kendo-numerictextbox>\n\n                    <kendo-datepicker\n                        *ngSwitchCase=\"'date'\"\n                        [format]=\"format\"\n                        [formControl]=\"formGroup.get(column.field)\"\n                        kendoGridFocusable\n                    ></kendo-datepicker>\n\n                    <input\n                        *ngSwitchCase=\"'boolean'\"\n                        type=\"checkbox\"\n                        [formControl]=\"formGroup.get(column.field)\"\n                        kendoGridFocusable\n                    />\n\n                    <input\n                        *ngSwitchDefault\n                        type=\"text\"\n                        class=\"k-textbox\"\n                        [formControl]=\"formGroup.get(column.field)\"\n                        kendoGridFocusable\n                    />\n                </ng-container>\n            </ng-container>\n        </ng-container>\n    `\n            },] },\n];\n/** @nocollapse */\nCellComponent.ctorParameters = () => [\n    { type: EditService },\n    { type: IdService },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CELL_CONTEXT,] }] }\n];\nCellComponent.propDecorators = {\n    commandCellClass: [{ type: HostBinding, args: ['class.k-command-cell',] }],\n    column: [{ type: Input }],\n    columnIndex: [{ type: Input }],\n    isNew: [{ type: Input }],\n    rowIndex: [{ type: Input }],\n    dataItem: [{ type: Input }]\n};\n\n/**\n * Represents the `edit` command of the Grid. You can apply this directive to any `button`\n * element inside a [`CommandColumnComponent`]({% slug api_grid_commandcolumncomponent %}).\n * When an associated button with the directive is clicked, the\n * [`edit`]({% slug api_grid_gridcomponent %}#toc-edit) event\n * is triggered ([see example]({% slug editing_grid %})).\n *\n * > When the row is in the edit mode, the button with `kendoGridEditCommand` is automatically hidden.\n *\n * @example\n * ```html-no-run\n * <kendo-grid>\n *   <kendo-grid-command-column title=\"command\">\n *     <ng-template kendoGridCellTemplate>\n *       <button kendoGridEditCommand class=\"k-primary\">Edit</button>\n *     </ng-template>\n *   </kendo-grid-command-column>\n * </kendo-grid>\n * ```\n *\n */\nclass EditCommandDirective extends Button {\n    constructor(editService, cellContext, element, renderer, localization, ngZone) {\n        super(element, renderer, null, localization, ngZone);\n        this.editService = editService;\n        this.cellContext = cellContext;\n        /**\n         * @hidden\n         */\n        this.commandClass = true;\n    }\n    /**\n     * @hidden\n     */\n    get visible() {\n        return this.isEdited ? 'none' : '';\n    }\n    /**\n     * @hidden\n     */\n    onClick(e) {\n        e.preventDefault();\n        this.editService.beginEdit(this.rowIndex);\n    }\n    ngDoCheck() {\n        if (this.cellContext) {\n            this.rowIndex = this.cellContext.rowIndex;\n            this.isEdited = this.editService.isEdited(this.rowIndex);\n        }\n    }\n}\nEditCommandDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridEditCommand]'\n            },] },\n];\n/** @nocollapse */\nEditCommandDirective.ctorParameters = () => [\n    { type: EditService },\n    { type: undefined, decorators: [{ type: Inject, args: [CELL_CONTEXT,] }] },\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: LocalizationService },\n    { type: NgZone }\n];\nEditCommandDirective.propDecorators = {\n    visible: [{ type: HostBinding, args: ['style.display',] }],\n    commandClass: [{ type: HostBinding, args: ['class.k-grid-edit-command',] }],\n    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]\n};\n\n/**\n * Represents the `cancel` command of the Grid. You can apply this directive to any `button`\n * element inside a [`CommandColumnComponent`]({% slug api_grid_commandcolumncomponent %}).\n * When an associated button with the directive is clicked, the\n * [`cancel`]({% slug api_grid_gridcomponent %}#toc-cancel) event\n * is triggered ([see example]({% slug editing_grid %})).\n *\n * > When the row is not in the edit mode, the button with the `kendoGridCancelCommand` is automatically hidden.\n *\n * @example\n * ```html-no-run\n * <kendo-grid>\n *   <kendo-grid-command-column title=\"command\">\n *     <ng-template kendoGridCellTemplate>\n *       <button kendoGridCancelCommand>Cancel changes</button>\n *     </ng-template>\n *   </kendo-grid-command-column>\n * </kendo-grid>\n * ```\n *\n * You can control the content of the button based on the state of the row.\n *\n * @example\n * ```html-no-run\n * <kendo-grid>\n *   <kendo-grid-command-column title=\"command\">\n *     <ng-template kendoGridCellTemplate let-isNew=\"isNew\">\n *       <button kendoGridCancelCommand>{{isNew ? 'Discard' : 'Cancel changes'}}</button>\n *     </ng-template>\n *   </kendo-grid-command-column>\n * </kendo-grid>\n * ```\n */\nclass CancelCommandDirective extends Button {\n    constructor(editService, cellContext, element, renderer, localization, ngZone) {\n        super(element, renderer, null, localization, ngZone);\n        this.editService = editService;\n        this.cellContext = cellContext;\n        /**\n         * @hidden\n         */\n        this.commandClass = true;\n    }\n    /**\n     * @hidden\n     */\n    get visible() {\n        return !this.isEdited ? 'none' : '';\n    }\n    /**\n     * @hidden\n     */\n    onClick(e) {\n        e.preventDefault();\n        if (this.isEdited) {\n            this.editService.endEdit(this.rowIndex);\n        }\n    }\n    ngDoCheck() {\n        if (this.cellContext) {\n            this.rowIndex = this.cellContext.rowIndex;\n            this.isEdited = this.editService.isEdited(this.rowIndex);\n        }\n    }\n}\nCancelCommandDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridCancelCommand]'\n            },] },\n];\n/** @nocollapse */\nCancelCommandDirective.ctorParameters = () => [\n    { type: EditService },\n    { type: undefined, decorators: [{ type: Inject, args: [CELL_CONTEXT,] }] },\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: LocalizationService },\n    { type: NgZone }\n];\nCancelCommandDirective.propDecorators = {\n    visible: [{ type: HostBinding, args: ['style.display',] }],\n    commandClass: [{ type: HostBinding, args: ['class.k-grid-cancel-command',] }],\n    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]\n};\n\n/**\n * Represents the `save` command of the Grid. You can apply this directive to any `button`\n * element inside a [`CommandColumnComponent`]({% slug api_grid_commandcolumncomponent %}).\n * When an associated button with the directive is clicked, the\n * [`save`]({% slug api_grid_gridcomponent %}#toc-save) event\n * is triggered ([see example]({% slug editing_grid %})).\n *\n * > When the row is not in the edit mode, the button with `kendoGridSaveCommand` is automatically hidden.\n *\n * @example\n * ```html-no-run\n * <kendo-grid>\n *   <kendo-grid-command-column title=\"command\">\n *     <ng-template kendoGridCellTemplate>\n *       <button kendoGridSaveCommand>Save changes</button>\n *     </ng-template>\n *   </kendo-grid-command-column>\n * </kendo-grid>\n * ```\n *\n * You can control the content of the button based on the state of the row.\n *\n * @example\n * ```html-no-run\n * <kendo-grid>\n *   <kendo-grid-command-column title=\"command\">\n *     <ng-template kendoGridCellTemplate let-isNew=\"isNew\">\n *       <button kendoGridSaveCommand>{{isNew ? 'Add' : 'Update'}}</button>\n *     </ng-template>\n *   </kendo-grid-command-column>\n * </kendo-grid>\n * ```\n */\nclass SaveCommandDirective extends Button {\n    constructor(editService, cellContext, element, renderer, localization, ngZone) {\n        super(element, renderer, null, localization, ngZone);\n        this.editService = editService;\n        this.cellContext = cellContext;\n        /**\n         * @hidden\n         */\n        this.commandClass = true;\n    }\n    /**\n     * @hidden\n     */\n    get visible() {\n        return !this.isEdited ? 'none' : '';\n    }\n    /**\n     * @hidden\n     */\n    onClick(e) {\n        e.preventDefault();\n        if (this.isEdited) {\n            this.editService.save(this.rowIndex);\n        }\n    }\n    ngDoCheck() {\n        if (this.cellContext) {\n            this.rowIndex = this.cellContext.rowIndex;\n            this.isEdited = this.editService.isEdited(this.rowIndex);\n        }\n    }\n}\nSaveCommandDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridSaveCommand]'\n            },] },\n];\n/** @nocollapse */\nSaveCommandDirective.ctorParameters = () => [\n    { type: EditService },\n    { type: undefined, decorators: [{ type: Inject, args: [CELL_CONTEXT,] }] },\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: LocalizationService },\n    { type: NgZone }\n];\nSaveCommandDirective.propDecorators = {\n    visible: [{ type: HostBinding, args: ['style.display',] }],\n    commandClass: [{ type: HostBinding, args: ['class.k-grid-save-command',] }],\n    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]\n};\n\n/**\n * Represents the `remove` command of the Grid. You can apply this directive to any `button` element\n * inside a [`CommandColumnComponent`]({% slug api_grid_commandcolumncomponent %}).\n * When an associated button with the directive is clicked, the\n * [`remove` event]({% slug api_grid_gridcomponent %}#toc-remove)\n * is triggered ([see example]({% slug editing_reactive_forms_grid %})).\n *\n * > When the row is in the edit mode, the button with the `kendoGridRemoveCommand` is automatically hidden.\n *\n * @example\n * ```html-no-run\n * <kendo-grid>\n *   <kendo-grid-command-column title=\"command\">\n *     <ng-template kendoGridCellTemplate>\n *       <button kendoGridRemoveCommand>Remove row</button>\n *     </ng-template>\n *   </kendo-grid-command-column>\n * </kendo-grid>\n * ```\n */\nclass RemoveCommandDirective extends Button {\n    constructor(editService, cellContext, element, renderer, localization, ngZone) {\n        super(element, renderer, null, localization, ngZone);\n        this.editService = editService;\n        this.cellContext = cellContext;\n        /**\n         * @hidden\n         */\n        this.commandClass = true;\n    }\n    /**\n     * @hidden\n     */\n    get visible() {\n        return this.isEdited ? 'none' : '';\n    }\n    /**\n     * @hidden\n     */\n    onClick(e) {\n        e.preventDefault();\n        this.editService.remove(this.rowIndex);\n    }\n    ngDoCheck() {\n        if (this.cellContext) {\n            this.rowIndex = this.cellContext.rowIndex;\n            this.isEdited = this.editService.isEdited(this.rowIndex);\n        }\n    }\n}\nRemoveCommandDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridRemoveCommand]'\n            },] },\n];\n/** @nocollapse */\nRemoveCommandDirective.ctorParameters = () => [\n    { type: EditService },\n    { type: undefined, decorators: [{ type: Inject, args: [CELL_CONTEXT,] }] },\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: LocalizationService },\n    { type: NgZone }\n];\nRemoveCommandDirective.propDecorators = {\n    visible: [{ type: HostBinding, args: ['style.display',] }],\n    commandClass: [{ type: HostBinding, args: ['class.k-grid-remove-command',] }],\n    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]\n};\n\n/**\n * Represents the command for adding a new item to the Grid. You can apply this directive to any\n * `button` element inside a [`ToolbarTemplate`]({% slug api_grid_commandcolumncomponent %}).\n * When an associated button with the directive is clicked, the\n * [`add`]({% slug api_grid_gridcomponent %}#toc-add) event is triggered\n * ([see example]({% slug editing_grid %})).\n *\n * @example\n * ```html-no-run\n * <kendo-grid>\n *    <ng-template kendoGridToolbarTemplate>\n *       <button kendoGridAddCommand>Add new</button>\n *    </ng-template>\n * </kendo-grid>\n * ```\n */\nclass AddCommandDirective extends Button {\n    constructor(editService, element, renderer, localization, ngZone) {\n        super(element, renderer, null, localization, ngZone);\n        this.editService = editService;\n    }\n    /**\n     * @hidden\n     */\n    onClick(e) {\n        e.preventDefault();\n        this.editService.beginAdd();\n    }\n    /**\n     * @hidden\n     */\n    get commandClass() {\n        return true;\n    }\n}\nAddCommandDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridAddCommand]'\n            },] },\n];\n/** @nocollapse */\nAddCommandDirective.ctorParameters = () => [\n    { type: EditService },\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: LocalizationService },\n    { type: NgZone }\n];\nAddCommandDirective.propDecorators = {\n    onClick: [{ type: HostListener, args: ['click', ['$event'],] }],\n    commandClass: [{ type: HostBinding, args: ['class.k-grid-add-command',] }]\n};\n\nconst exported$1 = [\n    CommandColumnComponent,\n    CheckboxColumnComponent,\n    SelectionCheckboxDirective,\n    CellTemplateDirective,\n    EditTemplateDirective,\n    TableBodyComponent,\n    NoRecordsTemplateDirective,\n    CellComponent,\n    EditCommandDirective,\n    CancelCommandDirective,\n    SaveCommandDirective,\n    RemoveCommandDirective,\n    AddCommandDirective\n];\nconst importedModules$3 = [\n    CommonModule,\n    ReactiveFormsModule,\n    FormsModule,\n    SharedModule,\n    GroupModule,\n    NumericTextBoxModule,\n    DatePickerModule\n];\n/**\n * @hidden\n */\nclass BodyModule {\n    static exports() {\n        return [\n            CommandColumnComponent,\n            CheckboxColumnComponent,\n            SelectionCheckboxDirective,\n            CellTemplateDirective,\n            NoRecordsTemplateDirective,\n            EditTemplateDirective,\n            EditCommandDirective,\n            CancelCommandDirective,\n            SaveCommandDirective,\n            RemoveCommandDirective,\n            AddCommandDirective\n        ];\n    }\n}\nBodyModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [exported$1],\n                exports: [exported$1],\n                imports: [...importedModules$3]\n            },] },\n];\n\n/**\n * @hidden\n */\nclass FooterComponent {\n    constructor() {\n        this.columns = [];\n        this.groups = [];\n        this.lockedColumnsCount = 0;\n    }\n    get footerClass() {\n        return !this.scrollable;\n    }\n    get columnsToRender() {\n        return columnsToRender(this.columns || []);\n    }\n}\nFooterComponent.decorators = [\n    { type: Component, args: [{\n                selector: '[kendoGridFooter]',\n                template: `\n    <ng-template [ngIf]=\"true\">\n        <tr [class.k-footer-template]=\"true\">\n            <td\n                [class.k-group-cell]=\"true\"\n                *ngFor=\"let g of groups\">\n            </td>\n            <td\n                [class.k-hierarchy-cell]=\"true\"\n                *ngIf=\"detailTemplate?.templateRef\">\n            </td>\n            <td\n                [ngClass]=\"column.footerClass\"\n                [ngStyle]=\"column.footerStyle\"\n                *ngFor=\"let column of columnsToRender; let columnIndex = index\">\n                <ng-template\n                    [templateContext]=\"{\n                        templateRef: column.footerTemplateRef,\n                        columnIndex: lockedColumnsCount + columnIndex,\n                        column: column,\n                        $implicit: column\n                    }\">\n                </ng-template>\n            </td>\n        </tr>\n    </ng-template>\n    `\n            },] },\n];\nFooterComponent.propDecorators = {\n    columns: [{ type: Input }],\n    groups: [{ type: Input }],\n    detailTemplate: [{ type: Input }],\n    scrollable: [{ type: Input }],\n    lockedColumnsCount: [{ type: Input }],\n    footerClass: [{ type: HostBinding, args: ['class.k-grid-footer',] }]\n};\n\nconst exportedModules$3 = [\n    FooterComponent\n];\nconst importedModules$4 = [\n    CommonModule,\n    SharedModule\n];\n/**\n * @hidden\n */\nclass FooterModule {\n    static exports() {\n        return [];\n    }\n}\nFooterModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [exportedModules$3],\n                exports: [exportedModules$3],\n                imports: [...importedModules$4]\n            },] },\n];\n\n/**\n * @hidden\n */\nclass ToolbarComponent {\n    constructor(grid) {\n        this.grid = grid;\n        this.context = {};\n    }\n    get classNames() {\n        return 'k-header k-grid-toolbar';\n    }\n    set position(value) {\n        this.context.position = value;\n    }\n    get toolbarTemplateRef() {\n        return this.grid.toolbarTemplate ? this.grid.toolbarTemplate.templateRef : undefined;\n    }\n}\nToolbarComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-grid-toolbar',\n                template: `\n        <ng-template\n            *ngIf=\"toolbarTemplateRef\"\n            [ngTemplateOutlet]=\"toolbarTemplateRef\"\n            [ngTemplateOutletContext]=\"context\"\n            >\n        </ng-template>\n    `\n            },] },\n];\n/** @nocollapse */\nToolbarComponent.ctorParameters = () => [\n    { type: GridComponent }\n];\nToolbarComponent.propDecorators = {\n    classNames: [{ type: HostBinding, args: ['class',] }],\n    position: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nclass LocalEditService {\n    constructor(grid, localDataChangesService) {\n        this.grid = grid;\n        this.localDataChangesService = localDataChangesService;\n    }\n    create(item) {\n        if (this.hasLocalData && this.grid.skip) {\n            this.localDataChangesService.data.splice(this.grid.skip, 0, item);\n        }\n        else {\n            this.data.unshift(item);\n        }\n        this.dataChanged();\n    }\n    update(_item) { } // tslint:disable-line:no-empty\n    remove(item) {\n        const data = this.data;\n        for (let idx = 0; idx < data.length; idx++) {\n            if (item === data[idx]) {\n                data.splice(idx, 1);\n                this.dataChanged({ action: 'remove', item: item });\n                break;\n            }\n        }\n    }\n    assignValues(target, source) {\n        Object.assign(target, source);\n    }\n    dataChanged(args = {}) {\n        if (this.hasLocalData) {\n            this.localDataChangesService.changes.emit(args);\n        }\n    }\n    get hasLocalData() {\n        return Array.isArray(this.localDataChangesService.data);\n    }\n    get data() {\n        if (this.hasLocalData) {\n            return this.localDataChangesService.data;\n        }\n        const data = this.grid.data;\n        if (Array.isArray(data)) {\n            return data;\n        }\n        if (isDevMode()) {\n            throw new Error('The default edit service of the editing directives works only when binding to plain array.' +\n                'Please provide an editService.');\n        }\n        return [];\n    }\n}\n\n/**\n * @hidden\n */\nclass EditingDirectiveBase {\n    constructor(grid, localDataChangesService) {\n        this.grid = grid;\n        this.localDataChangesService = localDataChangesService;\n        this.defaultEditService = this.createDefaultService();\n    }\n    // Consider adding support for the dependency injection of the service to allow for specifying a generic service without code.\n    // The Input should still be kept.\n    /**\n     * The edit service that will handle the operations.\n     */\n    set editService(value) {\n        this.userEditService = value;\n    }\n    get editService() {\n        return this.userEditService || this.defaultEditService;\n    }\n    /**\n     * @hidden\n     */\n    ngOnInit() {\n        this.subscriptions = this.grid.add.subscribe(this.addHandler.bind(this));\n        this.subscriptions.add(this.grid.remove.subscribe(this.removeHandler.bind(this)));\n        this.subscriptions.add(this.grid.cancel.subscribe(this.cancelHandler.bind(this)));\n        this.subscriptions.add(this.grid.save.subscribe(this.saveHandler.bind(this)));\n        this.subscriptions.add(this.grid.dataStateChange.subscribe(this.onStateChange.bind(this)));\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n        this.subscriptions.unsubscribe();\n    }\n    createDefaultService() {\n        return new LocalEditService(this.grid, this.localDataChangesService);\n    }\n    addHandler() {\n        this.grid.addRow(this.createModel({ isNew: true }));\n    }\n    saveHandler(args) {\n        const item = this.saveModel(args);\n        if (item) {\n            if (args.isNew) {\n                this.editService.create(item);\n            }\n            else {\n                this.editService.update(item);\n            }\n        }\n        this.grid.closeRow(args.rowIndex);\n    }\n    cancelHandler({ rowIndex }) {\n        this.closeEditor(rowIndex);\n    }\n    removeHandler({ dataItem }) {\n        const removeItem = (shouldRemove) => {\n            if (shouldRemove) {\n                this.editService.remove(dataItem);\n            }\n        };\n        if (this.removeConfirmation) {\n            const result = this.removeConfirmation(dataItem);\n            if (result instanceof Promise) {\n                result.then(removeItem);\n            }\n            else if (result instanceof Observable) {\n                result.pipe(take(1)).subscribe(removeItem);\n            }\n            else {\n                removeItem(result);\n            }\n        }\n        else {\n            removeItem(true);\n        }\n    }\n    onStateChange() {\n        this.closeEditor();\n    }\n    closeEditor(rowIndex) {\n        this.grid.closeRow(rowIndex);\n    }\n}\nEditingDirectiveBase.propDecorators = {\n    editService: [{ type: Input }],\n    removeConfirmation: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nclass LocalRowEditService extends LocalEditService {\n    update(_item) {\n        this.dataChanged();\n    }\n}\n\n/**\n * @hidden\n */\nclass RowEditingDirectiveBase extends EditingDirectiveBase {\n    /**\n     * @hidden\n     */\n    ngOnInit() {\n        super.ngOnInit();\n        this.subscriptions\n            .add(this.grid.edit.subscribe(this.editHandler.bind(this)));\n    }\n    createDefaultService() {\n        return new LocalRowEditService(this.grid, this.localDataChangesService);\n    }\n    addHandler() {\n        this.closeEditor();\n        super.addHandler();\n    }\n    editHandler(args) {\n        this.closeEditor();\n        this.rowIndex = args.rowIndex;\n        this.grid.editRow(args.rowIndex, this.createModel(args));\n    }\n    saveHandler(args) {\n        super.saveHandler(args);\n        this.clean();\n    }\n    closeEditor(rowIndex = this.rowIndex) {\n        super.closeEditor(rowIndex);\n        this.clean();\n    }\n    clean() {\n        delete this.rowIndex;\n    }\n}\n\n/**\n * A directive which encapsulates the editing operations of the Grid when using\n * the Template-Driven Angular Forms ([see example]({% slug editing_directives_grid %}#toc-the-template-directive)).\n */\nclass TemplateEditingDirective extends RowEditingDirectiveBase {\n    constructor(grid, localDataChangesService) {\n        super(grid, localDataChangesService);\n        this.grid = grid;\n        this.localDataChangesService = localDataChangesService;\n    }\n    editHandler(args) {\n        super.editHandler(args);\n        this.dataItem = args.dataItem;\n        this.originalValues = {};\n        this.editService.assignValues(this.originalValues, this.dataItem);\n    }\n    closeEditor(rowIndex) {\n        if (this.dataItem) {\n            this.editService.assignValues(this.dataItem, this.originalValues);\n        }\n        super.closeEditor(rowIndex);\n    }\n    createModel(args) {\n        if (args.isNew) {\n            return this.createNewItem();\n        }\n    }\n    saveModel(args) {\n        return args.dataItem;\n    }\n    clean() {\n        super.clean();\n        delete this.dataItem;\n    }\n}\nTemplateEditingDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridTemplateEditing]'\n            },] },\n];\n/** @nocollapse */\nTemplateEditingDirective.ctorParameters = () => [\n    { type: GridComponent },\n    { type: LocalDataChangesService }\n];\nTemplateEditingDirective.propDecorators = {\n    createNewItem: [{ type: Input, args: ['kendoGridTemplateEditing',] }]\n};\n\n/**\n * @hidden\n */\nconst markAllAsTouched = (control) => {\n    control.markAsTouched();\n    if (control.hasOwnProperty('controls')) {\n        let controls = control.controls;\n        for (let inner in controls) {\n            if (controls.hasOwnProperty(inner)) {\n                markAllAsTouched(controls[inner]);\n            }\n        }\n    }\n};\n\n/**\n * A directive which encapsulates the editing operations of the Grid when using the\n * Reactive Forms ([see example]({% slug editing_directives_grid %}#toc-the-reactive-directive)).\n */\nclass ReactiveEditingDirective extends RowEditingDirectiveBase {\n    constructor(grid, localDataChangesService) {\n        super(grid, localDataChangesService);\n        this.grid = grid;\n        this.localDataChangesService = localDataChangesService;\n    }\n    createModel(args) {\n        return this.createFormGroup(args);\n    }\n    saveModel({ dataItem, formGroup, isNew }) {\n        if (!formGroup.dirty && !isNew) {\n            return;\n        }\n        if (formGroup.valid) {\n            this.editService.assignValues(dataItem, formGroup.value);\n            return dataItem;\n        }\n        markAllAsTouched(formGroup);\n    }\n}\nReactiveEditingDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridReactiveEditing]'\n            },] },\n];\n/** @nocollapse */\nReactiveEditingDirective.ctorParameters = () => [\n    { type: GridComponent },\n    { type: LocalDataChangesService }\n];\nReactiveEditingDirective.propDecorators = {\n    createFormGroup: [{ type: Input, args: ['kendoGridReactiveEditing',] }]\n};\n\n/**\n * A directive which encapsulates the editing operations of the Grid when using the in-cell\n * editing with Reactive Forms ([see example]({% slug editing_directives_grid %}#toc-the-incell-directive)).\n */\nclass InCellEditingDirective extends EditingDirectiveBase {\n    constructor(grid, localDataChangesService) {\n        super(grid, localDataChangesService);\n        this.grid = grid;\n        this.localDataChangesService = localDataChangesService;\n    }\n    // Need mixin\n    createModel(args) {\n        return this.createFormGroup(args);\n    }\n    saveModel({ dataItem, formGroup, isNew }) {\n        if (!formGroup.dirty && !isNew) {\n            return;\n        }\n        if (formGroup.valid) {\n            this.editService.assignValues(dataItem, formGroup.value);\n            return dataItem;\n        }\n        markAllAsTouched(formGroup);\n    }\n    /**\n     * @hidden\n     */\n    ngOnInit() {\n        super.ngOnInit();\n        this.subscriptions.add(this.grid.cellClick.subscribe(this.cellClickHandler.bind(this)));\n        this.subscriptions.add(this.grid.cellClose.subscribe(this.cellCloseHandler.bind(this)));\n    }\n    removeHandler(args) {\n        super.removeHandler(args);\n        this.grid.cancelCell();\n    }\n    cellClickHandler(args) {\n        if (!args.isEdited && args.type !== 'contextmenu') {\n            this.grid.editCell(args.rowIndex, args.columnIndex, this.createFormGroup(args));\n        }\n    }\n    cellCloseHandler(args) {\n        const { formGroup, dataItem } = args;\n        if (!formGroup.valid) {\n            args.preventDefault();\n        }\n        else if (formGroup.dirty) {\n            this.editService.assignValues(dataItem, formGroup.value);\n            this.editService.update(dataItem);\n        }\n    }\n}\nInCellEditingDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridInCellEditing]'\n            },] },\n];\n/** @nocollapse */\nInCellEditingDirective.ctorParameters = () => [\n    { type: GridComponent },\n    { type: LocalDataChangesService }\n];\nInCellEditingDirective.propDecorators = {\n    createFormGroup: [{ type: Input, args: ['kendoGridInCellEditing',] }]\n};\n\nconst hasGroups = (items) => items && items.length && items[0].field && items[0].items;\nconst processGroups = (data, state$$1) => process(data, state$$1).data;\nconst removeParentDescriptors = (parents, owner) => g => g.field !== owner.field && !parents.some(y => y.field === g.field);\nconst findGroup = (groupIndex, groups) => {\n    const parents = [];\n    return {\n        group: groupIndex.split(\"_\").reduce((acc, x) => {\n            const idx = parseInt(x, 10);\n            if (acc.items) {\n                parents.push(acc);\n                return acc.items[idx];\n            }\n            return isArray(acc) ? acc[idx] : acc;\n        }, groups),\n        parents\n    };\n};\nconst findChildren = (data, parents) => {\n    const filters = parents.map(p => ({ field: p.field, operator: \"eq\", value: p.value }));\n    return filterBy(data, {\n        filters: filters,\n        logic: \"and\"\n    });\n};\n/**\n * @hidden\n */\nconst count = (groups, includeFooters = false) => (groups.reduce((acc, group) => {\n    if (!group.skipHeader) {\n        acc++;\n    }\n    if (group.items) {\n        const children = count(group.items, includeFooters);\n        if (includeFooters && children && !group.hideFooter) {\n            acc++;\n        }\n        acc += children;\n    }\n    return acc;\n}, 0) // tslint:disable-line:align\n);\n/**\n * @hidden\n */\nconst slice = (groups, skip, take$$1, includeFooters = false) => {\n    if (!isPresent(take$$1)) {\n        return groups;\n    }\n    const result = [];\n    for (let idx = 0, length = groups.length; idx < length; idx++) {\n        if (take$$1 <= 0) {\n            break;\n        }\n        const group = groups[idx];\n        const groupItems = group.items;\n        let itemCount = count(groupItems, includeFooters);\n        if (includeFooters && groupItems.length) {\n            itemCount++;\n        }\n        const skipHeader = skip > 0;\n        if (skip) {\n            skip--;\n            if (itemCount && skip >= itemCount) {\n                skip -= itemCount;\n                continue;\n            }\n        }\n        if (!skipHeader || itemCount) {\n            const items = [];\n            let hideFooter = true;\n            if (!skipHeader) {\n                take$$1--;\n            }\n            if (take$$1) {\n                if (hasGroups(groupItems)) {\n                    const children = slice(groupItems, skip, take$$1, includeFooters);\n                    items.push(...children);\n                    take$$1 -= count(children, includeFooters);\n                }\n                else {\n                    items.push(...groupItems.slice(skip, Math.min(skip + take$$1, groupItems.length)));\n                    take$$1 -= items.length;\n                }\n                if (take$$1 && includeFooters) {\n                    hideFooter = false;\n                    take$$1--;\n                }\n                skip = 0;\n            }\n            result.push({\n                aggregates: group.aggregates,\n                field: group.field,\n                hideFooter,\n                items,\n                offset: idx,\n                skipHeader,\n                value: group.value\n            });\n        }\n    }\n    return result;\n};\nconst skippedHeaders = (groupItem) => {\n    let total = 0;\n    while (groupItem) {\n        if (groupItem.skipHeader) {\n            total++;\n        }\n        groupItem = groupItem.items && groupItem.items[0] || null;\n    }\n    return total;\n};\n/**\n * A directive which encapsulates the in-memory handling of grouping with virtual scrolling.\n */\nclass GroupBindingDirective extends DataBindingDirective {\n    constructor(grid, changeDetector, localDataChangesService) {\n        super(grid, changeDetector, localDataChangesService);\n    }\n    /**\n     * The array of data which will be used to populate the Grid.\n     */\n    set kendoGridGroupBinding(value) {\n        this.groups = null;\n        this.grid.resetGroupsState();\n        this.data = value;\n    }\n    /**\n     * @hidden\n     */\n    set data(value) {\n        this.originalData = value || [];\n        this.dataChanged = true;\n    }\n    /**\n     * Defines the descriptors by which the data will be sorted.\n     */\n    set sort(value) {\n        const clear = this.state.sort !== value;\n        this.grid.sort = this.state.sort = value;\n        if (clear) {\n            this.groups = null;\n            this.grid.resetGroupsState();\n        }\n    }\n    /**\n     * Defines the descriptor by which the data will be filtered.\n     */\n    set filter(value) {\n        const clear = diffFilters(this.state.filter, value);\n        if (clear) {\n            this.state.filter = value;\n            this.grid.filter = cloneFilters(value);\n            this.groups = null;\n            this.grid.resetGroupsState();\n        }\n    }\n    /**\n     * Defines the descriptors by which the data will be grouped.\n     */\n    set group(value) {\n        const clear = this.state.group !== value;\n        this.grid.group = this.state.group = value;\n        if (clear) {\n            this.groups = null;\n            this.grid.resetGroupsState();\n            this.skip = 0;\n        }\n    }\n    /**\n     * @hidden\n     */\n    ngOnInit() {\n        super.ngOnInit();\n        this.grid.groupExpand.subscribe(this.groupExpand.bind(this));\n        this.grid.groupCollapse.subscribe(this.groupCollapse.bind(this));\n    }\n    groupExpand({ groupIndex }) {\n        this.grid.expandGroupChildren(groupIndex);\n        const { group, parents } = findGroup(groupIndex, this.groups);\n        if (!group.items.length) {\n            const descriptors = this.state.group.filter(removeParentDescriptors(parents, group));\n            const children = findChildren(this.originalData, parents.concat(group));\n            group.items = processGroups(children, {\n                filter: this.state.filter,\n                group: descriptors,\n                sort: this.state.sort\n            });\n        }\n        this.grid.data = this.dataResult(this.state.skip, this.state.take);\n    }\n    groupCollapse({ groupIndex }) {\n        const { group } = findGroup(groupIndex, this.groups);\n        if (group) {\n            group.items = [];\n        }\n        this.grid.data = this.dataResult(this.state.skip, this.state.take);\n    }\n    process(state$$1) {\n        if (state$$1.group && state$$1.group.length) {\n            const groups = this.processGroups(state$$1);\n            this.grid.skip -= skippedHeaders(groups.data[0]);\n            return groups;\n        }\n        else {\n            this.groups = null;\n        }\n        return super.process(state$$1);\n    }\n    processGroups(state$$1) {\n        if (!this.groups || !this.groups.length) {\n            this.groups = processGroups(this.originalData, {\n                filter: state$$1.filter,\n                group: state$$1.group,\n                sort: state$$1.sort\n            });\n        }\n        return this.dataResult(state$$1.skip, state$$1.take);\n    }\n    dataResult(skip, take$$1) {\n        const includeFooters = this.grid.showGroupFooters;\n        return {\n            data: slice(this.groups, skip, take$$1, includeFooters),\n            total: count(this.groups, includeFooters)\n        };\n    }\n    applyState({ skip, take: take$$1, sort, group, filter: filter$$1 }) {\n        this.skip = skip;\n        this.state.take = take$$1;\n        // this.pageSize = take; // do need to update take as the process with slice correctly\n        this.sort = sort;\n        this.group = group;\n        this.filter = filter$$1;\n    }\n}\nGroupBindingDirective.decorators = [\n    { type: Directive, args: [{ selector: '[kendoGridGroupBinding]' },] },\n];\n/** @nocollapse */\nGroupBindingDirective.ctorParameters = () => [\n    { type: GridComponent },\n    { type: ChangeDetectorRef },\n    { type: LocalDataChangesService }\n];\nGroupBindingDirective.propDecorators = {\n    kendoGridGroupBinding: [{ type: Input, args: [\"kendoGridGroupBinding\",] }],\n    sort: [{ type: Input }],\n    filter: [{ type: Input }],\n    group: [{ type: Input }]\n};\n\nconst exportedModules$4 = [\n    GridComponent,\n    ToolbarTemplateDirective,\n    ToolbarComponent,\n    DataBindingDirective,\n    SelectionDirective,\n    CustomMessagesComponent,\n    GroupBindingDirective,\n    TemplateEditingDirective,\n    ReactiveEditingDirective,\n    InCellEditingDirective,\n    ...GroupModule.exports(),\n    ...SharedModule.exports(),\n    ...BodyModule.exports(),\n    ...HeaderModule.exports(),\n    ...FooterModule.exports(),\n    ...PagerModule.exports(),\n    ...RowFilterModule.exports(),\n    ...FilterMenuModule.exports(),\n    ...ColumnMenuModule.exports()\n];\nconst declarations = [\n    GridComponent,\n    ListComponent,\n    ToolbarComponent,\n    LocalizedMessagesDirective,\n    CustomMessagesComponent,\n    DataBindingDirective,\n    ToolbarTemplateDirective,\n    SelectionDirective,\n    TemplateEditingDirective,\n    ReactiveEditingDirective,\n    InCellEditingDirective,\n    GroupBindingDirective\n];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Grid component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Grid module\n * import { GridModule } from '@progress/kendo-angular-grid';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, GridModule], // import Grid module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nclass GridModule {\n}\nGridModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [declarations],\n                exports: [exportedModules$4],\n                imports: [\n                    CommonModule,\n                    GroupModule,\n                    SharedModule,\n                    BodyModule,\n                    HeaderModule,\n                    FooterModule,\n                    PagerModule,\n                    RowFilterModule,\n                    FilterMenuModule,\n                    ResizeSensorModule,\n                    ColumnMenuModule\n                ]\n            },] },\n];\n\nclass PDFMarginComponent$1 extends PDFMarginComponent {\n}\nPDFMarginComponent$1.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-grid-pdf-margin',\n                template: ''\n            },] },\n];\n\n/**\n * Represents the PDF page template of the Grid that helps to customize the PDF pages. To define a page template,\n * nest an `<ng-template>` tag with the `kendoGridPDFTemplate` directive inside `<kendo-grid-pdf>`.\n *\n * The template context provides the following fields:\n * - `pageNumber`&mdash;Defines PDF page number.\n * - `totalPages`&mdash;Defines the total number of PDF pages.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *         <kendo-grid [data]=\"gridData\">\n *             <ng-template kendoGridToolbarTemplate>\n *                 <button kendoGridPDFCommand icon=\"file-pdf\">Export to PDF</button>\n *             </ng-template>\n *             <kendo-grid-column field=\"ProductName\">\n *             </kendo-grid-column>\n *              <kendo-grid-column field=\"UnitPrice\">\n *             </kendo-grid-column>\n *             <kendo-grid-pdf fileName=\"Products.pdf\" paperSize=\"A4\" [margin]=\"{ top: '1cm', left: '1cm', right: '1cm', bottom: '1cm' }\">\n *                 <ng-template kendoGridPDFTemplate let-pageNum=\"pageNum\" let-totalPages=\"totalPages\">\n *                     <div style=\"position: absolute;top: 5px; left: 5px;\">\n *                         Page {{ pageNum }} of {{ totalPages }}\n *                     </div>\n *                 </ng-template>\n *             </kendo-grid-pdf>\n *         </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *     public gridData = [{\n *         \"ProductID\": 1,\n *         \"ProductName\": \"Chai\",\n *         \"UnitPrice\": 18.0000\n *       }, {\n *         \"ProductID\": 2,\n *         \"ProductName\": \"Chang\",\n *         \"UnitPrice\": 19.0000\n *       }\n *     ];\n * }\n *\n * ```\n */\nclass PDFTemplateDirective$1 extends PDFTemplateDirective {\n    constructor(templateRef) {\n        super(templateRef);\n    }\n}\nPDFTemplateDirective$1.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridPDFTemplate]'\n            },] },\n];\n/** @nocollapse */\nPDFTemplateDirective$1.ctorParameters = () => [\n    { type: TemplateRef, decorators: [{ type: Optional }] }\n];\n\n/**\n * @hidden\n */\nconst HEADER_CLASS = 'k-grid-header';\n/**\n * @hidden\n */\nconst FOOTER_CLASS = 'k-grid-footer';\nconst GRID_LIST = 'KENDO-GRID-LIST';\nconst TABLE = 'TABLE';\nconst matchesList = matchesNodeName(GRID_LIST);\nconst matchesTable = matchesNodeName(TABLE);\nconst suffix = (locked) => locked ? 'locked' : 'wrap';\n/**\n * @hidden\n */\nclass GridQuery {\n    constructor(element) {\n        this.element = element;\n        this.list = findElement(element, matchesList);\n    }\n    content(locked) {\n        return findElement(this.list, matchesClasses(`k-grid-content${locked ? '-locked' : ''}`));\n    }\n    header(locked) {\n        this.headerWrap = this.headerWrap || findElement(this.element, matchesClasses(HEADER_CLASS));\n        return findElement(this.headerWrap, matchesClasses(`${HEADER_CLASS}-${suffix(locked)}`));\n    }\n    footer(locked) {\n        this.footerWrap = this.footerWrap || findElement(this.element, matchesClasses(FOOTER_CLASS));\n        return findElement(this.footerWrap, matchesClasses(`${FOOTER_CLASS}-${suffix(locked)}`));\n    }\n    table() {\n        return findElement(this.element, matchesTable);\n    }\n}\n\nconst FIRST_CLASS = 'k-first';\nconst INPUTS = ['input', 'select', 'textarea', 'option'];\n/** @hidden */\nconst cloneNode = (node) => {\n    const clone = node.cloneNode(false);\n    if (node._kendoExportVisual) {\n        clone._kendoExportVisual = node._kendoExportVisual;\n    }\n    if (INPUTS.indexOf(String(node.nodeName).toLowerCase()) >= 0) {\n        clone.removeAttribute(\"id\");\n        clone.removeAttribute(\"name\");\n        clone.value = node.value;\n        clone.checked = node.checked;\n        clone.selected = node.selected;\n    }\n    let child = node.firstChild;\n    while (child) {\n        clone.appendChild(cloneNode(child));\n        child = child.nextSibling;\n    }\n    return clone;\n};\nconst appendNodes = (element, nodes) => {\n    const length = nodes.length;\n    for (let idx = 0; idx < length; idx++) {\n        element.appendChild(cloneNode(nodes[idx]));\n    }\n};\nconst wrapTable = (table) => {\n    const wrapper = document.createElement('div');\n    wrapper.className = 'k-widget k-grid';\n    wrapper.appendChild(table);\n    return wrapper;\n};\nconst createTableElement = (sources) => {\n    const sourceCount = sources.length;\n    const element = cloneNode(sources[0]);\n    const rowsCount = element.rows.length;\n    if (sourceCount > 1) {\n        for (let rowIdx = 0; rowIdx < rowsCount; rowIdx++) {\n            for (let sourceIdx = 1; sourceIdx < sourceCount; sourceIdx++) {\n                appendNodes(element.rows[rowIdx], sources[sourceIdx].rows[rowIdx].cells);\n            }\n        }\n    }\n    return element;\n};\nconst setFirstCellClass = (header, headers) => {\n    if (headers.length > 1 && header.rows.length > 1) {\n        for (let idx = 1; idx < header.rows.length; idx++) {\n            const firstCellIndex = headers[0].rows[idx].cells.length;\n            const cell = header.rows[idx].cells[firstCellIndex];\n            if (String(cell.className).indexOf(FIRST_CLASS) === -1) {\n                cell.className += ` ${FIRST_CLASS}`;\n            }\n        }\n    }\n};\nconst createTable = (colGroups, headers, bodies, footers) => {\n    const table = document.createElement('table');\n    const colGroup = colGroups[0].cloneNode(true);\n    for (let idx = 1; idx < colGroups.length; idx++) {\n        appendNodes(colGroup, colGroups[idx].querySelectorAll('col'));\n    }\n    const header = createTableElement(headers);\n    const body = createTableElement(bodies);\n    header.className = HEADER_CLASS;\n    setFirstCellClass(header, headers);\n    table.appendChild(colGroup);\n    table.appendChild(header);\n    table.appendChild(body);\n    if (footers.length) {\n        const footer = createTableElement(footers);\n        footer.className = FOOTER_CLASS;\n        table.appendChild(footer);\n    }\n    return wrapTable(table);\n};\n/**\n * @hidden\n */\nconst exportElement = (wrapper) => {\n    const query = new GridQuery(wrapper);\n    const content = query.content();\n    let result;\n    if (content) {\n        const colGroups = [content.querySelector('colgroup')];\n        const headers = [query.header().querySelector('thead')];\n        const bodies = [content.querySelector('tbody')];\n        const footer = query.footer();\n        const footers = [];\n        if (footer) {\n            footers.push(footer.querySelector('tfoot'));\n        }\n        const lockedContent = query.content(true);\n        if (lockedContent) {\n            colGroups.unshift(lockedContent.querySelector('colgroup'));\n            headers.unshift(query.header(true).querySelector('thead'));\n            bodies.unshift(lockedContent.querySelector('tbody'));\n            if (footer) {\n                footers.unshift(query.footer(true).querySelector('tfoot'));\n            }\n        }\n        result = createTable(colGroups, headers, bodies, footers);\n    }\n    else {\n        result = wrapTable(query.table().cloneNode(true));\n    }\n    return result;\n};\n\nconst createElement = (tagName, className) => {\n    const element = document.createElement(tagName);\n    if (className) {\n        element.className = className;\n    }\n    return element;\n};\nconst createDiv = (className) => {\n    return createElement('div', className);\n};\n/**\n * Configures the settings for the export of Grid in PDF ([see example]({% slug pdfexport_grid %})).\n */\nclass PDFComponent extends PDFExportComponent {\n    constructor(pdfService, suspendService, ngZone, element) {\n        super(element);\n        this.pdfService = pdfService;\n        this.suspendService = suspendService;\n        this.ngZone = ngZone;\n        this.columns = new QueryList();\n        this.saveSubscription = pdfService.savePDF.subscribe(this.savePDF.bind(this));\n        this.drawSubscription = pdfService.drawPDF.subscribe(this.drawPDF.bind(this));\n        this.reset = this.reset.bind(this);\n        this.draw = this.draw.bind(this);\n    }\n    ngOnDestroy() {\n        this.saveSubscription.unsubscribe();\n        this.drawSubscription.unsubscribe();\n        this.reset();\n    }\n    savePDF(component) {\n        this.createPDF(component, this.draw);\n    }\n    drawPDF({ component, promise }) {\n        this.createPDF(component, () => {\n            this.createExportGroup(promise);\n        });\n    }\n    createPDF(component, callback) {\n        const pageSize = component.pageSize;\n        const total = component.view.total;\n        const columns = this.columns.toArray();\n        if (columns.length) {\n            this.originalColumns = component.columns.toArray();\n        }\n        this.component = component;\n        this.suspendService.scroll = true;\n        this.pdfService.exporting = true;\n        this.initProgress();\n        this.renderAllPages = this.allPages && pageSize < total;\n        if (this.renderAllPages) {\n            this.skip = component.skip;\n            this.pageSize = pageSize;\n            this.changePage(0, total, callback, columns);\n        }\n        else if (columns.length || component.virtualColumns) {\n            this.changeColumns(columns, callback);\n        }\n        else {\n            callback();\n        }\n    }\n    initProgress() {\n        const wrapperElement = this.component.wrapper.nativeElement;\n        const progress = this.progress = createDiv('k-loading-pdf-mask');\n        const overlay = cloneNode(wrapperElement);\n        progress.appendChild(overlay);\n        progress.appendChild(createDiv('k-loading-color'));\n        progress.appendChild(createElement('span', 'k-i-loading k-icon'));\n        this.originalHeight = wrapperElement.style.height;\n        this.originalOverflow = wrapperElement.style.overflow;\n        wrapperElement.style.height = wrapperElement.offsetHeight + 'px';\n        wrapperElement.style.overflow = 'hidden';\n        wrapperElement.appendChild(progress);\n        this.applyScroll(overlay);\n    }\n    applyScroll(overlay) {\n        const query = new GridQuery(this.component.wrapper.nativeElement);\n        const content = query.content();\n        if (content) {\n            const overlayQuery = new GridQuery(overlay);\n            const overlayContent = overlayQuery.content();\n            overlayContent.scrollTop = content.scrollTop;\n            overlayContent.scrollLeft = content.scrollLeft;\n            overlayQuery.header().scrollLeft = query.header().scrollLeft;\n            const footer = query.footer();\n            if (footer) {\n                overlayQuery.footer().scrollLeft = footer.scrollLeft;\n            }\n            const lockedContent = query.content(true);\n            if (lockedContent) {\n                const overlayLockedContent = overlayQuery.content(true);\n                overlayLockedContent.scrollTop = lockedContent.scrollTop;\n                overlayLockedContent.scrollLeft = lockedContent.scrollLeft;\n            }\n        }\n    }\n    draw() {\n        this.createExportElement((element) => {\n            this.save(element, this.fileName);\n        });\n    }\n    createExportGroup(promise) {\n        this.createExportElement((element) => {\n            this.exportElement(element).then(group => promise.resolve(group));\n        });\n    }\n    createExportElement(callback) {\n        this.ngZone.runOutsideAngular(() => {\n            const container = this.container = createDiv('k-grid-pdf-export-element');\n            const element = exportElement(this.component.wrapper.nativeElement);\n            container.appendChild(element);\n            document.body.appendChild(container);\n            callback(element);\n        });\n    }\n    drawOptions() {\n        const options = super.drawOptions();\n        options._destructive = true;\n        return options;\n    }\n    cleanup() {\n        super.cleanup();\n        this.pdfService.exporting = false;\n        if (this.component) {\n            const originalColumns = this.originalColumns;\n            delete this.originalColumns;\n            if (this.renderAllPages) {\n                this.changePage(this.skip, this.pageSize, this.reset, originalColumns);\n            }\n            else if (originalColumns || this.component.virtualColumns) {\n                this.changeColumns(originalColumns, this.reset);\n            }\n            else {\n                this.reset();\n            }\n        }\n        else {\n            this.reset();\n        }\n        this.removeContainer();\n    }\n    removeContainer() {\n        if (this.container) {\n            document.body.removeChild(this.container);\n            delete this.container;\n        }\n    }\n    changePage(skip, _take, callback, columns) {\n        this.ngZone.run(() => {\n            this.pdfService.dataChanged.pipe(take(1)).subscribe(() => {\n                if ((columns && columns.length) || this.component.virtualColumns) {\n                    this.changeColumns(columns, callback);\n                }\n                else {\n                    this.onStable(callback);\n                }\n            });\n            this.component.notifyPageChange('pdf', { skip: skip, take: _take });\n        });\n    }\n    changeColumns(columns, callback) {\n        this.ngZone.run(() => {\n            this.onStable(callback);\n            if (columns && columns.length) {\n                this.component.columns.reset(columns);\n            }\n        });\n    }\n    reset() {\n        this.suspendService.scroll = false;\n        this.renderAllPages = false;\n        if (!this.component) {\n            return;\n        }\n        const wrapperElement = this.component.wrapper.nativeElement;\n        wrapperElement.removeChild(this.progress);\n        wrapperElement.style.height = this.originalHeight;\n        wrapperElement.style.overflow = this.originalOverflow;\n        delete this.progress;\n        delete this.component;\n    }\n    onStable(callback) {\n        // not sure if it is an actual scenario. occurs in the tests.\n        // onStable is triggered in the same pass without the change detection.\n        // thus, the callback is called before the changes are applied without the timeout.\n        setTimeout(() => {\n            this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(callback);\n        }, 0); // tslint:disable-line: align\n    }\n}\nPDFComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-grid-pdf',\n                template: ''\n            },] },\n];\n/** @nocollapse */\nPDFComponent.ctorParameters = () => [\n    { type: PDFService },\n    { type: SuspendService },\n    { type: NgZone },\n    { type: ElementRef }\n];\nPDFComponent.propDecorators = {\n    allPages: [{ type: Input }],\n    columns: [{ type: ContentChildren, args: [ColumnBase$1,] }],\n    marginComponent: [{ type: ContentChild, args: [PDFMarginComponent$1,] }],\n    pageTemplateDirective: [{ type: ContentChild, args: [PDFTemplateDirective$1,] }]\n};\n\n/**\n * Represents the `export-to-PDF` command of the Grid.\n * You can apply this directive to any `button` element inside a\n * [`ToolbarTemplate`]({% slug api_grid_commandcolumncomponent %}).\n * When the user clicks a button that is associated with the directive, the\n * [`pdfExport`]({% slug api_grid_gridcomponent %}#toc-pdfexport) event\n * fires ([see example]({% slug pdfexport_grid %})).\n *\n * @example\n * ```html-no-run\n * <kendo-grid>\n *      <ng-template kendoGridToolbarTemplate>\n *          <button kendoGridPDFCommand>Export to PDF</button>\n *      </ng-template>\n *      <kendo-grid-pdf fileName=\"Grid.pdf\">\n *      </kendo-grid-pdf>\n * </kendo-grid>\n * ```\n */\nclass PDFCommandDirective extends Button {\n    constructor(pdfService, element, renderer, localization, ngZone) {\n        super(element, renderer, null, localization, ngZone);\n        this.pdfService = pdfService;\n        this.ngZone = ngZone;\n    }\n    /**\n     * @hidden\n     */\n    onClick(e) {\n        e.preventDefault();\n        this.pdfService.exportClick.emit();\n    }\n    /**\n     * @hidden\n     */\n    get pdfClass() {\n        return true;\n    }\n}\nPDFCommandDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridPDFCommand]'\n            },] },\n];\n/** @nocollapse */\nPDFCommandDirective.ctorParameters = () => [\n    { type: PDFService },\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: LocalizationService },\n    { type: NgZone }\n];\nPDFCommandDirective.propDecorators = {\n    onClick: [{ type: HostListener, args: ['click', ['$event'],] }],\n    pdfClass: [{ type: HostBinding, args: ['class.k-grid-pdf',] }]\n};\n\nconst exportedModules$5 = [\n    PDFComponent,\n    PDFMarginComponent$1,\n    PDFCommandDirective,\n    PDFTemplateDirective$1\n];\nconst declarations$1 = [\n    PDFComponent,\n    PDFMarginComponent$1,\n    PDFCommandDirective,\n    PDFTemplateDirective$1\n];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Grid PDF component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Grid and PDF modules\n * import { GridModule, PDFModule } from '@progress/kendo-angular-grid';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, GridModule, PDFModule], // import Grid and PDF modules\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nclass PDFModule {\n}\nPDFModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [declarations$1],\n                exports: [exportedModules$5]\n            },] },\n];\n\n/**\n * Arguments for the `excelExport` event.\n */\nclass ExcelExportEvent extends PreventableEvent {\n    constructor(workbook) {\n        super();\n        this.workbook = workbook;\n    }\n}\n\n/* tslint:disable object-literal-sort-keys */\nconst fetchComponentData = (component) => {\n    return {\n        data: component.view.map(item => item),\n        group: component.group\n    };\n};\nconst toExcelColumn = (column) => {\n    return {\n        title: column.title,\n        field: column.field,\n        locked: Boolean(column.locked),\n        width: column.width,\n        level: column.level,\n        hidden: !column.isVisible,\n        groupHeaderTemplate: column.groupHeaderTemplate,\n        groupHeaderColumnTemplate: column.groupHeaderColumnTemplate,\n        groupFooterTemplate: column.groupFooterTemplate,\n        footerTemplate: column.footerTemplate\n    };\n};\nconst toExcelColumns = (columns) => {\n    const result = [];\n    sortColumns(columns)\n        .forEach((column) => {\n        if (column.isSpanColumn) {\n            result.push(...toExcelColumns(column.childrenArray));\n        }\n        else {\n            const excelColumn = toExcelColumn(column);\n            if (column.isColumnGroup) {\n                excelColumn.children = [excelColumn].concat(toExcelColumns(column.childrenArray));\n            }\n            result.push(excelColumn);\n        }\n    });\n    return result;\n};\nconst componentColumns = (component) => {\n    const columns = toExcelColumns(component.columns.toArray());\n    return orderBy(columns, [{ field: 'locked', dir: 'desc' }]);\n};\n/**\n * Configures the settings for the export of Grid in Excel ([see example]({% slug excelexport_grid %})).\n */\nclass ExcelComponent {\n    constructor(excelService, localization, zone) {\n        this.localization = localization;\n        this.zone = zone;\n        /**\n         * Specifies the file name of the exported Excel file.\n         * @default \"Export.xlsx\"\n         */\n        this.fileName = 'Export.xlsx';\n        /**\n         * @hidden\n         */\n        this.columns = new QueryList();\n        this.saveSubscription = excelService.saveToExcel.subscribe(this.save.bind(this));\n    }\n    ngOnDestroy() {\n        this.saveSubscription.unsubscribe();\n        if (this.dataSubscription) {\n            this.dataSubscription.unsubscribe();\n        }\n    }\n    save(component) {\n        const data = (this.fetchData || fetchComponentData)(component);\n        const exportData = (result) => {\n            delete this.dataSubscription;\n            this.exportData(component, result);\n        };\n        if (data instanceof Promise) {\n            data.then(exportData);\n        }\n        else if (data instanceof Observable) {\n            this.dataSubscription = data.pipe(take(1)).subscribe(exportData);\n        }\n        else {\n            exportData(data);\n        }\n    }\n    exportData(component, result) {\n        const options = workbookOptions({\n            columns: this.columns.length ? this.columns : componentColumns(component),\n            data: result.data,\n            group: result.group,\n            filterable: this.filterable,\n            creator: this.creator,\n            date: this.date,\n            paddingCellOptions: this.paddingCellOptions,\n            headerPaddingCellOptions: this.headerPaddingCellOptions,\n            rtl: this.localization.rtl,\n            collapsible: this.collapsible\n        });\n        const args = new ExcelExportEvent(options);\n        component.excelExport.emit(args);\n        if (!args.isDefaultPrevented()) {\n            this.zone.runOutsideAngular(() => this.saveFile(options));\n        }\n    }\n    saveFile(options) {\n        toDataURL(options).then((dataURL) => {\n            saveAs(dataURL, this.fileName, {\n                forceProxy: this.forceProxy,\n                proxyURL: this.proxyURL\n            });\n        });\n    }\n}\nExcelComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-grid-excel',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nExcelComponent.ctorParameters = () => [\n    { type: ExcelService },\n    { type: LocalizationService },\n    { type: NgZone }\n];\nExcelComponent.propDecorators = {\n    fileName: [{ type: Input }],\n    filterable: [{ type: Input }],\n    creator: [{ type: Input }],\n    date: [{ type: Input }],\n    forceProxy: [{ type: Input }],\n    proxyURL: [{ type: Input }],\n    fetchData: [{ type: Input }],\n    paddingCellOptions: [{ type: Input }],\n    headerPaddingCellOptions: [{ type: Input }],\n    collapsible: [{ type: Input }],\n    columns: [{ type: ContentChildren, args: [ColumnBase, { descendants: true },] }]\n};\n\n/**\n * Represents the `export-to-Excel` command of the Grid. You can apply this\n * directive to any `button` element inside a\n * [`ToolbarTemplate`]({% slug api_grid_commandcolumncomponent %}).\n * When the user clicks a button associated with the directive, the\n * [`excelExport`]({% slug api_grid_gridcomponent %}#toc-excelexport) event\n * fires ([see example]({% slug excelexport_grid %})).\n *\n * @example\n * ```html-no-run\n * <kendo-grid>\n *      <ng-template kendoGridToolbarTemplate>\n *          <button kendoGridExcelCommand>Export to PDF</button>\n *      </ng-template>\n *      <kendo-grid-excel fileName=\"Grid.xlsx\">\n *      </kendo-grid-excel>\n * </kendo-grid>\n * ```\n */\nclass ExcelCommandDirective extends Button {\n    constructor(excelService, element, renderer, localization, ngZone) {\n        super(element, renderer, null, localization, ngZone);\n        this.excelService = excelService;\n        this.ngZone = ngZone;\n    }\n    /**\n     * @hidden\n     */\n    onClick(e) {\n        e.preventDefault();\n        this.excelService.exportClick.emit();\n    }\n    /**\n     * @hidden\n     */\n    get excelClass() {\n        return true;\n    }\n}\nExcelCommandDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoGridExcelCommand]'\n            },] },\n];\n/** @nocollapse */\nExcelCommandDirective.ctorParameters = () => [\n    { type: ExcelService },\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: LocalizationService },\n    { type: NgZone }\n];\nExcelCommandDirective.propDecorators = {\n    onClick: [{ type: HostListener, args: ['click', ['$event'],] }],\n    excelClass: [{ type: HostBinding, args: ['class.k-grid-excel',] }]\n};\n\nconst declarations$2 = [ExcelComponent, ExcelCommandDirective];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Excel component of the Grid.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Grid and Excel modules\n * import { GridModule, ExcelModule } from '@progress/kendo-angular-grid';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, GridModule, ExcelModule], // import Grid and Excel modules\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nclass ExcelModule {\n}\nExcelModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [declarations$2],\n                exports: [declarations$2, ExcelExportModule]\n            },] },\n];\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ColumnChooserComponent, ColumnListComponent, ColumnMenuChooserComponent, ColumnMenuFilterComponent, ColumnMenuItemBase, ColumnMenuItemContentTemplateDirective, ColumnMenuItemComponent, ColumnMenuLockComponent, ColumnMenuSortComponent, ColumnMenuTemplateDirective, ColumnMenuModule, ColumnMenuService, ColumnHandleDirective, ColumnResizingService, TableDirective, ColumnInfoService, DomEventsService, ExpandStateService, IdService, PreventableEvent, SortService, ChangeNotificationService, ColumnReorderService, DragAndDropModule, DragAndDropService, DragHintService, DraggableColumnDirective, DropCueService, DropTargetDirective, EditingDirectiveBase, RowEditingDirectiveBase, AddCommandDirective, CancelCommandDirective, EditCommandDirective, EditService as EditService$1, LocalDataChangesService, RemoveCommandDirective, SaveCommandDirective, ExcelCommandDirective, BooleanFilterComponent, BooleanFilterCellComponent, FilterCellHostDirective, FilterCellOperatorsComponent, FilterCellWrapperComponent, DateFilterComponent, FilterHostDirective, FilterInputWrapperComponent, FilterInputDirective, FilterRowComponent, DateFilterMenuInputComponent, FilterMenuContainerComponent, FilterMenuHostDirective, FilterMenuInputWrapperComponent, FilterMenuComponent, NumericFilterMenuInputComponent, StringFilterMenuInputComponent, NumericFilterComponent, FilterOperatorBase, SharedFilterModule, StringFilterComponent, GroupHeaderComponent, GroupIndicatorComponent, GroupInfoService, GroupPanelComponent, GroupsService, BrowserSupportService, ResizeService, ResponsiveService, LocalizedMessagesDirective, Messages, FocusGroup, FocusRoot, LogicalCellDirective, LogicalRowDirective, NavigationService, PagerContextService, PagerElementComponent, PDFCommandDirective, PDFTemplateDirective$1 as PDFTemplateDirective, CellComponent, CELL_CONTEXT, EMPTY_CELL_CONTEXT, FieldAccessorPipe, DetailsService, DEFAULT_SCROLLER_FACTORY, SCROLLER_FACTORY_TOKEN, ScrollRequestService, ScrollSyncService, ScrollerService, SelectAllCheckboxDirective, SelectionCheckboxDirective, Selection, SelectionService, GridModule, SharedModule, GridComponent, ColumnBase$1 as ColumnBase, ColumnComponent, CommandColumnComponent, SpanColumnComponent, ColumnGroupComponent, CheckboxColumnComponent, ToolbarComponent, ToolbarTemplateDirective, CellTemplateDirective, HeaderTemplateDirective, FooterTemplateDirective, PagerTemplateDirective, DetailTemplateDirective, DetailExpandEvent, DetailCollapseEvent, GroupHeaderTemplateDirective, GroupHeaderColumnTemplateDirective, GroupFooterTemplateDirective, ResizableContainerDirective, TemplateContextDirective, NoRecordsTemplateDirective, DataBindingDirective, SelectionDirective, FilterService, FilterCellTemplateDirective, FilterCellComponent, StringFilterCellComponent, DateFilterCellComponent, BaseFilterCellComponent, FilterMenuTemplateDirective, NumericFilterMenuComponent, StringFilterMenuComponent, DateFilterMenuComponent, BooleanFilterMenuComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent, AfterEqFilterOperatorComponent, AfterFilterOperatorComponent, ContainsFilterOperatorComponent, DoesNotContainFilterOperatorComponent, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, NotEqualFilterOperatorComponent, StartsWithFilterOperatorComponent, NumericFilterCellComponent, AutoCompleteFilterCellComponent, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, LessFilterOperatorComponent, PagerPrevButtonsComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerInputComponent, PagerInfoComponent, PagerPageSizesComponent, RowFilterModule, FilterMenuModule, BodyModule, GroupModule, HeaderModule, FooterModule, PagerModule, TemplateEditingDirective, ReactiveEditingDirective, InCellEditingDirective, EditTemplateDirective, ColGroupComponent, HeaderComponent, ListComponent, FooterComponent, TableBodyComponent, PagerComponent, CustomMessagesComponent, LoadingComponent, PDFModule, PDFComponent, PDFMarginComponent$1 as PDFMarginComponent, PDFService, ExcelModule, ExcelComponent, ExcelService, CellCloseEvent, SuspendService, GroupBindingDirective, slice, count, Skip, ColumnReorderEvent, FocusableDirective, ColumnVisibilityChangeEvent, ColumnMenuComponent, SinglePopupService, PopupCloseEvent };\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiFC,sIAKC;;;;;;;;;;;;kCAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0DD,2JAKC;;;;;;;;;;;;kCAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0BD,6KAKC;;;;;;;;;;;;kCAIA;;;;;;;;;;;;;;;;;;;;;CAmBD,sIAKC;;;;;;;;;;;;kCAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsDD,2JAKC;;;;;;;;;;;;kCAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuDD,4IAKC;;;;;;;;;;;;kCAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0DD,4IAKC;;;;;;;;;;;;kCAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA+CD,wJAKC;;;;;;;;;;;;kCAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;odAwLD;;;;;;;;;;;;;;;;;;;;;;;;AAuBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiHD,wJAKC;;;;;;;;;;;;kCAIA;;;;;;;;;;;;CAUD,wJAKC;;;;;;;;;;;;kCAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA+ID,gJAYC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAqBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA+ND,oJAYC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuLD,qJAYC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAqFD,6MAKC;;;;;;;;;;;;;;;;;;oBAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4DD,8HAGC;;;;;;;;2GAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgSD;;;gDAGC;;;;;;;;;;;CASD;;;gDAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoRD,+GAGC;;;;;;;;6GAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qNAyED;;;;;;AAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4MD,gGAGC;;;;;;;uEAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiED,yGAGC;;;;;gDAEuC;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0BxC,sGAGC;;;;;;;;;;;;kCAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmND;;;;;;;;;;;;;;;;;;;CAiBA,0IAGC;;;;;;;uEAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsED,qJAKC;;;;;;;;;;;;kCAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgEA,qIAKC;;;;;;;;;;;;kCAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4BA;;;gDAGC;;;;;;;;;;;;;;;;;CAeD;;;gDAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4BD;;;gDAGC;;;;;;;;;;;;;;;;;;;;;;CAoBD;;;gDAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiFD,iLAKC;;;;;;;;;;;;;;;;;;oBAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkED,kHAGC;;;;;;;uEAIA;;;;;;;;;;;;;;;;;;;;;;CAoBD;;;gDAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsQD;;;gDAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsGD,qHAGC;;;;;;;;;;;qMAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiHD;;;gDAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkFD,4GAGC;;;;;;;6EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8BD;;;0BAGC;;;;;;;;;;;;;;CAYD;;;gDAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4CD;;;gDAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6JD,iTAWC;;;;;;;;;;;;;;;;;;;;;;;;;2FAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2ZD;;;gDAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmhBD,kHAGC;;;;;;;;;;;;;;;;;;;kCAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwCD,0FAGC;;;;;gDAEkC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0CnC;;;gDAGC;;;;;;;;;;;;;;;AAYD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8wDA,sTAwaC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAgGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAyrBD,yIAmGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAmDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsID,8SAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0BD,2KAKC;;;;;;;;;;;2GAKA;;;;;;;;86DAMD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qEAqDC;;;;;;;;;;;;;;;;;CAUD,iDAWC;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;;;;CAcD,wJAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAaD,qDA0BC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAaA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6FD,uKAqBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2GAyED;;;;AAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;WAwID;;;;;AAIC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kTA0FD;;;;;;;;;;;;AAWC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkCD,qDA2BC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAqDD,kOAKC;;;;;;;;;;;;;;;;;;;;;;;;;;oBAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qMA2FD;;;;;;;;AAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAyBD,gGAeC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4MA4DD;;;;;;AAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoCD,0FAoBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuED,yHA+BC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuCD,0HAmBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAaA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0GAgED;;;;;;AAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2BD,0HAuBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iJAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wZAmGD;;;;;;;;;;;;;;;AAcC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6BD,wHA6BC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAQA;;;;;;;;;;;;;;;;;;;;;;CAgBD,uEAYC;;;;;;;;;;;;;;;;;;;;;;;;oBAKA;;;;;;;;;;;;;;;;;;;;;;;;;;CAaD,4BAUC;;;;;;;;;;;;;;;;;;;;;oBAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsDD,4PAKC;;;;;;;;;;;;;;;;;;;;;;;;oBAWA;;;;;;;;;;;;;;;;;;;;;;;;;;CAwBD,sLAKC;;;;;;;;;;;;;;;oBAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2DD,6FAGC;;;;;;;mEAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuHD,kDAUC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAyBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuDD,uRAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAgBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4BD,wGAMC;;;;;;;;;;;6EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgGD,0EAKC;;;;;;;;;;;;;;;;;;;;;;;;;;oBAaA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgCD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAOC;;;;;;;;;;;;;;;;;;CAWD,gKAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;CAWD,sKAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;CAWD,gKAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;CAWD,6JAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;CAWD,+JAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;CAWD,kKAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;CAWD,iKAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;CAWD,8JAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;CAWD,gKAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;CAWD,kKAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;CAWD,+JAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;CAWD,wKAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;CAWD,4JAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;CAWD,qKAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoBD,6JAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoBD,+JAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoBD,gKAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoBD,8JAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8CD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8KAoCD;;;;;AAIC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2BD,uLAKC;;;;;;;;;;;4HAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsCD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAQC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4ED,wDAuBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAeA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0BA,8EA0CC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uJAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0BD,8EA0CC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uJAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0DD,2GAiCC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA+DD,gIAwBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiDD,gDAOC;;;;;;;;;;;;;;;;;;;;;;;oBASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8KD,2FAiBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiCD;;;;;;;;;;;;;;;;;;;;;;;;;0BAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0DD,4LAqEC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAkBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2CD,uNAKC;;;;;;;;;;;;;;;;;;;;;;;;;oBAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgHD,uGA8CC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAeA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8BD,gDAgBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA+FD,+FAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAiBA;;;;;;;;;;;;CAUD;;;;;;;;;;0BAMC;;;;;;;;;;;;;;;;;;;;;;;CAqBD;;;;;;;;;;;;;;;;;;;;;0BAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkWD,0QA4LC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBA+BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkLD,4DAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAiBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoED,kIAKC;;;;;;;;;;;;;;;;;;;;;;;;;oBAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAyBD,gHAsBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoHD,2QAmCC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAaA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgDD,wEAgBC;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAMA;;;;;;;;;;;;;;;;;;;CASD,sKAiBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuCD,qHA+BC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoDD,8IA8CC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmBD,iIA4BC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoDD,2IAoDC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAyDD,0DAmBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA+BD,mOAKC;;;;;;;;;;;;;;;;oBAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoBD,6HAiCC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAqBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoCD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAQC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8HD,uFAgBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAkBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2GD,+DA0BC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAaA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4CD;;;gDAGC;;;;;;;;;;;;;;;;;;;;;;;;2CAoBD;;;;;AAIC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuED,oDAqBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwDD,6DAkBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwCD,yLAKC;;;;;;;;;;;;kCAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAyED,cAuCC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsED,mEAaC;;;;;;;;;;;;;;;;;;;2GAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwGD,0DAkCC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAeA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8ED,mEASC;;;;;;;;;;;;;;;;qJAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA+BD;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2BD;;;;;;;;;;;;;;;;;;;;;0BAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4ED,uJAYC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4ED,wJAYC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkED,8EAKC;;;;;;;;;;;;;;;;;;;;;;;oBAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAyQD,qDA4MC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAmCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4GD,uRA6DC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoDD,yDAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkED,yDAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkED,yDAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmDD,yDAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoCD,yDAKC;;;;;;;;;;;;;;;;;;;;;;;;oBAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6CD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAOC;;;;;;;;;;;;;;;;;;;;;;;;;CAiBD,iIAgCC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAQA;;;;;;;;;;;;;;;;;;CAgBD;;;;;;;;;;0BAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmBD,gFAaC;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uKA8ID;;;;;AAIC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mGA8CD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoCA,wQAKC;;;;;;;;;;;;;;;;;oBAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwCD,4QAKC;;;;;;;;;;;;;;;;;oBAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAqDD,oQAKC;;;;;;;;;;;;;;;;;oBAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4OD,iSAGC;;;;;;;;;;;;;;;;;;;;;;;;;oBAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAqED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAmBC;;;;;CAGD;;;;;;;;0BAMC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsDD,sLAKC;;;;;;;;;;;;kCAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoVD,uLAMC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAaA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwCD,yDAKC;;;;;;;;;;;;;;;;;;;;;;;;oBAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8CD;;;;;;;;;;;;;;0BAMC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAyHD,0YAMC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAmBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwCD,yDAKC;;;;;;;;;;;;;;;;;;;;;;;;oBAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmCD;;;;;;;;;;;0BAMC;;;;;;;"}