{"version":3,"file":"index.js","sources":["D:/project/projek_angular/hris_rni/node_modules/@progress/kendo-angular-inputs/dist/fesm2015/index.js"],"sourcesContent":["/**-----------------------------------------------------------------------------------------\n* Copyright Â© 2020 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport { Directive, TemplateRef, Optional, EventEmitter, Component, forwardRef, Injector, Renderer2, NgZone, ElementRef, Input, Output, ViewChild, ContentChild, HostBinding, ChangeDetectorRef, Inject, isDevMode, Injectable, HostListener, ViewChildren, NgModule, ViewContainerRef } from '@angular/core';\nimport { NgControl, NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';\nimport { Subscription, fromEvent, interval, merge, Observable } from 'rxjs';\nimport { take, filter, concatMap, startWith, takeUntil, skip, debounceTime } from 'rxjs/operators';\nimport { SliderModel, SliderUtil } from '@telerik/kendo-inputs-common';\nimport { LocalizationService, L10N_PREFIX, RTL, ComponentMessages } from '@progress/kendo-angular-l10n';\nimport { guid, hasObservers, anyChanged, isDocumentAvailable, Keys, KendoInput, isChanged, DraggableModule, EventsModule, ResizeSensorModule } from '@progress/kendo-angular-common';\nimport { browser, mobileOS } from '@progress/kendo-common';\nimport { IntlService } from '@progress/kendo-angular-intl';\nimport { CommonModule } from '@angular/common';\nimport { PopupService, PopupModule } from '@progress/kendo-angular-popup';\nimport { Color, parseColor, namedColors } from '@progress/kendo-drawing';\n\n/**\n * @hidden\n */\nconst MAX_PRECISION = 20;\n/**\n * @hidden\n */\nconst limitPrecision = (precision) => Math.min(precision, MAX_PRECISION);\n/**\n * @hidden\n */\nconst fractionLength = (value) => {\n    return (String(value).split('.')[1] || \"\").length;\n};\nconst maxFractionLength = (value1, value2) => {\n    return Math.max(fractionLength(value1), fractionLength(value2));\n};\n/**\n * @hidden\n */\nconst toFixedPrecision = (value, precision) => {\n    const maxPrecision = limitPrecision(precision);\n    return parseFloat(value.toFixed(maxPrecision));\n};\n/**\n * @hidden\n */\nconst add = (value1, value2) => {\n    const maxPrecision = maxFractionLength(value1, value2);\n    return toFixedPrecision(value1 + value2, maxPrecision);\n};\n/**\n * @hidden\n */\nconst subtract = (value1, value2) => {\n    return add(value1, -value2);\n};\n/**\n * @hidden\n */\nconst multiply = (value1, value2) => {\n    const maxPrecision = fractionLength(value1) + fractionLength(value2);\n    return toFixedPrecision(value1 * value2, maxPrecision);\n};\n/**\n * @hidden\n */\nconst divide = (dividend, divisor) => {\n    if (divisor === 0) {\n        return NaN;\n    }\n    const power = maxFractionLength(dividend, divisor);\n    const correctionValue = Math.pow(10, power);\n    return ((correctionValue * dividend) / (correctionValue * divisor));\n};\n/**\n * @hidden\n */\nconst remainder = (dividend, divisor) => {\n    return Math.abs(subtract(dividend, multiply(divisor, Math.floor(divide(dividend, divisor)))));\n};\n\nfunction elementOffset(element) {\n    const box = element.getBoundingClientRect();\n    const documentElement = document.documentElement;\n    return {\n        left: box.left + (window.pageXOffset || documentElement.scrollLeft) - (documentElement.clientLeft || 0),\n        top: box.top + (window.pageYOffset || documentElement.scrollTop) - (documentElement.clientTop || 0)\n    };\n}\nfunction limitValue(value, min, max) {\n    return Math.max(Math.min(value, max), min);\n}\n/**\n * @hidden\n */\nfunction decreaseValueToStep(value, { max, min, smallStep, largeStep }, large = false) {\n    const step = large && largeStep ? multiply(smallStep, largeStep) : smallStep;\n    const stepValue = subtract(value, min);\n    let result;\n    const stepRemainder = remainder(stepValue, step);\n    if (stepRemainder === 0) {\n        result = subtract(stepValue, step);\n    }\n    else {\n        result = subtract(stepValue, stepRemainder);\n    }\n    return limitValue(add(result, min), min, max);\n}\n/**\n * @hidden\n */\nfunction increaseValueToStep(value, { max, min, smallStep, largeStep }, large = false) {\n    const step = large && largeStep ? multiply(smallStep, largeStep) : smallStep;\n    const stepValue = subtract(value, min);\n    const stepRemainder = remainder(stepValue, step);\n    const result = add(subtract(stepValue, stepRemainder), step);\n    return limitValue(add(result, min), min, max);\n}\n/**\n * @hidden\n */\nfunction snapValue(value, options) {\n    const { smallStep, min, max } = options;\n    const limitted = limitValue(value, min, max);\n    if (value !== limitted) {\n        return limitted;\n    }\n    const left = decreaseValueToStep(value, options);\n    const right = increaseValueToStep(value, options);\n    if ((value - min) % smallStep === 0) {\n        return value;\n    }\n    if (right - value <= (right - left) / 2) {\n        return right;\n    }\n    return left;\n}\n/**\n * @hidden\n */\nfunction eventValue(eventArgs, scaleElement, options) {\n    const { min, max, vertical, rtl } = options;\n    const trackOffset = elementOffset(scaleElement);\n    const offset = vertical ? eventArgs.pageY - trackOffset.top : eventArgs.pageX - trackOffset.left;\n    const scale = (max - min) / (vertical ? scaleElement.clientHeight : scaleElement.clientWidth);\n    const offsetValue = offset * scale;\n    let value = rtl || vertical ? max - offsetValue : min + offsetValue;\n    const stepFractionLength = fractionLength(options.smallStep);\n    value = toFixedPrecision(value, stepFractionLength + 1);\n    return snapValue(value, options);\n}\n/**\n * @hidden\n */\nfunction isButton(element) {\n    return element.className.indexOf('k-button-increase') >= 0 || element.className.indexOf('k-button-decrease') >= 0;\n}\n/**\n * @hidden\n */\nfunction increment(options) {\n    return increaseValueToStep(options.value, options);\n}\n/**\n * @hidden\n */\nfunction decrement(options) {\n    return decreaseValueToStep(options.value, options);\n}\n/**\n * @hidden\n */\nfunction incrementLarge(options) {\n    return increaseValueToStep(options.value, options, true);\n}\n/**\n * @hidden\n */\nfunction decrementLarge(options) {\n    return decreaseValueToStep(options.value, options, true);\n}\n/**\n * @hidden\n */\nfunction calculateValueFromTick(index, { max, min, smallStep, reverse, vertical }) {\n    const value = add(min, multiply(index, smallStep));\n    return vertical || reverse ? Math.abs(subtract(value, max)) : value;\n}\n/**\n * @hidden\n */\nfunction calculateTicksCount(min = 0, max = 0, smallStep = 1) {\n    if (smallStep <= 0) {\n        throw new Error(\"Invalid argument: smallStep must be a positive number\");\n    }\n    const adjustedRange = Math.abs(subtract(max, min));\n    const adjustedRatio = Math.floor(divide(adjustedRange, smallStep));\n    const result = add(adjustedRatio, 1);\n    return result;\n}\n\n/**\n * @hidden\n */\nclass SliderModel$1 extends SliderModel {\n    getTickSizes() {\n        const { min, max, smallStep } = this.props;\n        const count = calculateTicksCount(min, max, smallStep);\n        const trackSize = this.trackWidth();\n        const distStep = trackSize / subtract(max, min);\n        const result = [];\n        let usedSpace = 0;\n        let endPoint = 0;\n        for (let i = 0; i < count; i++) {\n            if (i === 0 || i === count - 1) {\n                endPoint += (smallStep / 2) * distStep;\n            }\n            else {\n                endPoint += smallStep * distStep;\n            }\n            const size = Math.round(endPoint - usedSpace);\n            result.push(size);\n            usedSpace += size;\n        }\n        return result;\n    }\n}\n\n/**\n * Represents the template for the labels of the Slider.\n * To define the labels template, nest an `<ng-template>` tag with the `kendoSliderLabelTemplate` directive inside\n * the `<kendo-slider>` tag. The template context is passed to the `label` value.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *         <kendo-slider [largeStep]=\"2\">\n *           <ng-template kendoSliderLabelTemplate let-value=\"value\">\n *             <b>{{value}}</b>\n *           </ng-template>\n *         </kendo-slider>\n *     `\n * })\n *\n * class AppComponent {\n * }\n *\n * ```\n */\nclass LabelTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nLabelTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoSliderLabelTemplate]'\n            },] },\n];\n/** @nocollapse */\nLabelTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef, decorators: [{ type: Optional }] }\n];\n\n/**\n * @hidden\n *\n * Checks if the value is `null` or `undefined`. Falsy values like '', 0, false, NaN, etc. are regarded as present.\n */\nconst isPresent = (value) => value !== null && value !== undefined;\n/**\n * @hidden\n */\nconst areSame = (value1, value2) => value1 === value2 || (value1 === null && value2 === undefined) || (value1 === undefined && value2 === null);\n/**\n * @hidden\n */\nconst requiresZoneOnBlur = (ngControl) => ngControl &&\n    (!ngControl.touched || (ngControl.control && ngControl.control.updateOn === 'blur'));\n/**\n * @hidden\n *\n * Fits the contender number into the specified bounds. If the number is NaN or null, the min is returned.\n *\n * @param contender Represents the number you want to fit into specified bounds.\n * @param min The inclusive lower bound number.\n * @param max The inclusive upper bound number.\n */\nconst fitIntoBounds = (contender, min, max) => {\n    if (!isPresent(contender) || isNaN(contender)) {\n        return min;\n    }\n    return contender <= min ? min : contender >= max ? max : contender;\n};\n\nconst UNTOUCHED = 'ng-untouched';\nconst toClassList = (classNames) => String(classNames).trim().split(' ');\n/**\n * @hidden\n */\nconst hasClass = (element, className) => Boolean(toClassList(element.className).find((name) => name === className));\n/**\n * @hidden\n */\nfunction invokeElementMethod(element, name, ...args) {\n    if (element && element.nativeElement) {\n        return element.nativeElement[name].apply(element.nativeElement, args);\n    }\n}\n/**\n * @hidden\n */\nconst isUntouched = (element) => element && element.nativeElement && hasClass(element.nativeElement, UNTOUCHED);\n/**\n * @hidden\n */\nconst containsFocus = (hostElement, contender) => hostElement && contender && (hostElement === contender || hostElement.contains(contender));\n\nconst FOCUSED = 'k-state-focused';\nconst PRESSED = 'k-pressed';\n/**\n * Represents the [Kendo UI Slider component for Angular]({% slug overview_slider %}).\n */\nclass SliderComponent {\n    constructor(localizationService, injector, renderer, ngZone, hostElement) {\n        this.localizationService = localizationService;\n        this.injector = injector;\n        this.renderer = renderer;\n        this.ngZone = ngZone;\n        this.hostElement = hostElement;\n        /**\n         * @hidden\n         */\n        this.focusableId = `k-${guid()}`;\n        /**\n         * Determines if the animation will be played on value change.\n         * Regardless of this setting, no animation will be played during the initial rendering.\n         */\n        this.animate = true;\n        /**\n         * Renders the arrow side buttons of the Slider ([see example]({% slug sidebuttons_slider %}#toc-hidden-state)).\n         * When `showButtons` is set to `false`, the buttons are not displayed.\n         */\n        this.showButtons = true;\n        /**\n         * Denotes the location of the tick marks in the Slider ([see example]({% slug ticks_slider %}#toc-placement)).\n         *\n         * The available options are:\n         * * `before`&mdash;The tick marks are located to the top side of the horizontal track or to the left side of a vertical track.\n         * * `after`&mdash;The tick marks are located to the bottom side of the horizontal track or to the right side of the vertical track.\n         * * `both`&mdash;The tick marks are located on both sides of the track.\n         * * `none`&mdash;The tick marks are not visible. The actual elements are not added to the DOM tree.\n         */\n        this.tickPlacement = 'both';\n        /**\n         * Defines the title of the ticks ([see example]({% slug ticks_slider %}#toc-titles)). The default title\n         * for each tick is its Slider value. If you use a callback function, the function accepts an argument\n         * that holds the value of the component and returns a string with the new title.\n         */\n        this.title = SliderUtil.identity;\n        /**\n         * If `vertical` is set to `true`, the orientation of the Slider changes from horizontal to vertical\n         * ([see example]({% slug orientation_slider %})).\n         */\n        this.vertical = false;\n        /**\n         * The minimum value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).\n         * The attribute accepts both integers and floating-point numbers.\n         */\n        this.min = 0;\n        /**\n         * The maximum value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).\n         * The attribute accepts both integers and floating-point numbers.\n         */\n        this.max = 10;\n        /**\n         * The step value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).\n         * Accepts positive values only. Can be an integer or a floating-point number.\n         */\n        this.smallStep = 1;\n        /**\n         * Specifies that every n<sup>th</sup> tick will be large and will have a label\n         * ([see example]({% slug predefinedsteps_slider %}#toc-large-steps)).\n         * Accepts positive integer values only.\n         */\n        this.largeStep = null;\n        /**\n         * Determines whether the Slider is disabled ([see example]({% slug disabledstate_slider %})).\n         */\n        this.disabled = false;\n        /**\n         * Determines whether the Slider is in its read-only state ([see example]({% slug readonly_slider %})).\n         */\n        this.readonly = false;\n        /**\n         * The current value of the Slider when it is initially displayed.\n         * The component can use either NgModel or the `value` binding but not both of them at the same time.\n         */\n        this.value = 0;\n        /**\n         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the Slider.\n         */\n        this.tabindex = 0;\n        /**\n         * Fires each time the user focuses the `input` element.\n         */\n        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the `input` element gets blurred.\n         */\n        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the user selects a new value.\n         */\n        this.valueChange = new EventEmitter();\n        this.sliderClass = true;\n        this.widgetClass = true;\n        this.stateDefaultClass = true;\n        this.subscriptions = new Subscription();\n        /**\n         * @hidden\n         */\n        this.handleFocus = () => {\n            this.focused = true;\n            if (hasObservers(this.onFocus)) {\n                this.ngZone.run(() => {\n                    this.onFocus.emit();\n                });\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.handleBlur = () => {\n            this.focused = false;\n            if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {\n                this.ngZone.run(() => {\n                    this.ngTouched();\n                    this.onBlur.emit();\n                });\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.onWrapClick = (args) => {\n            const target = args.target;\n            if (!this.isDisabled && !(isButton(target) || isButton(target.parentNode))) {\n                const value = eventValue(args, this.track.nativeElement, this.getProps());\n                this.changeValue(value);\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.ifEnabled = (callback, event) => {\n            if (!this.isDisabled) {\n                callback.call(this, event);\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.onKeyDown = (e) => {\n            const options = this.getProps();\n            const { max, min } = options;\n            const handler = this.keyBinding[e.keyCode];\n            if (this.isDisabled || !handler) {\n                return;\n            }\n            const value = handler(options);\n            this.changeValue(SliderUtil.trimValue(max, min, value));\n            e.preventDefault();\n        };\n        this.ngChange = (_) => { };\n        this.ngTouched = () => { };\n        this.decreaseValue = () => {\n            this.changeValue(decreaseValueToStep(this.value, this.getProps()));\n        };\n        this.increaseValue = () => {\n            this.changeValue(increaseValueToStep(this.value, this.getProps()));\n        };\n        this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n    }\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n        this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n        return this.tabindex;\n    }\n    get horizontalClass() {\n        return !this.vertical;\n    }\n    get verticalClass() {\n        return this.vertical;\n    }\n    get disabledClass() {\n        return this.disabled;\n    }\n    get ariaDisabled() {\n        return this.disabled ? true : undefined;\n    }\n    get ariaReadonly() {\n        return this.readonly ? true : undefined;\n    }\n    get ariaMin() {\n        return this.min;\n    }\n    get ariaMax() {\n        return this.max;\n    }\n    get ariaValue() {\n        return this.value ? this.value : this.min;\n    }\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     *\n     * @param isDisabled\n     */\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n    }\n    ngOnInit() {\n        this.subscriptions.add(this.localizationService\n            .changes\n            .subscribe(({ rtl }) => {\n            this.direction = rtl ? 'rtl' : 'ltr';\n            this.sizeComponent(false);\n        }));\n        if (this.hostElement) {\n            this.renderer.removeAttribute(this.hostElement.nativeElement, \"tabindex\");\n        }\n        this.control = this.injector.get(NgControl, null);\n    }\n    /**\n     * Focuses the Slider.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"slider.focus()\">Focus</button>\n     *  <kendo-slider #slider></kendo-slider>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n        invokeElementMethod(this.wrapper, 'focus');\n    }\n    /**\n     * Blurs the Slider.\n     */\n    blur() {\n        invokeElementMethod(this.wrapper, 'blur');\n    }\n    ngOnChanges(changes) {\n        if (anyChanged(['value', 'fixedTickWidth', 'tickPlacement'], changes, true)) {\n            this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {\n                this.sizeComponent(false);\n            });\n        }\n    }\n    ngAfterViewInit() {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        if (this.showButtons) {\n            this.setValueChangeInterval(this.increaseButton.nativeElement, () => this.increaseValue());\n            this.setValueChangeInterval(this.decreaseButton.nativeElement, () => this.decreaseValue());\n        }\n        this.sizeComponent(false);\n        if (this.ticks) {\n            this.ticks.tickElements\n                .changes\n                .subscribe(() => this.sizeComponent(false));\n        }\n    }\n    ngOnDestroy() {\n        this.subscriptions.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n    get incrementMessage() {\n        return this.incrementTitle || this.localizationService.get('increment');\n    }\n    /**\n     * @hidden\n     */\n    get decrementMessage() {\n        return this.decrementTitle || this.localizationService.get('decrement');\n    }\n    /**\n     * @hidden\n     */\n    get dragHandleMessage() {\n        return this.dragHandleTitle || this.localizationService.get('dragHandle');\n    }\n    /**\n     * @hidden\n     */\n    handleDragPress(args) {\n        if (args.originalEvent) {\n            args.originalEvent.preventDefault();\n        }\n        this.focus();\n        this.renderer.removeClass(this.hostElement.nativeElement, 'k-slider-transitions');\n    }\n    /**\n     * @hidden\n     */\n    onHandleDrag(args) {\n        this.dragging = true;\n        this.changeValue(eventValue(args, this.track.nativeElement, this.getProps()));\n    }\n    /**\n     * @hidden\n     */\n    onHandleRelease() {\n        this.dragging = false; //needed for animation\n        this.renderer.addClass(this.hostElement.nativeElement, 'k-slider-transitions');\n    }\n    //ngModel binding\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n        this.value = value;\n        this.sizeComponent(this.animate);\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.ngTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    changeValue(value) {\n        if (!areSame(this.value, value)) {\n            this.ngZone.run(() => {\n                this.value = value;\n                this.ngChange(value);\n                this.valueChange.emit(value);\n                this.sizeComponent(this.animate);\n            });\n        }\n    }\n    /**\n     * @hidden\n     */\n    sizeComponent(animate) {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        const wrapper = this.wrapper.nativeElement;\n        const track = this.track.nativeElement;\n        const selectionEl = this.sliderSelection.nativeElement;\n        const dragHandleEl = this.draghandle.nativeElement;\n        const ticks = this.ticks ? this.ticksContainer.nativeElement : null;\n        if (!animate) {\n            this.renderer.removeClass(this.hostElement.nativeElement, 'k-slider-transitions');\n        }\n        this.resetStyles([track, selectionEl, dragHandleEl, ticks, this.hostElement.nativeElement]);\n        const props = this.getProps();\n        const model = new SliderModel$1(props, wrapper, track);\n        model.resizeTrack();\n        if (this.ticks) { //for case when tickPlacement: none\n            model.resizeTicks(this.ticksContainer.nativeElement, this.ticks.tickElements.map(element => element.nativeElement));\n        }\n        model.positionHandle(dragHandleEl);\n        model.positionSelection(dragHandleEl, selectionEl);\n        if (!animate) {\n            this.hostElement.nativeElement.getBoundingClientRect();\n            this.renderer.addClass(this.hostElement.nativeElement, 'k-slider-transitions');\n        }\n        if (this.fixedTickWidth) {\n            model.resizeWrapper();\n        }\n    }\n    /**\n     * @hidden\n     */\n    get isDisabled() {\n        return this.disabled || this.readonly;\n    }\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the component is empty.\n     */\n    isEmpty() {\n        return false;\n    }\n    get reverse() {\n        return this.localizationService.rtl && !this.vertical;\n    }\n    get keyBinding() {\n        const reverse = this.reverse;\n        return {\n            [Keys.ArrowLeft]: reverse ? increment : decrement,\n            [Keys.ArrowRight]: reverse ? decrement : increment,\n            [Keys.ArrowDown]: decrement,\n            [Keys.ArrowUp]: increment,\n            [Keys.PageUp]: incrementLarge,\n            [Keys.PageDown]: decrementLarge,\n            [Keys.Home]: ({ min }) => min,\n            [Keys.End]: ({ max }) => max\n        };\n    }\n    set focused(value) {\n        if (this.isFocused !== value && this.hostElement) {\n            const element = this.hostElement.nativeElement;\n            if (value) {\n                this.renderer.addClass(element, FOCUSED);\n            }\n            else {\n                this.renderer.removeClass(element, FOCUSED);\n            }\n            this.isFocused = value;\n        }\n    }\n    set dragging(value) {\n        if (this.isDragged !== value && this.sliderSelection && this.draghandle) {\n            const sliderSelection = this.sliderSelection.nativeElement;\n            const draghandle = this.draghandle.nativeElement;\n            if (value) {\n                this.renderer.addClass(sliderSelection, PRESSED);\n                this.renderer.addClass(draghandle, PRESSED);\n            }\n            else {\n                this.renderer.removeClass(sliderSelection, PRESSED);\n                this.renderer.removeClass(draghandle, PRESSED);\n            }\n            this.isDragged = value;\n        }\n    }\n    setValueChangeInterval(element, callback) {\n        this.ngZone.runOutsideAngular(() => {\n            const mousedown = fromEvent(element, 'mousedown');\n            const mouseup = fromEvent(element, 'mouseup');\n            const mouseout = fromEvent(element, 'mouseout');\n            const subscription = mousedown.pipe(filter((e) => e.button === 0 && !this.isDisabled), concatMap(() => interval(150).pipe(startWith(-1), takeUntil(merge(mouseup, mouseout))))).subscribe(() => {\n                this.focus();\n                callback();\n            });\n            this.subscriptions.add(subscription);\n        });\n    }\n    getProps() {\n        return {\n            buttons: this.showButtons,\n            disabled: this.disabled,\n            fixedTickWidth: this.fixedTickWidth,\n            largeStep: this.largeStep,\n            max: this.max,\n            min: this.min,\n            readonly: this.readonly,\n            reverse: this.reverse,\n            rtl: this.localizationService.rtl,\n            smallStep: this.smallStep,\n            value: SliderUtil.trimValue(this.max, this.min, this.value),\n            vertical: this.vertical\n        };\n    }\n    resetStyles(elements) {\n        elements.forEach(el => {\n            if (el) {\n                if (this.vertical) {\n                    el.style.removeProperty('width');\n                    el.style.removeProperty('left');\n                }\n                else {\n                    el.style.removeProperty('height');\n                    el.style.removeProperty('bottom');\n                }\n                el.style.removeProperty('padding-top');\n            }\n        });\n    }\n}\nSliderComponent.decorators = [\n    { type: Component, args: [{\n                exportAs: 'kendoSlider',\n                providers: [\n                    LocalizationService,\n                    { provide: L10N_PREFIX, useValue: 'kendo.slider' },\n                    { multi: true, provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => SliderComponent) },\n                    { provide: KendoInput, useExisting: forwardRef(() => SliderComponent) }\n                ],\n                selector: 'kendo-slider',\n                template: `\n        <ng-container kendoSliderLocalizedMessages\n            i18n-increment=\"kendo.slider.increment|The title of the **Increase** button of the Slider.\"\n            increment=\"increment\"\n            i18n-decrement=\"kendo.slider.decrement|The title of the **Decrease** button of the Slider.\"\n            decrement=\"decrement\"\n            i18n-dragHandle=\"kendo.slider.dragHandle|The title of the drag handle of the Slider.\"\n            dragHandle=\"Drag\"\n        >\n\n        <div class=\"k-slider-wrap\" #wrap\n            [id]=\"focusableId\"\n            [class.k-slider-buttons]=\"showButtons\"\n            [class.k-slider-topleft]=\"tickPlacement === 'before'\"\n            [class.k-slider-bottomright]=\"tickPlacement === 'after'\"\n            [attr.tabindex]=\"(this.disabled ? undefined : tabIndex)\"\n            [kendoEventsOutsideAngular]=\"{ focus: handleFocus, blur: handleBlur, click: onWrapClick, keydown: onKeyDown }\"\n            >\n            <a\n                #decreaseButton\n                *ngIf=\"showButtons\"\n                class=\"k-button k-button-decrease\"\n                [title]=\"decrementMessage\"\n                [attr.aria-label]=\"decrementMessage\"\n            >\n                <span class=\"k-icon\"\n                    [class.k-i-arrow-w]=\"!vertical\"\n                    [class.k-i-arrow-s]=\"vertical\"\n                >\n                </span>\n            </a>\n            <a\n                *ngIf=\"showButtons\"\n                #increaseButton\n                class=\"k-button k-button-increase\"\n                [title]=\"incrementMessage\"\n                [attr.aria-label]=\"incrementMessage\"\n            >\n                <span class=\"k-icon\"\n                    [class.k-i-arrow-e]=\"!vertical\"\n                    [class.k-i-arrow-n]=\"vertical\"\n                >\n                </span>\n            </a>\n            <ul kendoSliderTicks\n                #ticks\n                *ngIf=\"tickPlacement !== 'none'\"\n                [tickTitle]=\"title\"\n                [vertical]=\"vertical\"\n                [step]=\"smallStep\"\n                [largeStep]=\"largeStep\"\n                [min]=\"min\"\n                [max]=\"max\"\n                [labelTemplate]=\"labelTemplate?.templateRef\"\n            >\n            </ul>\n        <div #track class=\"k-slider-track\">\n            <div #sliderSelection class=\"k-slider-selection\">\n            </div>\n                <a #draghandle\n                    [style.touch-action]=\"isDisabled ? '' : 'none'\"\n                    class=\"k-draghandle\"\n                    [title]=\"dragHandleMessage\"\n                    kendoDraggable\n                    (kendoPress)=\"ifEnabled(handleDragPress ,$event)\"\n                    (kendoDrag)=\"ifEnabled(onHandleDrag ,$event)\"\n                    (kendoRelease)=\"ifEnabled(onHandleRelease, $event)\"\n                ></a>\n            </div>\n\n            <kendo-resize-sensor (resize)=\"sizeComponent(false)\"></kendo-resize-sensor>\n        </div>\n  `\n            },] },\n];\n/** @nocollapse */\nSliderComponent.ctorParameters = () => [\n    { type: LocalizationService },\n    { type: Injector },\n    { type: Renderer2 },\n    { type: NgZone },\n    { type: ElementRef }\n];\nSliderComponent.propDecorators = {\n    focusableId: [{ type: Input }],\n    incrementTitle: [{ type: Input }],\n    animate: [{ type: Input }],\n    decrementTitle: [{ type: Input }],\n    showButtons: [{ type: Input }],\n    tickPlacement: [{ type: Input }],\n    title: [{ type: Input }],\n    dragHandleTitle: [{ type: Input }],\n    vertical: [{ type: Input }],\n    min: [{ type: Input }],\n    max: [{ type: Input }],\n    smallStep: [{ type: Input }],\n    largeStep: [{ type: Input }],\n    fixedTickWidth: [{ type: Input }],\n    disabled: [{ type: Input }],\n    readonly: [{ type: Input }],\n    value: [{ type: Input }],\n    tabindex: [{ type: Input }],\n    tabIndex: [{ type: Input }],\n    onFocus: [{ type: Output, args: ['focus',] }],\n    onBlur: [{ type: Output, args: ['blur',] }],\n    valueChange: [{ type: Output }],\n    wrapper: [{ type: ViewChild, args: ['wrap', { static: true },] }],\n    track: [{ type: ViewChild, args: ['track', { static: true },] }],\n    draghandle: [{ type: ViewChild, args: ['draghandle', { static: true },] }],\n    sliderSelection: [{ type: ViewChild, args: ['sliderSelection', { static: true },] }],\n    ticksContainer: [{ type: ViewChild, args: ['ticks', { read: ElementRef },] }],\n    ticks: [{ type: ViewChild, args: ['ticks',] }],\n    decreaseButton: [{ type: ViewChild, args: ['decreaseButton',] }],\n    increaseButton: [{ type: ViewChild, args: ['increaseButton',] }],\n    labelTemplate: [{ type: ContentChild, args: [LabelTemplateDirective,] }],\n    direction: [{ type: HostBinding, args: ['attr.dir',] }],\n    horizontalClass: [{ type: HostBinding, args: ['class.k-slider-horizontal',] }],\n    verticalClass: [{ type: HostBinding, args: ['class.k-slider-vertical',] }],\n    sliderClass: [{ type: HostBinding, args: ['class.k-slider',] }],\n    widgetClass: [{ type: HostBinding, args: ['class.k-widget',] }],\n    stateDefaultClass: [{ type: HostBinding, args: ['class.k-state-default',] }],\n    disabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }],\n    ariaDisabled: [{ type: HostBinding, args: ['attr.aria-disabled',] }],\n    ariaReadonly: [{ type: HostBinding, args: ['attr.aria-readonly',] }],\n    ariaMin: [{ type: HostBinding, args: ['attr.aria-valuemin',] }],\n    ariaMax: [{ type: HostBinding, args: ['attr.aria-valuemax',] }],\n    ariaValue: [{ type: HostBinding, args: ['attr.aria-valuenow',] }]\n};\n\nconst FOCUSED$1 = 'k-state-focused';\n/**\n * Represents the [Kendo UI Switch component for Angular]({% slug overview_switch %}).\n */\nclass SwitchComponent {\n    constructor(renderer, hostElement, localizationService, injector, changeDetector, ngZone) {\n        this.renderer = renderer;\n        this.hostElement = hostElement;\n        this.localizationService = localizationService;\n        this.injector = injector;\n        this.changeDetector = changeDetector;\n        this.ngZone = ngZone;\n        /**\n         * @hidden\n         */\n        this.focusableId = `k-${guid()}`;\n        /**\n         * Sets the current value of the Switch when it is initially displayed.\n         */\n        this.checked = false;\n        /**\n         * Determines whether the Switch is disabled ([see example]({% slug disabled_switch %})).\n         */\n        this.disabled = false;\n        /**\n         * Determines whether the Switch is in its read-only state ([see example]({% slug readonly_switch %})).\n         */\n        this.readonly = false;\n        /**\n         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the Switch.\n         */\n        this.tabindex = 0;\n        /**\n         * Fires each time the user focuses the `input` element.\n         */\n        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the `input` element gets blurred.\n         */\n        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the user selects a new value.\n         */\n        this.valueChange = new EventEmitter();\n        this.ngChange = (_) => { };\n        this.ngTouched = () => { };\n        /**\n         * @hidden\n         */\n        this.handleFocus = () => {\n            this.focused = true;\n            if (hasObservers(this.onFocus)) {\n                this.ngZone.run(() => {\n                    this.onFocus.emit();\n                });\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.handleBlur = () => {\n            this.focused = false;\n            if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {\n                this.ngZone.run(() => {\n                    this.ngTouched();\n                    this.onBlur.emit();\n                });\n            }\n        };\n        this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n        this.keyDownHandler = this.keyDownHandler.bind(this);\n        this.clickHandler = this.clickHandler.bind(this);\n    }\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n        this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n        return this.tabindex;\n    }\n    get ieClass() {\n        return browser && browser.msie;\n    }\n    get ariaDisabled() {\n        return this.disabled ? true : undefined;\n    }\n    get ariaReadonly() {\n        return this.readonly ? true : undefined;\n    }\n    get ariaChecked() {\n        return this.checked ? true : undefined;\n    }\n    get hostClasses() {\n        return true;\n    }\n    get switchOnClass() {\n        return this.checked;\n    }\n    get switchOffClass() {\n        return !this.checked;\n    }\n    get disabledClass() {\n        return this.disabled;\n    }\n    /**\n     * @hidden\n     */\n    get onLabelMessage() {\n        return this.onLabel || this.localizationService.get('on');\n    }\n    /**\n     * @hidden\n     */\n    get offLabelMessage() {\n        return this.offLabel || this.localizationService.get('off');\n    }\n    get isEnabled() {\n        return !this.disabled && !this.readonly;\n    }\n    ngOnInit() {\n        if (this.hostElement) {\n            const wrapper = this.hostElement.nativeElement;\n            this.renderer.removeAttribute(wrapper, \"tabindex\");\n        }\n        this.localizationChangeSubscription = this.localizationService\n            .changes\n            .pipe(skip(1))\n            .subscribe(({ rtl }) => {\n            this.direction = rtl ? 'rtl' : 'ltr';\n        });\n        this.control = this.injector.get(NgControl, null);\n    }\n    ngOnDestroy() {\n        if (this.localizationChangeSubscription) {\n            this.localizationChangeSubscription.unsubscribe();\n        }\n    }\n    /**\n     * Focuses the Switch.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"switch.focus()\">Focus</button>\n     *  <kendo-switch #switch></kendo-switch>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n        if (!this.wrapper) {\n            return;\n        }\n        this.wrapper.nativeElement.focus();\n    }\n    /**\n     * Blurs the Switch.\n     */\n    blur() {\n        if (!this.wrapper) {\n            return;\n        }\n        this.wrapper.nativeElement.blur();\n    }\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     */\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n        this.changeDetector.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n        this.checked = value === null ? false : value;\n        this.changeDetector.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.ngTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    keyDownHandler(e) {\n        const keyCode = e.keyCode;\n        if (this.isEnabled && (keyCode === Keys.Space || keyCode === Keys.Enter)) {\n            this.changeValue(!this.checked);\n            e.preventDefault();\n        }\n    }\n    /**\n     * @hidden\n     */\n    clickHandler() {\n        if (this.isEnabled) {\n            this.changeValue(!this.checked);\n        }\n    }\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the component is empty.\n     */\n    isEmpty() {\n        return false;\n    }\n    changeValue(value) {\n        if (this.checked !== value) {\n            this.ngZone.run(() => {\n                this.checked = value;\n                this.ngChange(value);\n                this.valueChange.emit(value);\n                this.changeDetector.markForCheck();\n            });\n        }\n    }\n    set focused(value) {\n        if (this.isFocused !== value && this.hostElement) {\n            const element = this.hostElement.nativeElement;\n            if (value) {\n                this.renderer.addClass(element, FOCUSED$1);\n            }\n            else {\n                this.renderer.removeClass(element, FOCUSED$1);\n            }\n            this.isFocused = value;\n        }\n    }\n}\nSwitchComponent.decorators = [\n    { type: Component, args: [{\n                exportAs: 'kendoSwitch',\n                providers: [\n                    LocalizationService,\n                    { provide: L10N_PREFIX, useValue: 'kendo.switch' },\n                    {\n                        multi: true,\n                        provide: NG_VALUE_ACCESSOR,\n                        useExisting: forwardRef(() => SwitchComponent) /* tslint:disable-line */\n                    },\n                    {\n                        provide: KendoInput,\n                        useExisting: forwardRef(() => SwitchComponent)\n                    }\n                ],\n                selector: 'kendo-switch',\n                template: `\n        <ng-container kendoSwitchLocalizedMessages\n            i18n-on=\"kendo.switch.on|The **On** label of the Switch.\"\n            on=\"ON\"\n            i18n-off=\"kendo.switch.off|The **Off** label of the Switch.\"\n            off=\"OFF\"\n        >\n\n        <span\n            #wrapper\n            class=\"k-switch-container\"\n            [id]=\"focusableId\"\n            [attr.tabindex]=\"(disabled ? undefined : tabIndex)\"\n            [kendoEventsOutsideAngular]=\"{ click: clickHandler, keydown: keyDownHandler, focus: handleFocus, blur: handleBlur }\"\n        >\n            <span class=\"k-switch-label-on\">{{onLabelMessage}}</span>\n            <span class=\"k-switch-label-off\">{{offLabelMessage}}</span>\n            <span class=\"k-switch-handle\"></span>\n        </span>\n  `\n            },] },\n];\n/** @nocollapse */\nSwitchComponent.ctorParameters = () => [\n    { type: Renderer2 },\n    { type: ElementRef },\n    { type: LocalizationService },\n    { type: Injector },\n    { type: ChangeDetectorRef },\n    { type: NgZone }\n];\nSwitchComponent.propDecorators = {\n    focusableId: [{ type: Input }],\n    onLabel: [{ type: Input }],\n    offLabel: [{ type: Input }],\n    checked: [{ type: Input }],\n    disabled: [{ type: Input }],\n    readonly: [{ type: Input }],\n    tabindex: [{ type: Input }],\n    tabIndex: [{ type: Input }],\n    onFocus: [{ type: Output, args: ['focus',] }],\n    onBlur: [{ type: Output, args: ['blur',] }],\n    valueChange: [{ type: Output }],\n    wrapper: [{ type: ViewChild, args: ['wrapper',] }],\n    direction: [{ type: HostBinding, args: ['attr.dir',] }],\n    ieClass: [{ type: HostBinding, args: ['class.k-ie',] }],\n    ariaDisabled: [{ type: HostBinding, args: ['attr.aria-disabled',] }],\n    ariaReadonly: [{ type: HostBinding, args: ['attr.aria-readonly',] }],\n    ariaChecked: [{ type: HostBinding, args: ['attr.aria-checked',] }],\n    hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-switch',] }],\n    switchOnClass: [{ type: HostBinding, args: ['class.k-switch-on',] }],\n    switchOffClass: [{ type: HostBinding, args: ['class.k-switch-off',] }],\n    disabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }]\n};\n\n/**\n * Represents the [Kendo UI TextArea directive for the Inputs components for Angular]({% slug overview_textarea %}).\n * Provides floating labels to `textarea` elements.\n *\n * @example\n * ```ts-no-run\n * <textarea kendoTextArea></textarea>\n * ```\n */\nclass TextAreaDirective {\n    constructor(renderer, element, zone, changeDetector, injector, rtl) {\n        this.renderer = renderer;\n        this.element = element;\n        this.zone = zone;\n        this.changeDetector = changeDetector;\n        this.injector = injector;\n        this.elementClass = true;\n        this.autofillClass = true;\n        /**\n         * Fires each time the textarea value is changed.\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * Specifies if the `textarea` element will resize its height automatically\n         * ([see example]({% slug overview_textarea %}#toc-auto-resizing)).\n         *\n         * @default false\n         */\n        this.autoSize = false;\n        /**\n         * @hidden\n         */\n        this.onFocus = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.onBlur = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.onValueChange = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.autoFillStart = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.autoFillEnd = new EventEmitter();\n        this.listeners = [];\n        this.ngChange = (_) => { };\n        this.ngTouched = () => { };\n        this.direction = rtl ? 'rtl' : 'ltr';\n    }\n    get id() {\n        return this.element.nativeElement.id;\n    }\n    set id(id) {\n        this.renderer.setAttribute(this.element.nativeElement, 'id', id);\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n        this.elementValue = value;\n        this.resize();\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.ngTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n        this.setElementProperty('disabled', isDisabled);\n    }\n    ngOnInit() {\n        const element = this.element.nativeElement;\n        this.zone.runOutsideAngular(() => {\n            this.listeners = [\n                this.renderer.listen(element, 'focus', this.handleFocus.bind(this)),\n                this.renderer.listen(element, 'blur', this.handleBlur.bind(this)),\n                this.renderer.listen(element, 'animationstart', (e) => {\n                    if (e.animationName === 'autoFillStart') {\n                        this.autoFillStart.emit();\n                    }\n                    else if (e.animationName === 'autoFillEnd') {\n                        this.autoFillEnd.emit();\n                    }\n                })\n            ];\n            if (isDocumentAvailable() && this.autoSize) {\n                this.resizeSubscription = fromEvent(window, 'resize')\n                    .pipe((debounceTime(50)))\n                    .subscribe(() => this.resize());\n            }\n            this.inputSubscription = fromEvent(element, 'input')\n                .subscribe(this.handleInput.bind(this));\n        });\n        this.control = this.injector.get(NgControl, null);\n    }\n    ngOnChanges(changes) {\n        const element = this.element.nativeElement;\n        if (changes.value) {\n            this.elementValue = this.value;\n        }\n        if (changes.autoSize) {\n            if (this.autoSize) {\n                this.initialHeight = element.offsetHeight;\n                this.renderer.setStyle(element, 'resize', 'none');\n            }\n            else {\n                this.renderer.setStyle(element, 'overflow-y', 'auto');\n                this.renderer.setStyle(element, 'resize', 'both');\n                element.style.height = `${this.initialHeight}px`;\n            }\n        }\n        this.resize();\n    }\n    ngOnDestroy() {\n        this.listeners.forEach(listener => listener());\n        if (this.inputSubscription) {\n            this.inputSubscription.unsubscribe();\n        }\n        if (this.resizeSubscription) {\n            this.resizeSubscription.unsubscribe();\n        }\n    }\n    get elementValue() {\n        if (this.element) {\n            return this.element.nativeElement.value;\n        }\n        return '';\n    }\n    set elementValue(value) {\n        this.setElementProperty('value', (value === undefined || value === null) ? '' : value);\n    }\n    setElementProperty(name, value) {\n        if (this.element) {\n            this.renderer.setProperty(this.element.nativeElement, name, value);\n        }\n    }\n    resize() {\n        if (!this.autoSize) {\n            return;\n        }\n        const element = this.element.nativeElement;\n        this.renderer.setStyle(element, 'overflow-y', 'hidden');\n        element.style.height = `${this.initialHeight}px`;\n        const scrollHeight = element.scrollHeight;\n        if (scrollHeight > this.initialHeight) {\n            element.style.height = `${scrollHeight}px`;\n        }\n    }\n    handleInput() {\n        const value = this.elementValue;\n        this.value = value;\n        if (this.control || hasObservers(this.onValueChange) || hasObservers(this.valueChange)) {\n            this.zone.run(() => {\n                this.ngChange(value);\n                this.onValueChange.emit(value);\n                this.valueChange.emit(value);\n                this.changeDetector.markForCheck();\n            });\n        }\n        this.resize();\n    }\n    handleFocus() {\n        if (hasObservers(this.onFocus)) {\n            this.zone.run(() => {\n                this.onFocus.emit();\n            });\n        }\n    }\n    handleBlur() {\n        if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {\n            this.zone.run(() => {\n                this.ngTouched();\n                this.onBlur.emit();\n                this.changeDetector.markForCheck();\n            });\n        }\n    }\n}\nTextAreaDirective.decorators = [\n    { type: Directive, args: [{\n                providers: [{\n                        provide: NG_VALUE_ACCESSOR,\n                        useExisting: forwardRef(() => TextAreaDirective),\n                        multi: true\n                    }, {\n                        provide: KendoInput,\n                        useExisting: forwardRef(() => TextAreaDirective)\n                    }],\n                selector: 'textarea[kendoTextArea]'\n            },] },\n];\n/** @nocollapse */\nTextAreaDirective.ctorParameters = () => [\n    { type: Renderer2 },\n    { type: ElementRef },\n    { type: NgZone },\n    { type: ChangeDetectorRef },\n    { type: Injector },\n    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [RTL,] }] }\n];\nTextAreaDirective.propDecorators = {\n    elementClass: [{ type: HostBinding, args: ['class.k-textarea',] }],\n    autofillClass: [{ type: HostBinding, args: ['class.k-autofill',] }],\n    direction: [{ type: HostBinding, args: ['attr.dir',] }],\n    valueChange: [{ type: Output }],\n    autoSize: [{ type: Input }],\n    value: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nclass FloatingLabelInputAdapter {\n    constructor(component, formControl) {\n        this.component = component;\n        const isObservableOrEventEmitter = (event) => event instanceof Observable || event instanceof EventEmitter;\n        if (isObservableOrEventEmitter(component.onFocus)) {\n            this.onFocus = component.onFocus;\n        }\n        if (isObservableOrEventEmitter(component.autoFillStart)) {\n            this.autoFillStart = component.autoFillStart;\n        }\n        if (isObservableOrEventEmitter(component.autoFillEnd)) {\n            this.autoFillEnd = component.autoFillEnd;\n        }\n        if (isObservableOrEventEmitter(component.onBlur)) {\n            this.onBlur = component.onBlur;\n        }\n        if (formControl) {\n            this.onValueChange = formControl.valueChanges;\n        }\n        else if (component.onValueChange) {\n            this.onValueChange = component.onValueChange;\n        }\n    }\n    get focusableId() {\n        const component = this.component;\n        if ('focusableId' in component) {\n            return component.focusableId;\n        }\n        else if ('id' in component) {\n            return component.id;\n        }\n        return \"\";\n    }\n    set focusableId(value) {\n        const component = this.component;\n        if ('focusableId' in component) {\n            component.focusableId = value;\n        }\n        else if ('id' in component) {\n            component.id = value;\n        }\n    }\n}\n\nconst isFunction = (x) => Object.prototype.toString.call(x) === '[object Function]';\n/**\n * @hidden\n */\nclass TextBoxContainerComponent {\n    constructor(elementRef, renderer, changeDetectorRef, rtl) {\n        this.elementRef = elementRef;\n        this.renderer = renderer;\n        this.changeDetectorRef = changeDetectorRef;\n        /**\n         * @hidden\n         */\n        this.focused = false;\n        /**\n         * @hidden\n         */\n        this.empty = true;\n        /**\n         * @hidden\n         */\n        this.invalid = false;\n        this._subscriptions = [];\n        this.autoFillStarted = false;\n        this.direction = rtl ? 'rtl' : 'ltr';\n        this.renderer.removeAttribute(this.elementRef.nativeElement, \"id\");\n    }\n    get hostClasses() {\n        return true;\n    }\n    get textareaElementClass() {\n        return !!this.textarea;\n    }\n    get focusedClass() {\n        return this.focused;\n    }\n    get invalidClass() {\n        return this.invalid;\n    }\n    /**\n     * @hidden\n     */\n    ngAfterContentInit() {\n        if (!this.formControl && !this.kendoInput) {\n            if (isDevMode()) {\n                throw new Error(\"The TextBoxContainer requires a Kendo Input component\" +\n                    \" or a forms-bound component to function properly.\");\n            }\n            return;\n        }\n        // add focus/blur/valueChange handlers\n        const control = new FloatingLabelInputAdapter(this.kendoInput || this.formControl.valueAccessor, this.formControl);\n        const setFocus = (isFocused) => () => {\n            this.focused = isFocused;\n            this.updateState();\n        };\n        this.subscribe(control, 'onFocus', setFocus(true));\n        this.subscribe(control, 'onBlur', setFocus(false));\n        this.subscribe(control, 'autoFillStart', () => {\n            this.autoFillStarted = true;\n            this.renderer.removeClass(this.elementRef.nativeElement, 'k-state-empty');\n        });\n        this.subscribe(control, 'autoFillEnd', () => {\n            if (this.autoFillStarted) {\n                this.autoFillStarted = false;\n                if (this.empty) {\n                    this.renderer.addClass(this.elementRef.nativeElement, 'k-state-empty');\n                }\n            }\n        });\n        const updateState = () => this.updateState();\n        updateState();\n        this.subscribe(control, 'onValueChange', updateState);\n        // set label id for floating label\n        if (this.id && control.focusableId) {\n            // input wins\n            this.id = control.focusableId;\n        }\n        else if (this.id) {\n            control.focusableId = this.id;\n        }\n        else if (control.focusableId) {\n            this.id = control.focusableId;\n        }\n        else {\n            const id = \"_\" + guid();\n            control.focusableId = id;\n            this.id = id;\n        }\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n        this._subscriptions.forEach(s => s.unsubscribe());\n        this._subscriptions = [];\n    }\n    subscribe(control, eventName, handler) {\n        if (control[eventName] instanceof EventEmitter) {\n            const subscription = control[eventName].subscribe(handler);\n            this._subscriptions.push(subscription);\n        }\n    }\n    updateState() {\n        const empty = value => {\n            // zero is not an empty value (e.g., NumericTextBox)\n            if (value === 0 || value === false) {\n                return false;\n            }\n            // empty arrays are an empty value (e.g., MultiSelect)\n            if (Array.isArray(value) && !value.length) {\n                return true;\n            }\n            return !value;\n        };\n        const formControl = this.formControl;\n        if (formControl) {\n            const valueAccessor = formControl.valueAccessor;\n            if (isFunction(valueAccessor.isEmpty)) {\n                this.empty = valueAccessor.isEmpty();\n            }\n            else {\n                this.empty = empty(formControl.value);\n            }\n            this.invalid = formControl.invalid && (formControl.touched || formControl.dirty);\n        }\n        else {\n            this.empty = isFunction(this.kendoInput.isEmpty) ?\n                this.kendoInput.isEmpty() : empty(this.kendoInput.value);\n        }\n        if (this.empty) {\n            this.renderer.addClass(this.elementRef.nativeElement, 'k-state-empty');\n        }\n        else {\n            this.renderer.removeClass(this.elementRef.nativeElement, 'k-state-empty');\n        }\n        this.changeDetectorRef.markForCheck();\n    }\n}\nTextBoxContainerComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-textbox-container',\n                template: `\n        <ng-content></ng-content>\n        <label *ngIf=\"floatingLabel\" [for]=\"id\" class=\"k-label\">{{ floatingLabel }}</label>\n    `\n            },] },\n];\n/** @nocollapse */\nTextBoxContainerComponent.ctorParameters = () => [\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: ChangeDetectorRef },\n    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [RTL,] }] }\n];\nTextBoxContainerComponent.propDecorators = {\n    hostClasses: [{ type: HostBinding, args: ['class.k-textbox-container',] }],\n    textareaElementClass: [{ type: HostBinding, args: ['class.k-textarea-wrapper',] }],\n    focusedClass: [{ type: HostBinding, args: ['class.k-state-focused',] }],\n    invalidClass: [{ type: HostBinding, args: ['class.k-state-invalid',] }],\n    direction: [{ type: HostBinding, args: ['attr.dir',] }],\n    id: [{ type: Input }],\n    floatingLabel: [{ type: Input }],\n    kendoInput: [{ type: ContentChild, args: [KendoInput,] }],\n    textarea: [{ type: ContentChild, args: [TextAreaDirective,] }],\n    formControl: [{ type: ContentChild, args: [NgControl,] }]\n};\n\n/**\n * Represents the [Kendo UI TextBox directive]({% slug overview_textbox %}) for the Inputs components for Angular.\n * Used to style the textbox of any `input` element.\n *\n * @example\n * ```ts-no-run\n * <input kendoTextBox />\n * <input kendoTextBox type=\"email\" />\n * <input kendoTextBox type=\"password\" />\n * ```\n */\nclass TextBoxDirective {\n    constructor(renderer, inputElement, ngZone) {\n        this.renderer = renderer;\n        this.inputElement = inputElement;\n        this.ngZone = ngZone;\n        this.hostClass = true;\n        /**\n         * @hidden\n         */\n        this.onFocus = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.onBlur = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.onValueChange = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.autoFillStart = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.autoFillEnd = new EventEmitter();\n        this.listeners = [];\n    }\n    /**\n     * @hidden\n     */\n    set value(text) {\n        if (!this.inputElement) {\n            return;\n        }\n        this.inputElement.nativeElement.value = (text === undefined || text === null) ? '' : text;\n        this.onValueChange.emit();\n    }\n    /**\n     * @hidden\n     */\n    get value() {\n        return this.inputElement.nativeElement.value;\n    }\n    get id() {\n        return this.inputElement.nativeElement.id;\n    }\n    set id(id) {\n        this.renderer.setAttribute(this.inputElement.nativeElement, 'id', id);\n    }\n    ngAfterViewInit() {\n        const input = this.inputElement.nativeElement;\n        this.listeners = [\n            this.renderer.listen(input, 'focus', () => this.onFocus.emit()),\n            this.renderer.listen(input, 'blur', () => this.onBlur.emit())\n        ];\n        this.ngZone.runOutsideAngular(() => {\n            this.renderer.listen(input, 'animationstart', (e) => {\n                if (e.animationName === 'autoFillStart') {\n                    this.autoFillStart.emit();\n                }\n                else if (e.animationName === 'autoFillEnd') {\n                    this.autoFillEnd.emit();\n                }\n            });\n        });\n    }\n    ngOnDestroy() {\n        this.listeners.forEach(listener => listener());\n    }\n}\nTextBoxDirective.decorators = [\n    { type: Directive, args: [{\n                selector: 'input[kendoTextBox]',\n                providers: [{\n                        provide: KendoInput,\n                        useExisting: forwardRef(() => TextBoxDirective)\n                    }]\n            },] },\n];\n/** @nocollapse */\nTextBoxDirective.ctorParameters = () => [\n    { type: Renderer2 },\n    { type: ElementRef },\n    { type: NgZone }\n];\nTextBoxDirective.propDecorators = {\n    hostClass: [{ type: HostBinding, args: ['class.k-textbox',] }],\n    value: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nconst createMaxValidator = (maxValue) => {\n    return (c) => {\n        const err = {\n            maxError: {\n                maxValue: maxValue,\n                value: c.value\n            }\n        };\n        return (c.value !== null && c.value > maxValue) ? err : null;\n    };\n};\n\n/**\n * @hidden\n */\nconst createMinValidator = (minValue) => {\n    return (c) => {\n        const err = {\n            minError: {\n                minValue: minValue,\n                value: c.value\n            }\n        };\n        return (c.value !== null && c.value < minValue) ? err : null;\n    };\n};\n\n/**\n * @hidden\n */\nconst MIN_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/inputs/api/NumericTextBoxComponent/#toc-min';\n/**\n * @hidden\n */\nconst MAX_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/inputs/api/NumericTextBoxComponent/#toc-max';\n/**\n * @hidden\n */\nconst POINT = \".\";\n/**\n * @hidden\n */\nconst INITIAL_SPIN_DELAY = 500;\n/**\n * @hidden\n */\nconst SPIN_DELAY = 50;\n/**\n * @hidden\n */\nconst EXPONENT_REGEX = /[eE][\\-+]?([0-9]+)/;\n\n/**\n * @hidden\n */\nconst numericRegex = (options) => {\n    const { autoCorrect, decimals, min } = options;\n    let separator = options.separator;\n    if (separator === POINT) {\n        separator = '\\\\' + separator;\n    }\n    const signPattern = autoCorrect && min !== null && min >= 0 ? '' : '-?';\n    let numberPattern;\n    if (decimals === 0) {\n        numberPattern = '\\\\d*';\n    }\n    else {\n        numberPattern = `(?:(?:\\\\d+(${separator}\\\\d*)?)|(?:${separator}\\\\d*))?`;\n    }\n    return new RegExp(`^${signPattern}${numberPattern}$`);\n};\n/**\n * @hidden\n */\nconst decimalPart = (value) => {\n    return value >= 0 ? Math.floor(value) : Math.ceil(value);\n};\n/**\n * @hidden\n */\nconst noop = (_) => { }; // tslint:disable-line:no-empty\n/**\n * @hidden\n */\nconst defined = (value) => {\n    return typeof value !== 'undefined';\n};\n/**\n * @hidden\n */\nconst isNumber = (value) => {\n    return !isNaN(value) && value !== null;\n};\n/**\n * @hidden\n */\nfunction pad(value, digits) {\n    const count = digits - String(value).length;\n    let result = value;\n    if (count > 0) {\n        const padString = new Array(count + 1).join(\"0\");\n        result = parseFloat(value + padString);\n    }\n    return result;\n}\n/**\n * @hidden\n */\nconst getDeltaFromMouseWheel = (e) => {\n    let delta = 0;\n    if (e.wheelDelta) {\n        delta = e.wheelDelta / 120;\n        delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);\n    }\n    else if (e.detail) {\n        delta = Math.round(-e.detail / 3);\n    }\n    return delta;\n};\n/**\n * @hidden\n */\nconst getCaretPosition = (element) => element.selectionStart;\n/**\n * @hidden\n */\nconst extractSignificantNumericChars = (formattedString, separator) => {\n    const significantCharacters = `${separator}0123456789-`;\n    return formattedString.split('').reduce((acc, curr) => significantCharacters.includes(curr) ? ++acc : acc, 0);\n};\n\n/**\n * @hidden\n */\nvar ArrowDirection;\n(function (ArrowDirection) {\n    ArrowDirection[ArrowDirection[\"Down\"] = -1] = \"Down\";\n    ArrowDirection[ArrowDirection[\"None\"] = 0] = \"None\";\n    ArrowDirection[ArrowDirection[\"Up\"] = 1] = \"Up\";\n})(ArrowDirection || (ArrowDirection = {}));\n\nconst PARSABLE_OPTIONS = ['min', 'max', 'step', 'decimals'];\nconst PARSABLE_DEFAULTS = {\n    decimals: null,\n    max: null,\n    min: null,\n    step: 1\n};\nconst FOCUSED$2 = 'k-state-focused';\nconst FORMATTED_VALUE = 'k-formatted-value';\n/**\n * Represents the [Kendo UI NumericTextBox component for Angular]({% slug overview_numerictextbox %}).\n */\nclass NumericTextBoxComponent {\n    constructor(intl, renderer, localizationService, injector, ngZone, changeDetector, hostElement) {\n        this.intl = intl;\n        this.renderer = renderer;\n        this.localizationService = localizationService;\n        this.injector = injector;\n        this.ngZone = ngZone;\n        this.changeDetector = changeDetector;\n        this.hostElement = hostElement;\n        /**\n         * @hidden\n         */\n        this.focusableId = `k-${guid()}`;\n        /**\n         * Determines whether the NumericTextBox is disabled ([see example]({% slug disabled_numerictextbox %})).\n         */\n        this.disabled = false;\n        /**\n         * Determines whether the NumericTextBox is in its read-only state ([see example]({% slug readonly_numerictextbox %})).\n         */\n        this.readonly = false;\n        /**\n         * Sets the title of the `input` element of the NumericTextBox.\n         */\n        this.title = '';\n        /**\n         * Specifies whether the value will be auto-corrected based on the minimum and maximum values\n         * ([see example]({% slug precision_numerictextbox %})).\n         */\n        this.autoCorrect = false;\n        /**\n         * Specifies the number of decimals that the user can enter when the input is focused\n         * ([see example]({% slug precision_numerictextbox %})).\n         */\n        this.decimals = null;\n        /**\n         * Specifies the value that is used to increment or decrement the component value\n         * ([see example]({% slug predefinedsteps_numerictextbox %})).\n         */\n        this.step = 1;\n        /**\n         * Specifies whether the **Up** and **Down** spin buttons will be rendered\n         * ([see example]({% slug spinbuttons_numerictextbox %})).\n         */\n        this.spinners = true;\n        /**\n         * Determines whether the built-in minimum or maximum validators are enforced when a form is validated.\n         *\n         * > The 4.2.0 Angular version introduces the `min` and `max` validation directives. As a result, even if you set `rangeValidation`\n         * to `false`, the built-in Angular validators will be executed.\n         */\n        this.rangeValidation = true;\n        /**\n         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n         */\n        this.tabindex = 0;\n        /**\n         * Determines whether the whole value will be selected when the NumericTextBox is clicked. Defaults to `true`.\n         */\n        this.selectOnFocus = true;\n        /**\n         * Specifies the value of the NumericTextBox\n         * ([see example]({% slug formats_numerictextbox %})).\n         */\n        this.value = null;\n        /**\n         * Fires each time the user selects a new value ([see example]({% slug overview_numerictextbox %}#toc-events)).\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * Fires each time the user focuses the `input` element ([see example]({% slug overview_numerictextbox %}#toc-events)).\n         */\n        this.onFocus = new EventEmitter();\n        /**\n         * Fires each time the `input` element gets blurred ([see example]({% slug overview_numerictextbox %}#toc-events)).\n         */\n        this.onBlur = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.ArrowDirection = ArrowDirection;\n        /**\n         * @hidden\n         */\n        this.arrowDirection = ArrowDirection.None;\n        this.inputValue = '';\n        this.minValidateFn = noop;\n        this.maxValidateFn = noop;\n        this._format = \"n2\";\n        this.isPasted = false;\n        this.mouseDown = false;\n        this.ngChange = noop;\n        this.ngTouched = noop;\n        this.ngValidatorChange = noop;\n        /**\n         * @hidden\n         */\n        this.increasePress = (e) => {\n            this.arrowPress(ArrowDirection.Up, e);\n        };\n        /**\n         * @hidden\n         */\n        this.decreasePress = (e) => {\n            this.arrowPress(ArrowDirection.Down, e);\n        };\n        /**\n         * @hidden\n         */\n        this.releaseArrow = () => {\n            clearTimeout(this.spinTimeout);\n            if (this.arrowDirection !== ArrowDirection.None) {\n                this.arrowDirection = ArrowDirection.None;\n                this.changeDetector.detectChanges();\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.handlePaste = () => {\n            this.isPasted = true;\n        };\n        /**\n         * @hidden\n         */\n        this.handleInput = () => {\n            const input = this.numericInput.nativeElement;\n            let { selectionStart, selectionEnd, value: inputValue } = input;\n            if (this.pressedKey === Keys.NumpadDecimal) {\n                inputValue = this.replaceNumpadDotValue();\n            }\n            if (this.isPasted) {\n                inputValue = this.formatInputValue(this.intl.parseNumber(inputValue));\n            }\n            if (!this.isValid(inputValue)) {\n                input.value = this.inputValue;\n                this.setSelection(selectionStart - 1, selectionEnd - 1);\n                return;\n            }\n            const parsedValue = this.intl.parseNumber(inputValue);\n            let value = this.restrictDecimals(parsedValue);\n            if (this.autoCorrect) {\n                const limited = this.limitInputValue(value);\n                value = limited.value;\n                selectionStart = limited.selectionStart;\n                selectionEnd = limited.selectionEnd;\n            }\n            if (parsedValue !== value || this.hasTrailingZeros(inputValue) || !this.focused) {\n                this.setInputValue(value);\n                this.setSelection(selectionStart, selectionEnd);\n            }\n            else {\n                this.inputValue = inputValue;\n            }\n            if (this.isPasted) {\n                input.value = this.inputValue;\n            }\n            this.updateValue(value);\n            this.previousSelection = null;\n            this.isPasted = false;\n        };\n        /**\n         * @hidden\n         */\n        this.handleDragEnter = () => {\n            if (!this.focused && !this.isDisabled) {\n                this.setInputValue(this.value, true);\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.handleMouseDown = () => {\n            this.mouseDown = true;\n        };\n        /**\n         * @hidden\n         */\n        this.handleFocus = () => {\n            if (!this.focused) {\n                this.focused = true;\n                if (!this.isDisabled) {\n                    const shouldSelectAll = this.selectOnFocus || !this.mouseDown;\n                    this.ngZone.runOutsideAngular(() => {\n                        setTimeout(() => {\n                            if (shouldSelectAll) {\n                                this.selectAll();\n                            }\n                            else {\n                                this.selectCaret();\n                            }\n                        }, 0);\n                    });\n                }\n            }\n            this.mouseDown = false;\n            if (hasObservers(this.onFocus)) {\n                this.ngZone.run(() => {\n                    this.onFocus.emit();\n                });\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.handleBlur = () => {\n            this.focused = false;\n            //blur is thrown before input when dragging the input text in IE\n            if (this.inputValue !== this.elementValue) {\n                this.handleInput();\n            }\n            this.setInputValue();\n            if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {\n                this.ngZone.run(() => {\n                    this.ngTouched();\n                    this.onBlur.emit();\n                });\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.handleKeyDown = (e) => {\n            if (this.isDisabled) {\n                return;\n            }\n            let step;\n            if (e.keyCode === Keys.ArrowDown) {\n                step = -1;\n            }\n            else if (e.keyCode === Keys.ArrowUp) {\n                step = 1;\n            }\n            if (step && this.step) {\n                e.preventDefault();\n                this.addStep(step);\n            }\n            const input = this.numericInput.nativeElement;\n            this.previousSelection = {\n                end: input.selectionEnd,\n                start: input.selectionStart\n            };\n            this.pressedKey = e.keyCode;\n        };\n        /**\n         * @hidden\n         */\n        this.handleWheel = (e) => {\n            if (this.focused && !this.isDisabled) {\n                e.preventDefault();\n                const delta = getDeltaFromMouseWheel(e);\n                this.addStep(delta);\n            }\n        };\n        this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n    }\n    /**\n     * Specifies the number format which is used when the NumericTextBox is not focused\n     * ([see example]({% slug formats_numerictextbox %})).\n     * If `format` is set to `null` or `undefined`, the default format will be used.\n     */\n    get format() {\n        const format = this._format;\n        return format !== null && format !== undefined ? format : 'n2';\n    }\n    set format(value) {\n        this._format = value;\n    }\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n        this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n        return this.tabindex;\n    }\n    get widgetClasses() {\n        return true;\n    }\n    ngOnInit() {\n        this.subscriptions = this.localizationService\n            .changes\n            .subscribe(({ rtl }) => {\n            this.direction = rtl ? 'rtl' : 'ltr';\n        });\n        this.subscriptions.add(this.intl.changes.subscribe(this.intlChange.bind(this)));\n        if (this.hostElement) {\n            this.renderer.removeAttribute(this.hostElement.nativeElement, \"tabindex\");\n        }\n        this.control = this.injector.get(NgControl, null);\n    }\n    /**\n     * @hidden\n     */\n    ngOnChanges(changes) {\n        if (anyChanged(PARSABLE_OPTIONS, changes, false)) {\n            this.parseOptions(PARSABLE_OPTIONS.filter(option => changes[option]));\n        }\n        this.verifySettings();\n        if (anyChanged(['min', 'max', 'rangeValidation'], changes, false)) {\n            this.minValidateFn = this.rangeValidation ? createMinValidator(this.min) : noop;\n            this.maxValidateFn = this.rangeValidation ? createMaxValidator(this.max) : noop;\n            this.ngValidatorChange();\n        }\n        if (anyChanged(['autoCorrect', 'decimals', 'min'], changes)) {\n            delete this.numericRegex;\n        }\n        if (anyChanged(['value', 'format'], changes, false)) {\n            this.verifyValue(this.value);\n            this.value = this.restrictModelValue(this.value);\n            if (!this.focused || (this.intl.parseNumber(this.elementValue) !== this.value)) {\n                this.setInputValue();\n            }\n        }\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n        if (this.subscriptions) {\n            this.subscriptions.unsubscribe();\n        }\n        clearTimeout(this.spinTimeout);\n    }\n    /**\n     * @hidden\n     */\n    validate(control) {\n        return this.minValidateFn(control) || this.maxValidateFn(control);\n    }\n    /**\n     * @hidden\n     */\n    registerOnValidatorChange(fn) {\n        this.ngValidatorChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n        this.verifyValue(value);\n        let restrictedValue = this.restrictModelValue(value);\n        this.value = restrictedValue;\n        this.setInputValue();\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.ngTouched = fn;\n    }\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     *\n     * @param isDisabled\n     */\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n    }\n    /**\n     * Focuses the NumericTextBox.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"numerictextbox.focus()\">Focus NumericTextBox</button>\n     *  <kendo-numerictextbox #numerictextbox></kendo-numerictextbox>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n        invokeElementMethod(this.numericInput, 'focus');\n    }\n    /**\n     * Blurs the NumericTextBox.\n     */\n    blur() {\n        invokeElementMethod(this.numericInput, 'blur');\n    }\n    /**\n     * Notifies the `NumericTextBoxComponent` that the input value should be changed.\n     * Can be used to update the input after setting the component properties directly.\n     */\n    notifyValueChange() {\n        this.setInputValue();\n    }\n    /**\n     * @hidden\n     */\n    get incrementTitle() {\n        return this.localizationService.get('increment');\n    }\n    /**\n     * @hidden\n     */\n    get decrementTitle() {\n        return this.localizationService.get('decrement');\n    }\n    get decimalSeparator() {\n        const numberSymbols = this.intl.numberSymbols();\n        return numberSymbols.decimal;\n    }\n    get elementValue() {\n        return this.numericInput.nativeElement.value;\n    }\n    set elementValue(value) {\n        this.renderer.setProperty(this.numericInput.nativeElement, 'value', value);\n    }\n    get focused() {\n        return this.isFocused;\n    }\n    get hasDecimals() {\n        return this.decimals !== null && this.decimals >= 0;\n    }\n    set focused(value) {\n        if (this.isFocused !== value && this.numericWrap) {\n            const wrap = this.numericWrap.nativeElement;\n            const input = this.numericInput.nativeElement;\n            if (value) {\n                this.renderer.addClass(wrap, FOCUSED$2);\n                if (!this.isDisabled) {\n                    this.renderer.removeClass(input, FORMATTED_VALUE);\n                }\n            }\n            else {\n                this.renderer.removeClass(wrap, FOCUSED$2);\n                this.renderer.addClass(input, FORMATTED_VALUE);\n            }\n            this.isFocused = value;\n        }\n    }\n    get isDisabled() {\n        return this.disabled || this.readonly;\n    }\n    arrowPress(direction, e) {\n        e.preventDefault();\n        if (this.isDisabled) {\n            return;\n        }\n        if (!mobileOS) {\n            this.focused = true;\n            this.focus();\n        }\n        if (this.arrowDirection !== direction) {\n            this.arrowDirection = direction;\n            this.changeDetector.detectChanges();\n        }\n        if (this.step) {\n            this.spin(direction, INITIAL_SPIN_DELAY);\n        }\n        else {\n            this.setInputValue();\n        }\n    }\n    updateValue(value) {\n        if (!areSame(this.value, value)) {\n            this.ngZone.run(() => {\n                this.value = value;\n                this.ngChange(value);\n                this.valueChange.emit(value);\n                this.changeDetector.markForCheck();\n            });\n        }\n    }\n    replaceNumpadDotValue() {\n        let value = this.inputValue || \"\";\n        if (this.previousSelection) {\n            const input = this.numericInput.nativeElement;\n            const { selectionStart, selectionEnd } = input;\n            const { start, end } = this.previousSelection;\n            input.value = value = value.substring(0, start) + this.decimalSeparator + value.substring(end);\n            this.setSelection(selectionStart, selectionEnd);\n        }\n        return value;\n    }\n    isValid(value) {\n        if (!this.numericRegex) {\n            this.numericRegex = numericRegex({\n                autoCorrect: this.autoCorrect,\n                decimals: this.decimals,\n                min: this.min,\n                separator: this.decimalSeparator\n            });\n        }\n        return this.numericRegex.test(value);\n    }\n    spin(step, timeout) {\n        clearTimeout(this.spinTimeout);\n        this.spinTimeout = window.setTimeout(() => {\n            this.spin(step, SPIN_DELAY);\n        }, timeout);\n        this.addStep(step);\n    }\n    addStep(step) {\n        let value = add(this.value || 0, this.step * step);\n        value = this.limitValue(value);\n        value = this.restrictDecimals(value);\n        this.setInputValue(value);\n        this.updateValue(value);\n    }\n    setSelection(start, end) {\n        if (this.focused) {\n            invokeElementMethod(this.numericInput, 'setSelectionRange', start, end);\n        }\n    }\n    limitValue(value) {\n        let result = value;\n        if (!this.isInRange(value)) {\n            if (isNumber(this.max) && value > this.max) {\n                result = this.max;\n            }\n            if (isNumber(this.min) && value < this.min) {\n                result = this.min;\n            }\n        }\n        return result;\n    }\n    limitInputValue(value) {\n        let { selectionStart, selectionEnd, value: enteredValue } = this.numericInput.nativeElement;\n        let limitedValue = value;\n        let selectToEnd = false;\n        if (!this.isInRange(value)) {\n            const lengthChange = enteredValue.length - String(this.inputValue).length;\n            const { min, max } = this;\n            const hasMax = isNumber(max);\n            const hasMin = isNumber(min);\n            let padLimit, replaceNext;\n            let correctedValue = value;\n            if (selectionStart === 0 && this.inputValue.substr(1) === enteredValue) {\n                return {\n                    selectionEnd: selectionEnd,\n                    selectionStart: selectionStart,\n                    value: null\n                };\n            }\n            if (hasMax && value > max) {\n                if (value > 0) {\n                    replaceNext = true;\n                }\n                else {\n                    padLimit = max;\n                }\n            }\n            else if (hasMin && value < min) {\n                if (value > 0) {\n                    padLimit = min;\n                }\n                else {\n                    replaceNext = true;\n                }\n            }\n            if (padLimit) {\n                const paddedValue = this.tryPadValue(value, padLimit);\n                if (paddedValue && decimalPart(value) !== decimalPart(padLimit)) {\n                    correctedValue = paddedValue;\n                    selectToEnd = true;\n                }\n            }\n            else if (replaceNext) {\n                if (this.inputValue && selectionStart !== enteredValue.length) {\n                    correctedValue = parseFloat(enteredValue.substr(0, selectionStart) +\n                        enteredValue.substr(selectionStart + lengthChange));\n                }\n            }\n            limitedValue = this.limitValue(correctedValue);\n            selectToEnd = (selectToEnd || limitedValue !== correctedValue) && this.previousSelection &&\n                (this.previousSelection.end - this.previousSelection.start + lengthChange) > 0;\n        }\n        return {\n            selectionEnd: selectToEnd ? String(limitedValue).length : selectionEnd,\n            selectionStart: selectionStart,\n            value: limitedValue\n        };\n    }\n    tryPadValue(value, limit) {\n        const limitLength = String(Math.floor(limit)).length;\n        const zeroPadded = pad(value, limitLength);\n        const zeroPaddedNext = pad(value, limitLength + 1);\n        let result;\n        if (this.isInRange(zeroPadded)) {\n            result = zeroPadded;\n        }\n        else if (this.isInRange(zeroPaddedNext)) {\n            result = zeroPaddedNext;\n        }\n        return result;\n    }\n    isInRange(value) {\n        return !isNumber(value) || ((!isNumber(this.min) || this.min <= value) && (!isNumber(this.max) || value <= this.max));\n    }\n    restrictModelValue(value) {\n        let result = this.restrictDecimals(value, true);\n        if (this.autoCorrect && this.limitValue(result) !== result) {\n            result = null;\n        }\n        return result;\n    }\n    restrictDecimals(value, round) {\n        let result = value;\n        if (value && this.hasDecimals) {\n            const decimals = this.decimals;\n            const stringValue = String(value);\n            if (round || EXPONENT_REGEX.test(stringValue)) {\n                result = toFixedPrecision(value, decimals);\n            }\n            else {\n                const parts = stringValue.split(POINT);\n                let fraction = parts[1];\n                if (fraction && fraction.length > decimals) {\n                    fraction = fraction.substr(0, decimals);\n                    result = parseFloat(`${parts[0]}${POINT}${fraction}`);\n                }\n            }\n        }\n        return result;\n    }\n    formatInputValue(value) {\n        let stringValue = String(value);\n        const exponentMatch = EXPONENT_REGEX.exec(stringValue);\n        if (exponentMatch) {\n            stringValue = value.toFixed(limitPrecision(parseInt(exponentMatch[1], 10)));\n        }\n        return stringValue.replace(POINT, this.decimalSeparator);\n    }\n    formatValue(value, focused) {\n        let formattedValue;\n        if (value === null || !defined(value) || value === '') {\n            formattedValue = '';\n        }\n        else if (focused && !this.readonly) {\n            formattedValue = this.formatInputValue(value);\n        }\n        else {\n            formattedValue = this.intl.formatNumber(value, this.format);\n        }\n        return formattedValue;\n    }\n    setInputValue(value = this.value, focused = this.focused) {\n        const formattedValue = this.formatValue(value, focused);\n        this.elementValue = formattedValue;\n        this.inputValue = formattedValue;\n    }\n    verifySettings() {\n        if (!isDevMode()) {\n            return;\n        }\n        if (this.min !== null && this.max !== null && this.min > this.max) {\n            throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK} and ${MAX_DOC_LINK}.`);\n        }\n    }\n    verifyValue(value) {\n        if (isDevMode() && value && typeof value !== 'number') {\n            throw new Error(`The NumericTextBox component requires value of type Number and ${JSON.stringify(value)} was set.`);\n        }\n    }\n    parseOptions(options) {\n        for (let idx = 0; idx < options.length; idx++) {\n            const name = options[idx];\n            const value = this[name];\n            if (typeof value === 'string') {\n                const parsed = parseFloat(value);\n                const valid = !isNaN(parsed);\n                if (isDevMode() && !valid && value !== '') {\n                    throw new Error('The NumericTextBox component requires value of type Number or a String representing ' +\n                        `a number for the ${name} property and ${JSON.stringify(value)} was set.`);\n                }\n                this[name] = valid ? parsed : PARSABLE_DEFAULTS[name];\n            }\n        }\n    }\n    intlChange() {\n        delete this.numericRegex;\n        if (this.numericInput && (!this.focused || !this.isValid(this.elementValue))) {\n            this.setInputValue();\n        }\n    }\n    hasTrailingZeros(inputValue) {\n        if (this.hasDecimals && this.focused) {\n            const fraction = inputValue.split(this.decimalSeparator)[1];\n            return fraction && fraction.length > this.decimals && fraction.lastIndexOf('0') === fraction.length - 1;\n        }\n    }\n    selectAll() {\n        this.setInputValue();\n        this.setSelection(0, this.inputValue.length);\n    }\n    selectCaret() {\n        const caretPosition = getCaretPosition(this.numericInput.nativeElement);\n        const formattedValue = this.elementValue;\n        const partialValue = formattedValue.substring(0, caretPosition);\n        this.setInputValue();\n        if (partialValue.length) {\n            const significantCharsInFormattedValue = extractSignificantNumericChars(partialValue, this.decimalSeparator);\n            const adjustedSignificantChars = this.adjustSignificantChars(formattedValue, significantCharsInFormattedValue);\n            this.setSelection(adjustedSignificantChars, adjustedSignificantChars);\n        }\n        else {\n            this.setSelection(0, 0);\n        }\n    }\n    numberOfLeadingZeroes(formattedValue) {\n        const separatorIndex = formattedValue.indexOf(this.decimalSeparator);\n        const matchedLeadingZeroes = formattedValue.match(/^[^1-9]*?(0+)/);\n        if (matchedLeadingZeroes) {\n            const lengthOfMatch = matchedLeadingZeroes[0].length;\n            const lengthOfLeadingZeroesMatch = matchedLeadingZeroes[1].length;\n            return lengthOfMatch === separatorIndex ? lengthOfLeadingZeroesMatch - 1 : lengthOfLeadingZeroesMatch;\n        }\n        return 0;\n    }\n    adjustSignificantChars(formattedValue, significantChars) {\n        const leadingZeroes = this.numberOfLeadingZeroes(formattedValue);\n        if (leadingZeroes > 0) {\n            return Math.max(0, significantChars - leadingZeroes);\n        }\n        return significantChars;\n    }\n}\nNumericTextBoxComponent.decorators = [\n    { type: Component, args: [{\n                exportAs: 'kendoNumericTextBox',\n                providers: [\n                    LocalizationService,\n                    { provide: L10N_PREFIX, useValue: 'kendo.numerictextbox' },\n                    { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => NumericTextBoxComponent), multi: true },\n                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => NumericTextBoxComponent), multi: true },\n                    { provide: KendoInput, useExisting: forwardRef(() => NumericTextBoxComponent) }\n                ],\n                selector: 'kendo-numerictextbox',\n                template: `\n        <ng-container kendoNumericTextBoxLocalizedMessages\n            i18n-increment=\"kendo.numerictextbox.increment|The title for the **Increment** button in the NumericTextBox\"\n            increment=\"Increase value\"\n            i18n-decrement=\"kendo.numerictextbox.decrement|The title for the **Decrement** button in the NumericTextBox\"\n            decrement=\"Decrease value\"\n        >\n        </ng-container>\n        <span\n            class=\"k-numeric-wrap\"\n            [class.k-state-disabled]=\"disabled\"\n            [kendoEventsOutsideAngular]=\"{ mousewheel: handleWheel, DOMMouseScroll: handleWheel }\"\n            #numericWrap>\n            <input\n            role=\"spinbutton\"\n            class=\"k-input k-formatted-value\"\n            autocomplete=\"off\"\n            autocorrect=\"off\"\n            [id]=\"focusableId\"\n            [attr.aria-valuemin]=\"min\"\n            [attr.aria-valuemax]=\"max\"\n            [attr.aria-valuenow]=\"value\"\n            [attr.title]=\"title\"\n            [attr.placeholder]=\"placeholder\"\n            [tabindex]=\"tabIndex\"\n            [disabled]=\"disabled\"\n            [readonly]=\"readonly\"\n            [kendoEventsOutsideAngular]=\"{\n                mousedown: handleMouseDown,\n                dragenter: handleDragEnter,\n                keydown: handleKeyDown,\n                input: handleInput,\n                focus: handleFocus,\n                blur: handleBlur,\n                paste: handlePaste\n            }\"\n            #numericInput />\n            <span class=\"k-select\" *ngIf=\"spinners\" [kendoEventsOutsideAngular]=\"{ mouseup: releaseArrow, mouseleave: releaseArrow }\">\n                <span\n                    [kendoEventsOutsideAngular]=\"{ mousedown: increasePress }\"\n                    [attr.aria-label]=\"incrementTitle\"\n                    [title]=\"incrementTitle\"\n                    [class.k-state-active]=\"arrowDirection === ArrowDirection.Up\"\n                    class=\"k-link k-link-increase\"\n                >\n                    <span class=\"k-icon k-i-arrow-n\"></span>\n                </span>\n                <span\n                    [kendoEventsOutsideAngular]=\"{ mousedown: decreasePress }\"\n                    [attr.aria-label]=\"decrementTitle\"\n                    [title]=\"decrementTitle\"\n                    [class.k-state-active]=\"arrowDirection === ArrowDirection.Down\"\n                    class=\"k-link k-link-decrease\"\n                >\n                    <span class=\"k-icon k-i-arrow-s\"></span>\n                </span>\n            </span>\n        </span>\n      `\n            },] },\n];\n/** @nocollapse */\nNumericTextBoxComponent.ctorParameters = () => [\n    { type: IntlService },\n    { type: Renderer2 },\n    { type: LocalizationService },\n    { type: Injector },\n    { type: NgZone },\n    { type: ChangeDetectorRef },\n    { type: ElementRef }\n];\nNumericTextBoxComponent.propDecorators = {\n    focusableId: [{ type: Input }],\n    disabled: [{ type: Input }],\n    readonly: [{ type: Input }],\n    title: [{ type: Input }],\n    autoCorrect: [{ type: Input }],\n    format: [{ type: Input }],\n    max: [{ type: Input }],\n    min: [{ type: Input }],\n    decimals: [{ type: Input }],\n    placeholder: [{ type: Input }],\n    step: [{ type: Input }],\n    spinners: [{ type: Input }],\n    rangeValidation: [{ type: Input }],\n    tabindex: [{ type: Input }],\n    tabIndex: [{ type: Input }],\n    selectOnFocus: [{ type: Input }],\n    value: [{ type: Input }],\n    valueChange: [{ type: Output }],\n    onFocus: [{ type: Output, args: ['focus',] }],\n    onBlur: [{ type: Output, args: ['blur',] }],\n    numericInput: [{ type: ViewChild, args: ['numericInput', { static: true },] }],\n    numericWrap: [{ type: ViewChild, args: ['numericWrap',] }],\n    direction: [{ type: HostBinding, args: ['attr.dir',] }],\n    widgetClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-numerictextbox',] }]\n};\n\n/**\n * @hidden\n */\nclass NumericTextBoxMessages extends ComponentMessages {\n}\nNumericTextBoxMessages.propDecorators = {\n    decrement: [{ type: Input }],\n    increment: [{ type: Input }]\n};\n\n/**\n * Custom component messages override default component messages.\n */\nclass NumericTextBoxCustomMessagesComponent extends NumericTextBoxMessages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n    get override() {\n        return true;\n    }\n}\nNumericTextBoxCustomMessagesComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: NumericTextBoxMessages,\n                        useExisting: forwardRef(() => NumericTextBoxCustomMessagesComponent) // tslint:disable-line:no-forward-ref\n                    }\n                ],\n                selector: 'kendo-numerictextbox-messages',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nNumericTextBoxCustomMessagesComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * @hidden\n */\nvar ResultType;\n(function (ResultType) {\n    ResultType[ResultType[\"Literal\"] = 0] = \"Literal\";\n    ResultType[ResultType[\"Mask\"] = 1] = \"Mask\";\n    ResultType[ResultType[\"Undefined\"] = 2] = \"Undefined\";\n})(ResultType || (ResultType = {}));\n/**\n * @hidden\n */\nclass Result {\n    constructor(value, rest, type = ResultType.Undefined) {\n        this.value = value;\n        this.rest = rest;\n        this.type = type;\n    }\n    //map :: Functor f => f a ~> (a -> b) -> f b\n    map(fn) {\n        return new Result(fn(this.value), this.rest);\n    }\n    //chain :: Chain m => m a ~> (a -> m b) -> m b\n    chain(fn) {\n        return fn(this.value, this.rest);\n    }\n    fold(s, _ /*we don't need it*/) {\n        return s(this.value, this.rest);\n    }\n    concat(r) {\n        return this.map((vs, _) => r.chain((v, __) => vs.concat([v])));\n    }\n    toString() {\n        return `Result({ value: '${this.value}', rest: ${this.rest} })`;\n    }\n}\n\n/**\n * @hidden\n */\nclass Stream {\n    constructor(input = [], control = []) {\n        this.input = input;\n        this.control = control;\n        this.inputCursor = 0;\n        this.controlCursor = 0;\n    }\n    eof() {\n        return this.inputCursor >= this.input.length;\n    }\n    // Get the first value from the input.\n    next() {\n        return {\n            char: this.input[this.inputCursor++],\n            control: this.control[this.controlCursor++]\n        };\n    }\n    peek() {\n        return {\n            char: this.input[this.inputCursor],\n            control: this.control[this.controlCursor]\n        };\n    }\n    eat_input() {\n        this.inputCursor++;\n    }\n    eat_control() {\n        this.controlCursor++;\n    }\n    eat() {\n        this.inputCursor++;\n        this.controlCursor++;\n    }\n}\n\nconst toArray = (value) => (value || '').split('');\nconst ESCAPE_CHARACTER = '\\\\';\n/**\n * @hidden\n */\nclass Parser {\n    constructor(parse) {\n        this.parse = parse;\n    }\n    run(input, control = '') {\n        if (input instanceof Stream) {\n            return this.parse(input);\n        }\n        else {\n            return this.parse(new Stream(toArray(input), toArray(control)));\n        }\n    }\n    //map :: Functor f => f a ~> (a -> b) -> f b\n    map(f) {\n        return new Parser(stream => this.parse(stream).map(f));\n    }\n    //chain :: Chain m => m a ~> (a -> m b) -> m b\n    chain(f) {\n        return new Parser(stream => this.parse(stream).chain((v, s) => f(v).run(s)));\n    }\n    isLiteral(c) {\n        return this.run(c).type === ResultType.Literal;\n    }\n}\n/**\n * @hidden\n */\nconst mask = ({ prompt, promptPlaceholder }) => rule => new Parser(stream => {\n    while (!stream.eof()) {\n        const { char, control } = stream.peek();\n        if (char === control && control === prompt) {\n            stream.eat();\n            return new Result(prompt, stream, ResultType.Mask);\n        }\n        if (rule.test(char)) {\n            stream.eat();\n            return new Result(char, stream, ResultType.Mask);\n        }\n        if (char === promptPlaceholder) {\n            stream.eat();\n            return new Result(prompt, stream, ResultType.Mask);\n        }\n        stream.eat_input();\n    }\n    stream.eat();\n    return new Result(prompt, stream, ResultType.Mask);\n});\n/**\n * @hidden\n */\nconst literal = _token => new Parser(stream => {\n    //    let {char, control} = stream.peek();\n    let char = stream.peek().char;\n    if (char === _token) {\n        stream.eat();\n        return new Result(_token, stream, ResultType.Literal);\n    }\n    //    if (control === _token) {\n    //        while (!stream.eof() && char !== _token) {\n    //            stream.eat_input();\n    //            char = stream.peek().char;\n    //        }\n    //    }\n    //\n    //    if (control !== undefined) {\n    //        stream.eat();\n    //    }\n    return new Result(_token, stream, ResultType.Literal);\n});\n/**\n * @hidden\n */\nconst unmask = prompt => rule => new Parser(stream => {\n    while (!stream.eof()) {\n        const { char, control } = stream.peek();\n        if (char === prompt && control === prompt) {\n            stream.eat();\n            return new Result(char, stream);\n        }\n        if (rule.test(char)) {\n            stream.eat();\n            return new Result(char, stream);\n        }\n        stream.eat_input();\n    }\n    stream.eat();\n    return new Result('', stream);\n});\n/**\n * @hidden\n */\nconst unliteral = _token => new Parser(stream => {\n    if (stream.eof()) {\n        return new Result('', stream);\n    }\n    const { char } = stream.peek();\n    if (char === _token) {\n        stream.eat();\n    }\n    return new Result(_token, stream);\n});\n/**\n * @hidden\n */\nconst token = (rules, creator) => new Parser(stream => {\n    let { char } = stream.next();\n    const rule = rules[char];\n    if (char === ESCAPE_CHARACTER) {\n        char = stream.next().char;\n        return new Result(creator.literal(char), stream);\n    }\n    if (!rule) {\n        return new Result(creator.literal(char), stream);\n    }\n    return new Result(creator.mask(rule), stream);\n});\n/**\n * @hidden\n */\nconst rawMask = ({ prompt, promptPlaceholder }) => new Parser(stream => {\n    let { char } = stream.next();\n    if (char === prompt) {\n        return new Result(promptPlaceholder, stream);\n    }\n    return new Result(char, stream);\n});\n/**\n * @hidden\n */\nconst rawLiteral = includeLiterals => new Parser(stream => {\n    let { char } = stream.next();\n    if (includeLiterals) {\n        return new Result(char, stream);\n    }\n    return new Result('', stream);\n});\n\n/**\n * @hidden\n */\nconst always = value => new Parser(stream => new Result(value, stream));\n/**\n * @hidden\n */\nconst append = (p1, p2) => p1.chain(vs => p2.map(v => vs.concat([v])));\n/**\n * @hidden\n */\nconst sequence = list => list.reduce((acc, parser) => append(acc, parser), always([]));\n/**\n * @hidden\n */\nconst greedy = parser => new Parser(stream => {\n    let result = new Result([], stream);\n    while (!stream.eof()) {\n        result = result.concat(parser.run(stream));\n    }\n    return result;\n});\n\n/**\n * @hidden\n */\nclass MaskingService {\n    constructor() {\n        this.rules = {};\n        this.prompt = \"_\";\n        this.mask = \"\";\n        this.promptPlaceholder = \" \";\n        this.includeLiterals = false;\n        this.maskTokens = [];\n        this.unmaskTokens = [];\n        this.rawTokens = [];\n        this.validationTokens = [];\n    }\n    update({ mask: mask$$1 = '', prompt = '', promptPlaceholder = ' ', rules = {}, includeLiterals = false }) {\n        this.mask = mask$$1;\n        this.prompt = prompt;\n        this.promptPlaceholder = promptPlaceholder;\n        this.rules = rules;\n        this.includeLiterals = includeLiterals;\n        this.tokenize();\n    }\n    validationValue(maskedValue = '') {\n        let value = maskedValue;\n        sequence(this.validationTokens)\n            .run(maskedValue)\n            .fold(unmasked => {\n            value = unmasked.join('');\n        });\n        return value;\n    }\n    rawValue(maskedValue = '') {\n        let value = maskedValue;\n        if (!this.rawTokens.length) {\n            return value;\n        }\n        sequence(this.rawTokens)\n            .run(maskedValue)\n            .fold(unmasked => {\n            value = unmasked.join('');\n        });\n        return value;\n    }\n    /**\n     * @hidden\n     */\n    maskRaw(rawValue = '') {\n        let value = rawValue;\n        if (!this.maskTokens.length) {\n            return value;\n        }\n        sequence(this.maskTokens)\n            .run(rawValue)\n            .fold(masked => {\n            value = masked.join('');\n        });\n        return value;\n    }\n    maskInput(input, control, splitPoint) {\n        if (input.length < control.length) {\n            return this.maskRemoved(input, control, splitPoint);\n        }\n        return this.maskInserted(input, control, splitPoint);\n    }\n    maskInRange(pasted, oldValue, start, end) {\n        let value = '';\n        let selection = end;\n        const beforeChange = oldValue.split('').slice(0, start);\n        const afterChange = oldValue.split('').slice(end);\n        sequence(this.maskTokens.slice(start, end))\n            .run(pasted)\n            .fold(masked => {\n            value = beforeChange\n                .concat(masked)\n                .concat(afterChange)\n                .join('');\n        });\n        return {\n            selection,\n            value\n        };\n    }\n    maskRemoved(input, control, splitPoint) {\n        let value = '';\n        let selection = splitPoint;\n        const unchanged = input.split('').slice(splitPoint);\n        const changed = input.split('').slice(0, splitPoint).join('');\n        const take$$1 = this.maskTokens.length - (input.length - splitPoint);\n        sequence(this.maskTokens.slice(0, take$$1))\n            .run(changed, control)\n            .fold(masked => {\n            selection = this.adjustPosition(masked, selection);\n            value = masked.concat(unchanged).join('');\n        });\n        return {\n            selection,\n            value\n        };\n    }\n    adjustPosition(input, selection) {\n        const caretChar = input[selection];\n        const isLiteral = this.maskTokens[selection].isLiteral(caretChar);\n        if (!isLiteral && caretChar !== this.prompt) {\n            return selection + 1;\n        }\n        return selection;\n    }\n    maskInserted(input, control, splitPoint) {\n        let value = '';\n        let selection = splitPoint;\n        const changed = input.slice(0, splitPoint);\n        sequence(this.unmaskTokens)\n            .run(changed, control)\n            .chain(unmasked => {\n            selection = unmasked.join('').length;\n            const unchanged = control.slice(selection);\n            return sequence(this.maskTokens)\n                .run(unmasked.join('') + unchanged, control);\n        })\n            .fold(masked => {\n            value = masked.join('');\n        });\n        return {\n            selection,\n            value\n        };\n    }\n    get maskTokenCreator() {\n        const { prompt, promptPlaceholder } = this;\n        return {\n            literal: rule => literal(rule),\n            mask: rule => mask({ prompt, promptPlaceholder })(rule)\n        };\n    }\n    get unmaskTokenCreator() {\n        return {\n            literal: rule => unliteral(rule),\n            mask: rule => unmask(this.prompt)(rule)\n        };\n    }\n    get rawTokenCreator() {\n        const { prompt, promptPlaceholder, includeLiterals } = this;\n        return {\n            literal: _ => rawLiteral(includeLiterals),\n            mask: _ => rawMask({ prompt, promptPlaceholder })\n        };\n    }\n    get validationTokenCreator() {\n        const { prompt } = this;\n        return {\n            literal: _ => rawLiteral(false),\n            mask: _ => rawMask({ prompt, promptPlaceholder: '' })\n        };\n    }\n    tokenize() {\n        greedy(token(this.rules, this.maskTokenCreator))\n            .run(this.mask)\n            .fold((tokens, _) => {\n            this.maskTokens = tokens;\n        });\n        greedy(token(this.rules, this.unmaskTokenCreator))\n            .run(this.mask)\n            .fold((tokens, _) => {\n            this.unmaskTokens = tokens;\n        });\n        greedy(token(this.rules, this.rawTokenCreator))\n            .run(this.mask)\n            .fold((tokens, _) => {\n            this.rawTokens = tokens;\n        });\n        greedy(token(this.rules, this.validationTokenCreator))\n            .run(this.mask)\n            .fold((tokens, _) => {\n            this.validationTokens = tokens;\n        });\n    }\n}\nMaskingService.decorators = [\n    { type: Injectable },\n];\n\nconst resolvedPromise = Promise.resolve(null);\nconst FOCUSED$3 = 'k-state-focused';\n/**\n * Represents the [Kendo UI MaskedTextBox component for Angular]({% slug overview_maskedtextbox %}).\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *      <kendo-maskedtextbox\n *          [mask]=\"mask\"\n *          [value]=\"value\">\n *      </kendo-maskedtextbox>\n *     `\n * })\n *\n * class AppComponent {\n *  public value: string = \"9580128055807792\";\n *  public mask: string = \"0000-0000-0000-0000\";\n * }\n * ```\n */\nclass MaskedTextBoxComponent {\n    constructor(service, renderer, hostElement, ngZone, injector, rtl) {\n        this.service = service;\n        this.renderer = renderer;\n        this.hostElement = hostElement;\n        this.ngZone = ngZone;\n        this.injector = injector;\n        /**\n         * @hidden\n         */\n        this.focusableId = `k-${guid()}`;\n        /**\n         * Determines whether the MaskedTextBox is disabled ([see example]({% slug disabled_maskedtextbox %})).\n         */\n        this.disabled = false;\n        /**\n         * Determines whether the MaskedTextBox is in its read-only state ([see example]({% slug readonly_maskedtextbox %})).\n         */\n        this.readonly = false;\n        this.hostClasses = true;\n        /**\n         * Represents a prompt character for the masked value.\n         * @default `_`\n         */\n        this.prompt = '_';\n        /**\n         * Indicates a character which represents an empty position in the raw value.\n         * @default ' '\n         */\n        this.promptPlaceholder = ' ';\n        /**\n         * Indicates whether to include literals in the raw value  ([see example]({% slug value_maskedtextbox %})).\n         * @default false\n         */\n        this.includeLiterals = false;\n        /**\n         * Specifies if the mask should be shown on focus for empty value.\n         */\n        this.maskOnFocus = false;\n        /**\n         * Determines whether the built-in mask validator is enforced when a form is validated\n         * ([see example]({% slug validation_maskedtextbox %})).\n         * @default true\n         */\n        this.maskValidation = true;\n        /**\n         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n         */\n        this.tabindex = 0;\n        /**\n         * Fires each time the user focuses the `input` element.\n         *\n         * > To wire the event programmatically, use the `onFocus` property.\n         *\n         * @example\n         * ```ts\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-maskedtextbox (focus)=\"handleFocus()\"></kendo-maskedtextbox>\n         * `\n         * })\n         * class AppComponent {\n         *   public handleFocus(): void {\n         *      console.log(\"Component is focused\");\n         *   }\n         * }\n         * ```\n         */\n        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the `input` element gets blurred.\n         *\n         * > To wire the event programmatically, use the `onBlur` property.\n         *\n         * @example\n         * ```ts\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-maskedtextbox (blur)=\"handleBlur()\"></kendo-maskedtextbox>\n         * `\n         * })\n         * class AppComponent {\n         *   public handleBlur(): void {\n         *      console.log(\"Component is blurred\");\n         *   }\n         * }\n         * ```\n         */\n        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the value changes.\n         */\n        this.valueChange = new EventEmitter();\n        this.focusClick = false;\n        this.defaultRules = {\n            \"#\": /[\\d\\s\\+\\-]/,\n            \"&\": /[\\S]/,\n            \"0\": /[\\d]/,\n            \"9\": /[\\d\\s]/,\n            \"?\": /[a-zA-Z\\s]/,\n            \"A\": /[a-zA-Z0-9]/,\n            \"C\": /./,\n            \"L\": /[a-zA-Z]/,\n            \"a\": /[a-zA-Z0-9\\s]/\n        };\n        this.isPasted = false;\n        this.selection = [0, 0];\n        /**\n         * @hidden\n         */\n        this.handleFocus = () => {\n            this.focused = true;\n            if (this.maskOnFocus && this.emptyMask) {\n                this.updateInput(this.service.maskRaw(this.value));\n                this.ngZone.runOutsideAngular(() => {\n                    setTimeout(() => { this.setSelection(0, 0); }, 0);\n                });\n            }\n            if (hasObservers(this.onFocus)) {\n                this.ngZone.run(() => {\n                    this.onFocus.emit();\n                });\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.handleClick = () => {\n            if (this.focused && !this.focusClick) {\n                this.focusClick = true;\n                const { selectionStart, selectionEnd } = this.input.nativeElement;\n                if (selectionStart === selectionEnd) {\n                    this.setFocusSelection();\n                }\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.handleBlur = () => {\n            this.focused = false;\n            this.focusClick = false;\n            if (this.maskOnFocus && this.emptyMask) {\n                this.updateInput(this.maskedValue);\n            }\n            if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {\n                this.ngZone.run(() => {\n                    this.onTouched();\n                    this.onBlur.emit();\n                });\n            }\n        };\n        this.onChange = (_) => { };\n        this.onTouched = () => { };\n        this.direction = rtl ? 'rtl' : 'ltr';\n        this.updateService();\n    }\n    get hostDisabledClass() {\n        return this.disabled;\n    }\n    /**\n     * Exposes the RegExp-based mask validation array ([see example]({% slug masks_maskedtextbox %})).\n     */\n    get rules() {\n        return this._rules || this.defaultRules;\n    }\n    set rules(value) {\n        this._rules = Object.assign({}, this.defaultRules, value);\n    }\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n        this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n        return this.tabindex;\n    }\n    ngOnInit() {\n        if (this.hostElement) {\n            this.renderer.removeAttribute(this.hostElement.nativeElement, \"tabindex\");\n        }\n        this.control = this.injector.get(NgControl, null);\n    }\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the MaskedTextBox is empty.\n     */\n    isEmpty() {\n        if (this.input) {\n            return !Boolean(this.input.nativeElement.value);\n        }\n    }\n    /**\n     * @hidden\n     */\n    handleDragDrop() {\n        return false;\n    }\n    /**\n     * Focuses the MaskedTextBox.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"maskedinput.focus()\">Focus the input</button>\n     *  <kendo-maskedtextbox #maskedinput></kendo-maskedtextbox>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    focus() {\n        if (!this.input) {\n            return;\n        }\n        this.input.nativeElement.focus();\n        this.setFocusSelection();\n    }\n    /**\n     * Blurs the MaskedTextBox.\n     */\n    blur() {\n        if (!this.input) {\n            return;\n        }\n        this.input.nativeElement.blur();\n    }\n    /**\n     * @hidden\n     */\n    pasteHandler(e) {\n        const { selectionStart, selectionEnd } = e.target;\n        if (selectionEnd === selectionStart) {\n            return;\n        }\n        this.isPasted = true;\n        this.selection = [selectionStart, selectionEnd];\n    }\n    /**\n     * @hidden\n     */\n    inputHandler(e) {\n        const value = e.target.value;\n        const [start, end] = this.selection;\n        if (!this.mask) {\n            this.updateValue(value);\n            this.isPasted = false;\n            return;\n        }\n        let result;\n        if (this.isPasted) {\n            this.isPasted = false;\n            const rightPart = this.maskedValue.length - end;\n            const to = value.length - rightPart;\n            result = this.service.maskInRange(value.slice(start, to), this.maskedValue, start, end);\n        }\n        else {\n            result = this.service.maskInput(value, this.maskedValue, e.target.selectionStart);\n        }\n        this.updateInput(result.value, result.selection);\n        this.updateValue(result.value);\n    }\n    /**\n     * @hidden\n     */\n    ngOnChanges(changes) {\n        if (changes.value) {\n            this.value = this.normalizeValue();\n        }\n        if (!this.mask) {\n            this.updateInput(this.value);\n            return;\n        }\n        const next = this.extractChanges(changes);\n        this.updateService(next);\n        if (isChanged('value', changes)) {\n            const maskedValue = this.service.maskRaw(this.value);\n            if (maskedValue !== this.maskedValue) {\n                this.updateInput(maskedValue);\n            }\n        }\n        else if (anyChanged(['promptPlaceholder', 'includeLiterals'], changes)) {\n            resolvedPromise.then(() => {\n                this.updateValue(this.maskedValue);\n            });\n        }\n        else {\n            this.updateInput(this.service.maskRaw(this.value));\n        }\n    }\n    /**\n     * @hidden\n     * Writes a new value to the element.\n     */\n    writeValue(value) {\n        this.value = this.normalizeValue(value);\n        this.updateInput(this.service.maskRaw(this.value));\n    }\n    /**\n     * @hidden\n     * Sets the function that will be called when a `change` event is triggered.\n     */\n    registerOnChange(fn) {\n        this.onChange = fn;\n    }\n    /**\n     * @hidden\n     * Sets the function that will be called when a `touch` event is triggered.\n     */\n    registerOnTouched(fn) {\n        this.onTouched = fn;\n    }\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     *\n     * @param isDisabled\n     */\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n    validate(_) {\n        if (this.maskValidation === false || !this.mask) {\n            return null;\n        }\n        if (!this.service.validationValue(this.maskedValue)) {\n            return null;\n        }\n        if (this.maskedValue.indexOf(this.prompt) !== -1) {\n            return {\n                patternError: {\n                    mask: this.mask,\n                    maskedValue: this.maskedValue,\n                    value: this.value\n                }\n            };\n        }\n        return null;\n    }\n    /**\n     * @hidden\n     */\n    updateValue(maskedValue) {\n        if (this.mask && !this.service.validationValue(maskedValue)) {\n            this.value = '';\n        }\n        else {\n            this.value = this.service.rawValue(maskedValue);\n        }\n        this.onChange(this.value);\n        this.valueChange.emit(this.value);\n    }\n    updateInput(maskedValue = '', selection) {\n        this.maskedValue = maskedValue;\n        const value = this.maskOnFocus && !this.focused && this.emptyMask ? '' : maskedValue;\n        this.renderer.setProperty(this.input.nativeElement, \"value\", value);\n        if (selection !== undefined) {\n            this.setSelection(selection, selection);\n        }\n    }\n    extractChanges(changes) {\n        return Object.keys(changes).filter(key => key !== 'rules').reduce((obj, key) => {\n            obj[key] = changes[key].currentValue;\n            return obj;\n        }, {}); // tslint:disable-line:align\n    }\n    updateService(extra) {\n        const config = Object.assign({\n            includeLiterals: this.includeLiterals,\n            mask: this.mask,\n            prompt: this.prompt,\n            promptPlaceholder: this.promptPlaceholder,\n            rules: this.rules\n        }, extra); // tslint:disable-line:align\n        this.service.update(config);\n    }\n    setSelection(start = this.selection[0], end = this.selection[1]) {\n        if (this.focused) {\n            invokeElementMethod(this.input, 'setSelectionRange', start, end);\n        }\n    }\n    get emptyMask() {\n        return this.service.maskRaw() === this.maskedValue;\n    }\n    setFocusSelection() {\n        const selectionStart = this.input.nativeElement.selectionStart;\n        const index = this.maskedValue ? this.maskedValue.indexOf(this.prompt) : 0;\n        if (index >= 0 && index < selectionStart) {\n            this.selection = [index, index];\n            this.setSelection();\n        }\n    }\n    get focused() {\n        return this.isFocused;\n    }\n    set focused(value) {\n        if (this.isFocused !== value && this.hostElement) {\n            const element = this.hostElement.nativeElement;\n            if (value) {\n                this.renderer.addClass(element, FOCUSED$3);\n            }\n            else {\n                this.renderer.removeClass(element, FOCUSED$3);\n            }\n            this.isFocused = value;\n        }\n    }\n    normalizeValue(value = this.value) {\n        const present = isPresent(value);\n        if (present && typeof value !== 'string') {\n            if (isDevMode()) {\n                throw new Error('The MaskedTextBox component supports only string values.');\n            }\n            return String(value);\n        }\n        return present ? value : '';\n    }\n}\nMaskedTextBoxComponent.decorators = [\n    { type: Component, args: [{\n                exportAs: 'kendoMaskedTextBox',\n                providers: [\n                    MaskingService,\n                    {\n                        multi: true,\n                        provide: NG_VALUE_ACCESSOR,\n                        useExisting: forwardRef(() => MaskedTextBoxComponent) /* tslint:disable-line */\n                    },\n                    {\n                        multi: true,\n                        provide: NG_VALIDATORS,\n                        useExisting: forwardRef(() => MaskedTextBoxComponent) /* tslint:disable-line */\n                    },\n                    {\n                        provide: KendoInput,\n                        useExisting: forwardRef(() => MaskedTextBoxComponent)\n                    }\n                ],\n                selector: 'kendo-maskedtextbox',\n                template: `\n        <input type=\"text\"\n            #input\n            autocomplete=\"off\"\n            autocorrect=\"off\"\n            autocapitalize=\"off\"\n            spellcheck=\"false\"\n            class=\"k-textbox\"\n            [id]=\"focusableId\"\n            [tabindex]=\"tabIndex\"\n            [attr.title]=\"title\"\n            [disabled]=\"disabled\"\n            [readonly]=\"readonly\"\n            [kendoEventsOutsideAngular]=\"{\n                focus: handleFocus,\n                blur: handleBlur,\n                click: handleClick,\n                dragstart: handleDragDrop,\n                drop: handleDragDrop\n            }\"\n        />\n    `\n            },] },\n];\n/** @nocollapse */\nMaskedTextBoxComponent.ctorParameters = () => [\n    { type: MaskingService },\n    { type: Renderer2 },\n    { type: ElementRef },\n    { type: NgZone },\n    { type: Injector },\n    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [RTL,] }] }\n];\nMaskedTextBoxComponent.propDecorators = {\n    focusableId: [{ type: Input }],\n    disabled: [{ type: Input }],\n    readonly: [{ type: Input }],\n    title: [{ type: Input }],\n    direction: [{ type: HostBinding, args: ['attr.dir',] }],\n    hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-maskedtextbox',] }],\n    hostDisabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }],\n    mask: [{ type: Input }],\n    value: [{ type: Input }],\n    rules: [{ type: Input }],\n    prompt: [{ type: Input }],\n    promptPlaceholder: [{ type: Input }],\n    includeLiterals: [{ type: Input }],\n    maskOnFocus: [{ type: Input }],\n    maskValidation: [{ type: Input }],\n    tabindex: [{ type: Input }],\n    tabIndex: [{ type: Input }],\n    onFocus: [{ type: Output, args: ['focus',] }],\n    onBlur: [{ type: Output, args: ['blur',] }],\n    valueChange: [{ type: Output }],\n    input: [{ type: ViewChild, args: ['input', { static: true },] }],\n    pasteHandler: [{ type: HostListener, args: ['paste', ['$event'],] }],\n    inputHandler: [{ type: HostListener, args: ['input', ['$event'],] }]\n};\n\n/* tslint:disable:component-selector */\n/**\n * @hidden\n */\nclass SliderTick {\n    constructor(value) {\n        this.value = value;\n        this.classes = {\n            'k-tick': true\n        };\n    }\n}\n/**\n * @hidden\n */\nclass SliderTicksComponent {\n    constructor(rtl) {\n        this.rtl = rtl;\n        this.wrapperClasses = 'k-reset k-slider-items';\n        this.ticks = [];\n    }\n    ngOnChanges(_) {\n        this.createTicks();\n    }\n    createTicks() {\n        const count = calculateTicksCount(this.min, this.max, this.step);\n        const largeStep = this.largeStep;\n        const tickValueProps = {\n            max: this.max,\n            min: this.min,\n            smallStep: this.step\n        };\n        let result = [];\n        for (let i = 0; i < count; i++) {\n            result.push(new SliderTick(calculateValueFromTick(i, tickValueProps)));\n            if (largeStep && i % largeStep === 0) {\n                result[i].large = true;\n                result[i].classes['k-tick-large'] = true;\n            }\n        }\n        if (this.rtl || this.vertical) {\n            result = result.reverse();\n        }\n        if (result.length > 0) {\n            Object.assign(result[0].classes, this.endTickClasses(true));\n            Object.assign(result[result.length - 1].classes, this.endTickClasses(false));\n        }\n        this.ticks = result;\n    }\n    endTickClasses(first) {\n        return {\n            'k-first': (first && !this.vertical) || (!first && this.vertical),\n            'k-last': (!first && !this.vertical) || (first && this.vertical)\n        };\n    }\n}\nSliderTicksComponent.decorators = [\n    { type: Component, args: [{\n                selector: '[kendoSliderTicks]',\n                template: `\n    <li #tickElement *ngFor=\"let tick of ticks;\"\n        [ngClass]=\"tick.classes\"\n        title=\"{{ tickTitle(tick.value) }}\"\n        role=\"presentation\"\n     >\n         <ng-container [ngSwitch]=\"tick.large\">\n            <span class=\"k-label\" *ngSwitchCase=\"true\">\n                <ng-container [ngTemplateOutlet]=\"labelTemplate || defaultLabel\" [ngTemplateOutletContext]=\"tick\">\n                </ng-container>\n            </span>\n            <ng-container *ngSwitchCase=\"false\">&nbsp;</ng-container>\n         </ng-container>\n     </li>\n\n     <ng-template #defaultLabel let-value=\"value\">\n        {{ tickTitle(value) }}\n     </ng-template>\n  `\n            },] },\n];\n/** @nocollapse */\nSliderTicksComponent.ctorParameters = () => [\n    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [RTL,] }] }\n];\nSliderTicksComponent.propDecorators = {\n    wrapperClasses: [{ type: HostBinding, args: ['class',] }],\n    tickTitle: [{ type: Input }],\n    vertical: [{ type: Input }],\n    step: [{ type: Input }],\n    largeStep: [{ type: Input }],\n    min: [{ type: Input }],\n    max: [{ type: Input }],\n    labelTemplate: [{ type: Input }],\n    tickElements: [{ type: ViewChildren, args: ['tickElement',] }]\n};\n\n/**\n * @hidden\n */\nclass SliderMessages extends ComponentMessages {\n}\nSliderMessages.propDecorators = {\n    decrement: [{ type: Input }],\n    increment: [{ type: Input }],\n    dragHandle: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nclass LocalizedSliderMessagesDirective extends SliderMessages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n}\nLocalizedSliderMessagesDirective.decorators = [\n    { type: Directive, args: [{\n                providers: [\n                    {\n                        provide: SliderMessages,\n                        useExisting: forwardRef(() => LocalizedSliderMessagesDirective) // tslint:disable-line:no-forward-ref\n                    }\n                ],\n                selector: '[kendoSliderLocalizedMessages]'\n            },] },\n];\n/** @nocollapse */\nLocalizedSliderMessagesDirective.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * Custom component messages override default component messages.\n */\nclass SliderCustomMessagesComponent extends SliderMessages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n    get override() {\n        return true;\n    }\n}\nSliderCustomMessagesComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: SliderMessages,\n                        useExisting: forwardRef(() => SliderCustomMessagesComponent) // tslint:disable-line:no-forward-ref\n                    }\n                ],\n                selector: 'kendo-slider-messages',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nSliderCustomMessagesComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Slider component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Inputs module\n * import { SliderModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, BrowserAnimationsModule, SliderModule], // import Slider module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nclass SliderModule {\n}\nSliderModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [\n                    SliderComponent,\n                    SliderTicksComponent,\n                    SliderCustomMessagesComponent,\n                    LocalizedSliderMessagesDirective,\n                    LabelTemplateDirective\n                ],\n                exports: [\n                    SliderComponent,\n                    SliderCustomMessagesComponent,\n                    LocalizedSliderMessagesDirective,\n                    LabelTemplateDirective\n                ],\n                imports: [CommonModule, DraggableModule, EventsModule, ResizeSensorModule]\n            },] },\n];\n\n/**\n * @hidden\n */\nclass Messages extends ComponentMessages {\n}\nMessages.propDecorators = {\n    on: [{ type: Input }],\n    off: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nclass LocalizedSwitchMessagesDirective extends Messages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n}\nLocalizedSwitchMessagesDirective.decorators = [\n    { type: Directive, args: [{\n                providers: [\n                    {\n                        provide: Messages,\n                        useExisting: forwardRef(() => LocalizedSwitchMessagesDirective) // tslint:disable-line:no-forward-ref\n                    }\n                ],\n                selector: '[kendoSwitchLocalizedMessages]'\n            },] },\n];\n/** @nocollapse */\nLocalizedSwitchMessagesDirective.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * Custom component messages override default component messages.\n */\nclass SwitchCustomMessagesComponent extends Messages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n    get override() {\n        return true;\n    }\n}\nSwitchCustomMessagesComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: Messages,\n                        useExisting: forwardRef(() => SwitchCustomMessagesComponent) // tslint:disable-line:no-forward-ref\n                    }\n                ],\n                selector: 'kendo-switch-messages',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nSwitchCustomMessagesComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Switch component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Switch module\n * import { SwitchModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, SwitchModule], // import Switch module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nclass SwitchModule {\n}\nSwitchModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [\n                    SwitchComponent,\n                    SwitchCustomMessagesComponent,\n                    LocalizedSwitchMessagesDirective\n                ],\n                exports: [\n                    SwitchComponent,\n                    SwitchCustomMessagesComponent,\n                    LocalizedSwitchMessagesDirective\n                ],\n                imports: [CommonModule, EventsModule, ResizeSensorModule]\n            },] },\n];\n\n/**\n * @hidden\n */\nclass LocalizedNumericTextBoxMessagesDirective extends NumericTextBoxMessages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n}\nLocalizedNumericTextBoxMessagesDirective.decorators = [\n    { type: Directive, args: [{\n                providers: [\n                    {\n                        provide: NumericTextBoxMessages,\n                        useExisting: forwardRef(() => LocalizedNumericTextBoxMessagesDirective) // tslint:disable-line:no-forward-ref\n                    }\n                ],\n                selector: '[kendoNumericTextBoxLocalizedMessages]'\n            },] },\n];\n/** @nocollapse */\nLocalizedNumericTextBoxMessagesDirective.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the NumericTextBox component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the NumericTextBox module\n * import { NumericTextBoxModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, NumericTextBoxModule], // import NumericTextBox module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nclass NumericTextBoxModule {\n}\nNumericTextBoxModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [\n                    LocalizedNumericTextBoxMessagesDirective,\n                    NumericTextBoxComponent,\n                    NumericTextBoxCustomMessagesComponent\n                ],\n                exports: [\n                    NumericTextBoxComponent,\n                    NumericTextBoxCustomMessagesComponent\n                ],\n                imports: [CommonModule, EventsModule]\n            },] },\n];\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the MaskedTextBox component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the MaskedTextBox module\n * import { MaskedTextBoxModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, MaskedTextBoxModule], // import MaskedTextBox module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nclass MaskedTextBoxModule {\n}\nMaskedTextBoxModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [MaskedTextBoxComponent],\n                exports: [MaskedTextBoxComponent],\n                imports: [CommonModule, EventsModule]\n            },] },\n];\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the TextBox directive.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the TextBox module\n * import { TextBoxModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, TextBoxModule], // import TextBox module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nclass TextBoxModule {\n}\nTextBoxModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [TextBoxDirective, TextAreaDirective, TextBoxContainerComponent],\n                exports: [TextBoxDirective, TextAreaDirective, TextBoxContainerComponent],\n                imports: [CommonModule]\n            },] },\n];\n\n/**\n * @hidden\n */\nclass PreventableEvent {\n    constructor() {\n        this.prevented = false;\n    }\n    /**\n     * Prevents the default action for a specified event.\n     * In this way, the source component suppresses the built-in behavior that follows the event.\n     */\n    preventDefault() {\n        this.prevented = true;\n    }\n    /**\n     * If the event is prevented by any of its subscribers, returns `true`.\n     *\n     * @returns - `true` if the default action was prevented. Otherwise, returns `false`.\n     */\n    isDefaultPrevented() {\n        return this.prevented;\n    }\n}\n\n/**\n * Fires each time the left side of the ColorPicker wrapper is clicked.\n * The event is triggered regardless of whether a ColorPicker icon is set or not.\n *\n * Provides information about the current active color and gives the option to prevent the opening of the popup.\n *\n * @example\n *\n * ```ts\n * _@Component({\n *   selector: 'my-app',\n *   template: `\n *       <kendo-colorpicker\n *           [icon]=\"'edit-tools'\"\n *           [value]=\"'#900'\"\n *           (activeColorClick)=\"handleActiveColorClick($event)\"\n *       >\n *       </kendo-colorpicker>\n *   `\n * })\n * class AppComponent {\n *     public handleActiveColorClick(event: ActiveColorClickEvent): void {\n *         event.preventOpen();\n *\n *         console.log('Open prevented:', event.isOpenPrevented());\n *         console.log('Current color:', event.color);\n *     }\n *  }\n * ```\n */\nclass ActiveColorClickEvent {\n    /**\n     * @hidden\n     * @param color Represents the current value of the ColorPicker.\n     */\n    constructor(color) {\n        this.color = color;\n        this.openPrevented = false;\n    }\n    /**\n     * Prevents the opening of the popup.\n     */\n    preventOpen() {\n        this.openPrevented = true;\n    }\n    /**\n     * Returns `true` if the popup opening is prevented by any of its subscribers.\n     *\n     * @returns - Returns `true` if the open action was prevented. Otherwise, returns `false`.\n     */\n    isOpenPrevented() {\n        return this.openPrevented;\n    }\n}\n\n/**\n * @hidden\n *\n * Returns the hex or rgba string representation of the color.\n */\nconst parseColor$1 = (value, format, safe = true) => {\n    const allowedFormats = ['hex', 'rgba', 'name'];\n    if (allowedFormats.indexOf(format) === -1) {\n        throw new Error(`Unsupported color output format '${format}'. The available options are 'hex', 'rgba' or 'name'.`);\n    }\n    if (!isPresent(value)) {\n        return;\n    }\n    if (format === 'name') {\n        return nameFormat(value, safe);\n    }\n    const parsedColor = parseColor(value.trim(), safe);\n    if (!isPresent(parsedColor)) {\n        return;\n    }\n    return format === 'hex' ? parsedColor.toCss() : parsedColor.toCssRgba();\n};\n/**\n * @hidden\n *\n * Returns an HSV object representation of the color string.\n */\nconst getHSV = (value, safe = true) => {\n    const parsed = parseColor(value, safe);\n    if (!isPresent(parsed)) {\n        return {};\n    }\n    return parsed.toHSV();\n};\n/**\n * @hidden\n *\n * Returns an RGBA object representation of the color string.\n */\nconst getRGBA = (value, safe = true) => {\n    const parsed = parseColor(value, safe);\n    if (!isPresent(parsed)) {\n        return {};\n    }\n    return parsed.toBytes();\n};\n/**\n * @hidden\n *\n * Returns the RGBA string representation of the color.\n */\nconst getColorFromHSV = (hsva) => {\n    const hue = fitIntoBounds(hsva.h, 0, 359.9);\n    const saturation = fitIntoBounds(hsva.s, 0, 1);\n    const value = fitIntoBounds(hsva.v, 0, 1);\n    const alpha = fitIntoBounds(hsva.a, 0, 1);\n    return Color.fromHSV(hue, saturation, value, alpha).toCssRgba();\n};\n/**\n * @hidden\n *\n * Returns the RGBA string representation of the color based on the `hue`, assuming the `value`, `saturation` and `alpha` have value of `1`.\n */\nconst getColorFromHue = (hue) => {\n    return getColorFromHSV({ h: hue, s: 1, v: 1, a: 1 });\n};\n/**\n * @hidden\n *\n * Returns the RGBA string representation of the color.\n */\nconst getColorFromRGBA = (rgba) => {\n    const red = fitIntoBounds(rgba.r, 0, 255);\n    const green = fitIntoBounds(rgba.g, 0, 255);\n    const blue = fitIntoBounds(rgba.b, 0, 255);\n    const alpha = fitIntoBounds(rgba.a, 0, 1);\n    return Color.fromBytes(red, green, blue, alpha).toCssRgba();\n};\n/**\n *\n * @hidden\n */\nfunction nameFormat(value, safe) {\n    value = value.toLowerCase().trim();\n    if (isPresent(namedColors[value])) {\n        return value;\n    }\n    if (parseColor(value, safe)) {\n        value = parseColor(value, safe).toHex();\n    }\n    const key = Object.keys(namedColors).find(key => namedColors[key] === value);\n    if (!key && !safe) {\n        throw new Error(`The provided color ${value} is not supported for 'format=\"name\"' property.To display ${value} color, the component 'format' property shoud be set to 'hex' or 'rgba' `);\n    }\n    return key;\n}\n\n// tslint:disable:max-line-length\n/**\n * @hidden\n */\nconst PALETTEPRESETS = {\n    basic: {\n        colors: '000000,7f7f7f,880015,ed1c24,ff7f27,fff200,22b14c,00a2e8,3f48cc,a349a4,ffffff,c3c3c3,b97a57,ffaec9,ffc90e,efe4b0,b5e61d,99d9ea,7092be,c8bfe7',\n        columns: 10\n    },\n    office: {\n        colors: 'ffffff, 000000, e6e6e6, 435569, 4371c4, ed7e32, a5a4a5, febf04, 5a9bd5, 71ae48, f2f2f3, 7f7f7f, d1cece, d5dde3, dae1f4, fce5d4, deeded, fff2cc, deeaf6, e1efd9, d7d8d8, 585959, aeabab, adbaca, b4c5e7, f6caac, dbdbdb, ffe498, bcd6ee, c5e0b2, bfbfc0, 3f3f3f, 767070, 8595b1, 8fabdb, f5b183, c9c8c9, fed965, 9bc4e5, a8d08d, a5a5a6, 262625, 393939, 334050, 2e5496, c45a11, 7b7b7a, bf9000, 2f75b5, 548235, 7f7f7f, 0b0c0c, 161616, 222a34, 203764, 843d0b, 525252, 7f6000, 1d4d79, 375623',\n        columns: 10\n    },\n    apex: {\n        colors: 'ffffff, 000000, c9c2d1, 69676d, ceb966, 9cb084, 6bb1c9, 6585cf, 7e6bc9, a379bb, f2f2f2, 7f7f7f, f4f2f5, e0e0e2, f5f1e0, ebefe6, e1eff4, e0e6f5, e5e1f4, ece4f1, d8d8d8, 595959, e9e6ec, c2c1c5, ebe3c1, d7dfcd, c3dfe9, c1ceeb, cbc3e9, dac9e3, bfbfbf, 3f3f3f, dedae3, a4a3a8, e1d5a3, c3cfb5, a6d0de, a2b5e2, b1a6de, c7aed6, a5a5a5, 262626, 9688a5, 4e4d51, ae9638, 758c5a, 3d8da9, 365bb0, 533da9, 7d4d99, 7f7f7f, 0c0c0c, 635672, 343336, 746425, 4e5d3c, 295e70, 243c75, 372970, 533366',\n        columns: 10\n    },\n    austin: {\n        colors: 'ffffff, 000000, caf278, 3e3d2d, 94c600, 71685a, ff6700, 909465, 956b43, fea022, f2f2f2, 7f7f7f, f4fce4, dddcd0, efffc0, e3e1dc, ffe0cb, e8e9df, ece1d6, feecd2, d8d8d8, 595959, e9f9c9, bbb9a1, dfff82, c8c3ba, ffc299, d2d4c0, dac3ad, fed9a6, bfbfbf, 3f3f3f, dff7ae, ada598, cfff43, ada598, ffa365, bcbfa1, c8a585, fec67a, a5a5a5, 262626, a9ea25, 2e2d21, 6f9400, 544e43, bf4d00, 6c6f4b, 6f5032, d77b00, 7f7f7f, 0c0c0c, 74a50f, 1f1e16, 4a6300, 38342d, 7f3300, 484a32, 4a3521, 8f5200',\n        columns: 10\n    },\n    clarity: {\n        colors: 'ffffff, 292934, f3f2dc, d2533c, 93a299, ad8f67, 726056, 4c5a6a, 808da0, 79463d, f2f2f2, e7e7ec, e7e5b9, f6dcd8, e9ecea, eee8e0, e4dedb, d8dde3, e5e8ec, e9d6d3, d8d8d8, c4c4d1, d5d185, edbab1, d3d9d6, ded2c2, c9beb8, b2bcc8, ccd1d9, d3aea7, bfbfbf, 8a8aa3, aca73b, e4978a, bec7c1, cdbba3, af9e94, 8c9bac, b2bac6, bd857c, a5a5a5, 56566e, 56531d, a43925, 6b7c72, 866b48, 554840, 39434f, 5c697b, 5a342d, 7f7f7f, 3b3b4b, 22210b, 6d2619, 47534c, 594730, 39302b, 262d35, 3d4652, 3c231e',\n        columns: 10\n    },\n    slipstream: {\n        colors: 'ffffff, 000000, b4dcfa, 212745, 4e67c8, 5eccf3, a7ea52, 5dceaf, ff8021, f14124, f2f2f2, 7f7f7f, 8bc9f7, c7cce4, dbe0f4, def4fc, edfadc, def5ef, ffe5d2, fcd9d3, d8d8d8, 595959, 4facf3, 909aca, b8c2e9, beeafa, dbf6b9, beebdf, ffcca6, f9b3a7, bfbfbf, 3f3f3f, 0d78c9, 5967af, 94a3de, 9ee0f7, caf297, 9de1cf, ffb279, f68d7b, a5a5a5, 262626, 063c64, 181d33, 31479f, 11b2eb, 81d319, 34ac8b, d85c00, c3260c, 7f7f7f, 0c0c0c, 021828, 101322, 202f6a, 0b769c, 568c11, 22725c, 903d00, 821908',\n        columns: 10\n    },\n    metro: {\n        colors: 'ffffff, 000000, d6ecff, 4e5b6f, 7fd13b, ea157a, feb80a, 00addc, 738ac8, 1ab39f, f2f2f2, 7f7f7f, a7d6ff, d9dde4, e5f5d7, fad0e4, fef0cd, c5f2ff, e2e7f4, c9f7f1, d8d8d8, 595959, 60b5ff, b3bcca, cbecb0, f6a1c9, fee29c, 8be6ff, c7d0e9, 94efe3, bfbfbf, 3f3f3f, 007dea, 8d9baf, b2e389, f272af, fed46b, 51d9ff, aab8de, 5fe7d5, a5a5a5, 262626, 003e75, 3a4453, 5ea226, af0f5b, c58c00, 0081a5, 425ea9, 138677, 7f7f7f, 0c0c0c, 00192e, 272d37, 3f6c19, 750a3d, 835d00, 00566e, 2c3f71, 0c594f',\n        columns: 10\n    },\n    flow: {\n        colors: 'ffffff, 000000, dbf5f9, 04617b, 0f6fc6, 009dd9, 0bd0d9, 10cf9b, 7cca62, a5c249, f2f2f2, 7f7f7f, b2e9f2, b4ecfc, c7e2fa, c4eeff, c9fafc, c9faed, e4f4df, edf2da, d8d8d8, 595959, 76d9e8, 6adafa, 90c6f6, 89deff, 93f5f9, 94f6db, cae9c0, dbe6b6, bfbfbf, 3f3f3f, 21b2c8, 20c8f7, 59a9f2, 4fceff, 5df0f6, 5ff2ca, b0dfa0, c9da91, a5a5a5, 262626, 105964, 02485c, 0b5394, 0075a2, 089ca2, 0b9b74, 54a838, 7e9532, 7f7f7f, 0c0c0c, 062328, 01303d, 073763, 004e6c, 05686c, 07674d, 387025, 546321',\n        columns: 10\n    },\n    hardcover: {\n        colors: 'ffffff, 000000, ece9c6, 895d1d, 873624, d6862d, d0be40, 877f6c, 972109, aeb795, f2f2f2, 7f7f7f, e1dca5, f2e0c6, f0d0c9, f6e6d5, f5f2d8, e7e5e1, fbc7bc, eef0e9, d8d8d8, 595959, d0c974, e6c28d, e2a293, eeceaa, ece5b2, cfccc3, f78f7a, dee2d4, bfbfbf, 3f3f3f, a29a36, daa454, d4735e, e6b681, e2d88c, b7b2a5, f35838, ced3bf, a5a5a5, 262626, 514d1b, 664515, 65281a, a2641f, a39428, 655f50, 711806, 879464, 7f7f7f, 0c0c0c, 201e0a, 442e0e, 431b11, 6c4315, 6d621a, 433f35, 4b1004, 5a6243',\n        columns: 10\n    },\n    trek: {\n        colors: 'ffffff, 000000, fbeec9, 4e3b30, f0a22e, a5644e, b58b80, c3986d, a19574, c17529, f2f2f2, 7f7f7f, f7e09e, e1d6cf, fcecd5, eddfda, f0e7e5, f3eae1, ece9e3, f5e3d1, d8d8d8, 595959, f3cc5f, c4ad9f, f9d9ab, dcc0b6, e1d0cc, e7d5c4, d9d4c7, ebc7a3, bfbfbf, 3f3f3f, d29f0f, a78470, f6c781, cba092, d2b9b2, dbc1a7, c6bfab, e1ac76, a5a5a5, 262626, 694f07, 3a2c24, c87d0e, 7b4b3a, 926255, a17242, 7b7153, 90571e, 7f7f7f, 0c0c0c, 2a1f03, 271d18, 855309, 523226, 614138, 6b4c2c, 524b37, 603a14',\n        columns: 10\n    },\n    verve: {\n        colors: 'ffffff, 000000, d2d2d2, 666666, ff388c, e40059, 9c007f, 68007f, 005bd3, 00349e, f2f2f2, 7f7f7f, bdbdbd, e0e0e0, ffd7e8, ffc6dc, ffb8f1, f1b2ff, c3dcff, b8cfff, d8d8d8, 595959, 9d9d9d, c1c1c1, ffafd1, ff8eba, ff71e4, e365ff, 87baff, 72a0ff, bfbfbf, 3f3f3f, 696969, a3a3a3, ff87ba, ff5597, ff2ad7, d519ff, 4b98ff, 2b71ff, a5a5a5, 262626, 343434, 4c4c4c, e90062, ab0042, 75005f, 4e005f, 00449e, 002676, 7f7f7f, 0c0c0c, 151515, 333333, 9b0041, 72002c, 4e003f, 34003f, 002d69, 00194f',\n        columns: 10\n    },\n    monochrome: {\n        colors: '000000, 1a1a1a, 333333, 4d4d4d, 666666, 808080, 999999, b3b3b3, cccccc, e6e6e6, f2f2f2, ffffff',\n        columns: 12\n    },\n    accessible: {\n        colors: 'black, grey, darkred, red, darkorange, gold, green, blue, darkblue, purple, white, darkgrey, saddlebrown, pink, orange, yellow, lightgreen, lightskyblue, lightblue, mediumpurple',\n        columns: 10\n    }\n};\n\nconst DEFAULT_PRESET = 'office';\nconst DEFAULT_ACCESSIBLE_PRESET = 'accessible';\n/**\n * Represents the [Kendo UI ColorPicker component for Angular]({% slug overview_colorpicker %}).\n * Designed to replace the `<input type=\"color\">` HTML5 tag which is not widely supported in browsers.\n */\nclass ColorPickerComponent {\n    constructor(popupService, localizationService) {\n        this.popupService = popupService;\n        /**\n         * @hidden\n         */\n        this.hostClasses = true;\n        /**\n         * Sets what view the ColorPicker will render in the popup.\n         */\n        this.view = 'gradient';\n        /**\n         * Sets the read-only state of the ColorPicker.\n         */\n        this.readonly = false;\n        /**\n         * Sets the disabled state of the ColorPicker.\n         */\n        this.disabled = false;\n        /**\n         * Specifies the output format of the ColorPicker.\n         * The input value may be in a different format. However, it will be parsed into the output `format`\n         * after the component processes it.\n         *\n         * If the `gradient` view is used with the `opacity` option set to true, this setting will be ignored and `rgba` will be used instead.\n         *\n         * The supported values are:\n         * * `rgba` (default)\n         * * `hex`\n         * * [`name`](https://www.w3.org/wiki/CSS/Properties/color/keywords)\n         */\n        this.format = 'rgba';\n        /**\n         * Fires each time the value is changed.\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * Fires each time the popup is about to open.\n         * This event is preventable. If you cancel it, the popup will remain closed.\n         */\n        this.open = new EventEmitter();\n        /**\n         * Fires each time the popup is about to close.\n         * This event is preventable. If you cancel it, the popup will remain open.\n         */\n        this.close = new EventEmitter();\n        /**\n         * Fires each time ColorPicker is focused.\n         */\n        this.onFocus = new EventEmitter();\n        /**\n         * Fires each time the ColorPicker is blurred.\n         */\n        this.onBlur = new EventEmitter();\n        /**\n         * Fires each time the left side of the ColorPicker wrapper is clicked.\n         * The event is triggered regardless of whether a ColorPicker icon is set or not.\n         *\n         * The [`ActiveColorClickEvent`]({% slug api_inputs_activecolorclickevent %}) event provides the option to prevent the popup opening.\n         */\n        this.activeColorClick = new EventEmitter();\n        this._tabindex = 0;\n        this._popupSettings = { animate: true };\n        this._paletteSettings = {};\n        this._gradientSettings = { opacity: true, clearButton: false };\n        this.notifyNgTouched = () => { };\n        this.notifyNgChanged = () => { };\n        this.dynamicRTLSubscription = localizationService.changes.subscribe(({ rtl }) => {\n            this.direction = rtl ? 'rtl' : 'ltr';\n        });\n    }\n    /**\n     * Specifies the value of the initially selected color.\n     */\n    set value(value) {\n        this._value = parseColor$1(value, this.format);\n    }\n    get value() {\n        return this._value;\n    }\n    /**\n     * Configures the popup of the ColorPicker.\n     */\n    set popupSettings(value) {\n        this._popupSettings = Object.assign(this._popupSettings, value);\n    }\n    get popupSettings() {\n        return this._popupSettings;\n    }\n    /**\n     * Configures the palette that is displayed in the ColorPicker popup.\n     */\n    set paletteSettings(value) {\n        this._paletteSettings = Object.assign(this._paletteSettings, value);\n    }\n    get paletteSettings() {\n        return this._paletteSettings;\n    }\n    /**\n     * Configures the gradient that is displayed in the ColorPicker popup.\n     */\n    set gradientSettings(value) {\n        this._gradientSettings = Object.assign(this._gradientSettings, value);\n    }\n    get gradientSettings() {\n        return this._gradientSettings;\n    }\n    /**\n     * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n     */\n    set tabindex(value) {\n        const tabindex = Number(value);\n        const defaultValue = 0;\n        this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;\n    }\n    get tabindex() {\n        return !this.disabled ? this._tabindex : undefined;\n    }\n    /**\n     * Indicates whether the ColorPicker popup is open.\n     */\n    get isOpen() {\n        return isPresent(this.popupRef);\n    }\n    /**\n     * @hidden\n     */\n    get iconStyles() {\n        if (this.iconClass) {\n            return this.iconClass;\n        }\n        if (this.icon) {\n            return `k-icon k-i-${this.icon}`;\n        }\n    }\n    ngOnInit() {\n        const defaultPreset = (this.format !== 'name') ? DEFAULT_PRESET : DEFAULT_ACCESSIBLE_PRESET;\n        const settingsPalette = this._paletteSettings.palette;\n        const presetColumns = typeof settingsPalette === 'string' && PALETTEPRESETS[settingsPalette] ?\n            PALETTEPRESETS[settingsPalette].columns :\n            undefined;\n        this._paletteSettings = {\n            palette: settingsPalette || defaultPreset,\n            tileSize: this._paletteSettings.tileSize || 24,\n            columns: this._paletteSettings.columns || presetColumns || 10\n        };\n    }\n    ngOnChanges(changes) {\n        if (changes.format && changes.format.currentValue === 'name') {\n            this.view = 'palette';\n        }\n        if (this.view === 'gradient' && this.gradientSettings.opacity) {\n            this.format = 'rgba';\n            this.value = parseColor$1(this.value, this.format);\n        }\n    }\n    ngOnDestroy() {\n        this.closePopup();\n        if (this.dynamicRTLSubscription) {\n            this.dynamicRTLSubscription.unsubscribe();\n        }\n    }\n    /**\n     * @hidden\n     */\n    handleWrapperClick() {\n        this.toggleWithEvents(!this.isOpen);\n        this.focus();\n    }\n    /**\n     * @hidden\n     */\n    handleActiveColorClick() {\n        this.focus();\n        const event = new ActiveColorClickEvent(this.value);\n        this.activeColorClick.emit(event);\n        if (!event.isOpenPrevented() || this.isOpen) {\n            this.handleWrapperClick();\n        }\n    }\n    /**\n     * Focuses the wrapper of the ColorPicker.\n     */\n    focus() {\n        if (this.disabled) {\n            return;\n        }\n        this.wrapper.nativeElement.focus();\n    }\n    /**\n     * @hidden\n     */\n    handleWrapperFocus() {\n        if (isPresent(this.palette)) {\n            this.palette.nativeElement.focus();\n        }\n        if (this.isFocused) {\n            return;\n        }\n        this.isFocused = true;\n        this.onFocus.emit();\n    }\n    /**\n     * Blurs the ColorPicker.\n     */\n    blur() {\n        this.wrapper.nativeElement.blur();\n    }\n    /**\n     * @hidden\n     */\n    handleWrapperBlur() {\n        if (this.isOpen) {\n            return;\n        }\n        this.isFocused = false;\n        this.onBlur.emit();\n        this.notifyNgTouched();\n    }\n    /**\n     * Clears the color value of the ColorPicker.\n     */\n    reset() {\n        if (!isPresent(this.value)) {\n            return;\n        }\n        this._value = undefined;\n        this.notifyNgChanged(undefined);\n    }\n    /**\n     * Toggles the popup of the ColorPicker.\n     * Does not trigger the `open` and `close` events of the component.\n     *\n     * @param open An optional parameter. Specifies whether the popup will be opened or closed.\n     */\n    toggle(open) {\n        if (this.disabled || this.readonly) {\n            return;\n        }\n        this.closePopup();\n        open = isPresent(open) ? open : !this.isOpen;\n        if (open) {\n            this.openPopup();\n        }\n    }\n    /**\n     * @hidden\n     */\n    handleValueChange(color, closePopup) {\n        const parsedColor = parseColor$1(color, this.format);\n        const valueChange = parsedColor !== this.value;\n        if (closePopup) {\n            this.toggleWithEvents(false);\n            this.focus();\n        }\n        if (valueChange) {\n            this.value = parsedColor;\n            this.valueChange.emit(parsedColor);\n            this.notifyNgChanged(parsedColor);\n        }\n    }\n    /**\n     * @hidden\n     */\n    handlePopupBlur(event) {\n        const focusInPopupElement = this.popupRef.popupElement.contains(event.relatedTarget);\n        const wrapperClicked = event.relatedTarget === this.wrapper.nativeElement;\n        if (!this.isFocused || wrapperClicked || focusInPopupElement) {\n            return;\n        }\n        this.isFocused = false;\n        this.onBlur.emit();\n        this.notifyNgTouched();\n        this.toggleWithEvents(false);\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n        this.value = value;\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.notifyNgChanged = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.notifyNgTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n    handleWrapperKeyDown(event) {\n        if (event.keyCode === Keys.ArrowDown || event.keyCode === Keys.Enter) {\n            event.preventDefault();\n            this.toggleWithEvents(true);\n        }\n    }\n    /**\n     * @hidden\n     */\n    handlePopupKeyDown(keyCode) {\n        if (keyCode === Keys.Tab || keyCode === Keys.Escape) {\n            this.toggleWithEvents(false);\n            this.wrapper.nativeElement.focus();\n        }\n    }\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the component is empty.\n     */\n    isEmpty() {\n        return false;\n    }\n    toggleWithEvents(open) {\n        const sameState = this.isOpen === open;\n        if (this.disabled || this.readonly || sameState) {\n            return;\n        }\n        const eventArgs = new PreventableEvent();\n        open ? this.open.emit(eventArgs) : this.close.emit(eventArgs);\n        if (!eventArgs.isDefaultPrevented()) {\n            this.toggle(open);\n        }\n    }\n    openPopup() {\n        const horizontalAlign = this.direction === \"rtl\" ? \"right\" : \"left\";\n        const anchorPosition = { horizontal: horizontalAlign, vertical: \"bottom\" };\n        const popupPosition = { horizontal: horizontalAlign, vertical: \"top\" };\n        this.popupRef = this.popupService.open({\n            anchor: this.wrapper,\n            animate: this.popupSettings.animate,\n            appendTo: this.popupSettings.appendTo,\n            popupAlign: popupPosition,\n            anchorAlign: anchorPosition,\n            popupClass: 'k-colorpicker-popup',\n            content: this.popupTemplate,\n            positionMode: 'absolute'\n        });\n        this.popupRef.popupAnchorViewportLeave.subscribe(() => {\n            this.toggleWithEvents(false);\n            if (!this.isOpen) {\n                this.wrapper.nativeElement.focus({\n                    preventScroll: true\n                });\n            }\n        });\n    }\n    closePopup() {\n        if (!this.isOpen) {\n            return;\n        }\n        this.popupRef.close();\n        this.popupRef = null;\n        this.palette = null;\n    }\n}\nColorPickerComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-colorpicker',\n                providers: [{\n                        multi: true,\n                        provide: NG_VALUE_ACCESSOR,\n                        useExisting: forwardRef(() => ColorPickerComponent)\n                    }, {\n                        provide: KendoInput,\n                        useExisting: forwardRef(() => ColorPickerComponent)\n                    },\n                    LocalizationService,\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.colorpicker'\n                    }\n                ],\n                template: `\n        <span\n            #wrapper\n            [ngClass]=\"{\n                'k-picker-wrap': true,\n                'k-state-default': !this.disabled,\n                'k-state-disabled': this.disabled,\n                'k-state-focused': this.isFocused\n            }\"\n            [attr.tabindex]=\"tabindex\"\n            (focus)=\"handleWrapperFocus()\"\n            (blur)=\"handleWrapperBlur()\"\n            (mousedown)=\"$event.preventDefault()\"\n            (keydown)=\"handleWrapperKeyDown($event)\"\n        >\n            <span *ngIf=\"!iconStyles\" class=\"k-selected-color\" [style.background-color]=\"value\" (click)=\"handleActiveColorClick()\">\n                <span class=\"k-icon k-i-line\" *ngIf=\"!value\"></span>\n            </span>\n            <span *ngIf=\"iconStyles\" class=\"k-tool-icon\" [ngClass]=\"iconStyles\" (click)=\"handleActiveColorClick()\">\n                <span class=\"k-selected-color\" [style.background-color]=\"value\"></span>\n            </span>\n            <span class=\"k-select\" (click)=\"handleWrapperClick()\">\n                <span class=\"k-icon k-i-arrow-s\"></span>\n            </span>\n        </span>\n        <ng-template #popupTemplate>\n            <kendo-colorgradient\n                *ngIf=\"view === 'gradient' || view === 'combo'\"\n                kendoFocusOnDomReady\n                [value]=\"value\"\n                [format]=\"format\"\n                [opacity]=\"gradientSettings.opacity\"\n                [clearButton]=\"gradientSettings.clearButton\"\n                (focusout)=\"handlePopupBlur($event)\"\n                (valueChange)=\"handleValueChange($event, false)\"\n                (keydown)=\"handlePopupKeyDown($event.keyCode)\"\n            >\n            </kendo-colorgradient>\n            <kendo-colorpalette\n                #palette\n                *ngIf=\"view === 'palette' || view === 'combo'\"\n                kendoFocusOnDomReady\n                [palette]=\"paletteSettings.palette\"\n                [columns]=\"paletteSettings.columns\"\n                [tileSize]=\"paletteSettings.tileSize\"\n                [format]=\"format\"\n                [value]=\"value\"\n                (blur)=\"handlePopupBlur($event)\"\n                (cellSelection)=\"handleValueChange($event, true)\"\n                (mousedown)=\"$event.preventDefault()\"\n                (keydown)=\"handlePopupKeyDown($event.keyCode)\"\n            >\n            </kendo-colorpalette>\n        </ng-template>\n        <ng-container #container></ng-container>\n    `\n            },] },\n];\n/** @nocollapse */\nColorPickerComponent.ctorParameters = () => [\n    { type: PopupService },\n    { type: LocalizationService }\n];\nColorPickerComponent.propDecorators = {\n    hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-colorpicker',] }],\n    direction: [{ type: HostBinding, args: ['attr.dir',] }],\n    view: [{ type: Input }],\n    readonly: [{ type: Input }],\n    disabled: [{ type: Input }],\n    format: [{ type: Input }],\n    value: [{ type: Input }],\n    popupSettings: [{ type: Input }],\n    paletteSettings: [{ type: Input }],\n    gradientSettings: [{ type: Input }],\n    icon: [{ type: Input }],\n    iconClass: [{ type: Input }],\n    tabindex: [{ type: Input }],\n    valueChange: [{ type: Output }],\n    open: [{ type: Output }],\n    close: [{ type: Output }],\n    onFocus: [{ type: Output, args: ['focus',] }],\n    onBlur: [{ type: Output, args: ['blur',] }],\n    activeColorClick: [{ type: Output }],\n    container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef },] }],\n    wrapper: [{ type: ViewChild, args: ['wrapper',] }],\n    popupTemplate: [{ type: ViewChild, args: ['popupTemplate',] }],\n    palette: [{ type: ViewChild, args: ['palette', { read: ElementRef },] }]\n};\n\n/**\n * @hidden\n */\nclass ColorPaletteService {\n    constructor() {\n        this.colorRows = [];\n    }\n    setColorMatrix(palette, columns) {\n        this.colorRows = [];\n        if (!(isPresent(palette) && palette.length)) {\n            return;\n        }\n        columns = columns || palette.length;\n        for (let start = 0; start < palette.length; start += columns) {\n            const row = palette.slice(start, columns + start);\n            this.colorRows.push(row);\n        }\n    }\n    getCellCoordsFor(color) {\n        if (!isPresent(color)) {\n            return;\n        }\n        for (let row = 0; row < this.colorRows.length; row++) {\n            for (let col = 0; col < this.colorRows[row].length; col++) {\n                if (this.colorRows[row][col] === color) {\n                    return { row, col };\n                }\n            }\n        }\n    }\n    getColorAt(cellCoords) {\n        if (!(isPresent(cellCoords) && isPresent(this.colorRows[cellCoords.row]))) {\n            return;\n        }\n        return this.colorRows[cellCoords.row][cellCoords.col];\n    }\n    getNextCell(current, horizontalStep, verticalStep) {\n        if (!(isPresent(current) && isPresent(current.row) && isPresent(current.col))) {\n            return { row: 0, col: 0 };\n        }\n        const row = this.clampIndex(current.row + verticalStep, this.colorRows.length - 1);\n        const col = this.clampIndex(current.col + horizontalStep, this.colorRows[row].length - 1);\n        return { row, col };\n    }\n    clampIndex(index, max) {\n        const minArrayIndex = 0;\n        if (index < minArrayIndex) {\n            return minArrayIndex;\n        }\n        if (index > max) {\n            return max;\n        }\n        return index;\n    }\n}\nColorPaletteService.decorators = [\n    { type: Injectable },\n];\n\nconst DEFAULT_TILE_SIZE = 24;\nconst DEFAULT_COLUMNS_COUNT = 10;\nconst DEFAULT_PRESET$1 = 'office';\nconst DEFAULT_ACCESSIBLE_PRESET$1 = 'accessible';\n/**\n * The ColorPalette component provides a set of predefined palette presets and enables you to implement a custom color palette.\n * The ColorPalette is independently used by `kendo-colorpicker` and can be directly added to the page.\n */\nclass ColorPaletteComponent {\n    constructor(service, localizationService) {\n        this.service = service;\n        /**\n         * Specifies the output format of the ColorPaletteComponent.\n         * The input value may be in a different format. However, it will be parsed into the output `format`\n         * after the component processes it.\n         *\n         * The supported values are:\n         * * (Default) `hex`\n         * * `rgba`\n         * * `name`\n         */\n        this.format = 'hex';\n        /**\n         * Specifies the size of a color cell.\n         *\n         * The possible values are:\n         * * (Default) `tileSize = 24`\n         * * `{ width: number, height: number }`\n         */\n        this.tileSize = { width: DEFAULT_TILE_SIZE, height: DEFAULT_TILE_SIZE };\n        /**\n         * Fires each time the color selection is changed.\n         */\n        this.selectionChange = new EventEmitter();\n        /**\n         * Fires each time the value is changed.\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * Fires each time the user selects a cell with the mouse or presses `Enter`.\n         *\n         * @hidden\n         */\n        this.cellSelection = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.hostClasses = true;\n        this._tabindex = 0;\n        this.notifyNgTouched = () => { };\n        this.notifyNgChanged = () => { };\n        this.dynamicRTLSubscription = localizationService.changes.subscribe(({ rtl }) => {\n            this.direction = rtl ? 'rtl' : 'ltr';\n        });\n    }\n    /**\n     * Specifies the value of the initially selected color.\n     */\n    set value(value) {\n        this._value = parseColor$1(value, this.format);\n    }\n    get value() {\n        return this._value;\n    }\n    /**\n     * Specifies the number of columns that will be displayed.\n     * Defaults to `10`.\n     */\n    set columns(value) {\n        const minColumnsCount = 1;\n        this._columns = value > minColumnsCount ? value : minColumnsCount;\n    }\n    get columns() {\n        return this._columns;\n    }\n    /**\n     * The color palette that will be displayed.\n     *\n     * The supported values are:\n     * * The name of the predefined palette preset (for example, `office`, `basic`, and `apex`).\n     * * A string with comma-separated colors.\n     * * A string array.\n     */\n    set palette(value) {\n        if (!isPresent(value)) {\n            value = DEFAULT_PRESET$1;\n        }\n        if (typeof value === 'string' && isPresent(PALETTEPRESETS[value])) {\n            this.columns = this.columns || PALETTEPRESETS[value].columns;\n            value = PALETTEPRESETS[value].colors;\n        }\n        const colors = (typeof value === 'string') ? value.split(',') : value;\n        this._palette = colors.map(color => parseColor$1(color, this.format, false));\n    }\n    get palette() {\n        return this._palette;\n    }\n    /**\n     * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n     */\n    set tabindex(value) {\n        const tabindex = Number(value);\n        const defaultValue = 0;\n        this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;\n    }\n    get tabindex() {\n        return !this.disabled ? this._tabindex : undefined;\n    }\n    /**\n     * @hidden\n     */\n    get tileLayout() {\n        if (typeof this.tileSize !== 'number') {\n            return this.tileSize;\n        }\n        return { width: this.tileSize, height: this.tileSize };\n    }\n    /**\n     * @hidden\n     */\n    get colorRows() {\n        return this.service.colorRows;\n    }\n    /**\n     * @hidden\n     */\n    get hostTabindex() { return this.tabindex; }\n    /**\n     * @hidden\n     */\n    get disabledClass() { return this.disabled; }\n    ngOnInit() {\n        if (this.colorRows.length === 0) {\n            const defaultPreset = (this.format !== 'name') ? DEFAULT_PRESET$1 : DEFAULT_ACCESSIBLE_PRESET$1;\n            this.palette = this.palette || defaultPreset;\n            this.setRows();\n            this.focusedCell = this.service.getCellCoordsFor(this.value);\n        }\n    }\n    ngOnDestroy() {\n        if (this.dynamicRTLSubscription) {\n            this.dynamicRTLSubscription.unsubscribe();\n        }\n    }\n    ngOnChanges(changes) {\n        if (changes.palette || changes.columns) {\n            this.setRows();\n        }\n        if (changes.palette || changes.value || changes.columns) {\n            this.focusedCell = this.service.getCellCoordsFor(this.value);\n        }\n    }\n    /**\n     * @hidden\n     */\n    handleKeydown(event) {\n        const isRTL = this.direction === 'rtl';\n        switch (event.keyCode) {\n            case Keys.ArrowDown:\n                this.handleCellNavigation(0, 1);\n                break;\n            case Keys.ArrowUp:\n                this.handleCellNavigation(0, -1);\n                break;\n            case Keys.ArrowRight:\n                this.handleCellNavigation(isRTL ? -1 : 1, 0);\n                break;\n            case Keys.ArrowLeft:\n                this.handleCellNavigation(isRTL ? 1 : -1, 0);\n                break;\n            case Keys.Enter:\n                this.handleEnter();\n                break;\n            default: return;\n        }\n        event.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n    handleHostBlur() {\n        this.notifyNgTouched();\n    }\n    /**\n     * @hidden\n     */\n    handleCellSelection(value, focusedCell) {\n        if (this.readonly) {\n            return;\n        }\n        this.focusedCell = focusedCell;\n        const parsedColor = parseColor$1(value, this.format, false);\n        this.cellSelection.emit(parsedColor);\n        if (this.value !== parsedColor) {\n            this.value = parsedColor;\n            this.valueChange.emit(parsedColor);\n            this.notifyNgChanged(parsedColor);\n        }\n        if (this.selection !== parsedColor) {\n            this.selection = parsedColor;\n            this.selectionChange.emit(parsedColor);\n        }\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n        this.value = value;\n        this.focusedCell = this.service.getCellCoordsFor(this.value);\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.notifyNgChanged = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.notifyNgTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the component is empty.\n     */\n    isEmpty() {\n        return false;\n    }\n    /**\n     * Clears the color value of the ColorPalette.\n     */\n    reset() {\n        this.focusedCell = null;\n        if (isPresent(this.value)) {\n            this._value = undefined;\n            this.notifyNgChanged(undefined);\n        }\n    }\n    setRows() {\n        if (!isPresent(this.palette)) {\n            return;\n        }\n        this.columns = this.columns || DEFAULT_COLUMNS_COUNT;\n        this.service.setColorMatrix(this.palette, this.columns);\n    }\n    handleCellNavigation(horizontalStep, verticalStep) {\n        if (this.readonly) {\n            return;\n        }\n        this.focusedCell = this.service.getNextCell(this.focusedCell, horizontalStep, verticalStep);\n        const selection = this.service.getColorAt(this.focusedCell);\n        if (this.selection !== selection) {\n            this.selection = selection;\n            this.selectionChange.emit(selection);\n        }\n    }\n    handleEnter() {\n        if (!isPresent(this.focusedCell)) {\n            return;\n        }\n        const selectedColor = this.service.getColorAt(this.focusedCell);\n        this.handleCellSelection(selectedColor, this.focusedCell);\n    }\n}\nColorPaletteComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-colorpalette',\n                providers: [\n                    {\n                        multi: true,\n                        provide: NG_VALUE_ACCESSOR,\n                        useExisting: forwardRef(() => ColorPaletteComponent) // tslint:disable-line:no-forward-ref\n                    }, {\n                        provide: KendoInput,\n                        useExisting: forwardRef(() => ColorPaletteComponent)\n                    },\n                    ColorPaletteService,\n                    LocalizationService,\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.colorpalette'\n                    }\n                ],\n                template: `\n        <div role=\"grid\">\n            <table class=\"k-palette k-reset\" role=\"presentation\">\n                <tbody>\n                    <tr role=\"row\" *ngFor=\"let row of colorRows; let rowIndex = index\">\n                        <td *ngFor=\"let color of row; let colIndex = index\"\n                            [class.k-state-selected]=\"focusedCell?.row === rowIndex && focusedCell?.col === colIndex\"\n                            class=\"k-item\"\n                            [attr.value]=\"color\"\n                            (click)=\"handleCellSelection(color, { row: rowIndex, col: colIndex })\"\n                            [ngStyle]=\"{\n                                backgroundColor: color,\n                                width: tileLayout.width + 'px',\n                                height: tileLayout.height + 'px',\n                                minWidth: tileLayout.width + 'px'\n                            }\">\n                        </td>\n                    </tr>\n                </tbody>\n            </table>\n        </div>\n    `\n            },] },\n];\n/** @nocollapse */\nColorPaletteComponent.ctorParameters = () => [\n    { type: ColorPaletteService },\n    { type: LocalizationService }\n];\nColorPaletteComponent.propDecorators = {\n    direction: [{ type: HostBinding, args: ['attr.dir',] }],\n    format: [{ type: Input }],\n    value: [{ type: Input }],\n    columns: [{ type: Input }],\n    palette: [{ type: Input }],\n    tabindex: [{ type: Input }],\n    disabled: [{ type: Input }],\n    readonly: [{ type: Input }],\n    tileSize: [{ type: Input }],\n    selectionChange: [{ type: Output }],\n    valueChange: [{ type: Output }],\n    cellSelection: [{ type: Output }],\n    hostTabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],\n    hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-colorpalette',] }],\n    disabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }],\n    handleKeydown: [{ type: HostListener, args: ['keydown', ['$event'],] }],\n    handleHostBlur: [{ type: HostListener, args: ['blur',] }]\n};\n\nconst DEFAULT_OUTPUT_FORMAT = 'rgba';\nconst DEFAULT_BACKGROUND_COLOR = 'rgba(255, 0, 0, 1)';\n/**\n * The ColorGradient component enables smooth color transitions and provides options for selecting specific colors over the drag handle.\n * The ColorGradient is independently used by `kendo-colorpicker` and can be directly added to the page.\n */\nclass ColorGradientComponent {\n    constructor(host, ngZone, renderer, cdr, localizationService) {\n        this.host = host;\n        this.ngZone = ngZone;\n        this.renderer = renderer;\n        this.cdr = cdr;\n        this.hostClasses = true;\n        /**\n         * Defines whether the alpha slider will be displayed.\n         */\n        this.opacity = true;\n        /**\n         * Sets the disabled state of the ColorGradient.\n         */\n        this.disabled = false;\n        /**\n         * Sets the read-only state of the ColorGradient.\n         */\n        this.readonly = false;\n        /**\n         * Specifies whether the ColorGradient should display a 'Clear color' button.\n         */\n        this.clearButton = false;\n        /**\n         * Fires each time the user selects a new color.\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.backgroundColor = DEFAULT_BACKGROUND_COLOR;\n        /**\n         * @hidden\n         *\n         * Represents the currently selected `hue`, `saturation`, `value`, and `alpha` values.\n         * The values are initially set in `ngOnInit` or in `ngOnChanges` and are\n         * updated on moving the drag handle or the sliders.\n         */\n        this.hsva = {};\n        /**\n         * Specifies the output format of the ColorGradientComponent.\n         * The input value may be in a different format. However, it will be parsed into the output `format`\n         * after the component processes it.\n         *\n         * The supported values are:\n         * * (Default) `rgba`\n         * * `hex`\n         */\n        this.format = DEFAULT_OUTPUT_FORMAT;\n        this._tabindex = 0;\n        this.listeners = [];\n        this.notifyNgChanged = () => { };\n        this.notifyNgTouched = () => { };\n        this.dynamicRTLSubscription = localizationService.changes.subscribe(({ rtl }) => {\n            this.direction = rtl ? 'rtl' : 'ltr';\n        });\n    }\n    get disabledClass() {\n        return this.disabled;\n    }\n    get hostTabindex() {\n        return this.tabindex;\n    }\n    /**\n     * Specifies the value of the initially selected color.\n     */\n    set value(value) {\n        this._value = parseColor$1(value, this.format);\n    }\n    get value() {\n        return this._value;\n    }\n    /**\n     * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n     */\n    set tabindex(value) {\n        const tabindex = Number(value);\n        const defaultValue = 0;\n        this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;\n    }\n    get tabindex() {\n        return !this.disabled ? this._tabindex : undefined;\n    }\n    /**\n     * Indicates whether the ColorGradient or any of its content is focused.\n     */\n    get isFocused() {\n        if (!(isDocumentAvailable() && isPresent(this.host))) {\n            return false;\n        }\n        return this.host.nativeElement === document.activeElement || this.host.nativeElement.contains(document.activeElement);\n    }\n    /**\n     * @hidden\n     */\n    get alphaSliderValue() {\n        // setting the initial value to undefined to force the slider to recalculate the height of the slider track on the next cdr run\n        if (!(isPresent(this.hsva) && isPresent(this.hsva.a))) {\n            return;\n        }\n        return this.hsva.a * 100;\n    }\n    get gradientRect() {\n        return this.gradientWrapper.nativeElement.getBoundingClientRect();\n    }\n    ngAfterViewInit() {\n        this.updateUI();\n        this.cdr.detectChanges();\n        this.addEventListeners();\n    }\n    ngOnChanges(changes) {\n        if (isChanged('value', changes) && !this.isFocused) {\n            this.updateUI();\n        }\n    }\n    ngOnDestroy() {\n        this.listeners.forEach(removeListener => removeListener());\n        if (this.dynamicRTLSubscription) {\n            this.dynamicRTLSubscription.unsubscribe();\n        }\n    }\n    /**\n     * Focuses the component.\n     */\n    focus() {\n        if (this.disabled) {\n            return;\n        }\n        this.host.nativeElement.focus();\n    }\n    /**\n     * @hidden\n     */\n    reset() {\n        this.handleValueChange(undefined);\n        this.updateUI();\n    }\n    /**\n     * @hidden\n     */\n    handleDragPress(args) {\n        if (this.disabled || this.readonly || !isPresent(args.originalEvent)) {\n            return;\n        }\n        this.focus();\n        args.originalEvent.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n    onHandleDrag(args) {\n        if (this.disabled || this.readonly) {\n            return;\n        }\n        this.renderer.addClass(this.gradientWrapper.nativeElement, 'k-dragging');\n        this.changePosition(args);\n    }\n    /**\n     * @hidden\n     */\n    onHandleRelease() {\n        if (this.disabled || this.readonly) {\n            return;\n        }\n        this.renderer.removeClass(this.gradientWrapper.nativeElement, 'k-dragging');\n    }\n    /**\n     * @hidden\n     */\n    changePosition(position) {\n        if (this.disabled || this.readonly) {\n            return;\n        }\n        this.ngZone.run(() => this.moveDragHandle(position));\n    }\n    /**\n     * @hidden\n     */\n    handleHueSliderChange(hue) {\n        this.handleValueChange(getColorFromHSV(this.hsva));\n        this.backgroundColor = getColorFromHue(hue);\n        this.setAlphaSliderBackground(this.backgroundColor);\n    }\n    /**\n     * @hidden\n     */\n    handleAlphaSliderChange(alpha) {\n        this.hsva.a = alpha / 100;\n        this.handleValueChange(getColorFromHSV(this.hsva));\n    }\n    /**\n     * @hidden\n     */\n    handleInputsValueChange(color) {\n        const parsed = parseColor$1(color, this.format);\n        if (this.value !== parsed) {\n            this.handleValueChange(parsed);\n            this.updateUI();\n        }\n    }\n    /**\n     * @hidden\n     */\n    writeValue(value) {\n        this.value = value;\n        if (isPresent(this.gradientWrapper)) {\n            this.updateUI();\n        }\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.notifyNgChanged = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.notifyNgTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the component is empty.\n     */\n    isEmpty() {\n        return false;\n    }\n    moveDragHandle(position) {\n        const deltaX = position.clientX - this.gradientRect.left;\n        const deltaY = position.clientY - this.gradientRect.top;\n        const top = fitIntoBounds(deltaY, 0, this.gradientRect.height);\n        const left = fitIntoBounds(deltaX, 0, this.gradientRect.width);\n        this.setDragHandleElementPosition(top, left);\n        this.hsva.s = left / this.gradientRect.width;\n        this.hsva.v = 1 - top / this.gradientRect.height;\n        this.handleValueChange(getColorFromHSV(this.hsva));\n        this.setAlphaSliderBackground(getColorFromHSV(Object.assign({}, this.hsva, { a: 1 })));\n    }\n    updateUI() {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        this.hsva = this.value ? getHSV(this.value) : { h: 0, s: 0, v: 1, a: 1 };\n        const top = (1 - this.hsva.v) * this.gradientRect.height;\n        const left = this.hsva.s * this.gradientRect.width;\n        this.setDragHandleElementPosition(top, left);\n        this.backgroundColor = getColorFromHue(this.hsva.h);\n        this.setAlphaSliderBackground(this.backgroundColor);\n    }\n    handleValueChange(color) {\n        if (this.value === color) {\n            return;\n        }\n        this.value = color;\n        this.valueChange.emit(color);\n        this.notifyNgChanged(color);\n    }\n    setDragHandleElementPosition(top, left) {\n        const dragHandle = this.dragHandle.nativeElement;\n        this.renderer.setStyle(dragHandle, 'top', `${top}px`);\n        this.renderer.setStyle(dragHandle, 'left', `${left}px`);\n    }\n    setAlphaSliderBackground(backgroundColor) {\n        if (!isPresent(this.alphaSlider)) {\n            return;\n        }\n        const sliderTrack = this.alphaSlider.track.nativeElement;\n        this.renderer.setStyle(sliderTrack, 'background', `linear-gradient(to top, transparent, ${backgroundColor})`);\n    }\n    addEventListeners() {\n        this.ngZone.runOutsideAngular(() => {\n            const focusOutListener = this.renderer.listen(this.host.nativeElement, 'focusout', (event) => {\n                if (!containsFocus(this.host.nativeElement, event.relatedTarget) && isUntouched(this.host)) {\n                    this.ngZone.run(() => this.notifyNgTouched());\n                }\n            });\n            this.listeners.push(focusOutListener);\n        });\n    }\n}\nColorGradientComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-colorgradient',\n                providers: [{\n                        multi: true,\n                        provide: NG_VALUE_ACCESSOR,\n                        useExisting: forwardRef(() => ColorGradientComponent)\n                    }, {\n                        provide: KendoInput,\n                        useExisting: forwardRef(() => ColorGradientComponent)\n                    },\n                    LocalizationService,\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.colorgradient'\n                    }\n                ],\n                template: `\n        <div class=\"k-hbox k-hsv-wrap\">\n            <div class=\"k-hsv-rectangle\" [style.background-color]=\"backgroundColor\">\n                <div\n                    #gradientWrapper\n                    kendoDraggable\n                    class=\"k-hsv-gradient\"\n                    (click)=\"changePosition($event)\"\n                    (kendoPress)=\"handleDragPress($event)\"\n                    (kendoDrag)=\"onHandleDrag($event)\"\n                    (kendoRelease)=\"onHandleRelease()\">\n                    <div\n                        #dragHandle\n                        class=\"k-draghandle\"\n                    >\n                    </div>\n                </div>\n            </div>\n            <div class=\"k-hbox k-sliders-wrap {{ clearButton ? 'k-sliders-wrap-clearable' : '' }}\">\n                <span class=\"k-clear-color k-button k-bare k-button-icon\" *ngIf=\"clearButton\" (click)=\"reset()\">\n                    <span class=\"k-icon k-i-reset-color\"></span>\n                </span>\n                <kendo-slider\n                    class=\"k-hue-slider\"\n                    [disabled]=\"disabled\"\n                    [readonly]=\"readonly\"\n                    [showButtons]=\"false\"\n                    [tickPlacement]=\"'none'\"\n                    [vertical]=\"true\"\n                    [min]=\"0\"\n                    [max]=\"360\"\n                    [smallStep]=\"5\"\n                    [largeStep]=\"10\"\n                    [(value)]=\"hsva.h\"\n                    (valueChange)=\"handleHueSliderChange($event)\"\n                >\n                </kendo-slider>\n                <kendo-slider\n                    *ngIf=\"opacity && format === 'rgba'\"\n                    #alphaSlider\n                    class=\"k-alpha-slider\"\n                    [disabled]=\"disabled\"\n                    [readonly]=\"readonly\"\n                    [showButtons]=\"false\"\n                    [tickPlacement]=\"'none'\"\n                    [vertical]=\"true\"\n                    [min]=\"0\"\n                    [max]=\"100\"\n                    [smallStep]=\"1\"\n                    [largeStep]=\"10\"\n                    [value]=\"alphaSliderValue\"\n                    (valueChange)=\"handleAlphaSliderChange($event)\"\n                >\n                </kendo-slider>\n            </div>\n        </div>\n        <kendo-colorinput\n            [opacity]=\"opacity\"\n            [value]=\"value\"\n            [disabled]=\"disabled\"\n            [readonly]=\"readonly\"\n            (valueChange)=\"handleInputsValueChange($event)\"\n        >\n        </kendo-colorinput>\n`\n            },] },\n];\n/** @nocollapse */\nColorGradientComponent.ctorParameters = () => [\n    { type: ElementRef },\n    { type: NgZone },\n    { type: Renderer2 },\n    { type: ChangeDetectorRef },\n    { type: LocalizationService }\n];\nColorGradientComponent.propDecorators = {\n    hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-flatcolorpicker',] }],\n    disabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }],\n    hostTabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],\n    direction: [{ type: HostBinding, args: ['attr.dir',] }],\n    opacity: [{ type: Input }],\n    disabled: [{ type: Input }],\n    readonly: [{ type: Input }],\n    clearButton: [{ type: Input }],\n    value: [{ type: Input }],\n    tabindex: [{ type: Input }],\n    valueChange: [{ type: Output }],\n    format: [{ type: Input }],\n    alphaSlider: [{ type: ViewChild, args: ['alphaSlider',] }],\n    gradientWrapper: [{ type: ViewChild, args: ['gradientWrapper',] }],\n    dragHandle: [{ type: ViewChild, args: ['dragHandle',] }]\n};\n\n/**\n * @hidden\n */\nclass ColorInputComponent {\n    constructor(host) {\n        this.host = host;\n        /**\n         * Sets whether the alpha slider will be shown.\n         */\n        this.opacity = true;\n        /**\n         * Sets the disabled state of the ColorInput.\n         */\n        this.disabled = false;\n        /**\n         * Sets the read-only state of the ColorInput.\n         */\n        this.readonly = false;\n        /**\n         * Emits a parsed rgba string color.\n         */\n        this.valueChange = new EventEmitter();\n        this.colorInputClass = true;\n        /**\n         * The rgba inputs values.\n         */\n        this.rgba = {};\n    }\n    /**\n     * Indicates whether any of the inputs are focused.\n     */\n    get isFocused() {\n        if (!(isDocumentAvailable() && isPresent(this.host))) {\n            return false;\n        }\n        const activeElement = document.activeElement;\n        return this.host.nativeElement.contains(activeElement);\n    }\n    /**\n     * Indicates whether any of the rgba inputs have value.\n     */\n    get rgbaInputValid() {\n        return Object.keys(this.rgba).every(key => isPresent(this.rgba[key]));\n    }\n    ngOnChanges(changes) {\n        if (isPresent(changes.value) && !this.isFocused) {\n            this.hex = parseColor$1(this.value, 'hex');\n            this.rgba = getRGBA(this.value);\n            this.rgba.a = parseColor$1(this.value, 'rgba') ? this.rgba.a : 1;\n        }\n    }\n    handleRgbaValueChange() {\n        const color = getColorFromRGBA(this.rgba);\n        if (!this.rgbaInputValid || color === this.value) {\n            return;\n        }\n        this.value = color;\n        this.rgba = getRGBA(this.value);\n        this.hex = parseColor$1(color, 'hex');\n        this.valueChange.emit(color);\n    }\n    handleHexValueChange(hex) {\n        this.hex = hex;\n        const color = parseColor$1(hex, 'rgba');\n        if (!isPresent(color) || color === this.value) {\n            return;\n        }\n        this.value = color;\n        this.rgba = getRGBA(color);\n        this.valueChange.emit(color);\n    }\n    handleRgbaInputBlur() {\n        if (!this.rgbaInputValid) {\n            this.rgba = getRGBA(this.value);\n        }\n    }\n    handleHexInputBlur() {\n        this.hex = parseColor$1(this.value, 'hex');\n    }\n}\nColorInputComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-colorinput',\n                template: `\n        <div class=\"k-hbox k-gradient-values\">\n            <input\n                #hexInput\n                class=\"k-textbox k-hex-value\"\n                [disabled]=\"disabled\"\n                [readonly]=\"readonly\"\n                [value]=\"hex || ''\"\n                placeholder=\"no color\"\n                (blur)=\"handleHexInputBlur()\"\n                (input)=\"handleHexValueChange(hexInput.value)\"\n            />\n            <kendo-numerictextbox\n                [disabled]=\"disabled\"\n                [readonly]=\"readonly\"\n                [min]=\"0\"\n                [max]=\"255\"\n                placeholder=\"R\"\n                [(value)]=\"rgba.r\"\n                [autoCorrect]=\"true\"\n                [spinners]=\"false\"\n                [format]=\"'n'\"\n                [decimals]=\"0\"\n                (blur)=\"handleRgbaInputBlur()\"\n                (valueChange)=\"handleRgbaValueChange()\"\n            >\n            </kendo-numerictextbox>\n            <kendo-numerictextbox\n                [disabled]=\"disabled\"\n                [readonly]=\"readonly\"\n                [min]=\"0\"\n                [max]=\"255\"\n                placeholder=\"G\"\n                [(value)]=\"rgba.g\"\n                [autoCorrect]=\"true\"\n                [spinners]=\"false\"\n                [format]=\"'n'\"\n                [decimals]=\"0\"\n                (blur)=\"handleRgbaInputBlur()\"\n                (valueChange)=\"handleRgbaValueChange()\"\n            >\n            </kendo-numerictextbox>\n            <kendo-numerictextbox\n                [disabled]=\"disabled\"\n                [readonly]=\"readonly\"\n                [min]=\"0\"\n                [max]=\"255\"\n                placeholder=\"B\"\n                [(value)]=\"rgba.b\"\n                [autoCorrect]=\"true\"\n                [spinners]=\"false\"\n                [format]=\"'n'\"\n                [decimals]=\"0\"\n                (blur)=\"handleRgbaInputBlur()\"\n                (valueChange)=\"handleRgbaValueChange()\"\n            >\n            </kendo-numerictextbox>\n            <kendo-numerictextbox\n                *ngIf=\"opacity\"\n                [disabled]=\"disabled\"\n                [readonly]=\"readonly\"\n                [min]=\"0\"\n                [max]=\"1\"\n                placeholder=\"A\"\n                [(value)]=\"rgba.a\"\n                [autoCorrect]=\"true\"\n                [spinners]=\"false\"\n                [step]=\"0.01\"\n                [format]=\"'n2'\"\n                [decimals]=\"2\"\n                (blur)=\"handleRgbaInputBlur()\"\n                (valueChange)=\"handleRgbaValueChange()\"\n            >\n            </kendo-numerictextbox>\n        </div>\n        <div class=\"k-hbox k-gradient-values\">\n            <div class=\"k-hex-value\">hex</div>\n            <div>r</div>\n            <div>g</div>\n            <div>b</div>\n            <div *ngIf=\"opacity\">a</div>\n        </div>\n    `\n            },] },\n];\n/** @nocollapse */\nColorInputComponent.ctorParameters = () => [\n    { type: ElementRef }\n];\nColorInputComponent.propDecorators = {\n    value: [{ type: Input }],\n    opacity: [{ type: Input }],\n    disabled: [{ type: Input }],\n    readonly: [{ type: Input }],\n    valueChange: [{ type: Output }],\n    colorInputClass: [{ type: HostBinding, args: ['class.k-colorinputs',] }]\n};\n\n/**\n * @hidden\n */\nclass FocusOnDomReadyDirective {\n    constructor(host, ngZone) {\n        this.host = host;\n        this.ngZone = ngZone;\n    }\n    ngAfterContentInit() {\n        this.focusOnNextTick();\n    }\n    focusOnNextTick() {\n        this.ngZone.runOutsideAngular(() => setTimeout(() => this.host.nativeElement.focus()));\n    }\n}\nFocusOnDomReadyDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoFocusOnDomReady]'\n            },] },\n];\n/** @nocollapse */\nFocusOnDomReadyDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: NgZone }\n];\n\nconst PUBLIC_DIRECTIVES = [\n    ColorPickerComponent,\n    ColorPaletteComponent,\n    ColorGradientComponent\n];\nconst INTERNAL_DIRECTIVES = [\n    ColorInputComponent,\n    FocusOnDomReadyDirective\n];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the ColorPicker.\n */\nclass ColorPickerModule {\n}\nColorPickerModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [\n                    PUBLIC_DIRECTIVES,\n                    INTERNAL_DIRECTIVES\n                ],\n                exports: [PUBLIC_DIRECTIVES],\n                imports: [\n                    SliderModule,\n                    NumericTextBoxModule,\n                    CommonModule,\n                    PopupModule,\n                    DraggableModule\n                ]\n            },] },\n];\n\n/**\n * Represents the directive that renders the [Kendo UI CheckBox]({% slug overview_checkbox %}) input component.\n * The directive is placed on input type=\"checkbox\" elements.\n *\n * @example\n * ```ts-no-run\n * <input type=\"checkbox\" kendoCheckBox />\n * ```\n */\nclass CheckBoxDirective {\n    constructor() {\n        this.kendoClass = true;\n    }\n}\nCheckBoxDirective.decorators = [\n    { type: Directive, args: [{\n                selector: 'input[kendoCheckBox]'\n            },] },\n];\nCheckBoxDirective.propDecorators = {\n    kendoClass: [{ type: HostBinding, args: ['class.k-checkbox',] }]\n};\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the CheckBox directive.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the CheckBox module\n * import { CheckBoxModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, CheckBoxModule], // import CheckBox module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nclass CheckBoxModule {\n}\nCheckBoxModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [CheckBoxDirective],\n                exports: [CheckBoxDirective],\n                imports: [CommonModule]\n            },] },\n];\n\n/**\n * Represents the directive that renders the [Kendo UI RadioButton]({% slug overview_checkbox %}) input component.\n * The directive is placed on input type=\"radio\" elements.\n *\n * @example\n * ```ts-no-run\n * <input type=\"radio\" kendoRadioButton />\n * ```\n */\nclass RadioButtonDirective {\n    constructor() {\n        this.kendoClass = true;\n    }\n}\nRadioButtonDirective.decorators = [\n    { type: Directive, args: [{\n                selector: 'input[kendoRadioButton]'\n            },] },\n];\nRadioButtonDirective.propDecorators = {\n    kendoClass: [{ type: HostBinding, args: ['class.k-radio',] }]\n};\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the RadioButton directive.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the RadioButton module\n * import { RadioButtonModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, RadioButtonModule], // import RadioButton module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nclass RadioButtonModule {\n}\nRadioButtonModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [RadioButtonDirective],\n                exports: [RadioButtonDirective],\n                imports: [CommonModule]\n            },] },\n];\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Inputs components.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Inputs module\n * import { InputsModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, BrowserAnimationsModule, InputsModule], // import Inputs module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nclass InputsModule {\n}\nInputsModule.decorators = [\n    { type: NgModule, args: [{\n                exports: [TextBoxModule, SliderModule, SwitchModule, NumericTextBoxModule, MaskedTextBoxModule, ColorPickerModule, CheckBoxModule, RadioButtonModule],\n                imports: [CommonModule]\n            },] },\n];\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CheckBoxModule, ColorInputComponent, FocusOnDomReadyDirective, ColorPaletteService, MaskingService, NumericTextBoxMessages, RadioButtonModule, SliderCustomMessagesComponent, SliderMessages, SwitchCustomMessagesComponent, Messages, SliderComponent, LabelTemplateDirective, SwitchComponent, TextBoxContainerComponent, TextBoxDirective, TextAreaDirective, NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent, MaskedTextBoxComponent, InputsModule, SliderTicksComponent, SliderModule, SwitchModule, NumericTextBoxModule, MaskedTextBoxModule, TextBoxModule, ColorPickerComponent, ColorPaletteComponent, ColorGradientComponent, ColorPickerModule, ActiveColorClickEvent, CheckBoxDirective, RadioButtonDirective, LocalizedNumericTextBoxMessagesDirective, LocalizedSliderMessagesDirective, LocalizedSwitchMessagesDirective };\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0OC,2IAKC;;;;;;;;;;;;kCAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAohBD,sOAqFC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAqDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsPD,0IAuCC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAgCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkMD,kDAaC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAiBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0LD,uDASC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAmBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmFD,mBASC;;;;;;;;;;;;;;;;;;;;;;;;;oBAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAw3BD,+JAwEC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAoCA;;;;;;;;oMAMD;;;;;iGAIC;;;;;;;;;;;;;;;;;;;;CAaD,sKAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmaD;;;gDAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAocD,gFA6CC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAkCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAyDD,yIAwBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAeA;;;;;;;;8MAMD;;;;;;iFAKC;;;;;;;;;;;;;;;;;CAUD,iDAWC;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;;;CAaD,8JAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmCD;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAkBC;;;;;;;;8IAMD;;;;;qEAIC;;;;;;;;;;;;;;;;;CAUD,iDAWC;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;;;CAaD,8JAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkCD;;;;;;;;;;;;;;;;;;;;;0BAeC;;;;;;;;;;;;;;;;;CAUD,iDAWC;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkCD;;;;;;;;;;;;;;;;;;;0BAcC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkCD;;;;;;;;;0BAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkCD;;;;;;;;;;;;;0BAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAimBD,sDA2EC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBA8BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwDD;;;gDAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgRD,0EA2CC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAwBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsSD,oDAoFC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAyBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiFD,gFAwFC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAYA;;;;;;;;;;;;;;;;;;CAgBD,2IAKC;;;;;;;;;;;oGAKA;;;;;;;;;;;;;;;;;;;;;;;;CAgBD;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAgBC;;;;;;;;;;;;;;;;;;;CAeD,UAKC;;;;;;;;;;;;oBAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkCD;;;;;;;;;0BAOC;;;;;;;;;;;;;;;;;;;CAeD,UAKC;;;;;;;;;;;;oBAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkCD;;;;;;;;;0BAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmCD;;;;;;;;;;;;;;;0BAMC;;;;;;;"}