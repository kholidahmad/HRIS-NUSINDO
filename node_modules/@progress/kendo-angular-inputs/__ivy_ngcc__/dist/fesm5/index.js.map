{"version":3,"file":"index.js","sources":["D:/project/projek_angular/hris_rni/node_modules/@progress/kendo-angular-inputs/dist/fesm5/index.js"],"sourcesContent":["/**-----------------------------------------------------------------------------------------\n* Copyright Â© 2020 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport { Directive, TemplateRef, Optional, Component, forwardRef, Injector, Renderer2, NgZone, ElementRef, Input, Output, ViewChild, ContentChild, HostBinding, EventEmitter, ChangeDetectorRef, Inject, isDevMode, Injectable, HostListener, ViewChildren, NgModule, ViewContainerRef } from '@angular/core';\nimport { NgControl, NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';\nimport { fromEvent, interval, merge, Subscription, Observable } from 'rxjs';\nimport { take, filter, concatMap, startWith, takeUntil, skip, debounceTime } from 'rxjs/operators';\nimport { SliderModel, SliderUtil } from '@telerik/kendo-inputs-common';\nimport { __extends, __assign } from 'tslib';\nimport { LocalizationService, L10N_PREFIX, RTL, ComponentMessages } from '@progress/kendo-angular-l10n';\nimport { anyChanged, isDocumentAvailable, Keys, KendoInput, guid, hasObservers, isChanged, DraggableModule, EventsModule, ResizeSensorModule } from '@progress/kendo-angular-common';\nimport { browser, mobileOS } from '@progress/kendo-common';\nimport { IntlService } from '@progress/kendo-angular-intl';\nimport { CommonModule } from '@angular/common';\nimport { PopupService, PopupModule } from '@progress/kendo-angular-popup';\nimport { Color, parseColor, namedColors } from '@progress/kendo-drawing';\n\n/**\n * @hidden\n */\nvar MAX_PRECISION = 20;\n/**\n * @hidden\n */\nvar limitPrecision = function (precision) { return Math.min(precision, MAX_PRECISION); };\n/**\n * @hidden\n */\nvar fractionLength = function (value) {\n    return (String(value).split('.')[1] || \"\").length;\n};\nvar maxFractionLength = function (value1, value2) {\n    return Math.max(fractionLength(value1), fractionLength(value2));\n};\n/**\n * @hidden\n */\nvar toFixedPrecision = function (value, precision) {\n    var maxPrecision = limitPrecision(precision);\n    return parseFloat(value.toFixed(maxPrecision));\n};\n/**\n * @hidden\n */\nvar add = function (value1, value2) {\n    var maxPrecision = maxFractionLength(value1, value2);\n    return toFixedPrecision(value1 + value2, maxPrecision);\n};\n/**\n * @hidden\n */\nvar subtract = function (value1, value2) {\n    return add(value1, -value2);\n};\n/**\n * @hidden\n */\nvar multiply = function (value1, value2) {\n    var maxPrecision = fractionLength(value1) + fractionLength(value2);\n    return toFixedPrecision(value1 * value2, maxPrecision);\n};\n/**\n * @hidden\n */\nvar divide = function (dividend, divisor) {\n    if (divisor === 0) {\n        return NaN;\n    }\n    var power = maxFractionLength(dividend, divisor);\n    var correctionValue = Math.pow(10, power);\n    return ((correctionValue * dividend) / (correctionValue * divisor));\n};\n/**\n * @hidden\n */\nvar remainder = function (dividend, divisor) {\n    return Math.abs(subtract(dividend, multiply(divisor, Math.floor(divide(dividend, divisor)))));\n};\n\nfunction elementOffset(element) {\n    var box = element.getBoundingClientRect();\n    var documentElement = document.documentElement;\n    return {\n        left: box.left + (window.pageXOffset || documentElement.scrollLeft) - (documentElement.clientLeft || 0),\n        top: box.top + (window.pageYOffset || documentElement.scrollTop) - (documentElement.clientTop || 0)\n    };\n}\nfunction limitValue(value, min, max) {\n    return Math.max(Math.min(value, max), min);\n}\n/**\n * @hidden\n */\nfunction decreaseValueToStep(value, _a, large) {\n    var max = _a.max, min = _a.min, smallStep = _a.smallStep, largeStep = _a.largeStep;\n    if (large === void 0) { large = false; }\n    var step = large && largeStep ? multiply(smallStep, largeStep) : smallStep;\n    var stepValue = subtract(value, min);\n    var result;\n    var stepRemainder = remainder(stepValue, step);\n    if (stepRemainder === 0) {\n        result = subtract(stepValue, step);\n    }\n    else {\n        result = subtract(stepValue, stepRemainder);\n    }\n    return limitValue(add(result, min), min, max);\n}\n/**\n * @hidden\n */\nfunction increaseValueToStep(value, _a, large) {\n    var max = _a.max, min = _a.min, smallStep = _a.smallStep, largeStep = _a.largeStep;\n    if (large === void 0) { large = false; }\n    var step = large && largeStep ? multiply(smallStep, largeStep) : smallStep;\n    var stepValue = subtract(value, min);\n    var stepRemainder = remainder(stepValue, step);\n    var result = add(subtract(stepValue, stepRemainder), step);\n    return limitValue(add(result, min), min, max);\n}\n/**\n * @hidden\n */\nfunction snapValue(value, options) {\n    var smallStep = options.smallStep, min = options.min, max = options.max;\n    var limitted = limitValue(value, min, max);\n    if (value !== limitted) {\n        return limitted;\n    }\n    var left = decreaseValueToStep(value, options);\n    var right = increaseValueToStep(value, options);\n    if ((value - min) % smallStep === 0) {\n        return value;\n    }\n    if (right - value <= (right - left) / 2) {\n        return right;\n    }\n    return left;\n}\n/**\n * @hidden\n */\nfunction eventValue(eventArgs, scaleElement, options) {\n    var min = options.min, max = options.max, vertical = options.vertical, rtl = options.rtl;\n    var trackOffset = elementOffset(scaleElement);\n    var offset = vertical ? eventArgs.pageY - trackOffset.top : eventArgs.pageX - trackOffset.left;\n    var scale = (max - min) / (vertical ? scaleElement.clientHeight : scaleElement.clientWidth);\n    var offsetValue = offset * scale;\n    var value = rtl || vertical ? max - offsetValue : min + offsetValue;\n    var stepFractionLength = fractionLength(options.smallStep);\n    value = toFixedPrecision(value, stepFractionLength + 1);\n    return snapValue(value, options);\n}\n/**\n * @hidden\n */\nfunction isButton(element) {\n    return element.className.indexOf('k-button-increase') >= 0 || element.className.indexOf('k-button-decrease') >= 0;\n}\n/**\n * @hidden\n */\nfunction increment(options) {\n    return increaseValueToStep(options.value, options);\n}\n/**\n * @hidden\n */\nfunction decrement(options) {\n    return decreaseValueToStep(options.value, options);\n}\n/**\n * @hidden\n */\nfunction incrementLarge(options) {\n    return increaseValueToStep(options.value, options, true);\n}\n/**\n * @hidden\n */\nfunction decrementLarge(options) {\n    return decreaseValueToStep(options.value, options, true);\n}\n/**\n * @hidden\n */\nfunction calculateValueFromTick(index, _a) {\n    var max = _a.max, min = _a.min, smallStep = _a.smallStep, reverse = _a.reverse, vertical = _a.vertical;\n    var value = add(min, multiply(index, smallStep));\n    return vertical || reverse ? Math.abs(subtract(value, max)) : value;\n}\n/**\n * @hidden\n */\nfunction calculateTicksCount(min, max, smallStep) {\n    if (min === void 0) { min = 0; }\n    if (max === void 0) { max = 0; }\n    if (smallStep === void 0) { smallStep = 1; }\n    if (smallStep <= 0) {\n        throw new Error(\"Invalid argument: smallStep must be a positive number\");\n    }\n    var adjustedRange = Math.abs(subtract(max, min));\n    var adjustedRatio = Math.floor(divide(adjustedRange, smallStep));\n    var result = add(adjustedRatio, 1);\n    return result;\n}\n\n/**\n * @hidden\n */\nvar SliderModel$1 = /** @class */ (function (_super) {\n    __extends(SliderModel$$1, _super);\n    function SliderModel$$1() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    SliderModel$$1.prototype.getTickSizes = function () {\n        var _a = this.props, min = _a.min, max = _a.max, smallStep = _a.smallStep;\n        var count = calculateTicksCount(min, max, smallStep);\n        var trackSize = this.trackWidth();\n        var distStep = trackSize / subtract(max, min);\n        var result = [];\n        var usedSpace = 0;\n        var endPoint = 0;\n        for (var i = 0; i < count; i++) {\n            if (i === 0 || i === count - 1) {\n                endPoint += (smallStep / 2) * distStep;\n            }\n            else {\n                endPoint += smallStep * distStep;\n            }\n            var size = Math.round(endPoint - usedSpace);\n            result.push(size);\n            usedSpace += size;\n        }\n        return result;\n    };\n    return SliderModel$$1;\n}(SliderModel));\n\n/**\n * Represents the template for the labels of the Slider.\n * To define the labels template, nest an `<ng-template>` tag with the `kendoSliderLabelTemplate` directive inside\n * the `<kendo-slider>` tag. The template context is passed to the `label` value.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *         <kendo-slider [largeStep]=\"2\">\n *           <ng-template kendoSliderLabelTemplate let-value=\"value\">\n *             <b>{{value}}</b>\n *           </ng-template>\n *         </kendo-slider>\n *     `\n * })\n *\n * class AppComponent {\n * }\n *\n * ```\n */\nvar LabelTemplateDirective = /** @class */ (function () {\n    function LabelTemplateDirective(templateRef) {\n        this.templateRef = templateRef;\n    }\n    LabelTemplateDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[kendoSliderLabelTemplate]'\n                },] },\n    ];\n    /** @nocollapse */\n    LabelTemplateDirective.ctorParameters = function () { return [\n        { type: TemplateRef, decorators: [{ type: Optional }] }\n    ]; };\n    return LabelTemplateDirective;\n}());\n\n/**\n * @hidden\n *\n * Checks if the value is `null` or `undefined`. Falsy values like '', 0, false, NaN, etc. are regarded as present.\n */\nvar isPresent = function (value) { return value !== null && value !== undefined; };\n/**\n * @hidden\n */\nvar areSame = function (value1, value2) {\n    return value1 === value2 || (value1 === null && value2 === undefined) || (value1 === undefined && value2 === null);\n};\n/**\n * @hidden\n */\nvar requiresZoneOnBlur = function (ngControl) { return ngControl &&\n    (!ngControl.touched || (ngControl.control && ngControl.control.updateOn === 'blur')); };\n/**\n * @hidden\n *\n * Fits the contender number into the specified bounds. If the number is NaN or null, the min is returned.\n *\n * @param contender Represents the number you want to fit into specified bounds.\n * @param min The inclusive lower bound number.\n * @param max The inclusive upper bound number.\n */\nvar fitIntoBounds = function (contender, min, max) {\n    if (!isPresent(contender) || isNaN(contender)) {\n        return min;\n    }\n    return contender <= min ? min : contender >= max ? max : contender;\n};\n\nvar UNTOUCHED = 'ng-untouched';\nvar toClassList = function (classNames) { return String(classNames).trim().split(' '); };\n/**\n * @hidden\n */\nvar hasClass = function (element, className) {\n    return Boolean(toClassList(element.className).find(function (name) { return name === className; }));\n};\n/**\n * @hidden\n */\nfunction invokeElementMethod(element, name) {\n    var args = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        args[_i - 2] = arguments[_i];\n    }\n    if (element && element.nativeElement) {\n        return element.nativeElement[name].apply(element.nativeElement, args);\n    }\n}\n/**\n * @hidden\n */\nvar isUntouched = function (element) {\n    return element && element.nativeElement && hasClass(element.nativeElement, UNTOUCHED);\n};\n/**\n * @hidden\n */\nvar containsFocus = function (hostElement, contender) {\n    return hostElement && contender && (hostElement === contender || hostElement.contains(contender));\n};\n\nvar FOCUSED = 'k-state-focused';\nvar PRESSED = 'k-pressed';\n/**\n * Represents the [Kendo UI Slider component for Angular]({% slug overview_slider %}).\n */\nvar SliderComponent = /** @class */ (function () {\n    function SliderComponent(localizationService, injector, renderer, ngZone, hostElement) {\n        var _this = this;\n        this.localizationService = localizationService;\n        this.injector = injector;\n        this.renderer = renderer;\n        this.ngZone = ngZone;\n        this.hostElement = hostElement;\n        /**\n         * @hidden\n         */\n        this.focusableId = \"k-\" + guid();\n        /**\n         * Determines if the animation will be played on value change.\n         * Regardless of this setting, no animation will be played during the initial rendering.\n         */\n        this.animate = true;\n        /**\n         * Renders the arrow side buttons of the Slider ([see example]({% slug sidebuttons_slider %}#toc-hidden-state)).\n         * When `showButtons` is set to `false`, the buttons are not displayed.\n         */\n        this.showButtons = true;\n        /**\n         * Denotes the location of the tick marks in the Slider ([see example]({% slug ticks_slider %}#toc-placement)).\n         *\n         * The available options are:\n         * * `before`&mdash;The tick marks are located to the top side of the horizontal track or to the left side of a vertical track.\n         * * `after`&mdash;The tick marks are located to the bottom side of the horizontal track or to the right side of the vertical track.\n         * * `both`&mdash;The tick marks are located on both sides of the track.\n         * * `none`&mdash;The tick marks are not visible. The actual elements are not added to the DOM tree.\n         */\n        this.tickPlacement = 'both';\n        /**\n         * Defines the title of the ticks ([see example]({% slug ticks_slider %}#toc-titles)). The default title\n         * for each tick is its Slider value. If you use a callback function, the function accepts an argument\n         * that holds the value of the component and returns a string with the new title.\n         */\n        this.title = SliderUtil.identity;\n        /**\n         * If `vertical` is set to `true`, the orientation of the Slider changes from horizontal to vertical\n         * ([see example]({% slug orientation_slider %})).\n         */\n        this.vertical = false;\n        /**\n         * The minimum value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).\n         * The attribute accepts both integers and floating-point numbers.\n         */\n        this.min = 0;\n        /**\n         * The maximum value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).\n         * The attribute accepts both integers and floating-point numbers.\n         */\n        this.max = 10;\n        /**\n         * The step value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).\n         * Accepts positive values only. Can be an integer or a floating-point number.\n         */\n        this.smallStep = 1;\n        /**\n         * Specifies that every n<sup>th</sup> tick will be large and will have a label\n         * ([see example]({% slug predefinedsteps_slider %}#toc-large-steps)).\n         * Accepts positive integer values only.\n         */\n        this.largeStep = null;\n        /**\n         * Determines whether the Slider is disabled ([see example]({% slug disabledstate_slider %})).\n         */\n        this.disabled = false;\n        /**\n         * Determines whether the Slider is in its read-only state ([see example]({% slug readonly_slider %})).\n         */\n        this.readonly = false;\n        /**\n         * The current value of the Slider when it is initially displayed.\n         * The component can use either NgModel or the `value` binding but not both of them at the same time.\n         */\n        this.value = 0;\n        /**\n         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the Slider.\n         */\n        this.tabindex = 0;\n        /**\n         * Fires each time the user focuses the `input` element.\n         */\n        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the `input` element gets blurred.\n         */\n        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the user selects a new value.\n         */\n        this.valueChange = new EventEmitter();\n        this.sliderClass = true;\n        this.widgetClass = true;\n        this.stateDefaultClass = true;\n        this.subscriptions = new Subscription();\n        /**\n         * @hidden\n         */\n        this.handleFocus = function () {\n            _this.focused = true;\n            if (hasObservers(_this.onFocus)) {\n                _this.ngZone.run(function () {\n                    _this.onFocus.emit();\n                });\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.handleBlur = function () {\n            _this.focused = false;\n            if (hasObservers(_this.onBlur) || requiresZoneOnBlur(_this.control)) {\n                _this.ngZone.run(function () {\n                    _this.ngTouched();\n                    _this.onBlur.emit();\n                });\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.onWrapClick = function (args) {\n            var target = args.target;\n            if (!_this.isDisabled && !(isButton(target) || isButton(target.parentNode))) {\n                var value = eventValue(args, _this.track.nativeElement, _this.getProps());\n                _this.changeValue(value);\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.ifEnabled = function (callback, event) {\n            if (!_this.isDisabled) {\n                callback.call(_this, event);\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.onKeyDown = function (e) {\n            var options = _this.getProps();\n            var max = options.max, min = options.min;\n            var handler = _this.keyBinding[e.keyCode];\n            if (_this.isDisabled || !handler) {\n                return;\n            }\n            var value = handler(options);\n            _this.changeValue(SliderUtil.trimValue(max, min, value));\n            e.preventDefault();\n        };\n        this.ngChange = function (_) { };\n        this.ngTouched = function () { };\n        this.decreaseValue = function () {\n            _this.changeValue(decreaseValueToStep(_this.value, _this.getProps()));\n        };\n        this.increaseValue = function () {\n            _this.changeValue(increaseValueToStep(_this.value, _this.getProps()));\n        };\n        this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n    }\n    Object.defineProperty(SliderComponent.prototype, \"tabIndex\", {\n        get: function () {\n            return this.tabindex;\n        },\n        /**\n         * @hidden\n         */\n        set: function (tabIndex) {\n            this.tabindex = tabIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SliderComponent.prototype, \"horizontalClass\", {\n        get: function () {\n            return !this.vertical;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SliderComponent.prototype, \"verticalClass\", {\n        get: function () {\n            return this.vertical;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SliderComponent.prototype, \"disabledClass\", {\n        get: function () {\n            return this.disabled;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SliderComponent.prototype, \"ariaDisabled\", {\n        get: function () {\n            return this.disabled ? true : undefined;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SliderComponent.prototype, \"ariaReadonly\", {\n        get: function () {\n            return this.readonly ? true : undefined;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SliderComponent.prototype, \"ariaMin\", {\n        get: function () {\n            return this.min;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SliderComponent.prototype, \"ariaMax\", {\n        get: function () {\n            return this.max;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SliderComponent.prototype, \"ariaValue\", {\n        get: function () {\n            return this.value ? this.value : this.min;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     *\n     * @param isDisabled\n     */\n    SliderComponent.prototype.setDisabledState = function (isDisabled) {\n        this.disabled = isDisabled;\n    };\n    SliderComponent.prototype.ngOnInit = function () {\n        var _this = this;\n        this.subscriptions.add(this.localizationService\n            .changes\n            .subscribe(function (_a) {\n            var rtl = _a.rtl;\n            _this.direction = rtl ? 'rtl' : 'ltr';\n            _this.sizeComponent(false);\n        }));\n        if (this.hostElement) {\n            this.renderer.removeAttribute(this.hostElement.nativeElement, \"tabindex\");\n        }\n        this.control = this.injector.get(NgControl, null);\n    };\n    /**\n     * Focuses the Slider.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"slider.focus()\">Focus</button>\n     *  <kendo-slider #slider></kendo-slider>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    SliderComponent.prototype.focus = function () {\n        invokeElementMethod(this.wrapper, 'focus');\n    };\n    /**\n     * Blurs the Slider.\n     */\n    SliderComponent.prototype.blur = function () {\n        invokeElementMethod(this.wrapper, 'blur');\n    };\n    SliderComponent.prototype.ngOnChanges = function (changes) {\n        var _this = this;\n        if (anyChanged(['value', 'fixedTickWidth', 'tickPlacement'], changes, true)) {\n            this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(function () {\n                _this.sizeComponent(false);\n            });\n        }\n    };\n    SliderComponent.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        if (this.showButtons) {\n            this.setValueChangeInterval(this.increaseButton.nativeElement, function () { return _this.increaseValue(); });\n            this.setValueChangeInterval(this.decreaseButton.nativeElement, function () { return _this.decreaseValue(); });\n        }\n        this.sizeComponent(false);\n        if (this.ticks) {\n            this.ticks.tickElements\n                .changes\n                .subscribe(function () { return _this.sizeComponent(false); });\n        }\n    };\n    SliderComponent.prototype.ngOnDestroy = function () {\n        this.subscriptions.unsubscribe();\n    };\n    Object.defineProperty(SliderComponent.prototype, \"incrementMessage\", {\n        /**\n         * @hidden\n         */\n        get: function () {\n            return this.incrementTitle || this.localizationService.get('increment');\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SliderComponent.prototype, \"decrementMessage\", {\n        /**\n         * @hidden\n         */\n        get: function () {\n            return this.decrementTitle || this.localizationService.get('decrement');\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SliderComponent.prototype, \"dragHandleMessage\", {\n        /**\n         * @hidden\n         */\n        get: function () {\n            return this.dragHandleTitle || this.localizationService.get('dragHandle');\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @hidden\n     */\n    SliderComponent.prototype.handleDragPress = function (args) {\n        if (args.originalEvent) {\n            args.originalEvent.preventDefault();\n        }\n        this.focus();\n        this.renderer.removeClass(this.hostElement.nativeElement, 'k-slider-transitions');\n    };\n    /**\n     * @hidden\n     */\n    SliderComponent.prototype.onHandleDrag = function (args) {\n        this.dragging = true;\n        this.changeValue(eventValue(args, this.track.nativeElement, this.getProps()));\n    };\n    /**\n     * @hidden\n     */\n    SliderComponent.prototype.onHandleRelease = function () {\n        this.dragging = false; //needed for animation\n        this.renderer.addClass(this.hostElement.nativeElement, 'k-slider-transitions');\n    };\n    //ngModel binding\n    /**\n     * @hidden\n     */\n    SliderComponent.prototype.writeValue = function (value) {\n        this.value = value;\n        this.sizeComponent(this.animate);\n    };\n    /**\n     * @hidden\n     */\n    SliderComponent.prototype.registerOnChange = function (fn) {\n        this.ngChange = fn;\n    };\n    /**\n     * @hidden\n     */\n    SliderComponent.prototype.registerOnTouched = function (fn) {\n        this.ngTouched = fn;\n    };\n    /**\n     * @hidden\n     */\n    SliderComponent.prototype.changeValue = function (value) {\n        var _this = this;\n        if (!areSame(this.value, value)) {\n            this.ngZone.run(function () {\n                _this.value = value;\n                _this.ngChange(value);\n                _this.valueChange.emit(value);\n                _this.sizeComponent(_this.animate);\n            });\n        }\n    };\n    /**\n     * @hidden\n     */\n    SliderComponent.prototype.sizeComponent = function (animate) {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        var wrapper = this.wrapper.nativeElement;\n        var track = this.track.nativeElement;\n        var selectionEl = this.sliderSelection.nativeElement;\n        var dragHandleEl = this.draghandle.nativeElement;\n        var ticks = this.ticks ? this.ticksContainer.nativeElement : null;\n        if (!animate) {\n            this.renderer.removeClass(this.hostElement.nativeElement, 'k-slider-transitions');\n        }\n        this.resetStyles([track, selectionEl, dragHandleEl, ticks, this.hostElement.nativeElement]);\n        var props = this.getProps();\n        var model = new SliderModel$1(props, wrapper, track);\n        model.resizeTrack();\n        if (this.ticks) { //for case when tickPlacement: none\n            model.resizeTicks(this.ticksContainer.nativeElement, this.ticks.tickElements.map(function (element) { return element.nativeElement; }));\n        }\n        model.positionHandle(dragHandleEl);\n        model.positionSelection(dragHandleEl, selectionEl);\n        if (!animate) {\n            this.hostElement.nativeElement.getBoundingClientRect();\n            this.renderer.addClass(this.hostElement.nativeElement, 'k-slider-transitions');\n        }\n        if (this.fixedTickWidth) {\n            model.resizeWrapper();\n        }\n    };\n    Object.defineProperty(SliderComponent.prototype, \"isDisabled\", {\n        /**\n         * @hidden\n         */\n        get: function () {\n            return this.disabled || this.readonly;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the component is empty.\n     */\n    SliderComponent.prototype.isEmpty = function () {\n        return false;\n    };\n    Object.defineProperty(SliderComponent.prototype, \"reverse\", {\n        get: function () {\n            return this.localizationService.rtl && !this.vertical;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SliderComponent.prototype, \"keyBinding\", {\n        get: function () {\n            var _a;\n            var reverse = this.reverse;\n            return _a = {},\n                _a[Keys.ArrowLeft] = reverse ? increment : decrement,\n                _a[Keys.ArrowRight] = reverse ? decrement : increment,\n                _a[Keys.ArrowDown] = decrement,\n                _a[Keys.ArrowUp] = increment,\n                _a[Keys.PageUp] = incrementLarge,\n                _a[Keys.PageDown] = decrementLarge,\n                _a[Keys.Home] = function (_a) {\n                    var min = _a.min;\n                    return min;\n                },\n                _a[Keys.End] = function (_a) {\n                    var max = _a.max;\n                    return max;\n                },\n                _a;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SliderComponent.prototype, \"focused\", {\n        set: function (value) {\n            if (this.isFocused !== value && this.hostElement) {\n                var element = this.hostElement.nativeElement;\n                if (value) {\n                    this.renderer.addClass(element, FOCUSED);\n                }\n                else {\n                    this.renderer.removeClass(element, FOCUSED);\n                }\n                this.isFocused = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SliderComponent.prototype, \"dragging\", {\n        set: function (value) {\n            if (this.isDragged !== value && this.sliderSelection && this.draghandle) {\n                var sliderSelection = this.sliderSelection.nativeElement;\n                var draghandle = this.draghandle.nativeElement;\n                if (value) {\n                    this.renderer.addClass(sliderSelection, PRESSED);\n                    this.renderer.addClass(draghandle, PRESSED);\n                }\n                else {\n                    this.renderer.removeClass(sliderSelection, PRESSED);\n                    this.renderer.removeClass(draghandle, PRESSED);\n                }\n                this.isDragged = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SliderComponent.prototype.setValueChangeInterval = function (element, callback) {\n        var _this = this;\n        this.ngZone.runOutsideAngular(function () {\n            var mousedown = fromEvent(element, 'mousedown');\n            var mouseup = fromEvent(element, 'mouseup');\n            var mouseout = fromEvent(element, 'mouseout');\n            var subscription = mousedown.pipe(filter(function (e) { return e.button === 0 && !_this.isDisabled; }), concatMap(function () {\n                return interval(150).pipe(startWith(-1), takeUntil(merge(mouseup, mouseout)));\n            })).subscribe(function () {\n                _this.focus();\n                callback();\n            });\n            _this.subscriptions.add(subscription);\n        });\n    };\n    SliderComponent.prototype.getProps = function () {\n        return {\n            buttons: this.showButtons,\n            disabled: this.disabled,\n            fixedTickWidth: this.fixedTickWidth,\n            largeStep: this.largeStep,\n            max: this.max,\n            min: this.min,\n            readonly: this.readonly,\n            reverse: this.reverse,\n            rtl: this.localizationService.rtl,\n            smallStep: this.smallStep,\n            value: SliderUtil.trimValue(this.max, this.min, this.value),\n            vertical: this.vertical\n        };\n    };\n    SliderComponent.prototype.resetStyles = function (elements) {\n        var _this = this;\n        elements.forEach(function (el) {\n            if (el) {\n                if (_this.vertical) {\n                    el.style.removeProperty('width');\n                    el.style.removeProperty('left');\n                }\n                else {\n                    el.style.removeProperty('height');\n                    el.style.removeProperty('bottom');\n                }\n                el.style.removeProperty('padding-top');\n            }\n        });\n    };\n    SliderComponent.decorators = [\n        { type: Component, args: [{\n                    exportAs: 'kendoSlider',\n                    providers: [\n                        LocalizationService,\n                        { provide: L10N_PREFIX, useValue: 'kendo.slider' },\n                        { multi: true, provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(function () { return SliderComponent; }) },\n                        { provide: KendoInput, useExisting: forwardRef(function () { return SliderComponent; }) }\n                    ],\n                    selector: 'kendo-slider',\n                    template: \"\\n        <ng-container kendoSliderLocalizedMessages\\n            i18n-increment=\\\"kendo.slider.increment|The title of the **Increase** button of the Slider.\\\"\\n            increment=\\\"increment\\\"\\n            i18n-decrement=\\\"kendo.slider.decrement|The title of the **Decrease** button of the Slider.\\\"\\n            decrement=\\\"decrement\\\"\\n            i18n-dragHandle=\\\"kendo.slider.dragHandle|The title of the drag handle of the Slider.\\\"\\n            dragHandle=\\\"Drag\\\"\\n        >\\n\\n        <div class=\\\"k-slider-wrap\\\" #wrap\\n            [id]=\\\"focusableId\\\"\\n            [class.k-slider-buttons]=\\\"showButtons\\\"\\n            [class.k-slider-topleft]=\\\"tickPlacement === 'before'\\\"\\n            [class.k-slider-bottomright]=\\\"tickPlacement === 'after'\\\"\\n            [attr.tabindex]=\\\"(this.disabled ? undefined : tabIndex)\\\"\\n            [kendoEventsOutsideAngular]=\\\"{ focus: handleFocus, blur: handleBlur, click: onWrapClick, keydown: onKeyDown }\\\"\\n            >\\n            <a\\n                #decreaseButton\\n                *ngIf=\\\"showButtons\\\"\\n                class=\\\"k-button k-button-decrease\\\"\\n                [title]=\\\"decrementMessage\\\"\\n                [attr.aria-label]=\\\"decrementMessage\\\"\\n            >\\n                <span class=\\\"k-icon\\\"\\n                    [class.k-i-arrow-w]=\\\"!vertical\\\"\\n                    [class.k-i-arrow-s]=\\\"vertical\\\"\\n                >\\n                </span>\\n            </a>\\n            <a\\n                *ngIf=\\\"showButtons\\\"\\n                #increaseButton\\n                class=\\\"k-button k-button-increase\\\"\\n                [title]=\\\"incrementMessage\\\"\\n                [attr.aria-label]=\\\"incrementMessage\\\"\\n            >\\n                <span class=\\\"k-icon\\\"\\n                    [class.k-i-arrow-e]=\\\"!vertical\\\"\\n                    [class.k-i-arrow-n]=\\\"vertical\\\"\\n                >\\n                </span>\\n            </a>\\n            <ul kendoSliderTicks\\n                #ticks\\n                *ngIf=\\\"tickPlacement !== 'none'\\\"\\n                [tickTitle]=\\\"title\\\"\\n                [vertical]=\\\"vertical\\\"\\n                [step]=\\\"smallStep\\\"\\n                [largeStep]=\\\"largeStep\\\"\\n                [min]=\\\"min\\\"\\n                [max]=\\\"max\\\"\\n                [labelTemplate]=\\\"labelTemplate?.templateRef\\\"\\n            >\\n            </ul>\\n        <div #track class=\\\"k-slider-track\\\">\\n            <div #sliderSelection class=\\\"k-slider-selection\\\">\\n            </div>\\n                <a #draghandle\\n                    [style.touch-action]=\\\"isDisabled ? '' : 'none'\\\"\\n                    class=\\\"k-draghandle\\\"\\n                    [title]=\\\"dragHandleMessage\\\"\\n                    kendoDraggable\\n                    (kendoPress)=\\\"ifEnabled(handleDragPress ,$event)\\\"\\n                    (kendoDrag)=\\\"ifEnabled(onHandleDrag ,$event)\\\"\\n                    (kendoRelease)=\\\"ifEnabled(onHandleRelease, $event)\\\"\\n                ></a>\\n            </div>\\n\\n            <kendo-resize-sensor (resize)=\\\"sizeComponent(false)\\\"></kendo-resize-sensor>\\n        </div>\\n  \"\n                },] },\n    ];\n    /** @nocollapse */\n    SliderComponent.ctorParameters = function () { return [\n        { type: LocalizationService },\n        { type: Injector },\n        { type: Renderer2 },\n        { type: NgZone },\n        { type: ElementRef }\n    ]; };\n    SliderComponent.propDecorators = {\n        focusableId: [{ type: Input }],\n        incrementTitle: [{ type: Input }],\n        animate: [{ type: Input }],\n        decrementTitle: [{ type: Input }],\n        showButtons: [{ type: Input }],\n        tickPlacement: [{ type: Input }],\n        title: [{ type: Input }],\n        dragHandleTitle: [{ type: Input }],\n        vertical: [{ type: Input }],\n        min: [{ type: Input }],\n        max: [{ type: Input }],\n        smallStep: [{ type: Input }],\n        largeStep: [{ type: Input }],\n        fixedTickWidth: [{ type: Input }],\n        disabled: [{ type: Input }],\n        readonly: [{ type: Input }],\n        value: [{ type: Input }],\n        tabindex: [{ type: Input }],\n        tabIndex: [{ type: Input }],\n        onFocus: [{ type: Output, args: ['focus',] }],\n        onBlur: [{ type: Output, args: ['blur',] }],\n        valueChange: [{ type: Output }],\n        wrapper: [{ type: ViewChild, args: ['wrap', { static: true },] }],\n        track: [{ type: ViewChild, args: ['track', { static: true },] }],\n        draghandle: [{ type: ViewChild, args: ['draghandle', { static: true },] }],\n        sliderSelection: [{ type: ViewChild, args: ['sliderSelection', { static: true },] }],\n        ticksContainer: [{ type: ViewChild, args: ['ticks', { read: ElementRef },] }],\n        ticks: [{ type: ViewChild, args: ['ticks',] }],\n        decreaseButton: [{ type: ViewChild, args: ['decreaseButton',] }],\n        increaseButton: [{ type: ViewChild, args: ['increaseButton',] }],\n        labelTemplate: [{ type: ContentChild, args: [LabelTemplateDirective,] }],\n        direction: [{ type: HostBinding, args: ['attr.dir',] }],\n        horizontalClass: [{ type: HostBinding, args: ['class.k-slider-horizontal',] }],\n        verticalClass: [{ type: HostBinding, args: ['class.k-slider-vertical',] }],\n        sliderClass: [{ type: HostBinding, args: ['class.k-slider',] }],\n        widgetClass: [{ type: HostBinding, args: ['class.k-widget',] }],\n        stateDefaultClass: [{ type: HostBinding, args: ['class.k-state-default',] }],\n        disabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }],\n        ariaDisabled: [{ type: HostBinding, args: ['attr.aria-disabled',] }],\n        ariaReadonly: [{ type: HostBinding, args: ['attr.aria-readonly',] }],\n        ariaMin: [{ type: HostBinding, args: ['attr.aria-valuemin',] }],\n        ariaMax: [{ type: HostBinding, args: ['attr.aria-valuemax',] }],\n        ariaValue: [{ type: HostBinding, args: ['attr.aria-valuenow',] }]\n    };\n    return SliderComponent;\n}());\n\nvar FOCUSED$1 = 'k-state-focused';\n/**\n * Represents the [Kendo UI Switch component for Angular]({% slug overview_switch %}).\n */\nvar SwitchComponent = /** @class */ (function () {\n    function SwitchComponent(renderer, hostElement, localizationService, injector, changeDetector, ngZone) {\n        var _this = this;\n        this.renderer = renderer;\n        this.hostElement = hostElement;\n        this.localizationService = localizationService;\n        this.injector = injector;\n        this.changeDetector = changeDetector;\n        this.ngZone = ngZone;\n        /**\n         * @hidden\n         */\n        this.focusableId = \"k-\" + guid();\n        /**\n         * Sets the current value of the Switch when it is initially displayed.\n         */\n        this.checked = false;\n        /**\n         * Determines whether the Switch is disabled ([see example]({% slug disabled_switch %})).\n         */\n        this.disabled = false;\n        /**\n         * Determines whether the Switch is in its read-only state ([see example]({% slug readonly_switch %})).\n         */\n        this.readonly = false;\n        /**\n         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the Switch.\n         */\n        this.tabindex = 0;\n        /**\n         * Fires each time the user focuses the `input` element.\n         */\n        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the `input` element gets blurred.\n         */\n        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the user selects a new value.\n         */\n        this.valueChange = new EventEmitter();\n        this.ngChange = function (_) { };\n        this.ngTouched = function () { };\n        /**\n         * @hidden\n         */\n        this.handleFocus = function () {\n            _this.focused = true;\n            if (hasObservers(_this.onFocus)) {\n                _this.ngZone.run(function () {\n                    _this.onFocus.emit();\n                });\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.handleBlur = function () {\n            _this.focused = false;\n            if (hasObservers(_this.onBlur) || requiresZoneOnBlur(_this.control)) {\n                _this.ngZone.run(function () {\n                    _this.ngTouched();\n                    _this.onBlur.emit();\n                });\n            }\n        };\n        this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n        this.keyDownHandler = this.keyDownHandler.bind(this);\n        this.clickHandler = this.clickHandler.bind(this);\n    }\n    Object.defineProperty(SwitchComponent.prototype, \"tabIndex\", {\n        get: function () {\n            return this.tabindex;\n        },\n        /**\n         * @hidden\n         */\n        set: function (tabIndex) {\n            this.tabindex = tabIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SwitchComponent.prototype, \"ieClass\", {\n        get: function () {\n            return browser && browser.msie;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SwitchComponent.prototype, \"ariaDisabled\", {\n        get: function () {\n            return this.disabled ? true : undefined;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SwitchComponent.prototype, \"ariaReadonly\", {\n        get: function () {\n            return this.readonly ? true : undefined;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SwitchComponent.prototype, \"ariaChecked\", {\n        get: function () {\n            return this.checked ? true : undefined;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SwitchComponent.prototype, \"hostClasses\", {\n        get: function () {\n            return true;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SwitchComponent.prototype, \"switchOnClass\", {\n        get: function () {\n            return this.checked;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SwitchComponent.prototype, \"switchOffClass\", {\n        get: function () {\n            return !this.checked;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SwitchComponent.prototype, \"disabledClass\", {\n        get: function () {\n            return this.disabled;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SwitchComponent.prototype, \"onLabelMessage\", {\n        /**\n         * @hidden\n         */\n        get: function () {\n            return this.onLabel || this.localizationService.get('on');\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SwitchComponent.prototype, \"offLabelMessage\", {\n        /**\n         * @hidden\n         */\n        get: function () {\n            return this.offLabel || this.localizationService.get('off');\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SwitchComponent.prototype, \"isEnabled\", {\n        get: function () {\n            return !this.disabled && !this.readonly;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SwitchComponent.prototype.ngOnInit = function () {\n        var _this = this;\n        if (this.hostElement) {\n            var wrapper = this.hostElement.nativeElement;\n            this.renderer.removeAttribute(wrapper, \"tabindex\");\n        }\n        this.localizationChangeSubscription = this.localizationService\n            .changes\n            .pipe(skip(1))\n            .subscribe(function (_a) {\n            var rtl = _a.rtl;\n            _this.direction = rtl ? 'rtl' : 'ltr';\n        });\n        this.control = this.injector.get(NgControl, null);\n    };\n    SwitchComponent.prototype.ngOnDestroy = function () {\n        if (this.localizationChangeSubscription) {\n            this.localizationChangeSubscription.unsubscribe();\n        }\n    };\n    /**\n     * Focuses the Switch.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"switch.focus()\">Focus</button>\n     *  <kendo-switch #switch></kendo-switch>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    SwitchComponent.prototype.focus = function () {\n        if (!this.wrapper) {\n            return;\n        }\n        this.wrapper.nativeElement.focus();\n    };\n    /**\n     * Blurs the Switch.\n     */\n    SwitchComponent.prototype.blur = function () {\n        if (!this.wrapper) {\n            return;\n        }\n        this.wrapper.nativeElement.blur();\n    };\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     */\n    SwitchComponent.prototype.setDisabledState = function (isDisabled) {\n        this.disabled = isDisabled;\n        this.changeDetector.markForCheck();\n    };\n    /**\n     * @hidden\n     */\n    SwitchComponent.prototype.writeValue = function (value) {\n        this.checked = value === null ? false : value;\n        this.changeDetector.markForCheck();\n    };\n    /**\n     * @hidden\n     */\n    SwitchComponent.prototype.registerOnChange = function (fn) {\n        this.ngChange = fn;\n    };\n    /**\n     * @hidden\n     */\n    SwitchComponent.prototype.registerOnTouched = function (fn) {\n        this.ngTouched = fn;\n    };\n    /**\n     * @hidden\n     */\n    SwitchComponent.prototype.keyDownHandler = function (e) {\n        var keyCode = e.keyCode;\n        if (this.isEnabled && (keyCode === Keys.Space || keyCode === Keys.Enter)) {\n            this.changeValue(!this.checked);\n            e.preventDefault();\n        }\n    };\n    /**\n     * @hidden\n     */\n    SwitchComponent.prototype.clickHandler = function () {\n        if (this.isEnabled) {\n            this.changeValue(!this.checked);\n        }\n    };\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the component is empty.\n     */\n    SwitchComponent.prototype.isEmpty = function () {\n        return false;\n    };\n    SwitchComponent.prototype.changeValue = function (value) {\n        var _this = this;\n        if (this.checked !== value) {\n            this.ngZone.run(function () {\n                _this.checked = value;\n                _this.ngChange(value);\n                _this.valueChange.emit(value);\n                _this.changeDetector.markForCheck();\n            });\n        }\n    };\n    Object.defineProperty(SwitchComponent.prototype, \"focused\", {\n        set: function (value) {\n            if (this.isFocused !== value && this.hostElement) {\n                var element = this.hostElement.nativeElement;\n                if (value) {\n                    this.renderer.addClass(element, FOCUSED$1);\n                }\n                else {\n                    this.renderer.removeClass(element, FOCUSED$1);\n                }\n                this.isFocused = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SwitchComponent.decorators = [\n        { type: Component, args: [{\n                    exportAs: 'kendoSwitch',\n                    providers: [\n                        LocalizationService,\n                        { provide: L10N_PREFIX, useValue: 'kendo.switch' },\n                        {\n                            multi: true,\n                            provide: NG_VALUE_ACCESSOR,\n                            useExisting: forwardRef(function () { return SwitchComponent; }) /* tslint:disable-line */\n                        },\n                        {\n                            provide: KendoInput,\n                            useExisting: forwardRef(function () { return SwitchComponent; })\n                        }\n                    ],\n                    selector: 'kendo-switch',\n                    template: \"\\n        <ng-container kendoSwitchLocalizedMessages\\n            i18n-on=\\\"kendo.switch.on|The **On** label of the Switch.\\\"\\n            on=\\\"ON\\\"\\n            i18n-off=\\\"kendo.switch.off|The **Off** label of the Switch.\\\"\\n            off=\\\"OFF\\\"\\n        >\\n\\n        <span\\n            #wrapper\\n            class=\\\"k-switch-container\\\"\\n            [id]=\\\"focusableId\\\"\\n            [attr.tabindex]=\\\"(disabled ? undefined : tabIndex)\\\"\\n            [kendoEventsOutsideAngular]=\\\"{ click: clickHandler, keydown: keyDownHandler, focus: handleFocus, blur: handleBlur }\\\"\\n        >\\n            <span class=\\\"k-switch-label-on\\\">{{onLabelMessage}}</span>\\n            <span class=\\\"k-switch-label-off\\\">{{offLabelMessage}}</span>\\n            <span class=\\\"k-switch-handle\\\"></span>\\n        </span>\\n  \"\n                },] },\n    ];\n    /** @nocollapse */\n    SwitchComponent.ctorParameters = function () { return [\n        { type: Renderer2 },\n        { type: ElementRef },\n        { type: LocalizationService },\n        { type: Injector },\n        { type: ChangeDetectorRef },\n        { type: NgZone }\n    ]; };\n    SwitchComponent.propDecorators = {\n        focusableId: [{ type: Input }],\n        onLabel: [{ type: Input }],\n        offLabel: [{ type: Input }],\n        checked: [{ type: Input }],\n        disabled: [{ type: Input }],\n        readonly: [{ type: Input }],\n        tabindex: [{ type: Input }],\n        tabIndex: [{ type: Input }],\n        onFocus: [{ type: Output, args: ['focus',] }],\n        onBlur: [{ type: Output, args: ['blur',] }],\n        valueChange: [{ type: Output }],\n        wrapper: [{ type: ViewChild, args: ['wrapper',] }],\n        direction: [{ type: HostBinding, args: ['attr.dir',] }],\n        ieClass: [{ type: HostBinding, args: ['class.k-ie',] }],\n        ariaDisabled: [{ type: HostBinding, args: ['attr.aria-disabled',] }],\n        ariaReadonly: [{ type: HostBinding, args: ['attr.aria-readonly',] }],\n        ariaChecked: [{ type: HostBinding, args: ['attr.aria-checked',] }],\n        hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-switch',] }],\n        switchOnClass: [{ type: HostBinding, args: ['class.k-switch-on',] }],\n        switchOffClass: [{ type: HostBinding, args: ['class.k-switch-off',] }],\n        disabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }]\n    };\n    return SwitchComponent;\n}());\n\n/**\n * Represents the [Kendo UI TextArea directive for the Inputs components for Angular]({% slug overview_textarea %}).\n * Provides floating labels to `textarea` elements.\n *\n * @example\n * ```ts-no-run\n * <textarea kendoTextArea></textarea>\n * ```\n */\nvar TextAreaDirective = /** @class */ (function () {\n    function TextAreaDirective(renderer, element, zone, changeDetector, injector, rtl) {\n        this.renderer = renderer;\n        this.element = element;\n        this.zone = zone;\n        this.changeDetector = changeDetector;\n        this.injector = injector;\n        this.elementClass = true;\n        this.autofillClass = true;\n        /**\n         * Fires each time the textarea value is changed.\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * Specifies if the `textarea` element will resize its height automatically\n         * ([see example]({% slug overview_textarea %}#toc-auto-resizing)).\n         *\n         * @default false\n         */\n        this.autoSize = false;\n        /**\n         * @hidden\n         */\n        this.onFocus = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.onBlur = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.onValueChange = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.autoFillStart = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.autoFillEnd = new EventEmitter();\n        this.listeners = [];\n        this.ngChange = function (_) { };\n        this.ngTouched = function () { };\n        this.direction = rtl ? 'rtl' : 'ltr';\n    }\n    Object.defineProperty(TextAreaDirective.prototype, \"id\", {\n        get: function () {\n            return this.element.nativeElement.id;\n        },\n        set: function (id) {\n            this.renderer.setAttribute(this.element.nativeElement, 'id', id);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @hidden\n     */\n    TextAreaDirective.prototype.writeValue = function (value) {\n        this.elementValue = value;\n        this.resize();\n    };\n    /**\n     * @hidden\n     */\n    TextAreaDirective.prototype.registerOnChange = function (fn) {\n        this.ngChange = fn;\n    };\n    /**\n     * @hidden\n     */\n    TextAreaDirective.prototype.registerOnTouched = function (fn) {\n        this.ngTouched = fn;\n    };\n    /**\n     * @hidden\n     */\n    TextAreaDirective.prototype.setDisabledState = function (isDisabled) {\n        this.setElementProperty('disabled', isDisabled);\n    };\n    TextAreaDirective.prototype.ngOnInit = function () {\n        var _this = this;\n        var element = this.element.nativeElement;\n        this.zone.runOutsideAngular(function () {\n            _this.listeners = [\n                _this.renderer.listen(element, 'focus', _this.handleFocus.bind(_this)),\n                _this.renderer.listen(element, 'blur', _this.handleBlur.bind(_this)),\n                _this.renderer.listen(element, 'animationstart', function (e) {\n                    if (e.animationName === 'autoFillStart') {\n                        _this.autoFillStart.emit();\n                    }\n                    else if (e.animationName === 'autoFillEnd') {\n                        _this.autoFillEnd.emit();\n                    }\n                })\n            ];\n            if (isDocumentAvailable() && _this.autoSize) {\n                _this.resizeSubscription = fromEvent(window, 'resize')\n                    .pipe((debounceTime(50)))\n                    .subscribe(function () { return _this.resize(); });\n            }\n            _this.inputSubscription = fromEvent(element, 'input')\n                .subscribe(_this.handleInput.bind(_this));\n        });\n        this.control = this.injector.get(NgControl, null);\n    };\n    TextAreaDirective.prototype.ngOnChanges = function (changes) {\n        var element = this.element.nativeElement;\n        if (changes.value) {\n            this.elementValue = this.value;\n        }\n        if (changes.autoSize) {\n            if (this.autoSize) {\n                this.initialHeight = element.offsetHeight;\n                this.renderer.setStyle(element, 'resize', 'none');\n            }\n            else {\n                this.renderer.setStyle(element, 'overflow-y', 'auto');\n                this.renderer.setStyle(element, 'resize', 'both');\n                element.style.height = this.initialHeight + \"px\";\n            }\n        }\n        this.resize();\n    };\n    TextAreaDirective.prototype.ngOnDestroy = function () {\n        this.listeners.forEach(function (listener) { return listener(); });\n        if (this.inputSubscription) {\n            this.inputSubscription.unsubscribe();\n        }\n        if (this.resizeSubscription) {\n            this.resizeSubscription.unsubscribe();\n        }\n    };\n    Object.defineProperty(TextAreaDirective.prototype, \"elementValue\", {\n        get: function () {\n            if (this.element) {\n                return this.element.nativeElement.value;\n            }\n            return '';\n        },\n        set: function (value) {\n            this.setElementProperty('value', (value === undefined || value === null) ? '' : value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TextAreaDirective.prototype.setElementProperty = function (name, value) {\n        if (this.element) {\n            this.renderer.setProperty(this.element.nativeElement, name, value);\n        }\n    };\n    TextAreaDirective.prototype.resize = function () {\n        if (!this.autoSize) {\n            return;\n        }\n        var element = this.element.nativeElement;\n        this.renderer.setStyle(element, 'overflow-y', 'hidden');\n        element.style.height = this.initialHeight + \"px\";\n        var scrollHeight = element.scrollHeight;\n        if (scrollHeight > this.initialHeight) {\n            element.style.height = scrollHeight + \"px\";\n        }\n    };\n    TextAreaDirective.prototype.handleInput = function () {\n        var _this = this;\n        var value = this.elementValue;\n        this.value = value;\n        if (this.control || hasObservers(this.onValueChange) || hasObservers(this.valueChange)) {\n            this.zone.run(function () {\n                _this.ngChange(value);\n                _this.onValueChange.emit(value);\n                _this.valueChange.emit(value);\n                _this.changeDetector.markForCheck();\n            });\n        }\n        this.resize();\n    };\n    TextAreaDirective.prototype.handleFocus = function () {\n        var _this = this;\n        if (hasObservers(this.onFocus)) {\n            this.zone.run(function () {\n                _this.onFocus.emit();\n            });\n        }\n    };\n    TextAreaDirective.prototype.handleBlur = function () {\n        var _this = this;\n        if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {\n            this.zone.run(function () {\n                _this.ngTouched();\n                _this.onBlur.emit();\n                _this.changeDetector.markForCheck();\n            });\n        }\n    };\n    TextAreaDirective.decorators = [\n        { type: Directive, args: [{\n                    providers: [{\n                            provide: NG_VALUE_ACCESSOR,\n                            useExisting: forwardRef(function () { return TextAreaDirective; }),\n                            multi: true\n                        }, {\n                            provide: KendoInput,\n                            useExisting: forwardRef(function () { return TextAreaDirective; })\n                        }],\n                    selector: 'textarea[kendoTextArea]'\n                },] },\n    ];\n    /** @nocollapse */\n    TextAreaDirective.ctorParameters = function () { return [\n        { type: Renderer2 },\n        { type: ElementRef },\n        { type: NgZone },\n        { type: ChangeDetectorRef },\n        { type: Injector },\n        { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [RTL,] }] }\n    ]; };\n    TextAreaDirective.propDecorators = {\n        elementClass: [{ type: HostBinding, args: ['class.k-textarea',] }],\n        autofillClass: [{ type: HostBinding, args: ['class.k-autofill',] }],\n        direction: [{ type: HostBinding, args: ['attr.dir',] }],\n        valueChange: [{ type: Output }],\n        autoSize: [{ type: Input }],\n        value: [{ type: Input }]\n    };\n    return TextAreaDirective;\n}());\n\n/**\n * @hidden\n */\nvar FloatingLabelInputAdapter = /** @class */ (function () {\n    function FloatingLabelInputAdapter(component, formControl) {\n        this.component = component;\n        var isObservableOrEventEmitter = function (event) { return event instanceof Observable || event instanceof EventEmitter; };\n        if (isObservableOrEventEmitter(component.onFocus)) {\n            this.onFocus = component.onFocus;\n        }\n        if (isObservableOrEventEmitter(component.autoFillStart)) {\n            this.autoFillStart = component.autoFillStart;\n        }\n        if (isObservableOrEventEmitter(component.autoFillEnd)) {\n            this.autoFillEnd = component.autoFillEnd;\n        }\n        if (isObservableOrEventEmitter(component.onBlur)) {\n            this.onBlur = component.onBlur;\n        }\n        if (formControl) {\n            this.onValueChange = formControl.valueChanges;\n        }\n        else if (component.onValueChange) {\n            this.onValueChange = component.onValueChange;\n        }\n    }\n    Object.defineProperty(FloatingLabelInputAdapter.prototype, \"focusableId\", {\n        get: function () {\n            var component = this.component;\n            if ('focusableId' in component) {\n                return component.focusableId;\n            }\n            else if ('id' in component) {\n                return component.id;\n            }\n            return \"\";\n        },\n        set: function (value) {\n            var component = this.component;\n            if ('focusableId' in component) {\n                component.focusableId = value;\n            }\n            else if ('id' in component) {\n                component.id = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return FloatingLabelInputAdapter;\n}());\n\nvar isFunction = function (x) { return Object.prototype.toString.call(x) === '[object Function]'; };\n/**\n * @hidden\n */\nvar TextBoxContainerComponent = /** @class */ (function () {\n    function TextBoxContainerComponent(elementRef, renderer, changeDetectorRef, rtl) {\n        this.elementRef = elementRef;\n        this.renderer = renderer;\n        this.changeDetectorRef = changeDetectorRef;\n        /**\n         * @hidden\n         */\n        this.focused = false;\n        /**\n         * @hidden\n         */\n        this.empty = true;\n        /**\n         * @hidden\n         */\n        this.invalid = false;\n        this._subscriptions = [];\n        this.autoFillStarted = false;\n        this.direction = rtl ? 'rtl' : 'ltr';\n        this.renderer.removeAttribute(this.elementRef.nativeElement, \"id\");\n    }\n    Object.defineProperty(TextBoxContainerComponent.prototype, \"hostClasses\", {\n        get: function () {\n            return true;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TextBoxContainerComponent.prototype, \"textareaElementClass\", {\n        get: function () {\n            return !!this.textarea;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TextBoxContainerComponent.prototype, \"focusedClass\", {\n        get: function () {\n            return this.focused;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TextBoxContainerComponent.prototype, \"invalidClass\", {\n        get: function () {\n            return this.invalid;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @hidden\n     */\n    TextBoxContainerComponent.prototype.ngAfterContentInit = function () {\n        var _this = this;\n        if (!this.formControl && !this.kendoInput) {\n            if (isDevMode()) {\n                throw new Error(\"The TextBoxContainer requires a Kendo Input component\" +\n                    \" or a forms-bound component to function properly.\");\n            }\n            return;\n        }\n        // add focus/blur/valueChange handlers\n        var control = new FloatingLabelInputAdapter(this.kendoInput || this.formControl.valueAccessor, this.formControl);\n        var setFocus = function (isFocused) { return function () {\n            _this.focused = isFocused;\n            _this.updateState();\n        }; };\n        this.subscribe(control, 'onFocus', setFocus(true));\n        this.subscribe(control, 'onBlur', setFocus(false));\n        this.subscribe(control, 'autoFillStart', function () {\n            _this.autoFillStarted = true;\n            _this.renderer.removeClass(_this.elementRef.nativeElement, 'k-state-empty');\n        });\n        this.subscribe(control, 'autoFillEnd', function () {\n            if (_this.autoFillStarted) {\n                _this.autoFillStarted = false;\n                if (_this.empty) {\n                    _this.renderer.addClass(_this.elementRef.nativeElement, 'k-state-empty');\n                }\n            }\n        });\n        var updateState = function () { return _this.updateState(); };\n        updateState();\n        this.subscribe(control, 'onValueChange', updateState);\n        // set label id for floating label\n        if (this.id && control.focusableId) {\n            // input wins\n            this.id = control.focusableId;\n        }\n        else if (this.id) {\n            control.focusableId = this.id;\n        }\n        else if (control.focusableId) {\n            this.id = control.focusableId;\n        }\n        else {\n            var id = \"_\" + guid();\n            control.focusableId = id;\n            this.id = id;\n        }\n    };\n    /**\n     * @hidden\n     */\n    TextBoxContainerComponent.prototype.ngOnDestroy = function () {\n        this._subscriptions.forEach(function (s) { return s.unsubscribe(); });\n        this._subscriptions = [];\n    };\n    TextBoxContainerComponent.prototype.subscribe = function (control, eventName, handler) {\n        if (control[eventName] instanceof EventEmitter) {\n            var subscription = control[eventName].subscribe(handler);\n            this._subscriptions.push(subscription);\n        }\n    };\n    TextBoxContainerComponent.prototype.updateState = function () {\n        var empty = function (value) {\n            // zero is not an empty value (e.g., NumericTextBox)\n            if (value === 0 || value === false) {\n                return false;\n            }\n            // empty arrays are an empty value (e.g., MultiSelect)\n            if (Array.isArray(value) && !value.length) {\n                return true;\n            }\n            return !value;\n        };\n        var formControl = this.formControl;\n        if (formControl) {\n            var valueAccessor = formControl.valueAccessor;\n            if (isFunction(valueAccessor.isEmpty)) {\n                this.empty = valueAccessor.isEmpty();\n            }\n            else {\n                this.empty = empty(formControl.value);\n            }\n            this.invalid = formControl.invalid && (formControl.touched || formControl.dirty);\n        }\n        else {\n            this.empty = isFunction(this.kendoInput.isEmpty) ?\n                this.kendoInput.isEmpty() : empty(this.kendoInput.value);\n        }\n        if (this.empty) {\n            this.renderer.addClass(this.elementRef.nativeElement, 'k-state-empty');\n        }\n        else {\n            this.renderer.removeClass(this.elementRef.nativeElement, 'k-state-empty');\n        }\n        this.changeDetectorRef.markForCheck();\n    };\n    TextBoxContainerComponent.decorators = [\n        { type: Component, args: [{\n                    selector: 'kendo-textbox-container',\n                    template: \"\\n        <ng-content></ng-content>\\n        <label *ngIf=\\\"floatingLabel\\\" [for]=\\\"id\\\" class=\\\"k-label\\\">{{ floatingLabel }}</label>\\n    \"\n                },] },\n    ];\n    /** @nocollapse */\n    TextBoxContainerComponent.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: Renderer2 },\n        { type: ChangeDetectorRef },\n        { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [RTL,] }] }\n    ]; };\n    TextBoxContainerComponent.propDecorators = {\n        hostClasses: [{ type: HostBinding, args: ['class.k-textbox-container',] }],\n        textareaElementClass: [{ type: HostBinding, args: ['class.k-textarea-wrapper',] }],\n        focusedClass: [{ type: HostBinding, args: ['class.k-state-focused',] }],\n        invalidClass: [{ type: HostBinding, args: ['class.k-state-invalid',] }],\n        direction: [{ type: HostBinding, args: ['attr.dir',] }],\n        id: [{ type: Input }],\n        floatingLabel: [{ type: Input }],\n        kendoInput: [{ type: ContentChild, args: [KendoInput,] }],\n        textarea: [{ type: ContentChild, args: [TextAreaDirective,] }],\n        formControl: [{ type: ContentChild, args: [NgControl,] }]\n    };\n    return TextBoxContainerComponent;\n}());\n\n/**\n * Represents the [Kendo UI TextBox directive]({% slug overview_textbox %}) for the Inputs components for Angular.\n * Used to style the textbox of any `input` element.\n *\n * @example\n * ```ts-no-run\n * <input kendoTextBox />\n * <input kendoTextBox type=\"email\" />\n * <input kendoTextBox type=\"password\" />\n * ```\n */\nvar TextBoxDirective = /** @class */ (function () {\n    function TextBoxDirective(renderer, inputElement, ngZone) {\n        this.renderer = renderer;\n        this.inputElement = inputElement;\n        this.ngZone = ngZone;\n        this.hostClass = true;\n        /**\n         * @hidden\n         */\n        this.onFocus = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.onBlur = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.onValueChange = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.autoFillStart = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.autoFillEnd = new EventEmitter();\n        this.listeners = [];\n    }\n    Object.defineProperty(TextBoxDirective.prototype, \"value\", {\n        /**\n         * @hidden\n         */\n        get: function () {\n            return this.inputElement.nativeElement.value;\n        },\n        /**\n         * @hidden\n         */\n        set: function (text) {\n            if (!this.inputElement) {\n                return;\n            }\n            this.inputElement.nativeElement.value = (text === undefined || text === null) ? '' : text;\n            this.onValueChange.emit();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TextBoxDirective.prototype, \"id\", {\n        get: function () {\n            return this.inputElement.nativeElement.id;\n        },\n        set: function (id) {\n            this.renderer.setAttribute(this.inputElement.nativeElement, 'id', id);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TextBoxDirective.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        var input = this.inputElement.nativeElement;\n        this.listeners = [\n            this.renderer.listen(input, 'focus', function () { return _this.onFocus.emit(); }),\n            this.renderer.listen(input, 'blur', function () { return _this.onBlur.emit(); })\n        ];\n        this.ngZone.runOutsideAngular(function () {\n            _this.renderer.listen(input, 'animationstart', function (e) {\n                if (e.animationName === 'autoFillStart') {\n                    _this.autoFillStart.emit();\n                }\n                else if (e.animationName === 'autoFillEnd') {\n                    _this.autoFillEnd.emit();\n                }\n            });\n        });\n    };\n    TextBoxDirective.prototype.ngOnDestroy = function () {\n        this.listeners.forEach(function (listener) { return listener(); });\n    };\n    TextBoxDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: 'input[kendoTextBox]',\n                    providers: [{\n                            provide: KendoInput,\n                            useExisting: forwardRef(function () { return TextBoxDirective; })\n                        }]\n                },] },\n    ];\n    /** @nocollapse */\n    TextBoxDirective.ctorParameters = function () { return [\n        { type: Renderer2 },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    TextBoxDirective.propDecorators = {\n        hostClass: [{ type: HostBinding, args: ['class.k-textbox',] }],\n        value: [{ type: Input }]\n    };\n    return TextBoxDirective;\n}());\n\n/**\n * @hidden\n */\nvar createMaxValidator = function (maxValue) {\n    return function (c) {\n        var err = {\n            maxError: {\n                maxValue: maxValue,\n                value: c.value\n            }\n        };\n        return (c.value !== null && c.value > maxValue) ? err : null;\n    };\n};\n\n/**\n * @hidden\n */\nvar createMinValidator = function (minValue) {\n    return function (c) {\n        var err = {\n            minError: {\n                minValue: minValue,\n                value: c.value\n            }\n        };\n        return (c.value !== null && c.value < minValue) ? err : null;\n    };\n};\n\n/**\n * @hidden\n */\nvar MIN_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/inputs/api/NumericTextBoxComponent/#toc-min';\n/**\n * @hidden\n */\nvar MAX_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/inputs/api/NumericTextBoxComponent/#toc-max';\n/**\n * @hidden\n */\nvar POINT = \".\";\n/**\n * @hidden\n */\nvar INITIAL_SPIN_DELAY = 500;\n/**\n * @hidden\n */\nvar SPIN_DELAY = 50;\n/**\n * @hidden\n */\nvar EXPONENT_REGEX = /[eE][\\-+]?([0-9]+)/;\n\n/**\n * @hidden\n */\nvar numericRegex = function (options) {\n    var autoCorrect = options.autoCorrect, decimals = options.decimals, min = options.min;\n    var separator = options.separator;\n    if (separator === POINT) {\n        separator = '\\\\' + separator;\n    }\n    var signPattern = autoCorrect && min !== null && min >= 0 ? '' : '-?';\n    var numberPattern;\n    if (decimals === 0) {\n        numberPattern = '\\\\d*';\n    }\n    else {\n        numberPattern = \"(?:(?:\\\\d+(\" + separator + \"\\\\d*)?)|(?:\" + separator + \"\\\\d*))?\";\n    }\n    return new RegExp(\"^\" + signPattern + numberPattern + \"$\");\n};\n/**\n * @hidden\n */\nvar decimalPart = function (value) {\n    return value >= 0 ? Math.floor(value) : Math.ceil(value);\n};\n/**\n * @hidden\n */\nvar noop = function (_) { }; // tslint:disable-line:no-empty\n/**\n * @hidden\n */\nvar defined = function (value) {\n    return typeof value !== 'undefined';\n};\n/**\n * @hidden\n */\nvar isNumber = function (value) {\n    return !isNaN(value) && value !== null;\n};\n/**\n * @hidden\n */\nfunction pad(value, digits) {\n    var count = digits - String(value).length;\n    var result = value;\n    if (count > 0) {\n        var padString = new Array(count + 1).join(\"0\");\n        result = parseFloat(value + padString);\n    }\n    return result;\n}\n/**\n * @hidden\n */\nvar getDeltaFromMouseWheel = function (e) {\n    var delta = 0;\n    if (e.wheelDelta) {\n        delta = e.wheelDelta / 120;\n        delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);\n    }\n    else if (e.detail) {\n        delta = Math.round(-e.detail / 3);\n    }\n    return delta;\n};\n/**\n * @hidden\n */\nvar getCaretPosition = function (element) { return element.selectionStart; };\n/**\n * @hidden\n */\nvar extractSignificantNumericChars = function (formattedString, separator) {\n    var significantCharacters = separator + \"0123456789-\";\n    return formattedString.split('').reduce(function (acc, curr) { return significantCharacters.includes(curr) ? ++acc : acc; }, 0);\n};\n\n/**\n * @hidden\n */\nvar ArrowDirection;\n(function (ArrowDirection) {\n    ArrowDirection[ArrowDirection[\"Down\"] = -1] = \"Down\";\n    ArrowDirection[ArrowDirection[\"None\"] = 0] = \"None\";\n    ArrowDirection[ArrowDirection[\"Up\"] = 1] = \"Up\";\n})(ArrowDirection || (ArrowDirection = {}));\n\nvar PARSABLE_OPTIONS = ['min', 'max', 'step', 'decimals'];\nvar PARSABLE_DEFAULTS = {\n    decimals: null,\n    max: null,\n    min: null,\n    step: 1\n};\nvar FOCUSED$2 = 'k-state-focused';\nvar FORMATTED_VALUE = 'k-formatted-value';\n/**\n * Represents the [Kendo UI NumericTextBox component for Angular]({% slug overview_numerictextbox %}).\n */\nvar NumericTextBoxComponent = /** @class */ (function () {\n    function NumericTextBoxComponent(intl, renderer, localizationService, injector, ngZone, changeDetector, hostElement) {\n        var _this = this;\n        this.intl = intl;\n        this.renderer = renderer;\n        this.localizationService = localizationService;\n        this.injector = injector;\n        this.ngZone = ngZone;\n        this.changeDetector = changeDetector;\n        this.hostElement = hostElement;\n        /**\n         * @hidden\n         */\n        this.focusableId = \"k-\" + guid();\n        /**\n         * Determines whether the NumericTextBox is disabled ([see example]({% slug disabled_numerictextbox %})).\n         */\n        this.disabled = false;\n        /**\n         * Determines whether the NumericTextBox is in its read-only state ([see example]({% slug readonly_numerictextbox %})).\n         */\n        this.readonly = false;\n        /**\n         * Sets the title of the `input` element of the NumericTextBox.\n         */\n        this.title = '';\n        /**\n         * Specifies whether the value will be auto-corrected based on the minimum and maximum values\n         * ([see example]({% slug precision_numerictextbox %})).\n         */\n        this.autoCorrect = false;\n        /**\n         * Specifies the number of decimals that the user can enter when the input is focused\n         * ([see example]({% slug precision_numerictextbox %})).\n         */\n        this.decimals = null;\n        /**\n         * Specifies the value that is used to increment or decrement the component value\n         * ([see example]({% slug predefinedsteps_numerictextbox %})).\n         */\n        this.step = 1;\n        /**\n         * Specifies whether the **Up** and **Down** spin buttons will be rendered\n         * ([see example]({% slug spinbuttons_numerictextbox %})).\n         */\n        this.spinners = true;\n        /**\n         * Determines whether the built-in minimum or maximum validators are enforced when a form is validated.\n         *\n         * > The 4.2.0 Angular version introduces the `min` and `max` validation directives. As a result, even if you set `rangeValidation`\n         * to `false`, the built-in Angular validators will be executed.\n         */\n        this.rangeValidation = true;\n        /**\n         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n         */\n        this.tabindex = 0;\n        /**\n         * Determines whether the whole value will be selected when the NumericTextBox is clicked. Defaults to `true`.\n         */\n        this.selectOnFocus = true;\n        /**\n         * Specifies the value of the NumericTextBox\n         * ([see example]({% slug formats_numerictextbox %})).\n         */\n        this.value = null;\n        /**\n         * Fires each time the user selects a new value ([see example]({% slug overview_numerictextbox %}#toc-events)).\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * Fires each time the user focuses the `input` element ([see example]({% slug overview_numerictextbox %}#toc-events)).\n         */\n        this.onFocus = new EventEmitter();\n        /**\n         * Fires each time the `input` element gets blurred ([see example]({% slug overview_numerictextbox %}#toc-events)).\n         */\n        this.onBlur = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.ArrowDirection = ArrowDirection;\n        /**\n         * @hidden\n         */\n        this.arrowDirection = ArrowDirection.None;\n        this.inputValue = '';\n        this.minValidateFn = noop;\n        this.maxValidateFn = noop;\n        this._format = \"n2\";\n        this.isPasted = false;\n        this.mouseDown = false;\n        this.ngChange = noop;\n        this.ngTouched = noop;\n        this.ngValidatorChange = noop;\n        /**\n         * @hidden\n         */\n        this.increasePress = function (e) {\n            _this.arrowPress(ArrowDirection.Up, e);\n        };\n        /**\n         * @hidden\n         */\n        this.decreasePress = function (e) {\n            _this.arrowPress(ArrowDirection.Down, e);\n        };\n        /**\n         * @hidden\n         */\n        this.releaseArrow = function () {\n            clearTimeout(_this.spinTimeout);\n            if (_this.arrowDirection !== ArrowDirection.None) {\n                _this.arrowDirection = ArrowDirection.None;\n                _this.changeDetector.detectChanges();\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.handlePaste = function () {\n            _this.isPasted = true;\n        };\n        /**\n         * @hidden\n         */\n        this.handleInput = function () {\n            var input = _this.numericInput.nativeElement;\n            var selectionStart = input.selectionStart, selectionEnd = input.selectionEnd, inputValue = input.value;\n            if (_this.pressedKey === Keys.NumpadDecimal) {\n                inputValue = _this.replaceNumpadDotValue();\n            }\n            if (_this.isPasted) {\n                inputValue = _this.formatInputValue(_this.intl.parseNumber(inputValue));\n            }\n            if (!_this.isValid(inputValue)) {\n                input.value = _this.inputValue;\n                _this.setSelection(selectionStart - 1, selectionEnd - 1);\n                return;\n            }\n            var parsedValue = _this.intl.parseNumber(inputValue);\n            var value = _this.restrictDecimals(parsedValue);\n            if (_this.autoCorrect) {\n                var limited = _this.limitInputValue(value);\n                value = limited.value;\n                selectionStart = limited.selectionStart;\n                selectionEnd = limited.selectionEnd;\n            }\n            if (parsedValue !== value || _this.hasTrailingZeros(inputValue) || !_this.focused) {\n                _this.setInputValue(value);\n                _this.setSelection(selectionStart, selectionEnd);\n            }\n            else {\n                _this.inputValue = inputValue;\n            }\n            if (_this.isPasted) {\n                input.value = _this.inputValue;\n            }\n            _this.updateValue(value);\n            _this.previousSelection = null;\n            _this.isPasted = false;\n        };\n        /**\n         * @hidden\n         */\n        this.handleDragEnter = function () {\n            if (!_this.focused && !_this.isDisabled) {\n                _this.setInputValue(_this.value, true);\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.handleMouseDown = function () {\n            _this.mouseDown = true;\n        };\n        /**\n         * @hidden\n         */\n        this.handleFocus = function () {\n            if (!_this.focused) {\n                _this.focused = true;\n                if (!_this.isDisabled) {\n                    var shouldSelectAll_1 = _this.selectOnFocus || !_this.mouseDown;\n                    _this.ngZone.runOutsideAngular(function () {\n                        setTimeout(function () {\n                            if (shouldSelectAll_1) {\n                                _this.selectAll();\n                            }\n                            else {\n                                _this.selectCaret();\n                            }\n                        }, 0);\n                    });\n                }\n            }\n            _this.mouseDown = false;\n            if (hasObservers(_this.onFocus)) {\n                _this.ngZone.run(function () {\n                    _this.onFocus.emit();\n                });\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.handleBlur = function () {\n            _this.focused = false;\n            //blur is thrown before input when dragging the input text in IE\n            if (_this.inputValue !== _this.elementValue) {\n                _this.handleInput();\n            }\n            _this.setInputValue();\n            if (hasObservers(_this.onBlur) || requiresZoneOnBlur(_this.control)) {\n                _this.ngZone.run(function () {\n                    _this.ngTouched();\n                    _this.onBlur.emit();\n                });\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.handleKeyDown = function (e) {\n            if (_this.isDisabled) {\n                return;\n            }\n            var step;\n            if (e.keyCode === Keys.ArrowDown) {\n                step = -1;\n            }\n            else if (e.keyCode === Keys.ArrowUp) {\n                step = 1;\n            }\n            if (step && _this.step) {\n                e.preventDefault();\n                _this.addStep(step);\n            }\n            var input = _this.numericInput.nativeElement;\n            _this.previousSelection = {\n                end: input.selectionEnd,\n                start: input.selectionStart\n            };\n            _this.pressedKey = e.keyCode;\n        };\n        /**\n         * @hidden\n         */\n        this.handleWheel = function (e) {\n            if (_this.focused && !_this.isDisabled) {\n                e.preventDefault();\n                var delta = getDeltaFromMouseWheel(e);\n                _this.addStep(delta);\n            }\n        };\n        this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n    }\n    Object.defineProperty(NumericTextBoxComponent.prototype, \"format\", {\n        /**\n         * Specifies the number format which is used when the NumericTextBox is not focused\n         * ([see example]({% slug formats_numerictextbox %})).\n         * If `format` is set to `null` or `undefined`, the default format will be used.\n         */\n        get: function () {\n            var format = this._format;\n            return format !== null && format !== undefined ? format : 'n2';\n        },\n        set: function (value) {\n            this._format = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NumericTextBoxComponent.prototype, \"tabIndex\", {\n        get: function () {\n            return this.tabindex;\n        },\n        /**\n         * @hidden\n         */\n        set: function (tabIndex) {\n            this.tabindex = tabIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NumericTextBoxComponent.prototype, \"widgetClasses\", {\n        get: function () {\n            return true;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    NumericTextBoxComponent.prototype.ngOnInit = function () {\n        var _this = this;\n        this.subscriptions = this.localizationService\n            .changes\n            .subscribe(function (_a) {\n            var rtl = _a.rtl;\n            _this.direction = rtl ? 'rtl' : 'ltr';\n        });\n        this.subscriptions.add(this.intl.changes.subscribe(this.intlChange.bind(this)));\n        if (this.hostElement) {\n            this.renderer.removeAttribute(this.hostElement.nativeElement, \"tabindex\");\n        }\n        this.control = this.injector.get(NgControl, null);\n    };\n    /**\n     * @hidden\n     */\n    NumericTextBoxComponent.prototype.ngOnChanges = function (changes) {\n        if (anyChanged(PARSABLE_OPTIONS, changes, false)) {\n            this.parseOptions(PARSABLE_OPTIONS.filter(function (option) { return changes[option]; }));\n        }\n        this.verifySettings();\n        if (anyChanged(['min', 'max', 'rangeValidation'], changes, false)) {\n            this.minValidateFn = this.rangeValidation ? createMinValidator(this.min) : noop;\n            this.maxValidateFn = this.rangeValidation ? createMaxValidator(this.max) : noop;\n            this.ngValidatorChange();\n        }\n        if (anyChanged(['autoCorrect', 'decimals', 'min'], changes)) {\n            delete this.numericRegex;\n        }\n        if (anyChanged(['value', 'format'], changes, false)) {\n            this.verifyValue(this.value);\n            this.value = this.restrictModelValue(this.value);\n            if (!this.focused || (this.intl.parseNumber(this.elementValue) !== this.value)) {\n                this.setInputValue();\n            }\n        }\n    };\n    /**\n     * @hidden\n     */\n    NumericTextBoxComponent.prototype.ngOnDestroy = function () {\n        if (this.subscriptions) {\n            this.subscriptions.unsubscribe();\n        }\n        clearTimeout(this.spinTimeout);\n    };\n    /**\n     * @hidden\n     */\n    NumericTextBoxComponent.prototype.validate = function (control) {\n        return this.minValidateFn(control) || this.maxValidateFn(control);\n    };\n    /**\n     * @hidden\n     */\n    NumericTextBoxComponent.prototype.registerOnValidatorChange = function (fn) {\n        this.ngValidatorChange = fn;\n    };\n    /**\n     * @hidden\n     */\n    NumericTextBoxComponent.prototype.writeValue = function (value) {\n        this.verifyValue(value);\n        var restrictedValue = this.restrictModelValue(value);\n        this.value = restrictedValue;\n        this.setInputValue();\n    };\n    /**\n     * @hidden\n     */\n    NumericTextBoxComponent.prototype.registerOnChange = function (fn) {\n        this.ngChange = fn;\n    };\n    /**\n     * @hidden\n     */\n    NumericTextBoxComponent.prototype.registerOnTouched = function (fn) {\n        this.ngTouched = fn;\n    };\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     *\n     * @param isDisabled\n     */\n    NumericTextBoxComponent.prototype.setDisabledState = function (isDisabled) {\n        this.disabled = isDisabled;\n    };\n    /**\n     * Focuses the NumericTextBox.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"numerictextbox.focus()\">Focus NumericTextBox</button>\n     *  <kendo-numerictextbox #numerictextbox></kendo-numerictextbox>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    NumericTextBoxComponent.prototype.focus = function () {\n        invokeElementMethod(this.numericInput, 'focus');\n    };\n    /**\n     * Blurs the NumericTextBox.\n     */\n    NumericTextBoxComponent.prototype.blur = function () {\n        invokeElementMethod(this.numericInput, 'blur');\n    };\n    /**\n     * Notifies the `NumericTextBoxComponent` that the input value should be changed.\n     * Can be used to update the input after setting the component properties directly.\n     */\n    NumericTextBoxComponent.prototype.notifyValueChange = function () {\n        this.setInputValue();\n    };\n    Object.defineProperty(NumericTextBoxComponent.prototype, \"incrementTitle\", {\n        /**\n         * @hidden\n         */\n        get: function () {\n            return this.localizationService.get('increment');\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NumericTextBoxComponent.prototype, \"decrementTitle\", {\n        /**\n         * @hidden\n         */\n        get: function () {\n            return this.localizationService.get('decrement');\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NumericTextBoxComponent.prototype, \"decimalSeparator\", {\n        get: function () {\n            var numberSymbols = this.intl.numberSymbols();\n            return numberSymbols.decimal;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NumericTextBoxComponent.prototype, \"elementValue\", {\n        get: function () {\n            return this.numericInput.nativeElement.value;\n        },\n        set: function (value) {\n            this.renderer.setProperty(this.numericInput.nativeElement, 'value', value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NumericTextBoxComponent.prototype, \"focused\", {\n        get: function () {\n            return this.isFocused;\n        },\n        set: function (value) {\n            if (this.isFocused !== value && this.numericWrap) {\n                var wrap = this.numericWrap.nativeElement;\n                var input = this.numericInput.nativeElement;\n                if (value) {\n                    this.renderer.addClass(wrap, FOCUSED$2);\n                    if (!this.isDisabled) {\n                        this.renderer.removeClass(input, FORMATTED_VALUE);\n                    }\n                }\n                else {\n                    this.renderer.removeClass(wrap, FOCUSED$2);\n                    this.renderer.addClass(input, FORMATTED_VALUE);\n                }\n                this.isFocused = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NumericTextBoxComponent.prototype, \"hasDecimals\", {\n        get: function () {\n            return this.decimals !== null && this.decimals >= 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NumericTextBoxComponent.prototype, \"isDisabled\", {\n        get: function () {\n            return this.disabled || this.readonly;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    NumericTextBoxComponent.prototype.arrowPress = function (direction, e) {\n        e.preventDefault();\n        if (this.isDisabled) {\n            return;\n        }\n        if (!mobileOS) {\n            this.focused = true;\n            this.focus();\n        }\n        if (this.arrowDirection !== direction) {\n            this.arrowDirection = direction;\n            this.changeDetector.detectChanges();\n        }\n        if (this.step) {\n            this.spin(direction, INITIAL_SPIN_DELAY);\n        }\n        else {\n            this.setInputValue();\n        }\n    };\n    NumericTextBoxComponent.prototype.updateValue = function (value) {\n        var _this = this;\n        if (!areSame(this.value, value)) {\n            this.ngZone.run(function () {\n                _this.value = value;\n                _this.ngChange(value);\n                _this.valueChange.emit(value);\n                _this.changeDetector.markForCheck();\n            });\n        }\n    };\n    NumericTextBoxComponent.prototype.replaceNumpadDotValue = function () {\n        var value = this.inputValue || \"\";\n        if (this.previousSelection) {\n            var input = this.numericInput.nativeElement;\n            var selectionStart = input.selectionStart, selectionEnd = input.selectionEnd;\n            var _a = this.previousSelection, start = _a.start, end = _a.end;\n            input.value = value = value.substring(0, start) + this.decimalSeparator + value.substring(end);\n            this.setSelection(selectionStart, selectionEnd);\n        }\n        return value;\n    };\n    NumericTextBoxComponent.prototype.isValid = function (value) {\n        if (!this.numericRegex) {\n            this.numericRegex = numericRegex({\n                autoCorrect: this.autoCorrect,\n                decimals: this.decimals,\n                min: this.min,\n                separator: this.decimalSeparator\n            });\n        }\n        return this.numericRegex.test(value);\n    };\n    NumericTextBoxComponent.prototype.spin = function (step, timeout) {\n        var _this = this;\n        clearTimeout(this.spinTimeout);\n        this.spinTimeout = window.setTimeout(function () {\n            _this.spin(step, SPIN_DELAY);\n        }, timeout);\n        this.addStep(step);\n    };\n    NumericTextBoxComponent.prototype.addStep = function (step) {\n        var value = add(this.value || 0, this.step * step);\n        value = this.limitValue(value);\n        value = this.restrictDecimals(value);\n        this.setInputValue(value);\n        this.updateValue(value);\n    };\n    NumericTextBoxComponent.prototype.setSelection = function (start, end) {\n        if (this.focused) {\n            invokeElementMethod(this.numericInput, 'setSelectionRange', start, end);\n        }\n    };\n    NumericTextBoxComponent.prototype.limitValue = function (value) {\n        var result = value;\n        if (!this.isInRange(value)) {\n            if (isNumber(this.max) && value > this.max) {\n                result = this.max;\n            }\n            if (isNumber(this.min) && value < this.min) {\n                result = this.min;\n            }\n        }\n        return result;\n    };\n    NumericTextBoxComponent.prototype.limitInputValue = function (value) {\n        var _a = this.numericInput.nativeElement, selectionStart = _a.selectionStart, selectionEnd = _a.selectionEnd, enteredValue = _a.value;\n        var limitedValue = value;\n        var selectToEnd = false;\n        if (!this.isInRange(value)) {\n            var lengthChange = enteredValue.length - String(this.inputValue).length;\n            var _b = this, min = _b.min, max = _b.max;\n            var hasMax = isNumber(max);\n            var hasMin = isNumber(min);\n            var padLimit = void 0, replaceNext = void 0;\n            var correctedValue = value;\n            if (selectionStart === 0 && this.inputValue.substr(1) === enteredValue) {\n                return {\n                    selectionEnd: selectionEnd,\n                    selectionStart: selectionStart,\n                    value: null\n                };\n            }\n            if (hasMax && value > max) {\n                if (value > 0) {\n                    replaceNext = true;\n                }\n                else {\n                    padLimit = max;\n                }\n            }\n            else if (hasMin && value < min) {\n                if (value > 0) {\n                    padLimit = min;\n                }\n                else {\n                    replaceNext = true;\n                }\n            }\n            if (padLimit) {\n                var paddedValue = this.tryPadValue(value, padLimit);\n                if (paddedValue && decimalPart(value) !== decimalPart(padLimit)) {\n                    correctedValue = paddedValue;\n                    selectToEnd = true;\n                }\n            }\n            else if (replaceNext) {\n                if (this.inputValue && selectionStart !== enteredValue.length) {\n                    correctedValue = parseFloat(enteredValue.substr(0, selectionStart) +\n                        enteredValue.substr(selectionStart + lengthChange));\n                }\n            }\n            limitedValue = this.limitValue(correctedValue);\n            selectToEnd = (selectToEnd || limitedValue !== correctedValue) && this.previousSelection &&\n                (this.previousSelection.end - this.previousSelection.start + lengthChange) > 0;\n        }\n        return {\n            selectionEnd: selectToEnd ? String(limitedValue).length : selectionEnd,\n            selectionStart: selectionStart,\n            value: limitedValue\n        };\n    };\n    NumericTextBoxComponent.prototype.tryPadValue = function (value, limit) {\n        var limitLength = String(Math.floor(limit)).length;\n        var zeroPadded = pad(value, limitLength);\n        var zeroPaddedNext = pad(value, limitLength + 1);\n        var result;\n        if (this.isInRange(zeroPadded)) {\n            result = zeroPadded;\n        }\n        else if (this.isInRange(zeroPaddedNext)) {\n            result = zeroPaddedNext;\n        }\n        return result;\n    };\n    NumericTextBoxComponent.prototype.isInRange = function (value) {\n        return !isNumber(value) || ((!isNumber(this.min) || this.min <= value) && (!isNumber(this.max) || value <= this.max));\n    };\n    NumericTextBoxComponent.prototype.restrictModelValue = function (value) {\n        var result = this.restrictDecimals(value, true);\n        if (this.autoCorrect && this.limitValue(result) !== result) {\n            result = null;\n        }\n        return result;\n    };\n    NumericTextBoxComponent.prototype.restrictDecimals = function (value, round) {\n        var result = value;\n        if (value && this.hasDecimals) {\n            var decimals = this.decimals;\n            var stringValue = String(value);\n            if (round || EXPONENT_REGEX.test(stringValue)) {\n                result = toFixedPrecision(value, decimals);\n            }\n            else {\n                var parts = stringValue.split(POINT);\n                var fraction = parts[1];\n                if (fraction && fraction.length > decimals) {\n                    fraction = fraction.substr(0, decimals);\n                    result = parseFloat(\"\" + parts[0] + POINT + fraction);\n                }\n            }\n        }\n        return result;\n    };\n    NumericTextBoxComponent.prototype.formatInputValue = function (value) {\n        var stringValue = String(value);\n        var exponentMatch = EXPONENT_REGEX.exec(stringValue);\n        if (exponentMatch) {\n            stringValue = value.toFixed(limitPrecision(parseInt(exponentMatch[1], 10)));\n        }\n        return stringValue.replace(POINT, this.decimalSeparator);\n    };\n    NumericTextBoxComponent.prototype.formatValue = function (value, focused) {\n        var formattedValue;\n        if (value === null || !defined(value) || value === '') {\n            formattedValue = '';\n        }\n        else if (focused && !this.readonly) {\n            formattedValue = this.formatInputValue(value);\n        }\n        else {\n            formattedValue = this.intl.formatNumber(value, this.format);\n        }\n        return formattedValue;\n    };\n    NumericTextBoxComponent.prototype.setInputValue = function (value, focused) {\n        if (value === void 0) { value = this.value; }\n        if (focused === void 0) { focused = this.focused; }\n        var formattedValue = this.formatValue(value, focused);\n        this.elementValue = formattedValue;\n        this.inputValue = formattedValue;\n    };\n    NumericTextBoxComponent.prototype.verifySettings = function () {\n        if (!isDevMode()) {\n            return;\n        }\n        if (this.min !== null && this.max !== null && this.min > this.max) {\n            throw new Error(\"The max value should be bigger than the min. See \" + MIN_DOC_LINK + \" and \" + MAX_DOC_LINK + \".\");\n        }\n    };\n    NumericTextBoxComponent.prototype.verifyValue = function (value) {\n        if (isDevMode() && value && typeof value !== 'number') {\n            throw new Error(\"The NumericTextBox component requires value of type Number and \" + JSON.stringify(value) + \" was set.\");\n        }\n    };\n    NumericTextBoxComponent.prototype.parseOptions = function (options) {\n        for (var idx = 0; idx < options.length; idx++) {\n            var name_1 = options[idx];\n            var value = this[name_1];\n            if (typeof value === 'string') {\n                var parsed = parseFloat(value);\n                var valid = !isNaN(parsed);\n                if (isDevMode() && !valid && value !== '') {\n                    throw new Error('The NumericTextBox component requires value of type Number or a String representing ' +\n                        (\"a number for the \" + name_1 + \" property and \" + JSON.stringify(value) + \" was set.\"));\n                }\n                this[name_1] = valid ? parsed : PARSABLE_DEFAULTS[name_1];\n            }\n        }\n    };\n    NumericTextBoxComponent.prototype.intlChange = function () {\n        delete this.numericRegex;\n        if (this.numericInput && (!this.focused || !this.isValid(this.elementValue))) {\n            this.setInputValue();\n        }\n    };\n    NumericTextBoxComponent.prototype.hasTrailingZeros = function (inputValue) {\n        if (this.hasDecimals && this.focused) {\n            var fraction = inputValue.split(this.decimalSeparator)[1];\n            return fraction && fraction.length > this.decimals && fraction.lastIndexOf('0') === fraction.length - 1;\n        }\n    };\n    NumericTextBoxComponent.prototype.selectAll = function () {\n        this.setInputValue();\n        this.setSelection(0, this.inputValue.length);\n    };\n    NumericTextBoxComponent.prototype.selectCaret = function () {\n        var caretPosition = getCaretPosition(this.numericInput.nativeElement);\n        var formattedValue = this.elementValue;\n        var partialValue = formattedValue.substring(0, caretPosition);\n        this.setInputValue();\n        if (partialValue.length) {\n            var significantCharsInFormattedValue = extractSignificantNumericChars(partialValue, this.decimalSeparator);\n            var adjustedSignificantChars = this.adjustSignificantChars(formattedValue, significantCharsInFormattedValue);\n            this.setSelection(adjustedSignificantChars, adjustedSignificantChars);\n        }\n        else {\n            this.setSelection(0, 0);\n        }\n    };\n    NumericTextBoxComponent.prototype.numberOfLeadingZeroes = function (formattedValue) {\n        var separatorIndex = formattedValue.indexOf(this.decimalSeparator);\n        var matchedLeadingZeroes = formattedValue.match(/^[^1-9]*?(0+)/);\n        if (matchedLeadingZeroes) {\n            var lengthOfMatch = matchedLeadingZeroes[0].length;\n            var lengthOfLeadingZeroesMatch = matchedLeadingZeroes[1].length;\n            return lengthOfMatch === separatorIndex ? lengthOfLeadingZeroesMatch - 1 : lengthOfLeadingZeroesMatch;\n        }\n        return 0;\n    };\n    NumericTextBoxComponent.prototype.adjustSignificantChars = function (formattedValue, significantChars) {\n        var leadingZeroes = this.numberOfLeadingZeroes(formattedValue);\n        if (leadingZeroes > 0) {\n            return Math.max(0, significantChars - leadingZeroes);\n        }\n        return significantChars;\n    };\n    NumericTextBoxComponent.decorators = [\n        { type: Component, args: [{\n                    exportAs: 'kendoNumericTextBox',\n                    providers: [\n                        LocalizationService,\n                        { provide: L10N_PREFIX, useValue: 'kendo.numerictextbox' },\n                        { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(function () { return NumericTextBoxComponent; }), multi: true },\n                        { provide: NG_VALIDATORS, useExisting: forwardRef(function () { return NumericTextBoxComponent; }), multi: true },\n                        { provide: KendoInput, useExisting: forwardRef(function () { return NumericTextBoxComponent; }) }\n                    ],\n                    selector: 'kendo-numerictextbox',\n                    template: \"\\n        <ng-container kendoNumericTextBoxLocalizedMessages\\n            i18n-increment=\\\"kendo.numerictextbox.increment|The title for the **Increment** button in the NumericTextBox\\\"\\n            increment=\\\"Increase value\\\"\\n            i18n-decrement=\\\"kendo.numerictextbox.decrement|The title for the **Decrement** button in the NumericTextBox\\\"\\n            decrement=\\\"Decrease value\\\"\\n        >\\n        </ng-container>\\n        <span\\n            class=\\\"k-numeric-wrap\\\"\\n            [class.k-state-disabled]=\\\"disabled\\\"\\n            [kendoEventsOutsideAngular]=\\\"{ mousewheel: handleWheel, DOMMouseScroll: handleWheel }\\\"\\n            #numericWrap>\\n            <input\\n            role=\\\"spinbutton\\\"\\n            class=\\\"k-input k-formatted-value\\\"\\n            autocomplete=\\\"off\\\"\\n            autocorrect=\\\"off\\\"\\n            [id]=\\\"focusableId\\\"\\n            [attr.aria-valuemin]=\\\"min\\\"\\n            [attr.aria-valuemax]=\\\"max\\\"\\n            [attr.aria-valuenow]=\\\"value\\\"\\n            [attr.title]=\\\"title\\\"\\n            [attr.placeholder]=\\\"placeholder\\\"\\n            [tabindex]=\\\"tabIndex\\\"\\n            [disabled]=\\\"disabled\\\"\\n            [readonly]=\\\"readonly\\\"\\n            [kendoEventsOutsideAngular]=\\\"{\\n                mousedown: handleMouseDown,\\n                dragenter: handleDragEnter,\\n                keydown: handleKeyDown,\\n                input: handleInput,\\n                focus: handleFocus,\\n                blur: handleBlur,\\n                paste: handlePaste\\n            }\\\"\\n            #numericInput />\\n            <span class=\\\"k-select\\\" *ngIf=\\\"spinners\\\" [kendoEventsOutsideAngular]=\\\"{ mouseup: releaseArrow, mouseleave: releaseArrow }\\\">\\n                <span\\n                    [kendoEventsOutsideAngular]=\\\"{ mousedown: increasePress }\\\"\\n                    [attr.aria-label]=\\\"incrementTitle\\\"\\n                    [title]=\\\"incrementTitle\\\"\\n                    [class.k-state-active]=\\\"arrowDirection === ArrowDirection.Up\\\"\\n                    class=\\\"k-link k-link-increase\\\"\\n                >\\n                    <span class=\\\"k-icon k-i-arrow-n\\\"></span>\\n                </span>\\n                <span\\n                    [kendoEventsOutsideAngular]=\\\"{ mousedown: decreasePress }\\\"\\n                    [attr.aria-label]=\\\"decrementTitle\\\"\\n                    [title]=\\\"decrementTitle\\\"\\n                    [class.k-state-active]=\\\"arrowDirection === ArrowDirection.Down\\\"\\n                    class=\\\"k-link k-link-decrease\\\"\\n                >\\n                    <span class=\\\"k-icon k-i-arrow-s\\\"></span>\\n                </span>\\n            </span>\\n        </span>\\n      \"\n                },] },\n    ];\n    /** @nocollapse */\n    NumericTextBoxComponent.ctorParameters = function () { return [\n        { type: IntlService },\n        { type: Renderer2 },\n        { type: LocalizationService },\n        { type: Injector },\n        { type: NgZone },\n        { type: ChangeDetectorRef },\n        { type: ElementRef }\n    ]; };\n    NumericTextBoxComponent.propDecorators = {\n        focusableId: [{ type: Input }],\n        disabled: [{ type: Input }],\n        readonly: [{ type: Input }],\n        title: [{ type: Input }],\n        autoCorrect: [{ type: Input }],\n        format: [{ type: Input }],\n        max: [{ type: Input }],\n        min: [{ type: Input }],\n        decimals: [{ type: Input }],\n        placeholder: [{ type: Input }],\n        step: [{ type: Input }],\n        spinners: [{ type: Input }],\n        rangeValidation: [{ type: Input }],\n        tabindex: [{ type: Input }],\n        tabIndex: [{ type: Input }],\n        selectOnFocus: [{ type: Input }],\n        value: [{ type: Input }],\n        valueChange: [{ type: Output }],\n        onFocus: [{ type: Output, args: ['focus',] }],\n        onBlur: [{ type: Output, args: ['blur',] }],\n        numericInput: [{ type: ViewChild, args: ['numericInput', { static: true },] }],\n        numericWrap: [{ type: ViewChild, args: ['numericWrap',] }],\n        direction: [{ type: HostBinding, args: ['attr.dir',] }],\n        widgetClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-numerictextbox',] }]\n    };\n    return NumericTextBoxComponent;\n}());\n\n/**\n * @hidden\n */\nvar NumericTextBoxMessages = /** @class */ (function (_super) {\n    __extends(NumericTextBoxMessages, _super);\n    function NumericTextBoxMessages() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NumericTextBoxMessages.propDecorators = {\n        decrement: [{ type: Input }],\n        increment: [{ type: Input }]\n    };\n    return NumericTextBoxMessages;\n}(ComponentMessages));\n\n/**\n * Custom component messages override default component messages.\n */\nvar NumericTextBoxCustomMessagesComponent = /** @class */ (function (_super) {\n    __extends(NumericTextBoxCustomMessagesComponent, _super);\n    function NumericTextBoxCustomMessagesComponent(service) {\n        var _this = _super.call(this) || this;\n        _this.service = service;\n        return _this;\n    }\n    Object.defineProperty(NumericTextBoxCustomMessagesComponent.prototype, \"override\", {\n        get: function () {\n            return true;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    NumericTextBoxCustomMessagesComponent.decorators = [\n        { type: Component, args: [{\n                    providers: [\n                        {\n                            provide: NumericTextBoxMessages,\n                            useExisting: forwardRef(function () { return NumericTextBoxCustomMessagesComponent; }) // tslint:disable-line:no-forward-ref\n                        }\n                    ],\n                    selector: 'kendo-numerictextbox-messages',\n                    template: \"\"\n                },] },\n    ];\n    /** @nocollapse */\n    NumericTextBoxCustomMessagesComponent.ctorParameters = function () { return [\n        { type: LocalizationService }\n    ]; };\n    return NumericTextBoxCustomMessagesComponent;\n}(NumericTextBoxMessages));\n\n/**\n * @hidden\n */\nvar ResultType;\n(function (ResultType) {\n    ResultType[ResultType[\"Literal\"] = 0] = \"Literal\";\n    ResultType[ResultType[\"Mask\"] = 1] = \"Mask\";\n    ResultType[ResultType[\"Undefined\"] = 2] = \"Undefined\";\n})(ResultType || (ResultType = {}));\n/**\n * @hidden\n */\nvar Result = /** @class */ (function () {\n    function Result(value, rest, type) {\n        if (type === void 0) { type = ResultType.Undefined; }\n        this.value = value;\n        this.rest = rest;\n        this.type = type;\n    }\n    //map :: Functor f => f a ~> (a -> b) -> f b\n    Result.prototype.map = function (fn) {\n        return new Result(fn(this.value), this.rest);\n    };\n    //chain :: Chain m => m a ~> (a -> m b) -> m b\n    Result.prototype.chain = function (fn) {\n        return fn(this.value, this.rest);\n    };\n    Result.prototype.fold = function (s, _ /*we don't need it*/) {\n        return s(this.value, this.rest);\n    };\n    Result.prototype.concat = function (r) {\n        return this.map(function (vs, _) { return r.chain(function (v, __) { return vs.concat([v]); }); });\n    };\n    Result.prototype.toString = function () {\n        return \"Result({ value: '\" + this.value + \"', rest: \" + this.rest + \" })\";\n    };\n    return Result;\n}());\n\n/**\n * @hidden\n */\nvar Stream = /** @class */ (function () {\n    function Stream(input, control) {\n        if (input === void 0) { input = []; }\n        if (control === void 0) { control = []; }\n        this.input = input;\n        this.control = control;\n        this.inputCursor = 0;\n        this.controlCursor = 0;\n    }\n    Stream.prototype.eof = function () {\n        return this.inputCursor >= this.input.length;\n    };\n    // Get the first value from the input.\n    Stream.prototype.next = function () {\n        return {\n            char: this.input[this.inputCursor++],\n            control: this.control[this.controlCursor++]\n        };\n    };\n    Stream.prototype.peek = function () {\n        return {\n            char: this.input[this.inputCursor],\n            control: this.control[this.controlCursor]\n        };\n    };\n    Stream.prototype.eat_input = function () {\n        this.inputCursor++;\n    };\n    Stream.prototype.eat_control = function () {\n        this.controlCursor++;\n    };\n    Stream.prototype.eat = function () {\n        this.inputCursor++;\n        this.controlCursor++;\n    };\n    return Stream;\n}());\n\nvar toArray = function (value) { return (value || '').split(''); };\nvar ESCAPE_CHARACTER = '\\\\';\n/**\n * @hidden\n */\nvar Parser = /** @class */ (function () {\n    function Parser(parse) {\n        this.parse = parse;\n    }\n    Parser.prototype.run = function (input, control) {\n        if (control === void 0) { control = ''; }\n        if (input instanceof Stream) {\n            return this.parse(input);\n        }\n        else {\n            return this.parse(new Stream(toArray(input), toArray(control)));\n        }\n    };\n    //map :: Functor f => f a ~> (a -> b) -> f b\n    Parser.prototype.map = function (f) {\n        var _this = this;\n        return new Parser(function (stream) { return _this.parse(stream).map(f); });\n    };\n    //chain :: Chain m => m a ~> (a -> m b) -> m b\n    Parser.prototype.chain = function (f) {\n        var _this = this;\n        return new Parser(function (stream) { return _this.parse(stream).chain(function (v, s) { return f(v).run(s); }); });\n    };\n    Parser.prototype.isLiteral = function (c) {\n        return this.run(c).type === ResultType.Literal;\n    };\n    return Parser;\n}());\n/**\n * @hidden\n */\nvar mask = function (_a) {\n    var prompt = _a.prompt, promptPlaceholder = _a.promptPlaceholder;\n    return function (rule) { return new Parser(function (stream) {\n        while (!stream.eof()) {\n            var _a = stream.peek(), char = _a.char, control = _a.control;\n            if (char === control && control === prompt) {\n                stream.eat();\n                return new Result(prompt, stream, ResultType.Mask);\n            }\n            if (rule.test(char)) {\n                stream.eat();\n                return new Result(char, stream, ResultType.Mask);\n            }\n            if (char === promptPlaceholder) {\n                stream.eat();\n                return new Result(prompt, stream, ResultType.Mask);\n            }\n            stream.eat_input();\n        }\n        stream.eat();\n        return new Result(prompt, stream, ResultType.Mask);\n    }); };\n};\n/**\n * @hidden\n */\nvar literal = function (_token) { return new Parser(function (stream) {\n    //    let {char, control} = stream.peek();\n    var char = stream.peek().char;\n    if (char === _token) {\n        stream.eat();\n        return new Result(_token, stream, ResultType.Literal);\n    }\n    //    if (control === _token) {\n    //        while (!stream.eof() && char !== _token) {\n    //            stream.eat_input();\n    //            char = stream.peek().char;\n    //        }\n    //    }\n    //\n    //    if (control !== undefined) {\n    //        stream.eat();\n    //    }\n    return new Result(_token, stream, ResultType.Literal);\n}); };\n/**\n * @hidden\n */\nvar unmask = function (prompt) { return function (rule) { return new Parser(function (stream) {\n    while (!stream.eof()) {\n        var _a = stream.peek(), char = _a.char, control = _a.control;\n        if (char === prompt && control === prompt) {\n            stream.eat();\n            return new Result(char, stream);\n        }\n        if (rule.test(char)) {\n            stream.eat();\n            return new Result(char, stream);\n        }\n        stream.eat_input();\n    }\n    stream.eat();\n    return new Result('', stream);\n}); }; };\n/**\n * @hidden\n */\nvar unliteral = function (_token) { return new Parser(function (stream) {\n    if (stream.eof()) {\n        return new Result('', stream);\n    }\n    var char = stream.peek().char;\n    if (char === _token) {\n        stream.eat();\n    }\n    return new Result(_token, stream);\n}); };\n/**\n * @hidden\n */\nvar token = function (rules, creator) { return new Parser(function (stream) {\n    var char = stream.next().char;\n    var rule = rules[char];\n    if (char === ESCAPE_CHARACTER) {\n        char = stream.next().char;\n        return new Result(creator.literal(char), stream);\n    }\n    if (!rule) {\n        return new Result(creator.literal(char), stream);\n    }\n    return new Result(creator.mask(rule), stream);\n}); };\n/**\n * @hidden\n */\nvar rawMask = function (_a) {\n    var prompt = _a.prompt, promptPlaceholder = _a.promptPlaceholder;\n    return new Parser(function (stream) {\n        var char = stream.next().char;\n        if (char === prompt) {\n            return new Result(promptPlaceholder, stream);\n        }\n        return new Result(char, stream);\n    });\n};\n/**\n * @hidden\n */\nvar rawLiteral = function (includeLiterals) { return new Parser(function (stream) {\n    var char = stream.next().char;\n    if (includeLiterals) {\n        return new Result(char, stream);\n    }\n    return new Result('', stream);\n}); };\n\n/**\n * @hidden\n */\nvar always = function (value) { return new Parser(function (stream) { return new Result(value, stream); }); };\n/**\n * @hidden\n */\nvar append = function (p1, p2) { return p1.chain(function (vs) { return p2.map(function (v) { return vs.concat([v]); }); }); };\n/**\n * @hidden\n */\nvar sequence = function (list) { return list.reduce(function (acc, parser) { return append(acc, parser); }, always([])); };\n/**\n * @hidden\n */\nvar greedy = function (parser) { return new Parser(function (stream) {\n    var result = new Result([], stream);\n    while (!stream.eof()) {\n        result = result.concat(parser.run(stream));\n    }\n    return result;\n}); };\n\n/**\n * @hidden\n */\nvar MaskingService = /** @class */ (function () {\n    function MaskingService() {\n        this.rules = {};\n        this.prompt = \"_\";\n        this.mask = \"\";\n        this.promptPlaceholder = \" \";\n        this.includeLiterals = false;\n        this.maskTokens = [];\n        this.unmaskTokens = [];\n        this.rawTokens = [];\n        this.validationTokens = [];\n    }\n    MaskingService.prototype.update = function (_a) {\n        var _b = _a.mask, mask$$1 = _b === void 0 ? '' : _b, _c = _a.prompt, prompt = _c === void 0 ? '' : _c, _d = _a.promptPlaceholder, promptPlaceholder = _d === void 0 ? ' ' : _d, _e = _a.rules, rules = _e === void 0 ? {} : _e, _f = _a.includeLiterals, includeLiterals = _f === void 0 ? false : _f;\n        this.mask = mask$$1;\n        this.prompt = prompt;\n        this.promptPlaceholder = promptPlaceholder;\n        this.rules = rules;\n        this.includeLiterals = includeLiterals;\n        this.tokenize();\n    };\n    MaskingService.prototype.validationValue = function (maskedValue) {\n        if (maskedValue === void 0) { maskedValue = ''; }\n        var value = maskedValue;\n        sequence(this.validationTokens)\n            .run(maskedValue)\n            .fold(function (unmasked) {\n            value = unmasked.join('');\n        });\n        return value;\n    };\n    MaskingService.prototype.rawValue = function (maskedValue) {\n        if (maskedValue === void 0) { maskedValue = ''; }\n        var value = maskedValue;\n        if (!this.rawTokens.length) {\n            return value;\n        }\n        sequence(this.rawTokens)\n            .run(maskedValue)\n            .fold(function (unmasked) {\n            value = unmasked.join('');\n        });\n        return value;\n    };\n    /**\n     * @hidden\n     */\n    MaskingService.prototype.maskRaw = function (rawValue) {\n        if (rawValue === void 0) { rawValue = ''; }\n        var value = rawValue;\n        if (!this.maskTokens.length) {\n            return value;\n        }\n        sequence(this.maskTokens)\n            .run(rawValue)\n            .fold(function (masked) {\n            value = masked.join('');\n        });\n        return value;\n    };\n    MaskingService.prototype.maskInput = function (input, control, splitPoint) {\n        if (input.length < control.length) {\n            return this.maskRemoved(input, control, splitPoint);\n        }\n        return this.maskInserted(input, control, splitPoint);\n    };\n    MaskingService.prototype.maskInRange = function (pasted, oldValue, start, end) {\n        var value = '';\n        var selection = end;\n        var beforeChange = oldValue.split('').slice(0, start);\n        var afterChange = oldValue.split('').slice(end);\n        sequence(this.maskTokens.slice(start, end))\n            .run(pasted)\n            .fold(function (masked) {\n            value = beforeChange\n                .concat(masked)\n                .concat(afterChange)\n                .join('');\n        });\n        return {\n            selection: selection,\n            value: value\n        };\n    };\n    MaskingService.prototype.maskRemoved = function (input, control, splitPoint) {\n        var _this = this;\n        var value = '';\n        var selection = splitPoint;\n        var unchanged = input.split('').slice(splitPoint);\n        var changed = input.split('').slice(0, splitPoint).join('');\n        var take$$1 = this.maskTokens.length - (input.length - splitPoint);\n        sequence(this.maskTokens.slice(0, take$$1))\n            .run(changed, control)\n            .fold(function (masked) {\n            selection = _this.adjustPosition(masked, selection);\n            value = masked.concat(unchanged).join('');\n        });\n        return {\n            selection: selection,\n            value: value\n        };\n    };\n    MaskingService.prototype.adjustPosition = function (input, selection) {\n        var caretChar = input[selection];\n        var isLiteral = this.maskTokens[selection].isLiteral(caretChar);\n        if (!isLiteral && caretChar !== this.prompt) {\n            return selection + 1;\n        }\n        return selection;\n    };\n    MaskingService.prototype.maskInserted = function (input, control, splitPoint) {\n        var _this = this;\n        var value = '';\n        var selection = splitPoint;\n        var changed = input.slice(0, splitPoint);\n        sequence(this.unmaskTokens)\n            .run(changed, control)\n            .chain(function (unmasked) {\n            selection = unmasked.join('').length;\n            var unchanged = control.slice(selection);\n            return sequence(_this.maskTokens)\n                .run(unmasked.join('') + unchanged, control);\n        })\n            .fold(function (masked) {\n            value = masked.join('');\n        });\n        return {\n            selection: selection,\n            value: value\n        };\n    };\n    Object.defineProperty(MaskingService.prototype, \"maskTokenCreator\", {\n        get: function () {\n            var _a = this, prompt = _a.prompt, promptPlaceholder = _a.promptPlaceholder;\n            return {\n                literal: function (rule) { return literal(rule); },\n                mask: function (rule) { return mask({ prompt: prompt, promptPlaceholder: promptPlaceholder })(rule); }\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MaskingService.prototype, \"unmaskTokenCreator\", {\n        get: function () {\n            var _this = this;\n            return {\n                literal: function (rule) { return unliteral(rule); },\n                mask: function (rule) { return unmask(_this.prompt)(rule); }\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MaskingService.prototype, \"rawTokenCreator\", {\n        get: function () {\n            var _a = this, prompt = _a.prompt, promptPlaceholder = _a.promptPlaceholder, includeLiterals = _a.includeLiterals;\n            return {\n                literal: function (_) { return rawLiteral(includeLiterals); },\n                mask: function (_) { return rawMask({ prompt: prompt, promptPlaceholder: promptPlaceholder }); }\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MaskingService.prototype, \"validationTokenCreator\", {\n        get: function () {\n            var prompt = this.prompt;\n            return {\n                literal: function (_) { return rawLiteral(false); },\n                mask: function (_) { return rawMask({ prompt: prompt, promptPlaceholder: '' }); }\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MaskingService.prototype.tokenize = function () {\n        var _this = this;\n        greedy(token(this.rules, this.maskTokenCreator))\n            .run(this.mask)\n            .fold(function (tokens, _) {\n            _this.maskTokens = tokens;\n        });\n        greedy(token(this.rules, this.unmaskTokenCreator))\n            .run(this.mask)\n            .fold(function (tokens, _) {\n            _this.unmaskTokens = tokens;\n        });\n        greedy(token(this.rules, this.rawTokenCreator))\n            .run(this.mask)\n            .fold(function (tokens, _) {\n            _this.rawTokens = tokens;\n        });\n        greedy(token(this.rules, this.validationTokenCreator))\n            .run(this.mask)\n            .fold(function (tokens, _) {\n            _this.validationTokens = tokens;\n        });\n    };\n    MaskingService.decorators = [\n        { type: Injectable },\n    ];\n    return MaskingService;\n}());\n\nvar resolvedPromise = Promise.resolve(null);\nvar FOCUSED$3 = 'k-state-focused';\n/**\n * Represents the [Kendo UI MaskedTextBox component for Angular]({% slug overview_maskedtextbox %}).\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *      <kendo-maskedtextbox\n *          [mask]=\"mask\"\n *          [value]=\"value\">\n *      </kendo-maskedtextbox>\n *     `\n * })\n *\n * class AppComponent {\n *  public value: string = \"9580128055807792\";\n *  public mask: string = \"0000-0000-0000-0000\";\n * }\n * ```\n */\nvar MaskedTextBoxComponent = /** @class */ (function () {\n    function MaskedTextBoxComponent(service, renderer, hostElement, ngZone, injector, rtl) {\n        var _this = this;\n        this.service = service;\n        this.renderer = renderer;\n        this.hostElement = hostElement;\n        this.ngZone = ngZone;\n        this.injector = injector;\n        /**\n         * @hidden\n         */\n        this.focusableId = \"k-\" + guid();\n        /**\n         * Determines whether the MaskedTextBox is disabled ([see example]({% slug disabled_maskedtextbox %})).\n         */\n        this.disabled = false;\n        /**\n         * Determines whether the MaskedTextBox is in its read-only state ([see example]({% slug readonly_maskedtextbox %})).\n         */\n        this.readonly = false;\n        this.hostClasses = true;\n        /**\n         * Represents a prompt character for the masked value.\n         * @default `_`\n         */\n        this.prompt = '_';\n        /**\n         * Indicates a character which represents an empty position in the raw value.\n         * @default ' '\n         */\n        this.promptPlaceholder = ' ';\n        /**\n         * Indicates whether to include literals in the raw value  ([see example]({% slug value_maskedtextbox %})).\n         * @default false\n         */\n        this.includeLiterals = false;\n        /**\n         * Specifies if the mask should be shown on focus for empty value.\n         */\n        this.maskOnFocus = false;\n        /**\n         * Determines whether the built-in mask validator is enforced when a form is validated\n         * ([see example]({% slug validation_maskedtextbox %})).\n         * @default true\n         */\n        this.maskValidation = true;\n        /**\n         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n         */\n        this.tabindex = 0;\n        /**\n         * Fires each time the user focuses the `input` element.\n         *\n         * > To wire the event programmatically, use the `onFocus` property.\n         *\n         * @example\n         * ```ts\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-maskedtextbox (focus)=\"handleFocus()\"></kendo-maskedtextbox>\n         * `\n         * })\n         * class AppComponent {\n         *   public handleFocus(): void {\n         *      console.log(\"Component is focused\");\n         *   }\n         * }\n         * ```\n         */\n        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the `input` element gets blurred.\n         *\n         * > To wire the event programmatically, use the `onBlur` property.\n         *\n         * @example\n         * ```ts\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-maskedtextbox (blur)=\"handleBlur()\"></kendo-maskedtextbox>\n         * `\n         * })\n         * class AppComponent {\n         *   public handleBlur(): void {\n         *      console.log(\"Component is blurred\");\n         *   }\n         * }\n         * ```\n         */\n        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the value changes.\n         */\n        this.valueChange = new EventEmitter();\n        this.focusClick = false;\n        this.defaultRules = {\n            \"#\": /[\\d\\s\\+\\-]/,\n            \"&\": /[\\S]/,\n            \"0\": /[\\d]/,\n            \"9\": /[\\d\\s]/,\n            \"?\": /[a-zA-Z\\s]/,\n            \"A\": /[a-zA-Z0-9]/,\n            \"C\": /./,\n            \"L\": /[a-zA-Z]/,\n            \"a\": /[a-zA-Z0-9\\s]/\n        };\n        this.isPasted = false;\n        this.selection = [0, 0];\n        /**\n         * @hidden\n         */\n        this.handleFocus = function () {\n            _this.focused = true;\n            if (_this.maskOnFocus && _this.emptyMask) {\n                _this.updateInput(_this.service.maskRaw(_this.value));\n                _this.ngZone.runOutsideAngular(function () {\n                    setTimeout(function () { _this.setSelection(0, 0); }, 0);\n                });\n            }\n            if (hasObservers(_this.onFocus)) {\n                _this.ngZone.run(function () {\n                    _this.onFocus.emit();\n                });\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.handleClick = function () {\n            if (_this.focused && !_this.focusClick) {\n                _this.focusClick = true;\n                var _a = _this.input.nativeElement, selectionStart = _a.selectionStart, selectionEnd = _a.selectionEnd;\n                if (selectionStart === selectionEnd) {\n                    _this.setFocusSelection();\n                }\n            }\n        };\n        /**\n         * @hidden\n         */\n        this.handleBlur = function () {\n            _this.focused = false;\n            _this.focusClick = false;\n            if (_this.maskOnFocus && _this.emptyMask) {\n                _this.updateInput(_this.maskedValue);\n            }\n            if (hasObservers(_this.onBlur) || requiresZoneOnBlur(_this.control)) {\n                _this.ngZone.run(function () {\n                    _this.onTouched();\n                    _this.onBlur.emit();\n                });\n            }\n        };\n        this.onChange = function (_) { };\n        this.onTouched = function () { };\n        this.direction = rtl ? 'rtl' : 'ltr';\n        this.updateService();\n    }\n    Object.defineProperty(MaskedTextBoxComponent.prototype, \"hostDisabledClass\", {\n        get: function () {\n            return this.disabled;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MaskedTextBoxComponent.prototype, \"rules\", {\n        /**\n         * Exposes the RegExp-based mask validation array ([see example]({% slug masks_maskedtextbox %})).\n         */\n        get: function () {\n            return this._rules || this.defaultRules;\n        },\n        set: function (value) {\n            this._rules = Object.assign({}, this.defaultRules, value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MaskedTextBoxComponent.prototype, \"tabIndex\", {\n        get: function () {\n            return this.tabindex;\n        },\n        /**\n         * @hidden\n         */\n        set: function (tabIndex) {\n            this.tabindex = tabIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MaskedTextBoxComponent.prototype.ngOnInit = function () {\n        if (this.hostElement) {\n            this.renderer.removeAttribute(this.hostElement.nativeElement, \"tabindex\");\n        }\n        this.control = this.injector.get(NgControl, null);\n    };\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the MaskedTextBox is empty.\n     */\n    MaskedTextBoxComponent.prototype.isEmpty = function () {\n        if (this.input) {\n            return !Boolean(this.input.nativeElement.value);\n        }\n    };\n    /**\n     * @hidden\n     */\n    MaskedTextBoxComponent.prototype.handleDragDrop = function () {\n        return false;\n    };\n    /**\n     * Focuses the MaskedTextBox.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"maskedinput.focus()\">Focus the input</button>\n     *  <kendo-maskedtextbox #maskedinput></kendo-maskedtextbox>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    MaskedTextBoxComponent.prototype.focus = function () {\n        if (!this.input) {\n            return;\n        }\n        this.input.nativeElement.focus();\n        this.setFocusSelection();\n    };\n    /**\n     * Blurs the MaskedTextBox.\n     */\n    MaskedTextBoxComponent.prototype.blur = function () {\n        if (!this.input) {\n            return;\n        }\n        this.input.nativeElement.blur();\n    };\n    /**\n     * @hidden\n     */\n    MaskedTextBoxComponent.prototype.pasteHandler = function (e) {\n        var _a = e.target, selectionStart = _a.selectionStart, selectionEnd = _a.selectionEnd;\n        if (selectionEnd === selectionStart) {\n            return;\n        }\n        this.isPasted = true;\n        this.selection = [selectionStart, selectionEnd];\n    };\n    /**\n     * @hidden\n     */\n    MaskedTextBoxComponent.prototype.inputHandler = function (e) {\n        var value = e.target.value;\n        var _a = this.selection, start = _a[0], end = _a[1];\n        if (!this.mask) {\n            this.updateValue(value);\n            this.isPasted = false;\n            return;\n        }\n        var result;\n        if (this.isPasted) {\n            this.isPasted = false;\n            var rightPart = this.maskedValue.length - end;\n            var to = value.length - rightPart;\n            result = this.service.maskInRange(value.slice(start, to), this.maskedValue, start, end);\n        }\n        else {\n            result = this.service.maskInput(value, this.maskedValue, e.target.selectionStart);\n        }\n        this.updateInput(result.value, result.selection);\n        this.updateValue(result.value);\n    };\n    /**\n     * @hidden\n     */\n    MaskedTextBoxComponent.prototype.ngOnChanges = function (changes) {\n        var _this = this;\n        if (changes.value) {\n            this.value = this.normalizeValue();\n        }\n        if (!this.mask) {\n            this.updateInput(this.value);\n            return;\n        }\n        var next = this.extractChanges(changes);\n        this.updateService(next);\n        if (isChanged('value', changes)) {\n            var maskedValue = this.service.maskRaw(this.value);\n            if (maskedValue !== this.maskedValue) {\n                this.updateInput(maskedValue);\n            }\n        }\n        else if (anyChanged(['promptPlaceholder', 'includeLiterals'], changes)) {\n            resolvedPromise.then(function () {\n                _this.updateValue(_this.maskedValue);\n            });\n        }\n        else {\n            this.updateInput(this.service.maskRaw(this.value));\n        }\n    };\n    /**\n     * @hidden\n     * Writes a new value to the element.\n     */\n    MaskedTextBoxComponent.prototype.writeValue = function (value) {\n        this.value = this.normalizeValue(value);\n        this.updateInput(this.service.maskRaw(this.value));\n    };\n    /**\n     * @hidden\n     * Sets the function that will be called when a `change` event is triggered.\n     */\n    MaskedTextBoxComponent.prototype.registerOnChange = function (fn) {\n        this.onChange = fn;\n    };\n    /**\n     * @hidden\n     * Sets the function that will be called when a `touch` event is triggered.\n     */\n    MaskedTextBoxComponent.prototype.registerOnTouched = function (fn) {\n        this.onTouched = fn;\n    };\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     *\n     * @param isDisabled\n     */\n    MaskedTextBoxComponent.prototype.setDisabledState = function (isDisabled) {\n        this.disabled = isDisabled;\n    };\n    /**\n     * @hidden\n     */\n    MaskedTextBoxComponent.prototype.validate = function (_) {\n        if (this.maskValidation === false || !this.mask) {\n            return null;\n        }\n        if (!this.service.validationValue(this.maskedValue)) {\n            return null;\n        }\n        if (this.maskedValue.indexOf(this.prompt) !== -1) {\n            return {\n                patternError: {\n                    mask: this.mask,\n                    maskedValue: this.maskedValue,\n                    value: this.value\n                }\n            };\n        }\n        return null;\n    };\n    /**\n     * @hidden\n     */\n    MaskedTextBoxComponent.prototype.updateValue = function (maskedValue) {\n        if (this.mask && !this.service.validationValue(maskedValue)) {\n            this.value = '';\n        }\n        else {\n            this.value = this.service.rawValue(maskedValue);\n        }\n        this.onChange(this.value);\n        this.valueChange.emit(this.value);\n    };\n    MaskedTextBoxComponent.prototype.updateInput = function (maskedValue, selection) {\n        if (maskedValue === void 0) { maskedValue = ''; }\n        this.maskedValue = maskedValue;\n        var value = this.maskOnFocus && !this.focused && this.emptyMask ? '' : maskedValue;\n        this.renderer.setProperty(this.input.nativeElement, \"value\", value);\n        if (selection !== undefined) {\n            this.setSelection(selection, selection);\n        }\n    };\n    MaskedTextBoxComponent.prototype.extractChanges = function (changes) {\n        return Object.keys(changes).filter(function (key) { return key !== 'rules'; }).reduce(function (obj, key) {\n            obj[key] = changes[key].currentValue;\n            return obj;\n        }, {}); // tslint:disable-line:align\n    };\n    MaskedTextBoxComponent.prototype.updateService = function (extra) {\n        var config = Object.assign({\n            includeLiterals: this.includeLiterals,\n            mask: this.mask,\n            prompt: this.prompt,\n            promptPlaceholder: this.promptPlaceholder,\n            rules: this.rules\n        }, extra); // tslint:disable-line:align\n        this.service.update(config);\n    };\n    MaskedTextBoxComponent.prototype.setSelection = function (start, end) {\n        if (start === void 0) { start = this.selection[0]; }\n        if (end === void 0) { end = this.selection[1]; }\n        if (this.focused) {\n            invokeElementMethod(this.input, 'setSelectionRange', start, end);\n        }\n    };\n    Object.defineProperty(MaskedTextBoxComponent.prototype, \"emptyMask\", {\n        get: function () {\n            return this.service.maskRaw() === this.maskedValue;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MaskedTextBoxComponent.prototype.setFocusSelection = function () {\n        var selectionStart = this.input.nativeElement.selectionStart;\n        var index = this.maskedValue ? this.maskedValue.indexOf(this.prompt) : 0;\n        if (index >= 0 && index < selectionStart) {\n            this.selection = [index, index];\n            this.setSelection();\n        }\n    };\n    Object.defineProperty(MaskedTextBoxComponent.prototype, \"focused\", {\n        get: function () {\n            return this.isFocused;\n        },\n        set: function (value) {\n            if (this.isFocused !== value && this.hostElement) {\n                var element = this.hostElement.nativeElement;\n                if (value) {\n                    this.renderer.addClass(element, FOCUSED$3);\n                }\n                else {\n                    this.renderer.removeClass(element, FOCUSED$3);\n                }\n                this.isFocused = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MaskedTextBoxComponent.prototype.normalizeValue = function (value) {\n        if (value === void 0) { value = this.value; }\n        var present = isPresent(value);\n        if (present && typeof value !== 'string') {\n            if (isDevMode()) {\n                throw new Error('The MaskedTextBox component supports only string values.');\n            }\n            return String(value);\n        }\n        return present ? value : '';\n    };\n    MaskedTextBoxComponent.decorators = [\n        { type: Component, args: [{\n                    exportAs: 'kendoMaskedTextBox',\n                    providers: [\n                        MaskingService,\n                        {\n                            multi: true,\n                            provide: NG_VALUE_ACCESSOR,\n                            useExisting: forwardRef(function () { return MaskedTextBoxComponent; }) /* tslint:disable-line */\n                        },\n                        {\n                            multi: true,\n                            provide: NG_VALIDATORS,\n                            useExisting: forwardRef(function () { return MaskedTextBoxComponent; }) /* tslint:disable-line */\n                        },\n                        {\n                            provide: KendoInput,\n                            useExisting: forwardRef(function () { return MaskedTextBoxComponent; })\n                        }\n                    ],\n                    selector: 'kendo-maskedtextbox',\n                    template: \"\\n        <input type=\\\"text\\\"\\n            #input\\n            autocomplete=\\\"off\\\"\\n            autocorrect=\\\"off\\\"\\n            autocapitalize=\\\"off\\\"\\n            spellcheck=\\\"false\\\"\\n            class=\\\"k-textbox\\\"\\n            [id]=\\\"focusableId\\\"\\n            [tabindex]=\\\"tabIndex\\\"\\n            [attr.title]=\\\"title\\\"\\n            [disabled]=\\\"disabled\\\"\\n            [readonly]=\\\"readonly\\\"\\n            [kendoEventsOutsideAngular]=\\\"{\\n                focus: handleFocus,\\n                blur: handleBlur,\\n                click: handleClick,\\n                dragstart: handleDragDrop,\\n                drop: handleDragDrop\\n            }\\\"\\n        />\\n    \"\n                },] },\n    ];\n    /** @nocollapse */\n    MaskedTextBoxComponent.ctorParameters = function () { return [\n        { type: MaskingService },\n        { type: Renderer2 },\n        { type: ElementRef },\n        { type: NgZone },\n        { type: Injector },\n        { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [RTL,] }] }\n    ]; };\n    MaskedTextBoxComponent.propDecorators = {\n        focusableId: [{ type: Input }],\n        disabled: [{ type: Input }],\n        readonly: [{ type: Input }],\n        title: [{ type: Input }],\n        direction: [{ type: HostBinding, args: ['attr.dir',] }],\n        hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-maskedtextbox',] }],\n        hostDisabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }],\n        mask: [{ type: Input }],\n        value: [{ type: Input }],\n        rules: [{ type: Input }],\n        prompt: [{ type: Input }],\n        promptPlaceholder: [{ type: Input }],\n        includeLiterals: [{ type: Input }],\n        maskOnFocus: [{ type: Input }],\n        maskValidation: [{ type: Input }],\n        tabindex: [{ type: Input }],\n        tabIndex: [{ type: Input }],\n        onFocus: [{ type: Output, args: ['focus',] }],\n        onBlur: [{ type: Output, args: ['blur',] }],\n        valueChange: [{ type: Output }],\n        input: [{ type: ViewChild, args: ['input', { static: true },] }],\n        pasteHandler: [{ type: HostListener, args: ['paste', ['$event'],] }],\n        inputHandler: [{ type: HostListener, args: ['input', ['$event'],] }]\n    };\n    return MaskedTextBoxComponent;\n}());\n\n/* tslint:disable:component-selector */\n/**\n * @hidden\n */\nvar SliderTick = /** @class */ (function () {\n    function SliderTick(value) {\n        this.value = value;\n        this.classes = {\n            'k-tick': true\n        };\n    }\n    return SliderTick;\n}());\n/**\n * @hidden\n */\nvar SliderTicksComponent = /** @class */ (function () {\n    function SliderTicksComponent(rtl) {\n        this.rtl = rtl;\n        this.wrapperClasses = 'k-reset k-slider-items';\n        this.ticks = [];\n    }\n    SliderTicksComponent.prototype.ngOnChanges = function (_) {\n        this.createTicks();\n    };\n    SliderTicksComponent.prototype.createTicks = function () {\n        var count = calculateTicksCount(this.min, this.max, this.step);\n        var largeStep = this.largeStep;\n        var tickValueProps = {\n            max: this.max,\n            min: this.min,\n            smallStep: this.step\n        };\n        var result = [];\n        for (var i = 0; i < count; i++) {\n            result.push(new SliderTick(calculateValueFromTick(i, tickValueProps)));\n            if (largeStep && i % largeStep === 0) {\n                result[i].large = true;\n                result[i].classes['k-tick-large'] = true;\n            }\n        }\n        if (this.rtl || this.vertical) {\n            result = result.reverse();\n        }\n        if (result.length > 0) {\n            Object.assign(result[0].classes, this.endTickClasses(true));\n            Object.assign(result[result.length - 1].classes, this.endTickClasses(false));\n        }\n        this.ticks = result;\n    };\n    SliderTicksComponent.prototype.endTickClasses = function (first) {\n        return {\n            'k-first': (first && !this.vertical) || (!first && this.vertical),\n            'k-last': (!first && !this.vertical) || (first && this.vertical)\n        };\n    };\n    SliderTicksComponent.decorators = [\n        { type: Component, args: [{\n                    selector: '[kendoSliderTicks]',\n                    template: \"\\n    <li #tickElement *ngFor=\\\"let tick of ticks;\\\"\\n        [ngClass]=\\\"tick.classes\\\"\\n        title=\\\"{{ tickTitle(tick.value) }}\\\"\\n        role=\\\"presentation\\\"\\n     >\\n         <ng-container [ngSwitch]=\\\"tick.large\\\">\\n            <span class=\\\"k-label\\\" *ngSwitchCase=\\\"true\\\">\\n                <ng-container [ngTemplateOutlet]=\\\"labelTemplate || defaultLabel\\\" [ngTemplateOutletContext]=\\\"tick\\\">\\n                </ng-container>\\n            </span>\\n            <ng-container *ngSwitchCase=\\\"false\\\">&nbsp;</ng-container>\\n         </ng-container>\\n     </li>\\n\\n     <ng-template #defaultLabel let-value=\\\"value\\\">\\n        {{ tickTitle(value) }}\\n     </ng-template>\\n  \"\n                },] },\n    ];\n    /** @nocollapse */\n    SliderTicksComponent.ctorParameters = function () { return [\n        { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [RTL,] }] }\n    ]; };\n    SliderTicksComponent.propDecorators = {\n        wrapperClasses: [{ type: HostBinding, args: ['class',] }],\n        tickTitle: [{ type: Input }],\n        vertical: [{ type: Input }],\n        step: [{ type: Input }],\n        largeStep: [{ type: Input }],\n        min: [{ type: Input }],\n        max: [{ type: Input }],\n        labelTemplate: [{ type: Input }],\n        tickElements: [{ type: ViewChildren, args: ['tickElement',] }]\n    };\n    return SliderTicksComponent;\n}());\n\n/**\n * @hidden\n */\nvar SliderMessages = /** @class */ (function (_super) {\n    __extends(SliderMessages, _super);\n    function SliderMessages() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    SliderMessages.propDecorators = {\n        decrement: [{ type: Input }],\n        increment: [{ type: Input }],\n        dragHandle: [{ type: Input }]\n    };\n    return SliderMessages;\n}(ComponentMessages));\n\n/**\n * @hidden\n */\nvar LocalizedSliderMessagesDirective = /** @class */ (function (_super) {\n    __extends(LocalizedSliderMessagesDirective, _super);\n    function LocalizedSliderMessagesDirective(service) {\n        var _this = _super.call(this) || this;\n        _this.service = service;\n        return _this;\n    }\n    LocalizedSliderMessagesDirective.decorators = [\n        { type: Directive, args: [{\n                    providers: [\n                        {\n                            provide: SliderMessages,\n                            useExisting: forwardRef(function () { return LocalizedSliderMessagesDirective; }) // tslint:disable-line:no-forward-ref\n                        }\n                    ],\n                    selector: '[kendoSliderLocalizedMessages]'\n                },] },\n    ];\n    /** @nocollapse */\n    LocalizedSliderMessagesDirective.ctorParameters = function () { return [\n        { type: LocalizationService }\n    ]; };\n    return LocalizedSliderMessagesDirective;\n}(SliderMessages));\n\n/**\n * Custom component messages override default component messages.\n */\nvar SliderCustomMessagesComponent = /** @class */ (function (_super) {\n    __extends(SliderCustomMessagesComponent, _super);\n    function SliderCustomMessagesComponent(service) {\n        var _this = _super.call(this) || this;\n        _this.service = service;\n        return _this;\n    }\n    Object.defineProperty(SliderCustomMessagesComponent.prototype, \"override\", {\n        get: function () {\n            return true;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SliderCustomMessagesComponent.decorators = [\n        { type: Component, args: [{\n                    providers: [\n                        {\n                            provide: SliderMessages,\n                            useExisting: forwardRef(function () { return SliderCustomMessagesComponent; }) // tslint:disable-line:no-forward-ref\n                        }\n                    ],\n                    selector: 'kendo-slider-messages',\n                    template: \"\"\n                },] },\n    ];\n    /** @nocollapse */\n    SliderCustomMessagesComponent.ctorParameters = function () { return [\n        { type: LocalizationService }\n    ]; };\n    return SliderCustomMessagesComponent;\n}(SliderMessages));\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Slider component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Inputs module\n * import { SliderModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, BrowserAnimationsModule, SliderModule], // import Slider module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nvar SliderModule = /** @class */ (function () {\n    function SliderModule() {\n    }\n    SliderModule.decorators = [\n        { type: NgModule, args: [{\n                    declarations: [\n                        SliderComponent,\n                        SliderTicksComponent,\n                        SliderCustomMessagesComponent,\n                        LocalizedSliderMessagesDirective,\n                        LabelTemplateDirective\n                    ],\n                    exports: [\n                        SliderComponent,\n                        SliderCustomMessagesComponent,\n                        LocalizedSliderMessagesDirective,\n                        LabelTemplateDirective\n                    ],\n                    imports: [CommonModule, DraggableModule, EventsModule, ResizeSensorModule]\n                },] },\n    ];\n    return SliderModule;\n}());\n\n/**\n * @hidden\n */\nvar Messages = /** @class */ (function (_super) {\n    __extends(Messages, _super);\n    function Messages() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Messages.propDecorators = {\n        on: [{ type: Input }],\n        off: [{ type: Input }]\n    };\n    return Messages;\n}(ComponentMessages));\n\n/**\n * @hidden\n */\nvar LocalizedSwitchMessagesDirective = /** @class */ (function (_super) {\n    __extends(LocalizedSwitchMessagesDirective, _super);\n    function LocalizedSwitchMessagesDirective(service) {\n        var _this = _super.call(this) || this;\n        _this.service = service;\n        return _this;\n    }\n    LocalizedSwitchMessagesDirective.decorators = [\n        { type: Directive, args: [{\n                    providers: [\n                        {\n                            provide: Messages,\n                            useExisting: forwardRef(function () { return LocalizedSwitchMessagesDirective; }) // tslint:disable-line:no-forward-ref\n                        }\n                    ],\n                    selector: '[kendoSwitchLocalizedMessages]'\n                },] },\n    ];\n    /** @nocollapse */\n    LocalizedSwitchMessagesDirective.ctorParameters = function () { return [\n        { type: LocalizationService }\n    ]; };\n    return LocalizedSwitchMessagesDirective;\n}(Messages));\n\n/**\n * Custom component messages override default component messages.\n */\nvar SwitchCustomMessagesComponent = /** @class */ (function (_super) {\n    __extends(SwitchCustomMessagesComponent, _super);\n    function SwitchCustomMessagesComponent(service) {\n        var _this = _super.call(this) || this;\n        _this.service = service;\n        return _this;\n    }\n    Object.defineProperty(SwitchCustomMessagesComponent.prototype, \"override\", {\n        get: function () {\n            return true;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SwitchCustomMessagesComponent.decorators = [\n        { type: Component, args: [{\n                    providers: [\n                        {\n                            provide: Messages,\n                            useExisting: forwardRef(function () { return SwitchCustomMessagesComponent; }) // tslint:disable-line:no-forward-ref\n                        }\n                    ],\n                    selector: 'kendo-switch-messages',\n                    template: \"\"\n                },] },\n    ];\n    /** @nocollapse */\n    SwitchCustomMessagesComponent.ctorParameters = function () { return [\n        { type: LocalizationService }\n    ]; };\n    return SwitchCustomMessagesComponent;\n}(Messages));\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Switch component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Switch module\n * import { SwitchModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, SwitchModule], // import Switch module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nvar SwitchModule = /** @class */ (function () {\n    function SwitchModule() {\n    }\n    SwitchModule.decorators = [\n        { type: NgModule, args: [{\n                    declarations: [\n                        SwitchComponent,\n                        SwitchCustomMessagesComponent,\n                        LocalizedSwitchMessagesDirective\n                    ],\n                    exports: [\n                        SwitchComponent,\n                        SwitchCustomMessagesComponent,\n                        LocalizedSwitchMessagesDirective\n                    ],\n                    imports: [CommonModule, EventsModule, ResizeSensorModule]\n                },] },\n    ];\n    return SwitchModule;\n}());\n\n/**\n * @hidden\n */\nvar LocalizedNumericTextBoxMessagesDirective = /** @class */ (function (_super) {\n    __extends(LocalizedNumericTextBoxMessagesDirective, _super);\n    function LocalizedNumericTextBoxMessagesDirective(service) {\n        var _this = _super.call(this) || this;\n        _this.service = service;\n        return _this;\n    }\n    LocalizedNumericTextBoxMessagesDirective.decorators = [\n        { type: Directive, args: [{\n                    providers: [\n                        {\n                            provide: NumericTextBoxMessages,\n                            useExisting: forwardRef(function () { return LocalizedNumericTextBoxMessagesDirective; }) // tslint:disable-line:no-forward-ref\n                        }\n                    ],\n                    selector: '[kendoNumericTextBoxLocalizedMessages]'\n                },] },\n    ];\n    /** @nocollapse */\n    LocalizedNumericTextBoxMessagesDirective.ctorParameters = function () { return [\n        { type: LocalizationService }\n    ]; };\n    return LocalizedNumericTextBoxMessagesDirective;\n}(NumericTextBoxMessages));\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the NumericTextBox component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the NumericTextBox module\n * import { NumericTextBoxModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, NumericTextBoxModule], // import NumericTextBox module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nvar NumericTextBoxModule = /** @class */ (function () {\n    function NumericTextBoxModule() {\n    }\n    NumericTextBoxModule.decorators = [\n        { type: NgModule, args: [{\n                    declarations: [\n                        LocalizedNumericTextBoxMessagesDirective,\n                        NumericTextBoxComponent,\n                        NumericTextBoxCustomMessagesComponent\n                    ],\n                    exports: [\n                        NumericTextBoxComponent,\n                        NumericTextBoxCustomMessagesComponent\n                    ],\n                    imports: [CommonModule, EventsModule]\n                },] },\n    ];\n    return NumericTextBoxModule;\n}());\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the MaskedTextBox component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the MaskedTextBox module\n * import { MaskedTextBoxModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, MaskedTextBoxModule], // import MaskedTextBox module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nvar MaskedTextBoxModule = /** @class */ (function () {\n    function MaskedTextBoxModule() {\n    }\n    MaskedTextBoxModule.decorators = [\n        { type: NgModule, args: [{\n                    declarations: [MaskedTextBoxComponent],\n                    exports: [MaskedTextBoxComponent],\n                    imports: [CommonModule, EventsModule]\n                },] },\n    ];\n    return MaskedTextBoxModule;\n}());\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the TextBox directive.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the TextBox module\n * import { TextBoxModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, TextBoxModule], // import TextBox module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nvar TextBoxModule = /** @class */ (function () {\n    function TextBoxModule() {\n    }\n    TextBoxModule.decorators = [\n        { type: NgModule, args: [{\n                    declarations: [TextBoxDirective, TextAreaDirective, TextBoxContainerComponent],\n                    exports: [TextBoxDirective, TextAreaDirective, TextBoxContainerComponent],\n                    imports: [CommonModule]\n                },] },\n    ];\n    return TextBoxModule;\n}());\n\n/**\n * @hidden\n */\nvar PreventableEvent = /** @class */ (function () {\n    function PreventableEvent() {\n        this.prevented = false;\n    }\n    /**\n     * Prevents the default action for a specified event.\n     * In this way, the source component suppresses the built-in behavior that follows the event.\n     */\n    PreventableEvent.prototype.preventDefault = function () {\n        this.prevented = true;\n    };\n    /**\n     * If the event is prevented by any of its subscribers, returns `true`.\n     *\n     * @returns - `true` if the default action was prevented. Otherwise, returns `false`.\n     */\n    PreventableEvent.prototype.isDefaultPrevented = function () {\n        return this.prevented;\n    };\n    return PreventableEvent;\n}());\n\n/**\n * Fires each time the left side of the ColorPicker wrapper is clicked.\n * The event is triggered regardless of whether a ColorPicker icon is set or not.\n *\n * Provides information about the current active color and gives the option to prevent the opening of the popup.\n *\n * @example\n *\n * ```ts\n * _@Component({\n *   selector: 'my-app',\n *   template: `\n *       <kendo-colorpicker\n *           [icon]=\"'edit-tools'\"\n *           [value]=\"'#900'\"\n *           (activeColorClick)=\"handleActiveColorClick($event)\"\n *       >\n *       </kendo-colorpicker>\n *   `\n * })\n * class AppComponent {\n *     public handleActiveColorClick(event: ActiveColorClickEvent): void {\n *         event.preventOpen();\n *\n *         console.log('Open prevented:', event.isOpenPrevented());\n *         console.log('Current color:', event.color);\n *     }\n *  }\n * ```\n */\nvar ActiveColorClickEvent = /** @class */ (function () {\n    /**\n     * @hidden\n     * @param color Represents the current value of the ColorPicker.\n     */\n    function ActiveColorClickEvent(color) {\n        this.color = color;\n        this.openPrevented = false;\n    }\n    /**\n     * Prevents the opening of the popup.\n     */\n    ActiveColorClickEvent.prototype.preventOpen = function () {\n        this.openPrevented = true;\n    };\n    /**\n     * Returns `true` if the popup opening is prevented by any of its subscribers.\n     *\n     * @returns - Returns `true` if the open action was prevented. Otherwise, returns `false`.\n     */\n    ActiveColorClickEvent.prototype.isOpenPrevented = function () {\n        return this.openPrevented;\n    };\n    return ActiveColorClickEvent;\n}());\n\n/**\n * @hidden\n *\n * Returns the hex or rgba string representation of the color.\n */\nvar parseColor$1 = function (value, format, safe) {\n    if (safe === void 0) { safe = true; }\n    var allowedFormats = ['hex', 'rgba', 'name'];\n    if (allowedFormats.indexOf(format) === -1) {\n        throw new Error(\"Unsupported color output format '\" + format + \"'. The available options are 'hex', 'rgba' or 'name'.\");\n    }\n    if (!isPresent(value)) {\n        return;\n    }\n    if (format === 'name') {\n        return nameFormat(value, safe);\n    }\n    var parsedColor = parseColor(value.trim(), safe);\n    if (!isPresent(parsedColor)) {\n        return;\n    }\n    return format === 'hex' ? parsedColor.toCss() : parsedColor.toCssRgba();\n};\n/**\n * @hidden\n *\n * Returns an HSV object representation of the color string.\n */\nvar getHSV = function (value, safe) {\n    if (safe === void 0) { safe = true; }\n    var parsed = parseColor(value, safe);\n    if (!isPresent(parsed)) {\n        return {};\n    }\n    return parsed.toHSV();\n};\n/**\n * @hidden\n *\n * Returns an RGBA object representation of the color string.\n */\nvar getRGBA = function (value, safe) {\n    if (safe === void 0) { safe = true; }\n    var parsed = parseColor(value, safe);\n    if (!isPresent(parsed)) {\n        return {};\n    }\n    return parsed.toBytes();\n};\n/**\n * @hidden\n *\n * Returns the RGBA string representation of the color.\n */\nvar getColorFromHSV = function (hsva) {\n    var hue = fitIntoBounds(hsva.h, 0, 359.9);\n    var saturation = fitIntoBounds(hsva.s, 0, 1);\n    var value = fitIntoBounds(hsva.v, 0, 1);\n    var alpha = fitIntoBounds(hsva.a, 0, 1);\n    return Color.fromHSV(hue, saturation, value, alpha).toCssRgba();\n};\n/**\n * @hidden\n *\n * Returns the RGBA string representation of the color based on the `hue`, assuming the `value`, `saturation` and `alpha` have value of `1`.\n */\nvar getColorFromHue = function (hue) {\n    return getColorFromHSV({ h: hue, s: 1, v: 1, a: 1 });\n};\n/**\n * @hidden\n *\n * Returns the RGBA string representation of the color.\n */\nvar getColorFromRGBA = function (rgba) {\n    var red = fitIntoBounds(rgba.r, 0, 255);\n    var green = fitIntoBounds(rgba.g, 0, 255);\n    var blue = fitIntoBounds(rgba.b, 0, 255);\n    var alpha = fitIntoBounds(rgba.a, 0, 1);\n    return Color.fromBytes(red, green, blue, alpha).toCssRgba();\n};\n/**\n *\n * @hidden\n */\nfunction nameFormat(value, safe) {\n    value = value.toLowerCase().trim();\n    if (isPresent(namedColors[value])) {\n        return value;\n    }\n    if (parseColor(value, safe)) {\n        value = parseColor(value, safe).toHex();\n    }\n    var key = Object.keys(namedColors).find(function (key) { return namedColors[key] === value; });\n    if (!key && !safe) {\n        throw new Error(\"The provided color \" + value + \" is not supported for 'format=\\\"name\\\"' property.To display \" + value + \" color, the component 'format' property shoud be set to 'hex' or 'rgba' \");\n    }\n    return key;\n}\n\n// tslint:disable:max-line-length\n/**\n * @hidden\n */\nvar PALETTEPRESETS = {\n    basic: {\n        colors: '000000,7f7f7f,880015,ed1c24,ff7f27,fff200,22b14c,00a2e8,3f48cc,a349a4,ffffff,c3c3c3,b97a57,ffaec9,ffc90e,efe4b0,b5e61d,99d9ea,7092be,c8bfe7',\n        columns: 10\n    },\n    office: {\n        colors: 'ffffff, 000000, e6e6e6, 435569, 4371c4, ed7e32, a5a4a5, febf04, 5a9bd5, 71ae48, f2f2f3, 7f7f7f, d1cece, d5dde3, dae1f4, fce5d4, deeded, fff2cc, deeaf6, e1efd9, d7d8d8, 585959, aeabab, adbaca, b4c5e7, f6caac, dbdbdb, ffe498, bcd6ee, c5e0b2, bfbfc0, 3f3f3f, 767070, 8595b1, 8fabdb, f5b183, c9c8c9, fed965, 9bc4e5, a8d08d, a5a5a6, 262625, 393939, 334050, 2e5496, c45a11, 7b7b7a, bf9000, 2f75b5, 548235, 7f7f7f, 0b0c0c, 161616, 222a34, 203764, 843d0b, 525252, 7f6000, 1d4d79, 375623',\n        columns: 10\n    },\n    apex: {\n        colors: 'ffffff, 000000, c9c2d1, 69676d, ceb966, 9cb084, 6bb1c9, 6585cf, 7e6bc9, a379bb, f2f2f2, 7f7f7f, f4f2f5, e0e0e2, f5f1e0, ebefe6, e1eff4, e0e6f5, e5e1f4, ece4f1, d8d8d8, 595959, e9e6ec, c2c1c5, ebe3c1, d7dfcd, c3dfe9, c1ceeb, cbc3e9, dac9e3, bfbfbf, 3f3f3f, dedae3, a4a3a8, e1d5a3, c3cfb5, a6d0de, a2b5e2, b1a6de, c7aed6, a5a5a5, 262626, 9688a5, 4e4d51, ae9638, 758c5a, 3d8da9, 365bb0, 533da9, 7d4d99, 7f7f7f, 0c0c0c, 635672, 343336, 746425, 4e5d3c, 295e70, 243c75, 372970, 533366',\n        columns: 10\n    },\n    austin: {\n        colors: 'ffffff, 000000, caf278, 3e3d2d, 94c600, 71685a, ff6700, 909465, 956b43, fea022, f2f2f2, 7f7f7f, f4fce4, dddcd0, efffc0, e3e1dc, ffe0cb, e8e9df, ece1d6, feecd2, d8d8d8, 595959, e9f9c9, bbb9a1, dfff82, c8c3ba, ffc299, d2d4c0, dac3ad, fed9a6, bfbfbf, 3f3f3f, dff7ae, ada598, cfff43, ada598, ffa365, bcbfa1, c8a585, fec67a, a5a5a5, 262626, a9ea25, 2e2d21, 6f9400, 544e43, bf4d00, 6c6f4b, 6f5032, d77b00, 7f7f7f, 0c0c0c, 74a50f, 1f1e16, 4a6300, 38342d, 7f3300, 484a32, 4a3521, 8f5200',\n        columns: 10\n    },\n    clarity: {\n        colors: 'ffffff, 292934, f3f2dc, d2533c, 93a299, ad8f67, 726056, 4c5a6a, 808da0, 79463d, f2f2f2, e7e7ec, e7e5b9, f6dcd8, e9ecea, eee8e0, e4dedb, d8dde3, e5e8ec, e9d6d3, d8d8d8, c4c4d1, d5d185, edbab1, d3d9d6, ded2c2, c9beb8, b2bcc8, ccd1d9, d3aea7, bfbfbf, 8a8aa3, aca73b, e4978a, bec7c1, cdbba3, af9e94, 8c9bac, b2bac6, bd857c, a5a5a5, 56566e, 56531d, a43925, 6b7c72, 866b48, 554840, 39434f, 5c697b, 5a342d, 7f7f7f, 3b3b4b, 22210b, 6d2619, 47534c, 594730, 39302b, 262d35, 3d4652, 3c231e',\n        columns: 10\n    },\n    slipstream: {\n        colors: 'ffffff, 000000, b4dcfa, 212745, 4e67c8, 5eccf3, a7ea52, 5dceaf, ff8021, f14124, f2f2f2, 7f7f7f, 8bc9f7, c7cce4, dbe0f4, def4fc, edfadc, def5ef, ffe5d2, fcd9d3, d8d8d8, 595959, 4facf3, 909aca, b8c2e9, beeafa, dbf6b9, beebdf, ffcca6, f9b3a7, bfbfbf, 3f3f3f, 0d78c9, 5967af, 94a3de, 9ee0f7, caf297, 9de1cf, ffb279, f68d7b, a5a5a5, 262626, 063c64, 181d33, 31479f, 11b2eb, 81d319, 34ac8b, d85c00, c3260c, 7f7f7f, 0c0c0c, 021828, 101322, 202f6a, 0b769c, 568c11, 22725c, 903d00, 821908',\n        columns: 10\n    },\n    metro: {\n        colors: 'ffffff, 000000, d6ecff, 4e5b6f, 7fd13b, ea157a, feb80a, 00addc, 738ac8, 1ab39f, f2f2f2, 7f7f7f, a7d6ff, d9dde4, e5f5d7, fad0e4, fef0cd, c5f2ff, e2e7f4, c9f7f1, d8d8d8, 595959, 60b5ff, b3bcca, cbecb0, f6a1c9, fee29c, 8be6ff, c7d0e9, 94efe3, bfbfbf, 3f3f3f, 007dea, 8d9baf, b2e389, f272af, fed46b, 51d9ff, aab8de, 5fe7d5, a5a5a5, 262626, 003e75, 3a4453, 5ea226, af0f5b, c58c00, 0081a5, 425ea9, 138677, 7f7f7f, 0c0c0c, 00192e, 272d37, 3f6c19, 750a3d, 835d00, 00566e, 2c3f71, 0c594f',\n        columns: 10\n    },\n    flow: {\n        colors: 'ffffff, 000000, dbf5f9, 04617b, 0f6fc6, 009dd9, 0bd0d9, 10cf9b, 7cca62, a5c249, f2f2f2, 7f7f7f, b2e9f2, b4ecfc, c7e2fa, c4eeff, c9fafc, c9faed, e4f4df, edf2da, d8d8d8, 595959, 76d9e8, 6adafa, 90c6f6, 89deff, 93f5f9, 94f6db, cae9c0, dbe6b6, bfbfbf, 3f3f3f, 21b2c8, 20c8f7, 59a9f2, 4fceff, 5df0f6, 5ff2ca, b0dfa0, c9da91, a5a5a5, 262626, 105964, 02485c, 0b5394, 0075a2, 089ca2, 0b9b74, 54a838, 7e9532, 7f7f7f, 0c0c0c, 062328, 01303d, 073763, 004e6c, 05686c, 07674d, 387025, 546321',\n        columns: 10\n    },\n    hardcover: {\n        colors: 'ffffff, 000000, ece9c6, 895d1d, 873624, d6862d, d0be40, 877f6c, 972109, aeb795, f2f2f2, 7f7f7f, e1dca5, f2e0c6, f0d0c9, f6e6d5, f5f2d8, e7e5e1, fbc7bc, eef0e9, d8d8d8, 595959, d0c974, e6c28d, e2a293, eeceaa, ece5b2, cfccc3, f78f7a, dee2d4, bfbfbf, 3f3f3f, a29a36, daa454, d4735e, e6b681, e2d88c, b7b2a5, f35838, ced3bf, a5a5a5, 262626, 514d1b, 664515, 65281a, a2641f, a39428, 655f50, 711806, 879464, 7f7f7f, 0c0c0c, 201e0a, 442e0e, 431b11, 6c4315, 6d621a, 433f35, 4b1004, 5a6243',\n        columns: 10\n    },\n    trek: {\n        colors: 'ffffff, 000000, fbeec9, 4e3b30, f0a22e, a5644e, b58b80, c3986d, a19574, c17529, f2f2f2, 7f7f7f, f7e09e, e1d6cf, fcecd5, eddfda, f0e7e5, f3eae1, ece9e3, f5e3d1, d8d8d8, 595959, f3cc5f, c4ad9f, f9d9ab, dcc0b6, e1d0cc, e7d5c4, d9d4c7, ebc7a3, bfbfbf, 3f3f3f, d29f0f, a78470, f6c781, cba092, d2b9b2, dbc1a7, c6bfab, e1ac76, a5a5a5, 262626, 694f07, 3a2c24, c87d0e, 7b4b3a, 926255, a17242, 7b7153, 90571e, 7f7f7f, 0c0c0c, 2a1f03, 271d18, 855309, 523226, 614138, 6b4c2c, 524b37, 603a14',\n        columns: 10\n    },\n    verve: {\n        colors: 'ffffff, 000000, d2d2d2, 666666, ff388c, e40059, 9c007f, 68007f, 005bd3, 00349e, f2f2f2, 7f7f7f, bdbdbd, e0e0e0, ffd7e8, ffc6dc, ffb8f1, f1b2ff, c3dcff, b8cfff, d8d8d8, 595959, 9d9d9d, c1c1c1, ffafd1, ff8eba, ff71e4, e365ff, 87baff, 72a0ff, bfbfbf, 3f3f3f, 696969, a3a3a3, ff87ba, ff5597, ff2ad7, d519ff, 4b98ff, 2b71ff, a5a5a5, 262626, 343434, 4c4c4c, e90062, ab0042, 75005f, 4e005f, 00449e, 002676, 7f7f7f, 0c0c0c, 151515, 333333, 9b0041, 72002c, 4e003f, 34003f, 002d69, 00194f',\n        columns: 10\n    },\n    monochrome: {\n        colors: '000000, 1a1a1a, 333333, 4d4d4d, 666666, 808080, 999999, b3b3b3, cccccc, e6e6e6, f2f2f2, ffffff',\n        columns: 12\n    },\n    accessible: {\n        colors: 'black, grey, darkred, red, darkorange, gold, green, blue, darkblue, purple, white, darkgrey, saddlebrown, pink, orange, yellow, lightgreen, lightskyblue, lightblue, mediumpurple',\n        columns: 10\n    }\n};\n\nvar DEFAULT_PRESET = 'office';\nvar DEFAULT_ACCESSIBLE_PRESET = 'accessible';\n/**\n * Represents the [Kendo UI ColorPicker component for Angular]({% slug overview_colorpicker %}).\n * Designed to replace the `<input type=\"color\">` HTML5 tag which is not widely supported in browsers.\n */\nvar ColorPickerComponent = /** @class */ (function () {\n    function ColorPickerComponent(popupService, localizationService) {\n        var _this = this;\n        this.popupService = popupService;\n        /**\n         * @hidden\n         */\n        this.hostClasses = true;\n        /**\n         * Sets what view the ColorPicker will render in the popup.\n         */\n        this.view = 'gradient';\n        /**\n         * Sets the read-only state of the ColorPicker.\n         */\n        this.readonly = false;\n        /**\n         * Sets the disabled state of the ColorPicker.\n         */\n        this.disabled = false;\n        /**\n         * Specifies the output format of the ColorPicker.\n         * The input value may be in a different format. However, it will be parsed into the output `format`\n         * after the component processes it.\n         *\n         * If the `gradient` view is used with the `opacity` option set to true, this setting will be ignored and `rgba` will be used instead.\n         *\n         * The supported values are:\n         * * `rgba` (default)\n         * * `hex`\n         * * [`name`](https://www.w3.org/wiki/CSS/Properties/color/keywords)\n         */\n        this.format = 'rgba';\n        /**\n         * Fires each time the value is changed.\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * Fires each time the popup is about to open.\n         * This event is preventable. If you cancel it, the popup will remain closed.\n         */\n        this.open = new EventEmitter();\n        /**\n         * Fires each time the popup is about to close.\n         * This event is preventable. If you cancel it, the popup will remain open.\n         */\n        this.close = new EventEmitter();\n        /**\n         * Fires each time ColorPicker is focused.\n         */\n        this.onFocus = new EventEmitter();\n        /**\n         * Fires each time the ColorPicker is blurred.\n         */\n        this.onBlur = new EventEmitter();\n        /**\n         * Fires each time the left side of the ColorPicker wrapper is clicked.\n         * The event is triggered regardless of whether a ColorPicker icon is set or not.\n         *\n         * The [`ActiveColorClickEvent`]({% slug api_inputs_activecolorclickevent %}) event provides the option to prevent the popup opening.\n         */\n        this.activeColorClick = new EventEmitter();\n        this._tabindex = 0;\n        this._popupSettings = { animate: true };\n        this._paletteSettings = {};\n        this._gradientSettings = { opacity: true, clearButton: false };\n        this.notifyNgTouched = function () { };\n        this.notifyNgChanged = function () { };\n        this.dynamicRTLSubscription = localizationService.changes.subscribe(function (_a) {\n            var rtl = _a.rtl;\n            _this.direction = rtl ? 'rtl' : 'ltr';\n        });\n    }\n    Object.defineProperty(ColorPickerComponent.prototype, \"value\", {\n        get: function () {\n            return this._value;\n        },\n        /**\n         * Specifies the value of the initially selected color.\n         */\n        set: function (value) {\n            this._value = parseColor$1(value, this.format);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ColorPickerComponent.prototype, \"popupSettings\", {\n        get: function () {\n            return this._popupSettings;\n        },\n        /**\n         * Configures the popup of the ColorPicker.\n         */\n        set: function (value) {\n            this._popupSettings = Object.assign(this._popupSettings, value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ColorPickerComponent.prototype, \"paletteSettings\", {\n        get: function () {\n            return this._paletteSettings;\n        },\n        /**\n         * Configures the palette that is displayed in the ColorPicker popup.\n         */\n        set: function (value) {\n            this._paletteSettings = Object.assign(this._paletteSettings, value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ColorPickerComponent.prototype, \"gradientSettings\", {\n        get: function () {\n            return this._gradientSettings;\n        },\n        /**\n         * Configures the gradient that is displayed in the ColorPicker popup.\n         */\n        set: function (value) {\n            this._gradientSettings = Object.assign(this._gradientSettings, value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ColorPickerComponent.prototype, \"tabindex\", {\n        get: function () {\n            return !this.disabled ? this._tabindex : undefined;\n        },\n        /**\n         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n         */\n        set: function (value) {\n            var tabindex = Number(value);\n            var defaultValue = 0;\n            this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ColorPickerComponent.prototype, \"isOpen\", {\n        /**\n         * Indicates whether the ColorPicker popup is open.\n         */\n        get: function () {\n            return isPresent(this.popupRef);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ColorPickerComponent.prototype, \"iconStyles\", {\n        /**\n         * @hidden\n         */\n        get: function () {\n            if (this.iconClass) {\n                return this.iconClass;\n            }\n            if (this.icon) {\n                return \"k-icon k-i-\" + this.icon;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ColorPickerComponent.prototype.ngOnInit = function () {\n        var defaultPreset = (this.format !== 'name') ? DEFAULT_PRESET : DEFAULT_ACCESSIBLE_PRESET;\n        var settingsPalette = this._paletteSettings.palette;\n        var presetColumns = typeof settingsPalette === 'string' && PALETTEPRESETS[settingsPalette] ?\n            PALETTEPRESETS[settingsPalette].columns :\n            undefined;\n        this._paletteSettings = {\n            palette: settingsPalette || defaultPreset,\n            tileSize: this._paletteSettings.tileSize || 24,\n            columns: this._paletteSettings.columns || presetColumns || 10\n        };\n    };\n    ColorPickerComponent.prototype.ngOnChanges = function (changes) {\n        if (changes.format && changes.format.currentValue === 'name') {\n            this.view = 'palette';\n        }\n        if (this.view === 'gradient' && this.gradientSettings.opacity) {\n            this.format = 'rgba';\n            this.value = parseColor$1(this.value, this.format);\n        }\n    };\n    ColorPickerComponent.prototype.ngOnDestroy = function () {\n        this.closePopup();\n        if (this.dynamicRTLSubscription) {\n            this.dynamicRTLSubscription.unsubscribe();\n        }\n    };\n    /**\n     * @hidden\n     */\n    ColorPickerComponent.prototype.handleWrapperClick = function () {\n        this.toggleWithEvents(!this.isOpen);\n        this.focus();\n    };\n    /**\n     * @hidden\n     */\n    ColorPickerComponent.prototype.handleActiveColorClick = function () {\n        this.focus();\n        var event = new ActiveColorClickEvent(this.value);\n        this.activeColorClick.emit(event);\n        if (!event.isOpenPrevented() || this.isOpen) {\n            this.handleWrapperClick();\n        }\n    };\n    /**\n     * Focuses the wrapper of the ColorPicker.\n     */\n    ColorPickerComponent.prototype.focus = function () {\n        if (this.disabled) {\n            return;\n        }\n        this.wrapper.nativeElement.focus();\n    };\n    /**\n     * @hidden\n     */\n    ColorPickerComponent.prototype.handleWrapperFocus = function () {\n        if (isPresent(this.palette)) {\n            this.palette.nativeElement.focus();\n        }\n        if (this.isFocused) {\n            return;\n        }\n        this.isFocused = true;\n        this.onFocus.emit();\n    };\n    /**\n     * Blurs the ColorPicker.\n     */\n    ColorPickerComponent.prototype.blur = function () {\n        this.wrapper.nativeElement.blur();\n    };\n    /**\n     * @hidden\n     */\n    ColorPickerComponent.prototype.handleWrapperBlur = function () {\n        if (this.isOpen) {\n            return;\n        }\n        this.isFocused = false;\n        this.onBlur.emit();\n        this.notifyNgTouched();\n    };\n    /**\n     * Clears the color value of the ColorPicker.\n     */\n    ColorPickerComponent.prototype.reset = function () {\n        if (!isPresent(this.value)) {\n            return;\n        }\n        this._value = undefined;\n        this.notifyNgChanged(undefined);\n    };\n    /**\n     * Toggles the popup of the ColorPicker.\n     * Does not trigger the `open` and `close` events of the component.\n     *\n     * @param open An optional parameter. Specifies whether the popup will be opened or closed.\n     */\n    ColorPickerComponent.prototype.toggle = function (open) {\n        if (this.disabled || this.readonly) {\n            return;\n        }\n        this.closePopup();\n        open = isPresent(open) ? open : !this.isOpen;\n        if (open) {\n            this.openPopup();\n        }\n    };\n    /**\n     * @hidden\n     */\n    ColorPickerComponent.prototype.handleValueChange = function (color, closePopup) {\n        var parsedColor = parseColor$1(color, this.format);\n        var valueChange = parsedColor !== this.value;\n        if (closePopup) {\n            this.toggleWithEvents(false);\n            this.focus();\n        }\n        if (valueChange) {\n            this.value = parsedColor;\n            this.valueChange.emit(parsedColor);\n            this.notifyNgChanged(parsedColor);\n        }\n    };\n    /**\n     * @hidden\n     */\n    ColorPickerComponent.prototype.handlePopupBlur = function (event) {\n        var focusInPopupElement = this.popupRef.popupElement.contains(event.relatedTarget);\n        var wrapperClicked = event.relatedTarget === this.wrapper.nativeElement;\n        if (!this.isFocused || wrapperClicked || focusInPopupElement) {\n            return;\n        }\n        this.isFocused = false;\n        this.onBlur.emit();\n        this.notifyNgTouched();\n        this.toggleWithEvents(false);\n    };\n    /**\n     * @hidden\n     */\n    ColorPickerComponent.prototype.writeValue = function (value) {\n        this.value = value;\n    };\n    /**\n     * @hidden\n     */\n    ColorPickerComponent.prototype.registerOnChange = function (fn) {\n        this.notifyNgChanged = fn;\n    };\n    /**\n     * @hidden\n     */\n    ColorPickerComponent.prototype.registerOnTouched = function (fn) {\n        this.notifyNgTouched = fn;\n    };\n    /**\n     * @hidden\n     */\n    ColorPickerComponent.prototype.setDisabledState = function (isDisabled) {\n        this.disabled = isDisabled;\n    };\n    /**\n     * @hidden\n     */\n    ColorPickerComponent.prototype.handleWrapperKeyDown = function (event) {\n        if (event.keyCode === Keys.ArrowDown || event.keyCode === Keys.Enter) {\n            event.preventDefault();\n            this.toggleWithEvents(true);\n        }\n    };\n    /**\n     * @hidden\n     */\n    ColorPickerComponent.prototype.handlePopupKeyDown = function (keyCode) {\n        if (keyCode === Keys.Tab || keyCode === Keys.Escape) {\n            this.toggleWithEvents(false);\n            this.wrapper.nativeElement.focus();\n        }\n    };\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the component is empty.\n     */\n    ColorPickerComponent.prototype.isEmpty = function () {\n        return false;\n    };\n    ColorPickerComponent.prototype.toggleWithEvents = function (open) {\n        var sameState = this.isOpen === open;\n        if (this.disabled || this.readonly || sameState) {\n            return;\n        }\n        var eventArgs = new PreventableEvent();\n        open ? this.open.emit(eventArgs) : this.close.emit(eventArgs);\n        if (!eventArgs.isDefaultPrevented()) {\n            this.toggle(open);\n        }\n    };\n    ColorPickerComponent.prototype.openPopup = function () {\n        var _this = this;\n        var horizontalAlign = this.direction === \"rtl\" ? \"right\" : \"left\";\n        var anchorPosition = { horizontal: horizontalAlign, vertical: \"bottom\" };\n        var popupPosition = { horizontal: horizontalAlign, vertical: \"top\" };\n        this.popupRef = this.popupService.open({\n            anchor: this.wrapper,\n            animate: this.popupSettings.animate,\n            appendTo: this.popupSettings.appendTo,\n            popupAlign: popupPosition,\n            anchorAlign: anchorPosition,\n            popupClass: 'k-colorpicker-popup',\n            content: this.popupTemplate,\n            positionMode: 'absolute'\n        });\n        this.popupRef.popupAnchorViewportLeave.subscribe(function () {\n            _this.toggleWithEvents(false);\n            if (!_this.isOpen) {\n                _this.wrapper.nativeElement.focus({\n                    preventScroll: true\n                });\n            }\n        });\n    };\n    ColorPickerComponent.prototype.closePopup = function () {\n        if (!this.isOpen) {\n            return;\n        }\n        this.popupRef.close();\n        this.popupRef = null;\n        this.palette = null;\n    };\n    ColorPickerComponent.decorators = [\n        { type: Component, args: [{\n                    selector: 'kendo-colorpicker',\n                    providers: [{\n                            multi: true,\n                            provide: NG_VALUE_ACCESSOR,\n                            useExisting: forwardRef(function () { return ColorPickerComponent; })\n                        }, {\n                            provide: KendoInput,\n                            useExisting: forwardRef(function () { return ColorPickerComponent; })\n                        },\n                        LocalizationService,\n                        {\n                            provide: L10N_PREFIX,\n                            useValue: 'kendo.colorpicker'\n                        }\n                    ],\n                    template: \"\\n        <span\\n            #wrapper\\n            [ngClass]=\\\"{\\n                'k-picker-wrap': true,\\n                'k-state-default': !this.disabled,\\n                'k-state-disabled': this.disabled,\\n                'k-state-focused': this.isFocused\\n            }\\\"\\n            [attr.tabindex]=\\\"tabindex\\\"\\n            (focus)=\\\"handleWrapperFocus()\\\"\\n            (blur)=\\\"handleWrapperBlur()\\\"\\n            (mousedown)=\\\"$event.preventDefault()\\\"\\n            (keydown)=\\\"handleWrapperKeyDown($event)\\\"\\n        >\\n            <span *ngIf=\\\"!iconStyles\\\" class=\\\"k-selected-color\\\" [style.background-color]=\\\"value\\\" (click)=\\\"handleActiveColorClick()\\\">\\n                <span class=\\\"k-icon k-i-line\\\" *ngIf=\\\"!value\\\"></span>\\n            </span>\\n            <span *ngIf=\\\"iconStyles\\\" class=\\\"k-tool-icon\\\" [ngClass]=\\\"iconStyles\\\" (click)=\\\"handleActiveColorClick()\\\">\\n                <span class=\\\"k-selected-color\\\" [style.background-color]=\\\"value\\\"></span>\\n            </span>\\n            <span class=\\\"k-select\\\" (click)=\\\"handleWrapperClick()\\\">\\n                <span class=\\\"k-icon k-i-arrow-s\\\"></span>\\n            </span>\\n        </span>\\n        <ng-template #popupTemplate>\\n            <kendo-colorgradient\\n                *ngIf=\\\"view === 'gradient' || view === 'combo'\\\"\\n                kendoFocusOnDomReady\\n                [value]=\\\"value\\\"\\n                [format]=\\\"format\\\"\\n                [opacity]=\\\"gradientSettings.opacity\\\"\\n                [clearButton]=\\\"gradientSettings.clearButton\\\"\\n                (focusout)=\\\"handlePopupBlur($event)\\\"\\n                (valueChange)=\\\"handleValueChange($event, false)\\\"\\n                (keydown)=\\\"handlePopupKeyDown($event.keyCode)\\\"\\n            >\\n            </kendo-colorgradient>\\n            <kendo-colorpalette\\n                #palette\\n                *ngIf=\\\"view === 'palette' || view === 'combo'\\\"\\n                kendoFocusOnDomReady\\n                [palette]=\\\"paletteSettings.palette\\\"\\n                [columns]=\\\"paletteSettings.columns\\\"\\n                [tileSize]=\\\"paletteSettings.tileSize\\\"\\n                [format]=\\\"format\\\"\\n                [value]=\\\"value\\\"\\n                (blur)=\\\"handlePopupBlur($event)\\\"\\n                (cellSelection)=\\\"handleValueChange($event, true)\\\"\\n                (mousedown)=\\\"$event.preventDefault()\\\"\\n                (keydown)=\\\"handlePopupKeyDown($event.keyCode)\\\"\\n            >\\n            </kendo-colorpalette>\\n        </ng-template>\\n        <ng-container #container></ng-container>\\n    \"\n                },] },\n    ];\n    /** @nocollapse */\n    ColorPickerComponent.ctorParameters = function () { return [\n        { type: PopupService },\n        { type: LocalizationService }\n    ]; };\n    ColorPickerComponent.propDecorators = {\n        hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-colorpicker',] }],\n        direction: [{ type: HostBinding, args: ['attr.dir',] }],\n        view: [{ type: Input }],\n        readonly: [{ type: Input }],\n        disabled: [{ type: Input }],\n        format: [{ type: Input }],\n        value: [{ type: Input }],\n        popupSettings: [{ type: Input }],\n        paletteSettings: [{ type: Input }],\n        gradientSettings: [{ type: Input }],\n        icon: [{ type: Input }],\n        iconClass: [{ type: Input }],\n        tabindex: [{ type: Input }],\n        valueChange: [{ type: Output }],\n        open: [{ type: Output }],\n        close: [{ type: Output }],\n        onFocus: [{ type: Output, args: ['focus',] }],\n        onBlur: [{ type: Output, args: ['blur',] }],\n        activeColorClick: [{ type: Output }],\n        container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef },] }],\n        wrapper: [{ type: ViewChild, args: ['wrapper',] }],\n        popupTemplate: [{ type: ViewChild, args: ['popupTemplate',] }],\n        palette: [{ type: ViewChild, args: ['palette', { read: ElementRef },] }]\n    };\n    return ColorPickerComponent;\n}());\n\n/**\n * @hidden\n */\nvar ColorPaletteService = /** @class */ (function () {\n    function ColorPaletteService() {\n        this.colorRows = [];\n    }\n    ColorPaletteService.prototype.setColorMatrix = function (palette, columns) {\n        this.colorRows = [];\n        if (!(isPresent(palette) && palette.length)) {\n            return;\n        }\n        columns = columns || palette.length;\n        for (var start = 0; start < palette.length; start += columns) {\n            var row = palette.slice(start, columns + start);\n            this.colorRows.push(row);\n        }\n    };\n    ColorPaletteService.prototype.getCellCoordsFor = function (color) {\n        if (!isPresent(color)) {\n            return;\n        }\n        for (var row = 0; row < this.colorRows.length; row++) {\n            for (var col = 0; col < this.colorRows[row].length; col++) {\n                if (this.colorRows[row][col] === color) {\n                    return { row: row, col: col };\n                }\n            }\n        }\n    };\n    ColorPaletteService.prototype.getColorAt = function (cellCoords) {\n        if (!(isPresent(cellCoords) && isPresent(this.colorRows[cellCoords.row]))) {\n            return;\n        }\n        return this.colorRows[cellCoords.row][cellCoords.col];\n    };\n    ColorPaletteService.prototype.getNextCell = function (current, horizontalStep, verticalStep) {\n        if (!(isPresent(current) && isPresent(current.row) && isPresent(current.col))) {\n            return { row: 0, col: 0 };\n        }\n        var row = this.clampIndex(current.row + verticalStep, this.colorRows.length - 1);\n        var col = this.clampIndex(current.col + horizontalStep, this.colorRows[row].length - 1);\n        return { row: row, col: col };\n    };\n    ColorPaletteService.prototype.clampIndex = function (index, max) {\n        var minArrayIndex = 0;\n        if (index < minArrayIndex) {\n            return minArrayIndex;\n        }\n        if (index > max) {\n            return max;\n        }\n        return index;\n    };\n    ColorPaletteService.decorators = [\n        { type: Injectable },\n    ];\n    return ColorPaletteService;\n}());\n\nvar DEFAULT_TILE_SIZE = 24;\nvar DEFAULT_COLUMNS_COUNT = 10;\nvar DEFAULT_PRESET$1 = 'office';\nvar DEFAULT_ACCESSIBLE_PRESET$1 = 'accessible';\n/**\n * The ColorPalette component provides a set of predefined palette presets and enables you to implement a custom color palette.\n * The ColorPalette is independently used by `kendo-colorpicker` and can be directly added to the page.\n */\nvar ColorPaletteComponent = /** @class */ (function () {\n    function ColorPaletteComponent(service, localizationService) {\n        var _this = this;\n        this.service = service;\n        /**\n         * Specifies the output format of the ColorPaletteComponent.\n         * The input value may be in a different format. However, it will be parsed into the output `format`\n         * after the component processes it.\n         *\n         * The supported values are:\n         * * (Default) `hex`\n         * * `rgba`\n         * * `name`\n         */\n        this.format = 'hex';\n        /**\n         * Specifies the size of a color cell.\n         *\n         * The possible values are:\n         * * (Default) `tileSize = 24`\n         * * `{ width: number, height: number }`\n         */\n        this.tileSize = { width: DEFAULT_TILE_SIZE, height: DEFAULT_TILE_SIZE };\n        /**\n         * Fires each time the color selection is changed.\n         */\n        this.selectionChange = new EventEmitter();\n        /**\n         * Fires each time the value is changed.\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * Fires each time the user selects a cell with the mouse or presses `Enter`.\n         *\n         * @hidden\n         */\n        this.cellSelection = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.hostClasses = true;\n        this._tabindex = 0;\n        this.notifyNgTouched = function () { };\n        this.notifyNgChanged = function () { };\n        this.dynamicRTLSubscription = localizationService.changes.subscribe(function (_a) {\n            var rtl = _a.rtl;\n            _this.direction = rtl ? 'rtl' : 'ltr';\n        });\n    }\n    Object.defineProperty(ColorPaletteComponent.prototype, \"value\", {\n        get: function () {\n            return this._value;\n        },\n        /**\n         * Specifies the value of the initially selected color.\n         */\n        set: function (value) {\n            this._value = parseColor$1(value, this.format);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ColorPaletteComponent.prototype, \"columns\", {\n        get: function () {\n            return this._columns;\n        },\n        /**\n         * Specifies the number of columns that will be displayed.\n         * Defaults to `10`.\n         */\n        set: function (value) {\n            var minColumnsCount = 1;\n            this._columns = value > minColumnsCount ? value : minColumnsCount;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ColorPaletteComponent.prototype, \"palette\", {\n        get: function () {\n            return this._palette;\n        },\n        /**\n         * The color palette that will be displayed.\n         *\n         * The supported values are:\n         * * The name of the predefined palette preset (for example, `office`, `basic`, and `apex`).\n         * * A string with comma-separated colors.\n         * * A string array.\n         */\n        set: function (value) {\n            var _this = this;\n            if (!isPresent(value)) {\n                value = DEFAULT_PRESET$1;\n            }\n            if (typeof value === 'string' && isPresent(PALETTEPRESETS[value])) {\n                this.columns = this.columns || PALETTEPRESETS[value].columns;\n                value = PALETTEPRESETS[value].colors;\n            }\n            var colors = (typeof value === 'string') ? value.split(',') : value;\n            this._palette = colors.map(function (color) { return parseColor$1(color, _this.format, false); });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ColorPaletteComponent.prototype, \"tabindex\", {\n        get: function () {\n            return !this.disabled ? this._tabindex : undefined;\n        },\n        /**\n         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n         */\n        set: function (value) {\n            var tabindex = Number(value);\n            var defaultValue = 0;\n            this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ColorPaletteComponent.prototype, \"tileLayout\", {\n        /**\n         * @hidden\n         */\n        get: function () {\n            if (typeof this.tileSize !== 'number') {\n                return this.tileSize;\n            }\n            return { width: this.tileSize, height: this.tileSize };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ColorPaletteComponent.prototype, \"colorRows\", {\n        /**\n         * @hidden\n         */\n        get: function () {\n            return this.service.colorRows;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ColorPaletteComponent.prototype, \"hostTabindex\", {\n        /**\n         * @hidden\n         */\n        get: function () { return this.tabindex; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ColorPaletteComponent.prototype, \"disabledClass\", {\n        /**\n         * @hidden\n         */\n        get: function () { return this.disabled; },\n        enumerable: true,\n        configurable: true\n    });\n    ColorPaletteComponent.prototype.ngOnInit = function () {\n        if (this.colorRows.length === 0) {\n            var defaultPreset = (this.format !== 'name') ? DEFAULT_PRESET$1 : DEFAULT_ACCESSIBLE_PRESET$1;\n            this.palette = this.palette || defaultPreset;\n            this.setRows();\n            this.focusedCell = this.service.getCellCoordsFor(this.value);\n        }\n    };\n    ColorPaletteComponent.prototype.ngOnDestroy = function () {\n        if (this.dynamicRTLSubscription) {\n            this.dynamicRTLSubscription.unsubscribe();\n        }\n    };\n    ColorPaletteComponent.prototype.ngOnChanges = function (changes) {\n        if (changes.palette || changes.columns) {\n            this.setRows();\n        }\n        if (changes.palette || changes.value || changes.columns) {\n            this.focusedCell = this.service.getCellCoordsFor(this.value);\n        }\n    };\n    /**\n     * @hidden\n     */\n    ColorPaletteComponent.prototype.handleKeydown = function (event) {\n        var isRTL = this.direction === 'rtl';\n        switch (event.keyCode) {\n            case Keys.ArrowDown:\n                this.handleCellNavigation(0, 1);\n                break;\n            case Keys.ArrowUp:\n                this.handleCellNavigation(0, -1);\n                break;\n            case Keys.ArrowRight:\n                this.handleCellNavigation(isRTL ? -1 : 1, 0);\n                break;\n            case Keys.ArrowLeft:\n                this.handleCellNavigation(isRTL ? 1 : -1, 0);\n                break;\n            case Keys.Enter:\n                this.handleEnter();\n                break;\n            default: return;\n        }\n        event.preventDefault();\n    };\n    /**\n     * @hidden\n     */\n    ColorPaletteComponent.prototype.handleHostBlur = function () {\n        this.notifyNgTouched();\n    };\n    /**\n     * @hidden\n     */\n    ColorPaletteComponent.prototype.handleCellSelection = function (value, focusedCell) {\n        if (this.readonly) {\n            return;\n        }\n        this.focusedCell = focusedCell;\n        var parsedColor = parseColor$1(value, this.format, false);\n        this.cellSelection.emit(parsedColor);\n        if (this.value !== parsedColor) {\n            this.value = parsedColor;\n            this.valueChange.emit(parsedColor);\n            this.notifyNgChanged(parsedColor);\n        }\n        if (this.selection !== parsedColor) {\n            this.selection = parsedColor;\n            this.selectionChange.emit(parsedColor);\n        }\n    };\n    /**\n     * @hidden\n     */\n    ColorPaletteComponent.prototype.writeValue = function (value) {\n        this.value = value;\n        this.focusedCell = this.service.getCellCoordsFor(this.value);\n    };\n    /**\n     * @hidden\n     */\n    ColorPaletteComponent.prototype.registerOnChange = function (fn) {\n        this.notifyNgChanged = fn;\n    };\n    /**\n     * @hidden\n     */\n    ColorPaletteComponent.prototype.registerOnTouched = function (fn) {\n        this.notifyNgTouched = fn;\n    };\n    /**\n     * @hidden\n     */\n    ColorPaletteComponent.prototype.setDisabledState = function (isDisabled) {\n        this.disabled = isDisabled;\n    };\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the component is empty.\n     */\n    ColorPaletteComponent.prototype.isEmpty = function () {\n        return false;\n    };\n    /**\n     * Clears the color value of the ColorPalette.\n     */\n    ColorPaletteComponent.prototype.reset = function () {\n        this.focusedCell = null;\n        if (isPresent(this.value)) {\n            this._value = undefined;\n            this.notifyNgChanged(undefined);\n        }\n    };\n    ColorPaletteComponent.prototype.setRows = function () {\n        if (!isPresent(this.palette)) {\n            return;\n        }\n        this.columns = this.columns || DEFAULT_COLUMNS_COUNT;\n        this.service.setColorMatrix(this.palette, this.columns);\n    };\n    ColorPaletteComponent.prototype.handleCellNavigation = function (horizontalStep, verticalStep) {\n        if (this.readonly) {\n            return;\n        }\n        this.focusedCell = this.service.getNextCell(this.focusedCell, horizontalStep, verticalStep);\n        var selection = this.service.getColorAt(this.focusedCell);\n        if (this.selection !== selection) {\n            this.selection = selection;\n            this.selectionChange.emit(selection);\n        }\n    };\n    ColorPaletteComponent.prototype.handleEnter = function () {\n        if (!isPresent(this.focusedCell)) {\n            return;\n        }\n        var selectedColor = this.service.getColorAt(this.focusedCell);\n        this.handleCellSelection(selectedColor, this.focusedCell);\n    };\n    ColorPaletteComponent.decorators = [\n        { type: Component, args: [{\n                    selector: 'kendo-colorpalette',\n                    providers: [\n                        {\n                            multi: true,\n                            provide: NG_VALUE_ACCESSOR,\n                            useExisting: forwardRef(function () { return ColorPaletteComponent; }) // tslint:disable-line:no-forward-ref\n                        }, {\n                            provide: KendoInput,\n                            useExisting: forwardRef(function () { return ColorPaletteComponent; })\n                        },\n                        ColorPaletteService,\n                        LocalizationService,\n                        {\n                            provide: L10N_PREFIX,\n                            useValue: 'kendo.colorpalette'\n                        }\n                    ],\n                    template: \"\\n        <div role=\\\"grid\\\">\\n            <table class=\\\"k-palette k-reset\\\" role=\\\"presentation\\\">\\n                <tbody>\\n                    <tr role=\\\"row\\\" *ngFor=\\\"let row of colorRows; let rowIndex = index\\\">\\n                        <td *ngFor=\\\"let color of row; let colIndex = index\\\"\\n                            [class.k-state-selected]=\\\"focusedCell?.row === rowIndex && focusedCell?.col === colIndex\\\"\\n                            class=\\\"k-item\\\"\\n                            [attr.value]=\\\"color\\\"\\n                            (click)=\\\"handleCellSelection(color, { row: rowIndex, col: colIndex })\\\"\\n                            [ngStyle]=\\\"{\\n                                backgroundColor: color,\\n                                width: tileLayout.width + 'px',\\n                                height: tileLayout.height + 'px',\\n                                minWidth: tileLayout.width + 'px'\\n                            }\\\">\\n                        </td>\\n                    </tr>\\n                </tbody>\\n            </table>\\n        </div>\\n    \"\n                },] },\n    ];\n    /** @nocollapse */\n    ColorPaletteComponent.ctorParameters = function () { return [\n        { type: ColorPaletteService },\n        { type: LocalizationService }\n    ]; };\n    ColorPaletteComponent.propDecorators = {\n        direction: [{ type: HostBinding, args: ['attr.dir',] }],\n        format: [{ type: Input }],\n        value: [{ type: Input }],\n        columns: [{ type: Input }],\n        palette: [{ type: Input }],\n        tabindex: [{ type: Input }],\n        disabled: [{ type: Input }],\n        readonly: [{ type: Input }],\n        tileSize: [{ type: Input }],\n        selectionChange: [{ type: Output }],\n        valueChange: [{ type: Output }],\n        cellSelection: [{ type: Output }],\n        hostTabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],\n        hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-colorpalette',] }],\n        disabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }],\n        handleKeydown: [{ type: HostListener, args: ['keydown', ['$event'],] }],\n        handleHostBlur: [{ type: HostListener, args: ['blur',] }]\n    };\n    return ColorPaletteComponent;\n}());\n\nvar DEFAULT_OUTPUT_FORMAT = 'rgba';\nvar DEFAULT_BACKGROUND_COLOR = 'rgba(255, 0, 0, 1)';\n/**\n * The ColorGradient component enables smooth color transitions and provides options for selecting specific colors over the drag handle.\n * The ColorGradient is independently used by `kendo-colorpicker` and can be directly added to the page.\n */\nvar ColorGradientComponent = /** @class */ (function () {\n    function ColorGradientComponent(host, ngZone, renderer, cdr, localizationService) {\n        var _this = this;\n        this.host = host;\n        this.ngZone = ngZone;\n        this.renderer = renderer;\n        this.cdr = cdr;\n        this.hostClasses = true;\n        /**\n         * Defines whether the alpha slider will be displayed.\n         */\n        this.opacity = true;\n        /**\n         * Sets the disabled state of the ColorGradient.\n         */\n        this.disabled = false;\n        /**\n         * Sets the read-only state of the ColorGradient.\n         */\n        this.readonly = false;\n        /**\n         * Specifies whether the ColorGradient should display a 'Clear color' button.\n         */\n        this.clearButton = false;\n        /**\n         * Fires each time the user selects a new color.\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.backgroundColor = DEFAULT_BACKGROUND_COLOR;\n        /**\n         * @hidden\n         *\n         * Represents the currently selected `hue`, `saturation`, `value`, and `alpha` values.\n         * The values are initially set in `ngOnInit` or in `ngOnChanges` and are\n         * updated on moving the drag handle or the sliders.\n         */\n        this.hsva = {};\n        /**\n         * Specifies the output format of the ColorGradientComponent.\n         * The input value may be in a different format. However, it will be parsed into the output `format`\n         * after the component processes it.\n         *\n         * The supported values are:\n         * * (Default) `rgba`\n         * * `hex`\n         */\n        this.format = DEFAULT_OUTPUT_FORMAT;\n        this._tabindex = 0;\n        this.listeners = [];\n        this.notifyNgChanged = function () { };\n        this.notifyNgTouched = function () { };\n        this.dynamicRTLSubscription = localizationService.changes.subscribe(function (_a) {\n            var rtl = _a.rtl;\n            _this.direction = rtl ? 'rtl' : 'ltr';\n        });\n    }\n    Object.defineProperty(ColorGradientComponent.prototype, \"disabledClass\", {\n        get: function () {\n            return this.disabled;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ColorGradientComponent.prototype, \"hostTabindex\", {\n        get: function () {\n            return this.tabindex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ColorGradientComponent.prototype, \"value\", {\n        get: function () {\n            return this._value;\n        },\n        /**\n         * Specifies the value of the initially selected color.\n         */\n        set: function (value) {\n            this._value = parseColor$1(value, this.format);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ColorGradientComponent.prototype, \"tabindex\", {\n        get: function () {\n            return !this.disabled ? this._tabindex : undefined;\n        },\n        /**\n         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n         */\n        set: function (value) {\n            var tabindex = Number(value);\n            var defaultValue = 0;\n            this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ColorGradientComponent.prototype, \"isFocused\", {\n        /**\n         * Indicates whether the ColorGradient or any of its content is focused.\n         */\n        get: function () {\n            if (!(isDocumentAvailable() && isPresent(this.host))) {\n                return false;\n            }\n            return this.host.nativeElement === document.activeElement || this.host.nativeElement.contains(document.activeElement);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ColorGradientComponent.prototype, \"alphaSliderValue\", {\n        /**\n         * @hidden\n         */\n        get: function () {\n            // setting the initial value to undefined to force the slider to recalculate the height of the slider track on the next cdr run\n            if (!(isPresent(this.hsva) && isPresent(this.hsva.a))) {\n                return;\n            }\n            return this.hsva.a * 100;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ColorGradientComponent.prototype, \"gradientRect\", {\n        get: function () {\n            return this.gradientWrapper.nativeElement.getBoundingClientRect();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ColorGradientComponent.prototype.ngAfterViewInit = function () {\n        this.updateUI();\n        this.cdr.detectChanges();\n        this.addEventListeners();\n    };\n    ColorGradientComponent.prototype.ngOnChanges = function (changes) {\n        if (isChanged('value', changes) && !this.isFocused) {\n            this.updateUI();\n        }\n    };\n    ColorGradientComponent.prototype.ngOnDestroy = function () {\n        this.listeners.forEach(function (removeListener) { return removeListener(); });\n        if (this.dynamicRTLSubscription) {\n            this.dynamicRTLSubscription.unsubscribe();\n        }\n    };\n    /**\n     * Focuses the component.\n     */\n    ColorGradientComponent.prototype.focus = function () {\n        if (this.disabled) {\n            return;\n        }\n        this.host.nativeElement.focus();\n    };\n    /**\n     * @hidden\n     */\n    ColorGradientComponent.prototype.reset = function () {\n        this.handleValueChange(undefined);\n        this.updateUI();\n    };\n    /**\n     * @hidden\n     */\n    ColorGradientComponent.prototype.handleDragPress = function (args) {\n        if (this.disabled || this.readonly || !isPresent(args.originalEvent)) {\n            return;\n        }\n        this.focus();\n        args.originalEvent.preventDefault();\n    };\n    /**\n     * @hidden\n     */\n    ColorGradientComponent.prototype.onHandleDrag = function (args) {\n        if (this.disabled || this.readonly) {\n            return;\n        }\n        this.renderer.addClass(this.gradientWrapper.nativeElement, 'k-dragging');\n        this.changePosition(args);\n    };\n    /**\n     * @hidden\n     */\n    ColorGradientComponent.prototype.onHandleRelease = function () {\n        if (this.disabled || this.readonly) {\n            return;\n        }\n        this.renderer.removeClass(this.gradientWrapper.nativeElement, 'k-dragging');\n    };\n    /**\n     * @hidden\n     */\n    ColorGradientComponent.prototype.changePosition = function (position) {\n        var _this = this;\n        if (this.disabled || this.readonly) {\n            return;\n        }\n        this.ngZone.run(function () { return _this.moveDragHandle(position); });\n    };\n    /**\n     * @hidden\n     */\n    ColorGradientComponent.prototype.handleHueSliderChange = function (hue) {\n        this.handleValueChange(getColorFromHSV(this.hsva));\n        this.backgroundColor = getColorFromHue(hue);\n        this.setAlphaSliderBackground(this.backgroundColor);\n    };\n    /**\n     * @hidden\n     */\n    ColorGradientComponent.prototype.handleAlphaSliderChange = function (alpha) {\n        this.hsva.a = alpha / 100;\n        this.handleValueChange(getColorFromHSV(this.hsva));\n    };\n    /**\n     * @hidden\n     */\n    ColorGradientComponent.prototype.handleInputsValueChange = function (color) {\n        var parsed = parseColor$1(color, this.format);\n        if (this.value !== parsed) {\n            this.handleValueChange(parsed);\n            this.updateUI();\n        }\n    };\n    /**\n     * @hidden\n     */\n    ColorGradientComponent.prototype.writeValue = function (value) {\n        this.value = value;\n        if (isPresent(this.gradientWrapper)) {\n            this.updateUI();\n        }\n    };\n    /**\n     * @hidden\n     */\n    ColorGradientComponent.prototype.registerOnChange = function (fn) {\n        this.notifyNgChanged = fn;\n    };\n    /**\n     * @hidden\n     */\n    ColorGradientComponent.prototype.registerOnTouched = function (fn) {\n        this.notifyNgTouched = fn;\n    };\n    /**\n     * @hidden\n     */\n    ColorGradientComponent.prototype.setDisabledState = function (isDisabled) {\n        this.disabled = isDisabled;\n    };\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the component is empty.\n     */\n    ColorGradientComponent.prototype.isEmpty = function () {\n        return false;\n    };\n    ColorGradientComponent.prototype.moveDragHandle = function (position) {\n        var deltaX = position.clientX - this.gradientRect.left;\n        var deltaY = position.clientY - this.gradientRect.top;\n        var top = fitIntoBounds(deltaY, 0, this.gradientRect.height);\n        var left = fitIntoBounds(deltaX, 0, this.gradientRect.width);\n        this.setDragHandleElementPosition(top, left);\n        this.hsva.s = left / this.gradientRect.width;\n        this.hsva.v = 1 - top / this.gradientRect.height;\n        this.handleValueChange(getColorFromHSV(this.hsva));\n        this.setAlphaSliderBackground(getColorFromHSV(__assign({}, this.hsva, { a: 1 })));\n    };\n    ColorGradientComponent.prototype.updateUI = function () {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        this.hsva = this.value ? getHSV(this.value) : { h: 0, s: 0, v: 1, a: 1 };\n        var top = (1 - this.hsva.v) * this.gradientRect.height;\n        var left = this.hsva.s * this.gradientRect.width;\n        this.setDragHandleElementPosition(top, left);\n        this.backgroundColor = getColorFromHue(this.hsva.h);\n        this.setAlphaSliderBackground(this.backgroundColor);\n    };\n    ColorGradientComponent.prototype.handleValueChange = function (color) {\n        if (this.value === color) {\n            return;\n        }\n        this.value = color;\n        this.valueChange.emit(color);\n        this.notifyNgChanged(color);\n    };\n    ColorGradientComponent.prototype.setDragHandleElementPosition = function (top, left) {\n        var dragHandle = this.dragHandle.nativeElement;\n        this.renderer.setStyle(dragHandle, 'top', top + \"px\");\n        this.renderer.setStyle(dragHandle, 'left', left + \"px\");\n    };\n    ColorGradientComponent.prototype.setAlphaSliderBackground = function (backgroundColor) {\n        if (!isPresent(this.alphaSlider)) {\n            return;\n        }\n        var sliderTrack = this.alphaSlider.track.nativeElement;\n        this.renderer.setStyle(sliderTrack, 'background', \"linear-gradient(to top, transparent, \" + backgroundColor + \")\");\n    };\n    ColorGradientComponent.prototype.addEventListeners = function () {\n        var _this = this;\n        this.ngZone.runOutsideAngular(function () {\n            var focusOutListener = _this.renderer.listen(_this.host.nativeElement, 'focusout', function (event) {\n                if (!containsFocus(_this.host.nativeElement, event.relatedTarget) && isUntouched(_this.host)) {\n                    _this.ngZone.run(function () { return _this.notifyNgTouched(); });\n                }\n            });\n            _this.listeners.push(focusOutListener);\n        });\n    };\n    ColorGradientComponent.decorators = [\n        { type: Component, args: [{\n                    selector: 'kendo-colorgradient',\n                    providers: [{\n                            multi: true,\n                            provide: NG_VALUE_ACCESSOR,\n                            useExisting: forwardRef(function () { return ColorGradientComponent; })\n                        }, {\n                            provide: KendoInput,\n                            useExisting: forwardRef(function () { return ColorGradientComponent; })\n                        },\n                        LocalizationService,\n                        {\n                            provide: L10N_PREFIX,\n                            useValue: 'kendo.colorgradient'\n                        }\n                    ],\n                    template: \"\\n        <div class=\\\"k-hbox k-hsv-wrap\\\">\\n            <div class=\\\"k-hsv-rectangle\\\" [style.background-color]=\\\"backgroundColor\\\">\\n                <div\\n                    #gradientWrapper\\n                    kendoDraggable\\n                    class=\\\"k-hsv-gradient\\\"\\n                    (click)=\\\"changePosition($event)\\\"\\n                    (kendoPress)=\\\"handleDragPress($event)\\\"\\n                    (kendoDrag)=\\\"onHandleDrag($event)\\\"\\n                    (kendoRelease)=\\\"onHandleRelease()\\\">\\n                    <div\\n                        #dragHandle\\n                        class=\\\"k-draghandle\\\"\\n                    >\\n                    </div>\\n                </div>\\n            </div>\\n            <div class=\\\"k-hbox k-sliders-wrap {{ clearButton ? 'k-sliders-wrap-clearable' : '' }}\\\">\\n                <span class=\\\"k-clear-color k-button k-bare k-button-icon\\\" *ngIf=\\\"clearButton\\\" (click)=\\\"reset()\\\">\\n                    <span class=\\\"k-icon k-i-reset-color\\\"></span>\\n                </span>\\n                <kendo-slider\\n                    class=\\\"k-hue-slider\\\"\\n                    [disabled]=\\\"disabled\\\"\\n                    [readonly]=\\\"readonly\\\"\\n                    [showButtons]=\\\"false\\\"\\n                    [tickPlacement]=\\\"'none'\\\"\\n                    [vertical]=\\\"true\\\"\\n                    [min]=\\\"0\\\"\\n                    [max]=\\\"360\\\"\\n                    [smallStep]=\\\"5\\\"\\n                    [largeStep]=\\\"10\\\"\\n                    [(value)]=\\\"hsva.h\\\"\\n                    (valueChange)=\\\"handleHueSliderChange($event)\\\"\\n                >\\n                </kendo-slider>\\n                <kendo-slider\\n                    *ngIf=\\\"opacity && format === 'rgba'\\\"\\n                    #alphaSlider\\n                    class=\\\"k-alpha-slider\\\"\\n                    [disabled]=\\\"disabled\\\"\\n                    [readonly]=\\\"readonly\\\"\\n                    [showButtons]=\\\"false\\\"\\n                    [tickPlacement]=\\\"'none'\\\"\\n                    [vertical]=\\\"true\\\"\\n                    [min]=\\\"0\\\"\\n                    [max]=\\\"100\\\"\\n                    [smallStep]=\\\"1\\\"\\n                    [largeStep]=\\\"10\\\"\\n                    [value]=\\\"alphaSliderValue\\\"\\n                    (valueChange)=\\\"handleAlphaSliderChange($event)\\\"\\n                >\\n                </kendo-slider>\\n            </div>\\n        </div>\\n        <kendo-colorinput\\n            [opacity]=\\\"opacity\\\"\\n            [value]=\\\"value\\\"\\n            [disabled]=\\\"disabled\\\"\\n            [readonly]=\\\"readonly\\\"\\n            (valueChange)=\\\"handleInputsValueChange($event)\\\"\\n        >\\n        </kendo-colorinput>\\n\"\n                },] },\n    ];\n    /** @nocollapse */\n    ColorGradientComponent.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: NgZone },\n        { type: Renderer2 },\n        { type: ChangeDetectorRef },\n        { type: LocalizationService }\n    ]; };\n    ColorGradientComponent.propDecorators = {\n        hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-flatcolorpicker',] }],\n        disabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }],\n        hostTabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],\n        direction: [{ type: HostBinding, args: ['attr.dir',] }],\n        opacity: [{ type: Input }],\n        disabled: [{ type: Input }],\n        readonly: [{ type: Input }],\n        clearButton: [{ type: Input }],\n        value: [{ type: Input }],\n        tabindex: [{ type: Input }],\n        valueChange: [{ type: Output }],\n        format: [{ type: Input }],\n        alphaSlider: [{ type: ViewChild, args: ['alphaSlider',] }],\n        gradientWrapper: [{ type: ViewChild, args: ['gradientWrapper',] }],\n        dragHandle: [{ type: ViewChild, args: ['dragHandle',] }]\n    };\n    return ColorGradientComponent;\n}());\n\n/**\n * @hidden\n */\nvar ColorInputComponent = /** @class */ (function () {\n    function ColorInputComponent(host) {\n        this.host = host;\n        /**\n         * Sets whether the alpha slider will be shown.\n         */\n        this.opacity = true;\n        /**\n         * Sets the disabled state of the ColorInput.\n         */\n        this.disabled = false;\n        /**\n         * Sets the read-only state of the ColorInput.\n         */\n        this.readonly = false;\n        /**\n         * Emits a parsed rgba string color.\n         */\n        this.valueChange = new EventEmitter();\n        this.colorInputClass = true;\n        /**\n         * The rgba inputs values.\n         */\n        this.rgba = {};\n    }\n    Object.defineProperty(ColorInputComponent.prototype, \"isFocused\", {\n        /**\n         * Indicates whether any of the inputs are focused.\n         */\n        get: function () {\n            if (!(isDocumentAvailable() && isPresent(this.host))) {\n                return false;\n            }\n            var activeElement = document.activeElement;\n            return this.host.nativeElement.contains(activeElement);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ColorInputComponent.prototype, \"rgbaInputValid\", {\n        /**\n         * Indicates whether any of the rgba inputs have value.\n         */\n        get: function () {\n            var _this = this;\n            return Object.keys(this.rgba).every(function (key) { return isPresent(_this.rgba[key]); });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ColorInputComponent.prototype.ngOnChanges = function (changes) {\n        if (isPresent(changes.value) && !this.isFocused) {\n            this.hex = parseColor$1(this.value, 'hex');\n            this.rgba = getRGBA(this.value);\n            this.rgba.a = parseColor$1(this.value, 'rgba') ? this.rgba.a : 1;\n        }\n    };\n    ColorInputComponent.prototype.handleRgbaValueChange = function () {\n        var color = getColorFromRGBA(this.rgba);\n        if (!this.rgbaInputValid || color === this.value) {\n            return;\n        }\n        this.value = color;\n        this.rgba = getRGBA(this.value);\n        this.hex = parseColor$1(color, 'hex');\n        this.valueChange.emit(color);\n    };\n    ColorInputComponent.prototype.handleHexValueChange = function (hex) {\n        this.hex = hex;\n        var color = parseColor$1(hex, 'rgba');\n        if (!isPresent(color) || color === this.value) {\n            return;\n        }\n        this.value = color;\n        this.rgba = getRGBA(color);\n        this.valueChange.emit(color);\n    };\n    ColorInputComponent.prototype.handleRgbaInputBlur = function () {\n        if (!this.rgbaInputValid) {\n            this.rgba = getRGBA(this.value);\n        }\n    };\n    ColorInputComponent.prototype.handleHexInputBlur = function () {\n        this.hex = parseColor$1(this.value, 'hex');\n    };\n    ColorInputComponent.decorators = [\n        { type: Component, args: [{\n                    selector: 'kendo-colorinput',\n                    template: \"\\n        <div class=\\\"k-hbox k-gradient-values\\\">\\n            <input\\n                #hexInput\\n                class=\\\"k-textbox k-hex-value\\\"\\n                [disabled]=\\\"disabled\\\"\\n                [readonly]=\\\"readonly\\\"\\n                [value]=\\\"hex || ''\\\"\\n                placeholder=\\\"no color\\\"\\n                (blur)=\\\"handleHexInputBlur()\\\"\\n                (input)=\\\"handleHexValueChange(hexInput.value)\\\"\\n            />\\n            <kendo-numerictextbox\\n                [disabled]=\\\"disabled\\\"\\n                [readonly]=\\\"readonly\\\"\\n                [min]=\\\"0\\\"\\n                [max]=\\\"255\\\"\\n                placeholder=\\\"R\\\"\\n                [(value)]=\\\"rgba.r\\\"\\n                [autoCorrect]=\\\"true\\\"\\n                [spinners]=\\\"false\\\"\\n                [format]=\\\"'n'\\\"\\n                [decimals]=\\\"0\\\"\\n                (blur)=\\\"handleRgbaInputBlur()\\\"\\n                (valueChange)=\\\"handleRgbaValueChange()\\\"\\n            >\\n            </kendo-numerictextbox>\\n            <kendo-numerictextbox\\n                [disabled]=\\\"disabled\\\"\\n                [readonly]=\\\"readonly\\\"\\n                [min]=\\\"0\\\"\\n                [max]=\\\"255\\\"\\n                placeholder=\\\"G\\\"\\n                [(value)]=\\\"rgba.g\\\"\\n                [autoCorrect]=\\\"true\\\"\\n                [spinners]=\\\"false\\\"\\n                [format]=\\\"'n'\\\"\\n                [decimals]=\\\"0\\\"\\n                (blur)=\\\"handleRgbaInputBlur()\\\"\\n                (valueChange)=\\\"handleRgbaValueChange()\\\"\\n            >\\n            </kendo-numerictextbox>\\n            <kendo-numerictextbox\\n                [disabled]=\\\"disabled\\\"\\n                [readonly]=\\\"readonly\\\"\\n                [min]=\\\"0\\\"\\n                [max]=\\\"255\\\"\\n                placeholder=\\\"B\\\"\\n                [(value)]=\\\"rgba.b\\\"\\n                [autoCorrect]=\\\"true\\\"\\n                [spinners]=\\\"false\\\"\\n                [format]=\\\"'n'\\\"\\n                [decimals]=\\\"0\\\"\\n                (blur)=\\\"handleRgbaInputBlur()\\\"\\n                (valueChange)=\\\"handleRgbaValueChange()\\\"\\n            >\\n            </kendo-numerictextbox>\\n            <kendo-numerictextbox\\n                *ngIf=\\\"opacity\\\"\\n                [disabled]=\\\"disabled\\\"\\n                [readonly]=\\\"readonly\\\"\\n                [min]=\\\"0\\\"\\n                [max]=\\\"1\\\"\\n                placeholder=\\\"A\\\"\\n                [(value)]=\\\"rgba.a\\\"\\n                [autoCorrect]=\\\"true\\\"\\n                [spinners]=\\\"false\\\"\\n                [step]=\\\"0.01\\\"\\n                [format]=\\\"'n2'\\\"\\n                [decimals]=\\\"2\\\"\\n                (blur)=\\\"handleRgbaInputBlur()\\\"\\n                (valueChange)=\\\"handleRgbaValueChange()\\\"\\n            >\\n            </kendo-numerictextbox>\\n        </div>\\n        <div class=\\\"k-hbox k-gradient-values\\\">\\n            <div class=\\\"k-hex-value\\\">hex</div>\\n            <div>r</div>\\n            <div>g</div>\\n            <div>b</div>\\n            <div *ngIf=\\\"opacity\\\">a</div>\\n        </div>\\n    \"\n                },] },\n    ];\n    /** @nocollapse */\n    ColorInputComponent.ctorParameters = function () { return [\n        { type: ElementRef }\n    ]; };\n    ColorInputComponent.propDecorators = {\n        value: [{ type: Input }],\n        opacity: [{ type: Input }],\n        disabled: [{ type: Input }],\n        readonly: [{ type: Input }],\n        valueChange: [{ type: Output }],\n        colorInputClass: [{ type: HostBinding, args: ['class.k-colorinputs',] }]\n    };\n    return ColorInputComponent;\n}());\n\n/**\n * @hidden\n */\nvar FocusOnDomReadyDirective = /** @class */ (function () {\n    function FocusOnDomReadyDirective(host, ngZone) {\n        this.host = host;\n        this.ngZone = ngZone;\n    }\n    FocusOnDomReadyDirective.prototype.ngAfterContentInit = function () {\n        this.focusOnNextTick();\n    };\n    FocusOnDomReadyDirective.prototype.focusOnNextTick = function () {\n        var _this = this;\n        this.ngZone.runOutsideAngular(function () { return setTimeout(function () { return _this.host.nativeElement.focus(); }); });\n    };\n    FocusOnDomReadyDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[kendoFocusOnDomReady]'\n                },] },\n    ];\n    /** @nocollapse */\n    FocusOnDomReadyDirective.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    return FocusOnDomReadyDirective;\n}());\n\nvar PUBLIC_DIRECTIVES = [\n    ColorPickerComponent,\n    ColorPaletteComponent,\n    ColorGradientComponent\n];\nvar INTERNAL_DIRECTIVES = [\n    ColorInputComponent,\n    FocusOnDomReadyDirective\n];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the ColorPicker.\n */\nvar ColorPickerModule = /** @class */ (function () {\n    function ColorPickerModule() {\n    }\n    ColorPickerModule.decorators = [\n        { type: NgModule, args: [{\n                    declarations: [\n                        PUBLIC_DIRECTIVES,\n                        INTERNAL_DIRECTIVES\n                    ],\n                    exports: [PUBLIC_DIRECTIVES],\n                    imports: [\n                        SliderModule,\n                        NumericTextBoxModule,\n                        CommonModule,\n                        PopupModule,\n                        DraggableModule\n                    ]\n                },] },\n    ];\n    return ColorPickerModule;\n}());\n\n/**\n * Represents the directive that renders the [Kendo UI CheckBox]({% slug overview_checkbox %}) input component.\n * The directive is placed on input type=\"checkbox\" elements.\n *\n * @example\n * ```ts-no-run\n * <input type=\"checkbox\" kendoCheckBox />\n * ```\n */\nvar CheckBoxDirective = /** @class */ (function () {\n    function CheckBoxDirective() {\n        this.kendoClass = true;\n    }\n    CheckBoxDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: 'input[kendoCheckBox]'\n                },] },\n    ];\n    CheckBoxDirective.propDecorators = {\n        kendoClass: [{ type: HostBinding, args: ['class.k-checkbox',] }]\n    };\n    return CheckBoxDirective;\n}());\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the CheckBox directive.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the CheckBox module\n * import { CheckBoxModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, CheckBoxModule], // import CheckBox module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nvar CheckBoxModule = /** @class */ (function () {\n    function CheckBoxModule() {\n    }\n    CheckBoxModule.decorators = [\n        { type: NgModule, args: [{\n                    declarations: [CheckBoxDirective],\n                    exports: [CheckBoxDirective],\n                    imports: [CommonModule]\n                },] },\n    ];\n    return CheckBoxModule;\n}());\n\n/**\n * Represents the directive that renders the [Kendo UI RadioButton]({% slug overview_checkbox %}) input component.\n * The directive is placed on input type=\"radio\" elements.\n *\n * @example\n * ```ts-no-run\n * <input type=\"radio\" kendoRadioButton />\n * ```\n */\nvar RadioButtonDirective = /** @class */ (function () {\n    function RadioButtonDirective() {\n        this.kendoClass = true;\n    }\n    RadioButtonDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: 'input[kendoRadioButton]'\n                },] },\n    ];\n    RadioButtonDirective.propDecorators = {\n        kendoClass: [{ type: HostBinding, args: ['class.k-radio',] }]\n    };\n    return RadioButtonDirective;\n}());\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the RadioButton directive.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the RadioButton module\n * import { RadioButtonModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, RadioButtonModule], // import RadioButton module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nvar RadioButtonModule = /** @class */ (function () {\n    function RadioButtonModule() {\n    }\n    RadioButtonModule.decorators = [\n        { type: NgModule, args: [{\n                    declarations: [RadioButtonDirective],\n                    exports: [RadioButtonDirective],\n                    imports: [CommonModule]\n                },] },\n    ];\n    return RadioButtonModule;\n}());\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Inputs components.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Inputs module\n * import { InputsModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, BrowserAnimationsModule, InputsModule], // import Inputs module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nvar InputsModule = /** @class */ (function () {\n    function InputsModule() {\n    }\n    InputsModule.decorators = [\n        { type: NgModule, args: [{\n                    exports: [TextBoxModule, SliderModule, SwitchModule, NumericTextBoxModule, MaskedTextBoxModule, ColorPickerModule, CheckBoxModule, RadioButtonModule],\n                    imports: [CommonModule]\n                },] },\n    ];\n    return InputsModule;\n}());\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CheckBoxModule, ColorInputComponent, FocusOnDomReadyDirective, ColorPaletteService, MaskingService, NumericTextBoxMessages, RadioButtonModule, SliderCustomMessagesComponent, SliderMessages, SwitchCustomMessagesComponent, Messages, SliderComponent, LabelTemplateDirective, SwitchComponent, TextBoxContainerComponent, TextBoxDirective, TextAreaDirective, NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent, MaskedTextBoxComponent, InputsModule, SliderTicksComponent, SliderModule, SwitchModule, NumericTextBoxModule, MaskedTextBoxModule, TextBoxModule, ColorPickerComponent, ColorPaletteComponent, ColorGradientComponent, ColorPickerModule, ActiveColorClickEvent, CheckBoxDirective, RadioButtonDirective, LocalizedNumericTextBoxMessagesDirective, LocalizedSliderMessagesDirective, LocalizedSwitchMessagesDirective };\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAsPK,AAKC;;;;;;;;;;;;;;kCAIG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAsnBH,AAaA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAqDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OA+SC,AAoBD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAgCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA+MA,AAaA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAiBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAiNA,AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAmBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA6FA,AASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAw6BA,AAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAoCA;;;;;;;;;;;;;;;;;;+FAeA;;;;;;;;;;;;;;;;;;;;OAoBC,AAYD;;;;;;;;;;;;;;;;;;;;;;;;oFAIG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA2cH;;;;;gDAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA+dA,AAwBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAkCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA2DA,AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAeA;;;;;;;;;;;;;;;;;;;+EAgBA;;;;;;;;;;;;;KAaD,AAWC;;;;;;;;;;;;;;;;;;;;;;;oFAIG;;;;;;;;;;;;;;;;;;;;OAoBF,AAYD;;;;;;;;;;;;;;;;;;;;;;;;oFAIG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAsCJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gDAkBC;;;;;;;;;;;;;;;;;;mEAeA;;;;;;;;;;;;;KAaD,AAWC;;;;;;;;;;;;;;;;;;;;;;;oFAIG;;;;;;;;;;;;;;;;;;;;OAoBF,AAYD;;;;;;;;;;;;;;;;;;;;;;;;oFAIG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAqCJ;;;;;;;;;;;;;;;;;;;;;;;gDAeC;;;;;;;;;;;;;KAaD,AAWC;;;;;;;;;;;;;;;;;;;;;;;oFAIG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAqCJ;;;;;;;;;;;;;;;;;;;;;gDAcC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAqCD;;;;;;;;;;;gDAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAqCD;;;;;;;;;;;;;;;gDAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAsoBA,AAoBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBA8BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAyDA;;;;;gDAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAoTA,AAsBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAwBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAuUA,AAoBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAyBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA2FA,AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAYA;;;;;;;;;;;;;;;;;;MAkBA,AAKA;;;;;;;;;;;;;oGAKG;;;;;;;;;;;;;;;;;;;KAmBJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gDAgBC;;;;;;;;;;;;;;;;KAgBD,AAKC;;;;;;;;;;;;;;;;oBAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAqCD;;;;;;;;;;;gDAOC;;;;;;;;;;;;;;;;KAgBD,AAKC;;;;;;;;;;;;;;;;oBAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAqCD;;;;;;;;;;;gDAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAsCD;;;;;;;;;;;;;;;;;;;;;;;;;gDAMC;;;;;;;;;"}