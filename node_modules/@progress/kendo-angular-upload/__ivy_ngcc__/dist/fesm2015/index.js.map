{"version":3,"file":"index.js","sources":["D:/project/projek_angular/hris_rni/node_modules/@progress/kendo-angular-upload/dist/fesm2015/index.js"],"sourcesContent":["/**-----------------------------------------------------------------------------------------\n* Copyright Â© 2020 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport { Component, ContentChild, Directive, ElementRef, EventEmitter, HostBinding, HostListener, Injectable, Input, NgModule, NgZone, Output, Renderer2, TemplateRef, ViewChild, ViewChildren, ViewContainerRef, forwardRef, isDevMode } from '@angular/core';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { ComponentMessages, L10N_PREFIX, LocalizationService } from '@progress/kendo-angular-l10n';\nimport { KendoInput, Keys, guid, isChanged, isDocumentAvailable } from '@progress/kendo-angular-common';\nimport { fromEvent, merge } from 'rxjs';\nimport { filter } from 'rxjs/operators';\nimport { HttpClient, HttpEventType, HttpHeaders, HttpRequest, HttpResponse } from '@angular/common/http';\nimport { CommonModule } from '@angular/common';\nimport { animate, state, style, transition, trigger } from '@angular/animations';\n\n/**\n * Lists the possible states of a file.\n */\nvar FileState;\n(function (FileState) {\n    /**\n     * The file upload process has failed.\n     */\n    FileState[FileState[\"Failed\"] = 0] = \"Failed\";\n    /**\n     * An initially selected fake file without a set state.\n     */\n    FileState[FileState[\"Initial\"] = 1] = \"Initial\";\n    /**\n     * The file is selected.\n     */\n    FileState[FileState[\"Selected\"] = 2] = \"Selected\";\n    /**\n     * The file is successfully uploaded.\n     */\n    FileState[FileState[\"Uploaded\"] = 3] = \"Uploaded\";\n    /**\n     * The file is in the process of uploading.\n     */\n    FileState[FileState[\"Uploading\"] = 4] = \"Uploading\";\n    /**\n     * The file upload process has been paused.\n     */\n    FileState[FileState[\"Paused\"] = 5] = \"Paused\";\n})(FileState || (FileState = {}));\n\n/**\n * @hidden\n */\nclass FileMap {\n    constructor() {\n        this._files = {};\n    }\n    add(file) {\n        let uid = file.uid;\n        if (this.has(uid)) {\n            if (file.validationErrors && file.validationErrors.length > 0) {\n                this._files[uid].unshift(file);\n            }\n            else {\n                this._files[uid].push(file);\n            }\n        }\n        else {\n            this._files[uid] = [file];\n        }\n    }\n    remove(uid) {\n        if (this.has(uid)) {\n            this._files[uid] = null;\n            delete this._files[uid];\n        }\n    }\n    clear() {\n        let allFiles = this._files;\n        for (let uid in allFiles) {\n            if (allFiles.hasOwnProperty(uid)) {\n                for (let file of allFiles[uid]) {\n                    if (file.httpSubscription) {\n                        file.httpSubscription.unsubscribe();\n                    }\n                }\n                allFiles[uid] = null;\n                delete allFiles[uid];\n            }\n        }\n    }\n    has(uid) {\n        return uid in this._files;\n    }\n    get(uid) {\n        return this._files[uid];\n    }\n    setFilesState(files, state$$1) {\n        for (let file of files) {\n            this.setFilesStateByUid(file.uid, state$$1);\n        }\n    }\n    setFilesStateByUid(uid, state$$1) {\n        this.get(uid).forEach((f) => {\n            f.state = state$$1;\n        });\n    }\n    get count() {\n        return Object.getOwnPropertyNames(this._files).length;\n    }\n    get files() {\n        let initial = this._files;\n        let transformed = [];\n        for (let uid in initial) {\n            if (initial.hasOwnProperty(uid)) {\n                transformed.push(initial[uid]);\n            }\n        }\n        return transformed;\n    }\n    get filesFlat() {\n        let initial = this._files;\n        let transformed = [];\n        for (let uid in initial) {\n            if (initial.hasOwnProperty(uid)) {\n                let current = initial[uid];\n                current.forEach((file) => {\n                    transformed.push(file);\n                });\n            }\n        }\n        return transformed;\n    }\n    get filesToUpload() {\n        let files = this._files;\n        let notUploaded = [];\n        for (let uid in files) {\n            if (files.hasOwnProperty(uid)) {\n                let currentFiles = files[uid];\n                let currentFilesValid = true;\n                for (let file of currentFiles) {\n                    if (file.state !== FileState.Selected || (file.validationErrors && file.validationErrors.length > 0)) {\n                        currentFilesValid = false;\n                    }\n                }\n                if (currentFilesValid) {\n                    notUploaded.push(currentFiles);\n                }\n            }\n        }\n        return notUploaded;\n    }\n    get firstFileToUpload() {\n        let files = this._files;\n        for (let uid in files) {\n            if (files.hasOwnProperty(uid)) {\n                let currentFiles = files[uid];\n                let currentFilesValid = true;\n                for (let file of currentFiles) {\n                    if (file.state !== FileState.Selected || (file.validationErrors && file.validationErrors.length > 0)) {\n                        currentFilesValid = false;\n                    }\n                }\n                if (currentFilesValid) {\n                    return currentFiles;\n                }\n            }\n        }\n        return null;\n    }\n    hasFileWithState(fileStates) {\n        let files = this._files;\n        for (let uid in files) {\n            if (files.hasOwnProperty(uid)) {\n                let currentFiles = files[uid];\n                for (let file of currentFiles) {\n                    if (fileStates.indexOf(file.state) >= 0) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\n\n/**\n * Arguments for the `cancel` event. The `cancel` event fires when\n * the user cancels the process of uploading a file or a batch of files.\n *\n * ```ts-no-run\n *  @Component({\n *    selector: 'my-upload',\n *    template: `\n *    <p>Click the <span class='k-icon k-i-cancel'></span> icon during upload to trigger the event</p>\n *    <kendo-upload\n *      [saveUrl]=\"uploadSaveUrl\"\n *      [removeUrl]=\"uploadRemoveUrl\"\n *      (cancel)=\"cancelEventHandler($event)\">\n *    </kendo-upload>\n *    `\n *  })\n *  export class UploadComponent {\n *    uploadSaveUrl = 'saveUrl'; // should represent an actual API endpoint\n *    uploadRemoveUrl = 'removeUrl'; // should represent an actual API endpoint\n *\n *    cancelEventHandler(e: CancelEvent) {\n *      console.log('Canceling file upload', e.files);\n *    }\n *  }\n * ```\n */\nclass CancelEvent {\n    /**\n     * Constructs the event arguments for the `cancel` event.\n     * @param files - The list of the files that were going to be uploaded.\n     */\n    constructor(files) {\n        this.files = files;\n    }\n}\n\n/**\n * @hidden\n */\nclass PreventableEvent {\n    constructor() {\n        this.prevented = false;\n    }\n    /**\n     * Prevents the default action for a specified event.\n     * In this way, the source component suppresses the built-in behavior that follows the event.\n     */\n    preventDefault() {\n        this.prevented = true;\n    }\n    /**\n     * If the event is prevented by any of its subscribers, returns `true`.\n     *\n     * @returns `true` if the default action was prevented. Otherwise, returns `false`.\n     */\n    isDefaultPrevented() {\n        return this.prevented;\n    }\n}\n\n/**\n * Arguments for the `clear` event. The `clear` event fires when\n * the **Clear** button is clicked. At this point, the selected files are about to be cleared.\n *\n * ```ts-no-run\n *  @Component({\n *    selector: 'my-upload',\n *    template: `\n *    <kendo-upload\n *      [autoUpload]=\"false\"\n *      [saveUrl]=\"uploadSaveUrl\"\n *      [removeUrl]=\"uploadRemoveUrl\"\n *      (clear)=\"clearEventHandler($event)\">\n *    </kendo-upload>\n *    `\n *  })\n *  export class UploadComponent {\n *    uploadSaveUrl = 'saveUrl'; // should represent an actual API endpoint\n *    uploadRemoveUrl = 'removeUrl'; // should represent an actual API endpoint\n *\n *    clearEventHandler(e: ClearEvent) {\n *      console.log('Clearing the file upload');\n *    }\n *  }\n * ```\n */\nclass ClearEvent extends PreventableEvent {\n    /**\n     * Constructs the event arguments for the `clear` event.\n     */\n    constructor() { super(); }\n}\n\n/**\n * Arguments for the `error` event. The `error` event fires when\n * an `upload` or `remove` operation fails.\n *\n * ```ts-no-run\n *  @Component({\n *    selector: 'my-upload',\n *    template: `\n *    <kendo-upload\n *      [saveUrl]=\"uploadSaveUrl\"\n *      [removeUrl]=\"uploadRemoveUrl\"\n *      (error)=\"errorEventHandler($event)\">\n *    </kendo-upload>\n *    `\n *  })\n *  export class UploadComponent {\n *    uploadSaveUrl = 'saveUrl'; // should represent an actual API endpoint\n *    uploadRemoveUrl = 'removeUrl'; // should represent an actual API endpoint\n *\n *    errorEventHandler(e: ErrorEvent) {\n *      console.log('An error occurred');\n *    }\n *  }\n * ```\n */\nclass ErrorEvent {\n    /**\n     * Constructs the event arguments for the `error` event.\n     *\n     * @param files - The list of the files that failed to be uploaded or removed.\n     * @param operation - The operation type (`upload` or `remove`).\n     * @param response - The response object returned by the server.\n     */\n    constructor(files, operation, response) {\n        this.files = files;\n        this.operation = operation;\n        this.response = response;\n    }\n}\n\n/**\n * Arguments for the `pause` event. The `pause` event fires when the user\n * pauses a file that is currently uploading.\n *\n * ```ts-no-run\n *  @Component({\n *    selector: 'my-upload',\n *    template: `\n *    <kendo-upload\n *      [chunkable]=\"true\"\n *      [saveUrl]=\"uploadSaveUrl\"\n *      [removeUrl]=\"uploadRemoveUrl\"\n *      (pause)=\"pauseEventHandler($event)\">\n *    </kendo-upload>\n *    `\n *  })\n *  export class UploadComponent {\n *    uploadSaveUrl = 'saveUrl'; // should represent an actual API endpoint\n *    uploadRemoveUrl = 'removeUrl'; // should represent an actual API endpoint\n *\n *    pauseEventHandler(ev: PauseEvent) {\n *      console.log('File paused');\n *    }\n *  }\n * ```\n *\n */\nclass PauseEvent {\n    /**\n     * Constructs the event arguments for the `pause` event.\n     * @param file - The file that is going to be paused.\n     */\n    constructor(file) {\n        this.file = file;\n    }\n}\n\n/**\n * Arguments for the `remove` event. The `remove` event fires when an uploaded\n * or selected file is about to be removed. If you cancel the event, the removal is prevented.\n *\n * ```ts-no-run\n *  @Component({\n *    selector: 'my-upload',\n *    template: `\n *    <kendo-upload\n *      [saveUrl]=\"uploadSaveUrl\"\n *      [removeUrl]=\"uploadRemoveUrl\"\n *      (remove)=\"removeEventHandler($event)\">\n *    </kendo-upload>\n *    `\n *  })\n *  export class UploadComponent {\n *    uploadSaveUrl = 'saveUrl'; // should represent an actual API endpoint\n *    uploadRemoveUrl = 'removeUrl'; // should represent an actual API endpoint\n *\n *    removeEventHandler(e: RemoveEvent) {\n *      console.log('Removing a file');\n *    }\n *  }\n * ```\n */\nclass RemoveEvent extends PreventableEvent {\n    /**\n     * Constructs the event arguments for the `remove` event.\n     * @param files - The list of the files that will be removed.\n     * @param headers - The headers of the request.\n     */\n    constructor(files, headers) {\n        super();\n        this.files = files;\n        this.headers = headers;\n    }\n}\n\n/**\n * Arguments for the `resume` event. The `resume` event fires when the user\n * resumes the upload of a file that has been previously paused.\n *\n * ```ts-no-run\n *  @Component({\n *    selector: 'my-upload',\n *    template: `\n *    <kendo-upload\n *      [chunkable]=\"true\"\n *      [saveUrl]=\"uploadSaveUrl\"\n *      [removeUrl]=\"uploadRemoveUrl\"\n *      (resume)=\"resumeEventHandler($event)\">\n *    </kendo-upload>\n *    `\n *  })\n *  export class UploadComponent {\n *    uploadSaveUrl = 'saveUrl'; // should represent an actual API endpoint\n *    uploadRemoveUrl = 'removeUrl'; // should represent an actual API endpoint\n *\n *    resumeEventHandler(ev: ResumeEvent) {\n *      console.log('File resumed');\n *    }\n *  }\n * ```\n *\n */\nclass ResumeEvent {\n    /**\n     * Constructs the event arguments for the `resume` event.\n     * @param file - The file that is going to be resumed.\n     */\n    constructor(file) {\n        this.file = file;\n    }\n}\n\n/**\n * Arguments for the `select` event. The `select` event fires when the user\n * selects a file or multiple files for upload. If you cancel the event, the selection is prevented.\n *\n * ```ts-no-run\n *  @Component({\n *    selector: 'my-upload',\n *    template: `\n *    <kendo-upload\n *      [saveUrl]=\"uploadSaveUrl\"\n *      [removeUrl]=\"uploadRemoveUrl\"\n *      (select)=\"selectEventHandler($event)\">\n *    </kendo-upload>\n *    `\n *  })\n *  export class UploadComponent {\n *    uploadSaveUrl = 'saveUrl'; // should represent an actual API endpoint\n *    uploadRemoveUrl = 'removeUrl'; // should represent an actual API endpoint\n *\n *    selectEventHandler(e: SelectEvent) {\n *      console.log('File selected');\n *    }\n *  }\n * ```\n */\nclass SelectEvent extends PreventableEvent {\n    /**\n     * Constructs the event arguments for the `select` event.\n     * @param files - The list of the selected files.\n     */\n    constructor(files) {\n        super();\n        this.files = files;\n    }\n}\n\n/**\n * Arguments for the `success` event. The `success` event fires when\n * the selected files are successfully uploaded or removed.\n *\n * ```ts-no-run\n *  @Component({\n *    selector: 'my-upload',\n *    template: `\n *    <kendo-upload\n *      [saveUrl]=\"uploadSaveUrl\"\n *      [removeUrl]=\"uploadRemoveUrl\"\n *      (success)=\"successEventHandler($event)\">\n *    </kendo-upload>\n *    `\n *  })\n *  export class UploadComponent {\n *    uploadSaveUrl = 'saveUrl'; // should represent an actual API endpoint\n *    uploadRemoveUrl = 'removeUrl'; // should represent an actual API endpoint\n *\n *    successEventHandler(e: SuccessEvent) {\n *      console.log('The ' + e.operation + ' was successful!');\n *    }\n *  }\n * ```\n */\nclass SuccessEvent extends PreventableEvent {\n    /**\n     * Constructs the event arguments for the `success` event.\n     * @param files - The list of the files that were uploaded or removed.\n     * @param operation - The operation type (`upload` or `remove`).\n     * @param response - The response object returned by the server.\n     */\n    constructor(files, operation, response) {\n        super();\n        this.files = files;\n        this.operation = operation;\n        this.response = response;\n    }\n}\n\n/**\n * Arguments for the `upload` event. The `upload` event fires when one or more files are about\n * to be uploaded. If you cancel the event, the upload is prevented. You can add headers to the request.\n *\n * ```ts-no-run\n *  @Component({\n *    selector: 'my-upload',\n *    template: `\n *    <kendo-upload\n *      [saveUrl]=\"uploadSaveUrl\"\n *      [removeUrl]=\"uploadRemoveUrl\"\n *      (upload)=\"uploadEventHandler($event)\">\n *    </kendo-upload>\n *    `\n *  })\n *  export class UploadComponent {\n *    uploadSaveUrl = 'saveUrl'; // should represent an actual API endpoint\n *    uploadRemoveUrl = 'removeUrl'; // should represent an actual API endpoint\n *\n *    uploadEventHandler(e: UploadEvent) {\n *      e.headers = e.headers.append('X-Foo', 'Bar');\n *    }\n *  }\n * ```\n */\nclass UploadEvent extends PreventableEvent {\n    /**\n     * Constructs the event arguments for the `upload` event.\n     * @param files - The list of the files that will be uploaded.\n     * @param headers - The headers of the request.\n     */\n    constructor(files, headers) {\n        super();\n        this.files = files;\n        this.headers = headers;\n    }\n}\n\n/**\n * Arguments for the `uploadprogress` event. The `uploadprogress` event\n * fires when the files are in the process of uploading.\n *\n * ```ts-no-run\n *  @Component({\n *    selector: 'my-upload',\n *    template: `\n *    <kendo-upload\n *      [saveUrl]=\"uploadSaveUrl\"\n *      [removeUrl]=\"uploadRemoveUrl\"\n *      (uploadProgress)=\"uploadProgressEventHandler($event)\">\n *    </kendo-upload>\n *    `\n *  })\n *  export class UploadComponent {\n *    uploadSaveUrl = 'saveUrl'; // should represent an actual API endpoint\n *    uploadRemoveUrl = 'removeUrl'; // should represent an actual API endpoint\n *\n *    uploadProgressEventHandler(e: UploadProgressEvent) {\n *      console.log(e.files[0].name + ' is ' + e.percentComplete + ' uploaded');\n *    }\n *  }\n * ```\n */\nclass UploadProgressEvent {\n    /**\n     * Constructs the event arguments for the `uploadprogress` event.\n     * @param files - The list of files that are being uploaded.\n     * @param percentComplete - The portion that has been uploaded.\n     */\n    constructor(files, percentComplete) {\n        this.files = files;\n        this.percentComplete = percentComplete;\n    }\n}\n\n/* tslint:disable: no-bitwise */\n/**\n * @hidden\n */\nconst getTotalFilesSizeMessage = (files) => {\n    let totalSize = 0;\n    let i;\n    if (typeof files[0].size === \"number\") {\n        for (i = 0; i < files.length; i++) {\n            if (files[i].size) {\n                totalSize += files[i].size;\n            }\n        }\n    }\n    else {\n        return \"\";\n    }\n    totalSize /= 1024;\n    if (totalSize < 1024) {\n        return totalSize.toFixed(2) + \" KB\";\n    }\n    else {\n        return (totalSize / 1024).toFixed(2) + \" MB\";\n    }\n};\nconst stripPath = (name) => {\n    let slashIndex = name.lastIndexOf(\"\\\\\");\n    return (slashIndex !== -1) ? name.substr(slashIndex + 1) : name;\n};\nconst getFileExtension = (fileName) => {\n    const rFileExtension = /\\.([^\\.]+)$/;\n    const matches = fileName.match(rFileExtension);\n    return matches ? matches[0] : \"\";\n};\nconst ampRegExp = /&/g;\nconst ltRegExp = /</g;\nconst quoteRegExp = /\"/g;\nconst aposRegExp = /'/g;\nconst gtRegExp = />/g;\nconst htmlEncode = (value) => {\n    return (\"\" + value).replace(ampRegExp, \"&amp;\")\n        .replace(ltRegExp, \"&lt;\")\n        .replace(gtRegExp, \"&gt;\")\n        .replace(quoteRegExp, \"&quot;\")\n        .replace(aposRegExp, \"&#39;\");\n};\n/**\n * @hidden\n */\nconst validateInitialFileInfo = (file) => {\n    if (file instanceof Object && file.hasOwnProperty(\"name\")) {\n        return true;\n    }\n    return false;\n};\n/**\n * @hidden\n */\nconst getInitialFileInfo = (fakeFile) => {\n    fakeFile.extension = fakeFile.extension || getFileExtension(fakeFile.name);\n    fakeFile.name = htmlEncode(fakeFile.name);\n    fakeFile.size = fakeFile.size || 0;\n    if (!fakeFile.hasOwnProperty(\"state\")) {\n        fakeFile.state = FileState.Initial;\n    }\n    if (!fakeFile.hasOwnProperty(\"uid\")) {\n        fakeFile.uid = guid();\n    }\n    return fakeFile;\n};\nconst getFileInfo = (rawFile) => {\n    const fileName = rawFile.name;\n    const fileSize = rawFile.size;\n    return {\n        extension: getFileExtension(fileName),\n        name: htmlEncode(fileName),\n        rawFile: rawFile,\n        size: fileSize,\n        state: FileState.Selected\n    };\n};\n/**\n * @hidden\n */\nconst getAllFileInfo = (rawFiles) => {\n    let allFileInfo = new Array();\n    let i;\n    for (i = 0; i < rawFiles.length; i++) {\n        allFileInfo.push(getFileInfo(rawFiles[i]));\n    }\n    return allFileInfo;\n};\n/**\n * @hidden\n */\nconst fileHasValidationErrors = (file) => {\n    if (file.validationErrors && file.validationErrors.length > 0) {\n        return true;\n    }\n    return false;\n};\n/**\n * @hidden\n */\nconst filesHaveValidationErrors = (files) => {\n    for (let file of files) {\n        if (fileHasValidationErrors(file)) {\n            return true;\n        }\n    }\n    return false;\n};\n/**\n * @hidden\n */\nconst inputFiles = (input) => {\n    if (input.files) {\n        return getAllFileInfo(input.files);\n    }\n    else {\n        //Required for testing\n        let fileNames = input.value.split(\"|\").map((file, index) => {\n            let fileName = file.trim();\n            return {\n                extension: getFileExtension(fileName),\n                name: stripPath(fileName),\n                rawFile: null,\n                size: (index + 1) * 1000,\n                state: FileState.Selected\n            };\n        });\n        return fileNames;\n    }\n};\n/**\n * @hidden\n */\nconst assignGuidToFiles = (files, isUnique) => {\n    const uid = guid();\n    return files.map((file) => {\n        file.uid = isUnique ? guid() : uid;\n        return file;\n    });\n};\n/**\n * @hidden\n */\n\n/**\n * @hidden\n */\n\nconst focusableRegex = /^(?:a|input|select|textarea|button|object)$/i;\n/**\n * @hidden\n */\nconst IGNORE_TARGET_CLASSES = 'k-icon k-select k-input';\n/**\n * @hidden\n */\nconst UPLOAD_CLASSES = 'k-upload-button k-clear-selected k-upload-selected k-upload-action';\nconst isVisible = (element) => {\n    const rect = element.getBoundingClientRect();\n    return !!(rect.width && rect.height) && window.getComputedStyle(element).visibility !== 'hidden';\n};\nconst toClassList = (classNames) => String(classNames).trim().split(' ');\n/**\n * @hidden\n */\nconst hasClasses = (element, classNames) => {\n    const namesList = toClassList(classNames);\n    return Boolean(toClassList(element.className).find((className) => namesList.indexOf(className) >= 0));\n};\n/**\n * @hidden\n */\nconst isFocusable = (element, checkVisibility = true) => {\n    if (element.tagName) {\n        const tagName = element.tagName.toLowerCase();\n        const tabIndex = element.getAttribute('tabIndex');\n        const validTabIndex = tabIndex !== null && !isNaN(tabIndex) && tabIndex > -1;\n        let focusable = false;\n        if (focusableRegex.test(tagName)) {\n            focusable = !element.disabled;\n        }\n        else {\n            focusable = validTabIndex;\n        }\n        return focusable && (!checkVisibility || isVisible(element));\n    }\n    return false;\n};\n\n/**\n * @hidden\n */\nclass ChunkMap {\n    constructor() {\n        this._files = {};\n    }\n    add(uid, totalChunks) {\n        const initialChunkInfo = {\n            index: 0,\n            position: 0,\n            retries: 0,\n            totalChunks: totalChunks\n        };\n        this._files[uid] = initialChunkInfo;\n        return initialChunkInfo;\n    }\n    remove(uid) {\n        if (this.has(uid)) {\n            this._files[uid] = null;\n            delete this._files[uid];\n        }\n    }\n    has(uid) {\n        return uid in this._files;\n    }\n    get(uid) {\n        return this._files[uid];\n    }\n}\n\n/**\n * @hidden\n */\nclass UploadService {\n    constructor(http$$1) {\n        this.http = http$$1;\n        this.cancelEvent = new EventEmitter();\n        this.clearEvent = new EventEmitter();\n        this.completeEvent = new EventEmitter();\n        this.errorEvent = new EventEmitter();\n        this.pauseEvent = new EventEmitter();\n        this.removeEvent = new EventEmitter();\n        this.resumeEvent = new EventEmitter();\n        this.selectEvent = new EventEmitter();\n        this.successEvent = new EventEmitter();\n        this.uploadEvent = new EventEmitter();\n        this.uploadProgressEvent = new EventEmitter();\n        /**\n         * Required for the `ControlValueAccessor` integration\n         */\n        this.changeEvent = new EventEmitter();\n        /**\n         * Default async settings\n         */\n        this.async = {\n            autoUpload: true,\n            batch: false,\n            chunk: false,\n            concurrent: true,\n            removeField: \"fileNames\",\n            removeHeaders: new HttpHeaders(),\n            removeMethod: \"POST\",\n            removeUrl: \"\",\n            responseType: \"json\",\n            saveField: \"files\",\n            saveHeaders: new HttpHeaders(),\n            saveMethod: \"POST\",\n            saveUrl: \"\",\n            withCredentials: true\n        };\n        /**\n         * Default chunk settings\n         */\n        this.chunk = {\n            autoRetryAfter: 100,\n            size: 1024 * 1024,\n            maxAutoRetries: 1,\n            resumable: true\n        };\n        this.component = 'Upload';\n        this.chunkMap = new ChunkMap();\n        this.fileList = new FileMap();\n    }\n    get files() {\n        return this.fileList;\n    }\n    setChunkSettings(settings) {\n        if (settings !== false) {\n            this.async.chunk = true;\n            if (typeof settings === \"object\") {\n                this.chunk = Object.assign({}, this.chunk, settings);\n            }\n        }\n    }\n    onChange() {\n        let files = this.fileList.filesFlat.filter((file) => {\n            return file.state === FileState.Initial ||\n                file.state === FileState.Uploaded;\n        });\n        this.changeEvent.emit(files.length > 0 ? files : null);\n    }\n    addFiles(files) {\n        let selectEventArgs = new SelectEvent(files);\n        this.selectEvent.emit(selectEventArgs);\n        if (!selectEventArgs.isDefaultPrevented()) {\n            for (let file of files) {\n                this.fileList.add(file);\n            }\n            if (this.async.autoUpload) {\n                this.uploadFiles();\n            }\n        }\n        if (this.component === 'FileSelect') {\n            this.changeEvent.emit(this.fileList.filesFlat);\n        }\n    }\n    addInitialFiles(initialFiles) {\n        this.fileList.clear();\n        initialFiles.forEach((file) => {\n            let fakeFile = getInitialFileInfo(file);\n            this.fileList.add(fakeFile);\n        });\n    }\n    resumeFile(uid) {\n        const fileToResume = this.fileList.get(uid);\n        this.resumeEvent.emit(new ResumeEvent(fileToResume[0]));\n        this.fileList.setFilesStateByUid(uid, FileState.Uploading);\n        this._uploadFiles([fileToResume]);\n    }\n    pauseFile(uid) {\n        let pausedFile = this.fileList.get(uid)[0];\n        this.pauseEvent.emit(new PauseEvent(pausedFile));\n        this.fileList.setFilesStateByUid(uid, FileState.Paused);\n    }\n    removeFiles(uid) {\n        let removedFiles = this.fileList.get(uid);\n        // Clone the Headers so that the default ones are not overridden\n        let removeEventArgs = new RemoveEvent(removedFiles, this.cloneRequestHeaders(this.async.removeHeaders));\n        this.removeEvent.emit(removeEventArgs);\n        if (!removeEventArgs.isDefaultPrevented()) {\n            if (this.component === 'Upload' &&\n                (removedFiles[0].state === FileState.Uploaded ||\n                    removedFiles[0].state === FileState.Initial)) {\n                this.performRemove(removedFiles, removeEventArgs);\n            }\n            else {\n                this.fileList.remove(uid);\n                if (this.component === 'FileSelect') {\n                    this.changeEvent.emit(this.fileList.filesFlat);\n                }\n            }\n        }\n    }\n    cancelFiles(uid) {\n        let canceledFiles = this.fileList.get(uid);\n        let cancelEventArgs = new CancelEvent(canceledFiles);\n        this.cancelEvent.emit(cancelEventArgs);\n        for (let file of canceledFiles) {\n            if (file.httpSubscription) {\n                file.httpSubscription.unsubscribe();\n            }\n        }\n        this.fileList.remove(uid);\n        this.checkAllComplete();\n    }\n    clearFiles() {\n        let clearEventArgs = new ClearEvent();\n        this.clearEvent.emit(clearEventArgs);\n        if (!clearEventArgs.isDefaultPrevented()) {\n            let triggerChange = this.fileList.hasFileWithState([\n                FileState.Initial,\n                FileState.Uploaded\n            ]);\n            this.fileList.clear();\n            if (triggerChange) {\n                this.onChange();\n            }\n        }\n    }\n    uploadFiles() {\n        let filesToUpload = [];\n        if (this.async.concurrent) {\n            filesToUpload = this.fileList.filesToUpload;\n        }\n        if (!this.async.concurrent && !this.fileList.hasFileWithState([FileState.Uploading])) {\n            filesToUpload = [this.fileList.firstFileToUpload];\n        }\n        if (filesToUpload && filesToUpload.length > 0) {\n            this._uploadFiles(filesToUpload);\n        }\n    }\n    retryFiles(uid) {\n        let filesToRetry = [this.fileList.get(uid)];\n        if (filesToRetry) {\n            this._uploadFiles(filesToRetry);\n        }\n    }\n    _uploadFiles(allFiles) {\n        for (let filesToUpload of allFiles) {\n            if (filesToUpload[0].state === FileState.Paused) {\n                return;\n            }\n            // Clone the Headers so that the default ones are not overridden\n            let uploadEventArgs = new UploadEvent(filesToUpload, this.cloneRequestHeaders(this.async.saveHeaders));\n            this.uploadEvent.emit(uploadEventArgs);\n            if (!uploadEventArgs.isDefaultPrevented()) {\n                this.fileList.setFilesState(filesToUpload, FileState.Uploading);\n                let httpSubcription = this.performUpload(filesToUpload, uploadEventArgs);\n                filesToUpload.forEach((file) => {\n                    file.httpSubscription = httpSubcription;\n                });\n            }\n            else {\n                this.fileList.remove(filesToUpload[0].uid);\n            }\n        }\n    }\n    performRemove(files, removeEventArgs) {\n        const async = this.async;\n        let fileNames = files.map((file) => {\n            return file.name;\n        });\n        let formData = this.populateRemoveFormData(fileNames, removeEventArgs.data);\n        let options = this.populateRequestOptions(removeEventArgs.headers);\n        let removeRequest = new HttpRequest(async.removeMethod, async.removeUrl, formData, options);\n        this.http.request(removeRequest)\n            .subscribe(success => {\n            this.onSuccess(success, files, \"remove\");\n        }, error => {\n            this.onError(error, files, \"remove\");\n        });\n    }\n    performUpload(files, uploadEventArgs) {\n        const async = this.async;\n        let formData = this.populateUploadFormData(files, uploadEventArgs.data);\n        let options = this.populateRequestOptions(uploadEventArgs.headers);\n        let uploadRequest = new HttpRequest(async.saveMethod, async.saveUrl, formData, options);\n        let httpSubscription = this.http.request(uploadRequest)\n            .subscribe(event => {\n            if (event.type === HttpEventType.UploadProgress && !this.async.chunk) {\n                this.onProgress(event, files);\n            }\n            else if (event instanceof HttpResponse) {\n                this.onSuccess(event, files, \"upload\");\n                this.checkAllComplete();\n            }\n        }, error => {\n            this.onError(error, files, \"upload\");\n            this.checkAllComplete();\n        });\n        return httpSubscription;\n    }\n    onSuccess(successResponse, files, operation) {\n        if (operation === \"upload\" && this.async.chunk) {\n            this.onChunkProgress(files);\n            if (this.isChunkUploadComplete(files[0].uid)) {\n                this.removeChunkInfo(files[0].uid);\n            }\n            else {\n                this.updateChunkInfo(files[0].uid);\n                this._uploadFiles([files]);\n                return;\n            }\n        }\n        const successArgs = new SuccessEvent(files, operation, successResponse);\n        this.successEvent.emit(successArgs);\n        if (operation === \"upload\") {\n            this.fileList.setFilesState(files, successArgs.isDefaultPrevented() ? FileState.Failed : FileState.Uploaded);\n        }\n        else {\n            if (!successArgs.isDefaultPrevented()) {\n                this.fileList.remove(files[0].uid);\n            }\n        }\n        if (!successArgs.isDefaultPrevented()) {\n            this.onChange();\n        }\n    }\n    onError(errorResponse, files, operation) {\n        if (operation === \"upload\" && this.async.chunk) {\n            const maxRetries = this.chunk.maxAutoRetries;\n            const chunkInfo = this.chunkMap.get(files[0].uid);\n            if (chunkInfo.retries < maxRetries) {\n                chunkInfo.retries += 1;\n                setTimeout(() => {\n                    this.retryFiles(files[0].uid);\n                }, this.chunk.autoRetryAfter);\n                return;\n            }\n        }\n        const errorArgs = new ErrorEvent(files, operation, errorResponse);\n        this.errorEvent.emit(errorArgs);\n        if (operation === \"upload\") {\n            this.fileList.setFilesState(files, FileState.Failed);\n        }\n    }\n    onProgress(event, files) {\n        const percentComplete = Math.round(100 * event.loaded / event.total);\n        const progressArgs = new UploadProgressEvent(files, percentComplete < 100 ? percentComplete : 100);\n        this.uploadProgressEvent.emit(progressArgs);\n    }\n    onChunkProgress(files) {\n        const chunkInfo = this.chunkMap.get(files[0].uid);\n        let percentComplete = 0;\n        if (chunkInfo) {\n            if (chunkInfo.index === chunkInfo.totalChunks - 1) {\n                percentComplete = 100;\n            }\n            else {\n                percentComplete = Math.round(((chunkInfo.index + 1) / chunkInfo.totalChunks) * 100);\n            }\n        }\n        const progressArgs = new UploadProgressEvent(files, percentComplete < 100 ? percentComplete : 100);\n        this.uploadProgressEvent.emit(progressArgs);\n    }\n    checkAllComplete() {\n        if (!this.fileList.hasFileWithState([\n            FileState.Selected,\n            FileState.Uploading,\n            FileState.Paused\n        ])) {\n            this.completeEvent.emit();\n        }\n        else if (this.shouldUploadNextFile()) {\n            this.uploadFiles();\n        }\n    }\n    shouldUploadNextFile() {\n        return !this.async.concurrent &&\n            this.fileList.hasFileWithState([FileState.Selected]) &&\n            !this.fileList.hasFileWithState([FileState.Uploading]);\n    }\n    cloneRequestHeaders(headers) {\n        let cloned = {};\n        if (headers) {\n            headers.keys().forEach((key) => {\n                cloned[key] = headers.get(key);\n            });\n        }\n        return new HttpHeaders(cloned);\n    }\n    populateRequestOptions(headers) {\n        return {\n            headers: headers,\n            reportProgress: true,\n            responseType: this.async.responseType,\n            withCredentials: this.async.withCredentials\n        };\n    }\n    populateUploadFormData(files, clientData) {\n        const saveField = this.async.saveField;\n        let data = new FormData();\n        this.populateClientFormData(data, clientData);\n        if (this.async.chunk) {\n            data.append(saveField, this.getNextChunk(files[0]));\n            data.append(\"metadata\", this.getChunkMetadata(files[0]));\n        }\n        else {\n            for (let file of files) {\n                data.append(saveField, file.rawFile);\n            }\n        }\n        return data;\n    }\n    populateRemoveFormData(fileNames, clientData) {\n        let data = new FormData();\n        this.populateClientFormData(data, clientData);\n        for (let fileName of fileNames) {\n            data.append(this.async.removeField, fileName);\n        }\n        return data;\n    }\n    populateClientFormData(data, clientData) {\n        for (var key in clientData) {\n            if (clientData.hasOwnProperty(key)) {\n                data.append(key, clientData[key]);\n            }\n        }\n    }\n    /* Chunking Helper Methods Section */\n    getNextChunk(file) {\n        const info = this.getChunkInfo(file);\n        const newPosition = info.position + this.chunk.size;\n        return file.rawFile.slice(info.position, newPosition);\n    }\n    getChunkInfo(file) {\n        let chunkInfo = this.chunkMap.get(file.uid);\n        if (!chunkInfo) {\n            const totalChunks = Math.ceil(file.size / this.chunk.size);\n            chunkInfo = this.chunkMap.add(file.uid, totalChunks);\n        }\n        return chunkInfo;\n    }\n    updateChunkInfo(uid) {\n        const chunkInfo = this.chunkMap.get(uid);\n        if (chunkInfo.index < chunkInfo.totalChunks - 1) {\n            chunkInfo.index += 1;\n            chunkInfo.position += this.chunk.size;\n            chunkInfo.retries = 0;\n        }\n    }\n    removeChunkInfo(uid) {\n        this.chunkMap.remove(uid);\n    }\n    getChunkMetadata(file) {\n        const chunkInfo = this.chunkMap.get(file.uid);\n        const chunkMetadata = {\n            chunkIndex: chunkInfo.index,\n            contentType: file.rawFile.type,\n            fileName: file.name,\n            fileSize: file.size,\n            fileUid: file.uid,\n            totalChunks: chunkInfo.totalChunks\n        };\n        return JSON.stringify(chunkMetadata);\n    }\n    isChunkUploadComplete(uid) {\n        const chunkInfo = this.chunkMap.get(uid);\n        if (chunkInfo) {\n            return chunkInfo.index + 1 === chunkInfo.totalChunks;\n        }\n        return false;\n    }\n}\nUploadService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nUploadService.ctorParameters = () => [\n    { type: HttpClient }\n];\n\n/**\n * @hidden\n */\nclass NavigationService {\n    constructor(uploadService) {\n        this.uploadService = uploadService;\n        this.onActionButtonAction = new EventEmitter();\n        this.onActionButtonFocus = new EventEmitter();\n        this.onFileAction = new EventEmitter();\n        this.onFileFocus = new EventEmitter();\n        this.onTab = new EventEmitter();\n        this.onWrapperFocus = new EventEmitter();\n        this.onSelectButtonFocus = new EventEmitter();\n        this.actionButtonsVisible = false;\n        this.focused = false;\n        this._focusedIndex = -1;\n    }\n    action(event) {\n        const key = event.keyCode;\n        return this.keyBindings[key];\n    }\n    process(event) {\n        const handler = this.action(event);\n        if (handler) {\n            handler(event.shiftKey);\n        }\n    }\n    computeKeys(direction) {\n        this.keyBindings = {\n            [Keys.Enter]: () => this.handleEnter(),\n            [Keys.Escape]: () => this.handleEscape(),\n            [Keys.Delete]: () => this.handleDelete(),\n            [Keys.Tab]: (shifted) => this.handleTab(shifted),\n            [Keys.ArrowUp]: () => this.handleUp(),\n            [Keys.ArrowDown]: () => this.handleDown(),\n            [this.invertKeys(direction, Keys.ArrowLeft, Keys.ArrowRight)]: () => this.handleLeft(),\n            [this.invertKeys(direction, Keys.ArrowRight, Keys.ArrowLeft)]: () => this.handleRight()\n        };\n    }\n    invertKeys(direction, original, inverted) {\n        return direction === 'rtl' ? inverted : original;\n    }\n    focusSelectButton() {\n        this.focused = true;\n        this._focusedIndex = -1;\n        this.onSelectButtonFocus.emit();\n    }\n    handleEnter() {\n        if (this.lastIndex >= 0) {\n            if (this.focusedIndex <= this.lastFileIndex) {\n                this.onFileAction.emit(Keys.Enter);\n                return;\n            }\n            if (this.actionButtonsVisible && this.focusedIndex <= this.lastIndex) {\n                this.onActionButtonAction.emit(this.focusedIndex < this.lastIndex ? \"clear\" : \"upload\");\n            }\n        }\n    }\n    handleDelete() {\n        if (this.focusedIndex >= 0 && this.focusedIndex <= this.lastFileIndex) {\n            this.onFileAction.emit(Keys.Delete);\n        }\n    }\n    handleEscape() {\n        if (this.focusedIndex >= 0 && this.focusedIndex <= this.lastFileIndex) {\n            this.onFileAction.emit(Keys.Escape);\n        }\n    }\n    handleLeft() {\n        if (this.actionButtonsVisible && this.focusedIndex === this.lastIndex) {\n            this.focusedIndex -= 1;\n            this.onActionButtonFocus.emit(\"clear\");\n        }\n    }\n    handleRight() {\n        if (this.actionButtonsVisible && this.focusedIndex === this.lastIndex - 1) {\n            this.focusedIndex += 1;\n            this.onActionButtonFocus.emit(\"upload\");\n        }\n    }\n    handleTab(shifted) {\n        if (this.focusedIndex >= 0 && shifted) {\n            this.focusedIndex = -1;\n            return;\n        }\n        this.onTab.emit();\n    }\n    handleDown() {\n        if (this.lastIndex >= 0 && this.focusedIndex < this.lastIndex) {\n            if (this.focusedIndex < this.lastFileIndex) {\n                this.focusedIndex += 1;\n                this.onFileFocus.emit(this.focusedIndex);\n                return;\n            }\n            if (this.actionButtonsVisible && this.focusedIndex === this.lastFileIndex) {\n                this.focusedIndex += 1;\n                this.onActionButtonFocus.emit(\"clear\");\n            }\n        }\n    }\n    handleUp() {\n        if (this.lastIndex >= 0 && this.focusedIndex > -1) {\n            this.focusedIndex -= 1;\n            if (this.focusedIndex === -1) {\n                this.onSelectButtonFocus.emit();\n                return;\n            }\n            if (this.focusedIndex <= this.lastFileIndex) {\n                this.onFileFocus.emit(this.focusedIndex);\n                return;\n            }\n            if (this.actionButtonsVisible && this.focusedIndex <= this.lastIndex) {\n                this.focusedIndex = this.lastFileIndex;\n                this.onFileFocus.emit(this.focusedIndex);\n            }\n        }\n    }\n    get focusedIndex() {\n        return this._focusedIndex;\n    }\n    set focusedIndex(index) {\n        if (!this.focused) {\n            this.onWrapperFocus.emit();\n        }\n        this._focusedIndex = index;\n        this.focused = true;\n        if (this._focusedIndex >= 0 && this._focusedIndex <= this.lastFileIndex) {\n            this.onFileFocus.emit(index);\n        }\n    }\n    get lastFileIndex() {\n        return this.actionButtonsVisible ? this.lastIndex - 2 : this.lastIndex;\n    }\n    get lastIndex() {\n        const fileCount = this.uploadService.files.count;\n        return this.actionButtonsVisible ? fileCount + 1 : fileCount - 1;\n    }\n}\nNavigationService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nNavigationService.ctorParameters = () => [\n    { type: UploadService }\n];\n\n/**\n * Used to customize the rendering of the files in the list ([see example]({% slug templates_upload %})).\n */\nclass FileTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nFileTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoUploadFileTemplate], [kendoFileSelectFileTemplate]' // tslint:disable-line:directive-selector-prefix\n            },] },\n];\n/** @nocollapse */\nFileTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef }\n];\n\n/**\n * @hidden\n */\nconst FILESELECT_VALUE_ACCESSOR = {\n    multi: true,\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(() => FileSelectComponent) // tslint:disable-line:no-forward-ref\n};\nclass FileSelectComponent {\n    constructor(uploadService, localization, navigation, ngZone, renderer, wrapper) {\n        this.uploadService = uploadService;\n        this.localization = localization;\n        this.navigation = navigation;\n        this.ngZone = ngZone;\n        this.renderer = renderer;\n        /**\n         * Disables the FileSelect.\n         * The default value is `false`.\n         */\n        this.disabled = false;\n        /**\n         * Enables the selection of multiple files\n         * ([see example]({% slug fileprocessing_upload %}#toc-upload-of-sinlge-or-multiple-files)).\n         * If set to `false`, only one file can be selected at a time.\n         */\n        this.multiple = true;\n        /**\n         * Toggles the visibility of the file list.\n         */\n        this.showFileList = true;\n        /**\n         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the FileSelect.\n         */\n        this.tabindex = 0;\n        /**\n         * @hidden\n         */\n        this.focusableId = `k-${guid()}`;\n        /**\n         * Fires when the user navigates outside the component.\n         */\n        this.onBlur = new EventEmitter();\n        /**\n         * Fires when the component is focused.\n         */\n        this.onFocus = new EventEmitter();\n        /**\n         * Fires when files are selected. If prevented, the selected files will not be added to the list.\n         */\n        this.select = new EventEmitter();\n        /**\n         * Fires when a file is about to be removed. If prevented, the file will remain in the list.\n         */\n        this.remove = new EventEmitter();\n        /**\n         * Fires when the value of the component has changed as a result of a successful `select` or `remove` operation.\n         */\n        this.valueChange = new EventEmitter();\n        this.hostDefaultClasses = true;\n        /**\n         * @hidden\n         */\n        this._restrictions = {\n            allowedExtensions: [],\n            maxFileSize: 0,\n            minFileSize: 0\n        };\n        this.onTouchedCallback = (_) => { };\n        this.onChangeCallback = (_) => { };\n        this.wrapper = wrapper.nativeElement;\n        this.direction = localization.rtl ? 'rtl' : 'ltr';\n        this.navigation.computeKeys(this.direction);\n        this.fileList = this.uploadService.files;\n        this.localizationChangeSubscription = localization.changes.subscribe(({ rtl }) => {\n            this.direction = rtl ? 'rtl' : 'ltr';\n            this.navigation.computeKeys(this.direction);\n        });\n        this.subscribeBlur();\n        this.subscribeFocus();\n        this.attachEventHandlers();\n        this.setDefaultSettings();\n    }\n    /**\n     * Sets the `name` attribute of the `input` element of the FileSelect.\n     */\n    set name(name) {\n        this.uploadService.async.saveField = name;\n    }\n    get name() {\n        return this.uploadService.async.saveField;\n    }\n    /**\n     * Sets the restrictions for selected files.\n     */\n    set restrictions(restrictions) {\n        let parsedRestrictions = Object.assign({}, this._restrictions, restrictions);\n        this._restrictions = parsedRestrictions;\n    }\n    get restrictions() {\n        return this._restrictions;\n    }\n    get hostDisabledClass() {\n        return this.disabled;\n    }\n    get dir() {\n        return this.direction;\n    }\n    ngOnInit() {\n        this.renderer.removeAttribute(this.wrapper, \"tabindex\");\n    }\n    /**\n     * @hidden\n     */\n    textFor(key) {\n        return this.localization.get(key);\n    }\n    /**\n     * Focuses the underlying input element.\n     */\n    focus() {\n        setTimeout(() => {\n            this.fileSelectButton.nativeElement.focus();\n        });\n    }\n    ngOnDestroy() {\n        this.fileList.clear();\n        if (this.blurSubscription) {\n            this.blurSubscription.unsubscribe();\n        }\n        if (this.wrapperFocusSubscription) {\n            this.wrapperFocusSubscription.unsubscribe();\n        }\n        if (this.selectButtonFocusSubscription) {\n            this.selectButtonFocusSubscription.unsubscribe();\n        }\n        if (this.localizationChangeSubscription) {\n            this.localizationChangeSubscription.unsubscribe();\n        }\n        if (this.subs) {\n            this.subs.unsubscribe();\n        }\n    }\n    /**\n     * @hidden\n     */\n    handleKeydown(event) {\n        if (this.disabled) {\n            return;\n        }\n        if ((event.keyCode === Keys.Enter || event.keyCode === Keys.Space) &&\n            event.target === this.fileSelectButton.nativeElement) {\n            event.preventDefault();\n            this.fileSelect.nativeElement.click();\n            return;\n        }\n        if (hasClasses(event.target, UPLOAD_CLASSES) ||\n            (!isFocusable(event.target) && !hasClasses(event.target, IGNORE_TARGET_CLASSES))) {\n            this.navigation.process(event);\n        }\n    }\n    /**\n     * @hidden\n     */\n    writeValue(newValue) {\n        let isValid = true;\n        if (newValue instanceof Array) {\n            newValue.forEach((file) => {\n                if (!validateInitialFileInfo(file)) {\n                    isValid = false;\n                }\n            });\n            if (isValid) {\n                this.uploadService.addInitialFiles(newValue);\n            }\n        }\n        if (newValue === null) {\n            this.fileList.clear();\n        }\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.onChangeCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.onTouchedCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n    }\n    /**\n     * Removes specific file from the file list.\n     */\n    removeFileByUid(uid) {\n        this.uploadService.removeFiles(uid);\n    }\n    /**\n     * Visually clears all files from the UI.\n     */\n    clearFiles() {\n        this.uploadService.clearFiles();\n    }\n    /**\n     * @hidden\n     * Used to determine if the component is empty.\n     */\n    isEmpty() {\n        return false;\n    }\n    /**\n     * @hidden\n     */\n    get selectButtonTabIndex() {\n        return this.disabled ? undefined : this.tabindex;\n    }\n    /**\n     * @hidden\n     */\n    onFileSelectButtonFocus(_event) {\n        this.renderer.addClass(this.fileSelectButton.nativeElement, 'k-state-focused');\n        if (!this.navigation.focused) {\n            this.navigation.focusedIndex = -1;\n        }\n    }\n    /**\n     * @hidden\n     */\n    onFileSelectButtonBlur(_event) {\n        this.renderer.removeClass(this.fileSelectButton.nativeElement, 'k-state-focused');\n    }\n    subscribeBlur() {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        this.ngZone.runOutsideAngular(() => {\n            this.documentClick = fromEvent(document, 'click').pipe(filter((event) => {\n                return !(this.wrapper !== event.target && this.wrapper.contains(event.target));\n            }));\n            this.blurSubscription = merge(this.documentClick, this.navigation.onTab).subscribe(() => this.ngZone.run(() => {\n                if (this.navigation.focused) {\n                    this.navigation.focused = false;\n                    this.onTouchedCallback();\n                    this.onBlur.emit();\n                }\n            }));\n        });\n    }\n    subscribeFocus() {\n        this.wrapperFocusSubscription = this.navigation.onWrapperFocus.subscribe(() => {\n            this.onFocus.emit();\n        });\n        this.selectButtonFocusSubscription = this.navigation.onSelectButtonFocus.subscribe(() => {\n            this.fileSelectButton.nativeElement.focus();\n        });\n    }\n    attachEventHandlers() {\n        this.subs = this.uploadService.changeEvent.subscribe((files) => {\n            const rawFiles = files.map(file => file.rawFile);\n            this.onChangeCallback(rawFiles);\n            this.valueChange.emit(rawFiles);\n        });\n        this.subs.add(this.uploadService.removeEvent.subscribe((args) => {\n            this.remove.emit(args);\n        }));\n        this.subs.add(this.uploadService.selectEvent.subscribe((args) => {\n            this.select.emit(args);\n        }));\n    }\n    setDefaultSettings() {\n        this.uploadService.async.autoUpload = false;\n        this.uploadService.component = 'FileSelect';\n    }\n}\nFileSelectComponent.decorators = [\n    { type: Component, args: [{\n                exportAs: 'kendoFileSelect',\n                providers: [\n                    LocalizationService,\n                    NavigationService,\n                    UploadService,\n                    FILESELECT_VALUE_ACCESSOR,\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.fileselect'\n                    },\n                    {\n                        provide: KendoInput,\n                        useExisting: forwardRef(() => FileSelectComponent)\n                    }\n                ],\n                selector: 'kendo-fileselect',\n                template: `\n        <ng-container kendoUploadLocalizedMessages\n            i18n-dropFilesHere=\"kendo.upload.dropFilesHere|The drop zone hint\"\n            dropFilesHere=\"Drop files here to select\"\n\n            i18n-invalidFileExtension=\"kendo.upload.invalidFileExtension|The text for the invalid allowed extensions restriction message\"\n            invalidFileExtension=\"File type not allowed.\"\n\n            i18n-invalidMaxFileSize=\"kendo.upload.invalidMaxFileSize|The text for the invalid max file size restriction message\"\n            invalidMaxFileSize=\"File size too large.\"\n\n            i18n-invalidMinFileSize=\"kendo.upload.invalidMinFileSize|The text for the invalid min file size restriction message\"\n            invalidMinFileSize=\"File size too small.\"\n\n            i18n-remove=\"kendo.upload.remove|The text for the Remove button\"\n            remove=\"Remove\"\n\n            i18n-select=\"kendo.upload.select|The text for the Select button\"\n            select=\"Select files...\"\n        >\n        </ng-container>\n        <div kendoUploadDropzone\n            [restrictions]=\"restrictions\"\n            [multiple]=\"multiple\"\n            [disabled]=\"disabled\">\n            <div role=\"button\" #fileSelectButton\n                [id]=\"focusableId\"\n                [attr.aria-label]=\"textFor('select')\"\n                [attr.tabindex]=\"selectButtonTabIndex\"\n                (focus)=\"onFileSelectButtonFocus($event)\"\n                (blur)=\"onFileSelectButtonBlur($event)\"\n                class=\"k-button k-upload-button\">\n                <input #fileSelect kendoFileSelect\n                    [attr.accept]=\"accept ? accept : null\"\n                    [dir]=\"direction\"\n                    [restrictions]=\"restrictions\"\n                    [multiple]=\"multiple\"\n                    [disabled]=\"disabled\" />\n                <span>{{textFor('select')}}</span>\n            </div>\n            <div class=\"k-dropzone-hint\">{{textFor('dropFilesHere')}}</div>\n        </div>\n        <ul kendo-upload-file-list\n            class=\"k-upload-files k-reset\"\n            *ngIf=\"showFileList && fileList.count > 0\"\n            [disabled]=\"disabled\"\n            [fileList]=\"fileList.files\"\n            [fileTemplate]=\"fileTemplate\">\n        </ul>\n    `\n            },] },\n];\n/** @nocollapse */\nFileSelectComponent.ctorParameters = () => [\n    { type: UploadService },\n    { type: LocalizationService },\n    { type: NavigationService },\n    { type: NgZone },\n    { type: Renderer2 },\n    { type: ElementRef }\n];\nFileSelectComponent.propDecorators = {\n    accept: [{ type: Input }],\n    disabled: [{ type: Input }],\n    multiple: [{ type: Input }],\n    name: [{ type: Input }],\n    showFileList: [{ type: Input }],\n    tabindex: [{ type: Input }],\n    restrictions: [{ type: Input }],\n    focusableId: [{ type: Input }],\n    fileTemplate: [{ type: ContentChild, args: [FileTemplateDirective,] }],\n    fileSelect: [{ type: ViewChild, args: ['fileSelect',] }],\n    fileSelectButton: [{ type: ViewChild, args: ['fileSelectButton',] }],\n    onBlur: [{ type: Output, args: ['blur',] }],\n    onFocus: [{ type: Output, args: ['focus',] }],\n    select: [{ type: Output }],\n    remove: [{ type: Output }],\n    valueChange: [{ type: Output }],\n    hostDefaultClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-upload',] }, { type: HostBinding, args: ['class.k-header',] }],\n    hostDisabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }],\n    dir: [{ type: HostBinding, args: ['attr.dir',] }],\n    handleKeydown: [{ type: HostListener, args: ['keydown', ['$event'],] }]\n};\n\n/**\n * @hidden\n */\nclass Messages extends ComponentMessages {\n}\nMessages.propDecorators = {\n    cancel: [{ type: Input }],\n    clearSelectedFiles: [{ type: Input }],\n    dropFilesHere: [{ type: Input }],\n    headerStatusPaused: [{ type: Input }],\n    headerStatusUploaded: [{ type: Input }],\n    headerStatusUploading: [{ type: Input }],\n    invalidFileExtension: [{ type: Input }],\n    invalidFiles: [{ type: Input }],\n    invalidMaxFileSize: [{ type: Input }],\n    invalidMinFileSize: [{ type: Input }],\n    pause: [{ type: Input }],\n    remove: [{ type: Input }],\n    resume: [{ type: Input }],\n    retry: [{ type: Input }],\n    select: [{ type: Input }],\n    uploadSelectedFiles: [{ type: Input }]\n};\n\n/**\n * Custom component messages override default component messages.\n */\nclass CustomMessagesComponent extends Messages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n    get override() {\n        return true;\n    }\n}\nCustomMessagesComponent.decorators = [\n    { type: Component, args: [{\n                providers: [\n                    {\n                        provide: Messages,\n                        useExisting: forwardRef(() => CustomMessagesComponent) // tslint:disable-line:no-forward-ref\n                    }\n                ],\n                selector: 'kendo-upload-messages, kendo-fileselect-messages',\n                template: ``\n            },] },\n];\n/** @nocollapse */\nCustomMessagesComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\nconst INVALIDMAXFILESIZE = \"invalidMaxFileSize\";\nconst INVALIDMINFILESIZE = \"invalidMinFileSize\";\nconst INVALIDFILEEXTENSION = \"invalidFileExtension\";\nconst validateFileExtension = (file, allowedExtensions) => {\n    if (allowedExtensions.length > 0) {\n        if (allowedExtensions.indexOf(file.extension.toLowerCase()) < 0) {\n            file.validationErrors = file.validationErrors || [];\n            if (file.validationErrors.indexOf(INVALIDFILEEXTENSION) < 0) {\n                file.validationErrors.push(INVALIDFILEEXTENSION);\n            }\n        }\n    }\n};\nconst validateFileSize = (file, minFileSize, maxFileSize) => {\n    if (minFileSize !== 0 && file.size < minFileSize) {\n        file.validationErrors = file.validationErrors || [];\n        if (file.validationErrors.indexOf(INVALIDMINFILESIZE) < 0) {\n            file.validationErrors.push(INVALIDMINFILESIZE);\n        }\n    }\n    if (maxFileSize !== 0 && file.size > maxFileSize) {\n        file.validationErrors = file.validationErrors || [];\n        if (file.validationErrors.indexOf(INVALIDMAXFILESIZE) < 0) {\n            file.validationErrors.push(INVALIDMAXFILESIZE);\n        }\n    }\n};\nconst parseAllowedExtensions = (extensions) => {\n    const allowedExtensions = extensions.map((ext) => {\n        var parsedExt = (ext.substring(0, 1) === \".\") ? ext : (\".\" + ext);\n        return parsedExt.toLowerCase();\n    });\n    return allowedExtensions;\n};\n/**\n * @hidden\n */\nconst validateFiles = (files, restrictionInfo) => {\n    const allowedExtensions = parseAllowedExtensions(restrictionInfo.allowedExtensions);\n    const maxFileSize = restrictionInfo.maxFileSize;\n    const minFileSize = restrictionInfo.minFileSize;\n    let i;\n    for (i = 0; i < files.length; i++) {\n        validateFileExtension(files[i], allowedExtensions);\n        validateFileSize(files[i], minFileSize, maxFileSize);\n    }\n};\n\n/**\n * @hidden\n */\nclass DropZoneDirective {\n    constructor(element, uploadService, _ngZone, renderer) {\n        this.element = element;\n        this.uploadService = uploadService;\n        this._ngZone = _ngZone;\n        this.renderer = renderer;\n        this.hideIntervalDocument = null;\n        this.hideIntervalElement = null;\n        this.state = {\n            active: \"k-dropzone k-dropzone-active\",\n            hovered: \"k-dropzone k-dropzone-active k-dropzone-hovered\",\n            inactive: \"k-dropzone\"\n        };\n        this.element = element;\n        this.setClasses(this.state.inactive);\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        this._ngZone.runOutsideAngular(() => {\n            this.unsubscribeDocumentDragEnter = this.renderer.listen('document', 'dragenter', () => this.onDocumentDragEnter());\n            this.unsubscribeDocumentDragOver = this.renderer.listen('document', 'dragover', () => this.onDocumentDragOver());\n        });\n    }\n    ngOnDestroy() {\n        this._ngZone.runOutsideAngular(() => {\n            if (this.unsubscribeDocumentDragEnter) {\n                this.unsubscribeDocumentDragEnter();\n            }\n            if (this.unsubscribeDocumentDragOver) {\n                this.unsubscribeDocumentDragOver();\n            }\n        });\n    }\n    /**\n     * @hidden\n     */\n    onDocumentDragEnter() {\n        if (this.lastDragElement) {\n            if (this.calculateTimeDiff(this.lastDragElement) > 100) {\n                this.setClasses(this.state.active);\n            }\n        }\n        else {\n            this.setClasses(this.state.active);\n        }\n        this.lastDragDocument = new Date();\n        if (!this.hideIntervalDocument) {\n            this.hideIntervalDocument = setInterval(() => {\n                if (this.calculateTimeDiff(this.lastDragDocument) < 100) {\n                    return;\n                }\n                this.setClasses(this.state.inactive);\n                clearInterval(this.hideIntervalDocument);\n                this.hideIntervalDocument = null;\n            }, 100);\n        }\n        return false;\n    }\n    /**\n     * @hidden\n     */\n    onDocumentDragOver() {\n        this.lastDragDocument = new Date();\n        return false;\n    }\n    /**\n     * @hidden\n     */\n    onElementDragEnterListener() {\n        this.setClasses(this.state.hovered);\n        this.lastDragElement = new Date();\n        if (!this.hideIntervalElement) {\n            this.hideIntervalElement = setInterval(() => {\n                if (this.calculateTimeDiff(this.lastDragElement) < 100) {\n                    return;\n                }\n                if (this.lastDrop) {\n                    let diff = this.calculateTimeDiff(this.lastDrop);\n                    this.setClasses(diff > 200 ? this.state.active : this.state.inactive);\n                }\n                else {\n                    this.setClasses(this.state.active);\n                }\n                clearInterval(this.hideIntervalElement);\n                this.hideIntervalElement = null;\n            }, 100);\n        }\n        return false;\n    }\n    /**\n     * @hidden\n     */\n    onElementDragOverListener() {\n        this.lastDragElement = new Date();\n        return false;\n    }\n    /**\n     * @hidden\n     */\n    onDropListener(event) {\n        this.lastDrop = new Date();\n        let droppedFiles = event.dataTransfer.files;\n        if (droppedFiles.length > 0 && !this.disabled) {\n            let files = getAllFileInfo(droppedFiles);\n            files = assignGuidToFiles(files, !this.uploadService.async.batch);\n            if (!this.multiple) {\n                files.splice(1, files.length - 1);\n                this.uploadService.clearFiles();\n            }\n            validateFiles(files, this.restrictions);\n            this.uploadService.addFiles(files);\n        }\n        return false;\n    }\n    calculateTimeDiff(prevEvent) {\n        return new Date().getTime() - prevEvent.getTime();\n    }\n    setClasses(classes) {\n        if (!this.disabled) {\n            this.element.nativeElement.className = classes;\n        }\n    }\n    /**\n     * @hidden\n     */\n    get initialClassName() {\n        return true;\n    }\n}\nDropZoneDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoUploadDropzone]'\n            },] },\n];\n/** @nocollapse */\nDropZoneDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: UploadService },\n    { type: NgZone },\n    { type: Renderer2 }\n];\nDropZoneDirective.propDecorators = {\n    disabled: [{ type: Input }],\n    multiple: [{ type: Input }],\n    restrictions: [{ type: Input }],\n    onElementDragEnterListener: [{ type: HostListener, args: ['dragenter',] }],\n    onElementDragOverListener: [{ type: HostListener, args: ['dragover',] }],\n    onDropListener: [{ type: HostListener, args: ['drop', ['$event'],] }],\n    initialClassName: [{ type: HostBinding, args: ['class.k-dropzone',] }]\n};\n\n/**\n * @hidden\n */\nclass FileListItemDirective {\n    constructor(el, navigationService) {\n        this.navigationService = navigationService;\n        this.fileClass = true;\n        this.focused = false;\n        this.element = el;\n    }\n    focus() {\n        this.element.nativeElement.focus();\n    }\n    get uidAttribute() {\n        return this.files[0].uid;\n    }\n    get tabIndex() {\n        return \"-1\";\n    }\n    get kFileError() {\n        return this.files[0].state === FileState.Failed;\n    }\n    get kFileInvalid() {\n        return filesHaveValidationErrors(this.files);\n    }\n    get kFileProgress() {\n        return this.files[0].state === FileState.Uploading ||\n            this.files[0].state === FileState.Paused;\n    }\n    get kFileSuccess() {\n        return this.files[0].state === FileState.Uploaded ||\n            this.files[0].state === FileState.Initial;\n    }\n    get kStateFocused() {\n        return this.focused;\n    }\n    onFocus() {\n        this.focused = true;\n    }\n    onBlur() {\n        this.focused = false;\n    }\n    onClick(event) {\n        if (!isFocusable(event.target) && !hasClasses(event.target, IGNORE_TARGET_CLASSES)) {\n            this.navigationService.focusedIndex = this.index;\n        }\n    }\n}\nFileListItemDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoUploadFileListItem]'\n            },] },\n];\n/** @nocollapse */\nFileListItemDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: NavigationService }\n];\nFileListItemDirective.propDecorators = {\n    files: [{ type: Input }],\n    index: [{ type: Input }],\n    fileClass: [{ type: HostBinding, args: ['class.k-file',] }],\n    uidAttribute: [{ type: HostBinding, args: ['attr.data-uid',] }],\n    tabIndex: [{ type: HostBinding, args: ['attr.tabIndex',] }],\n    kFileError: [{ type: HostBinding, args: ['class.k-file-error',] }],\n    kFileInvalid: [{ type: HostBinding, args: ['class.k-file-invalid',] }],\n    kFileProgress: [{ type: HostBinding, args: ['class.k-file-progress',] }],\n    kFileSuccess: [{ type: HostBinding, args: ['class.k-file-success',] }],\n    kStateFocused: [{ type: HostBinding, args: ['class.k-state-focused',] }],\n    onFocus: [{ type: HostListener, args: [\"focus\",] }],\n    onBlur: [{ type: HostListener, args: [\"blur\",] }],\n    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]\n};\n\n/* tslint:disable:component-selector */\n/**\n * @hidden\n */\nclass FileListComponent {\n    constructor(uploadService, navigation) {\n        this.uploadService = uploadService;\n        this.navigation = navigation;\n        this.onItemFocus();\n        this.onItemAction();\n    }\n    onItemFocus() {\n        this.focusSubscription = this.navigation.onFileFocus.subscribe((index) => {\n            this.fileListItems.toArray()[index].focus();\n        });\n    }\n    onItemAction() {\n        this.actionSubscription = this.navigation.onFileAction.subscribe((key) => {\n            this.itemActionHandler(key);\n        });\n    }\n    itemActionHandler(key) {\n        let index = this.navigation.focusedIndex;\n        let item = this.fileListItems.toArray()[index];\n        let uid = item.uidAttribute;\n        let files = this.uploadService.files.get(uid);\n        if (key === Keys.Escape && files[0].state === FileState.Uploading) {\n            this.uploadService.cancelFiles(uid);\n            this.navigation.focusSelectButton();\n            return;\n        }\n        if (key === Keys.Enter && files[0].state === FileState.Failed) {\n            this.uploadService.retryFiles(uid);\n            return;\n        }\n        if (key === Keys.Delete) {\n            if (files[0].state === FileState.Uploading) {\n                this.uploadService.cancelFiles(uid);\n            }\n            else if (this.hasDelete(item)) {\n                this.uploadService.removeFiles(uid);\n            }\n            this.navigation.focusSelectButton();\n        }\n    }\n    hasDelete(item) {\n        return item.element.nativeElement.getElementsByClassName('k-delete').length > 0;\n    }\n    ngOnDestroy() {\n        this.focusSubscription.unsubscribe();\n        this.actionSubscription.unsubscribe();\n    }\n}\nFileListComponent.decorators = [\n    { type: Component, args: [{\n                selector: '[kendo-upload-file-list]',\n                template: `\n    <ng-template ngFor\n      [ngForOf]=\"fileList\"\n      let-files\n      let-index=\"index\">\n      <li kendoUploadFileListItem [files]='files' [index]='index'>\n          <kendo-upload-file-list-single-item\n            class='k-file-single'\n            *ngIf='files.length === 1 && !fileTemplate'\n            [disabled]='disabled'\n            [file]='files[0]'>\n          </kendo-upload-file-list-single-item>\n          <kendo-upload-file-list-multiple-items\n            class='k-file-multiple'\n            *ngIf='files.length > 1 && !fileTemplate'\n            [disabled]='disabled'\n            [files]='files'>\n          </kendo-upload-file-list-multiple-items>\n          <ng-template *ngIf=\"fileTemplate\"\n              [templateContext]=\"{\n                templateRef: fileTemplate.templateRef,\n                state: files[0].state,\n                $implicit: files\n              }\"></ng-template>\n      </li>\n    </ng-template>\n    `\n            },] },\n];\n/** @nocollapse */\nFileListComponent.ctorParameters = () => [\n    { type: UploadService },\n    { type: NavigationService }\n];\nFileListComponent.propDecorators = {\n    disabled: [{ type: Input }],\n    fileList: [{ type: Input }],\n    fileTemplate: [{ type: Input }],\n    fileListItems: [{ type: ViewChildren, args: [FileListItemDirective,] }]\n};\n\n/**\n * @hidden\n */\nclass FileListItemActionButtonComponent {\n    constructor(uploadService, localization) {\n        this.uploadService = uploadService;\n        this.localization = localization;\n        this.actionFocused = false;\n        this.retryFocused = false;\n        this.pauseResumeFocused = false;\n    }\n    onFocus(type) {\n        if (type === 'action') {\n            this.actionFocused = true;\n        }\n        if (type === 'retry') {\n            this.retryFocused = true;\n        }\n        if (type === 'pauseResume') {\n            this.pauseResumeFocused = true;\n        }\n    }\n    onBlur(type) {\n        if (type === 'retry') {\n            this.retryFocused = false;\n        }\n        if (type === 'action') {\n            this.actionFocused = false;\n        }\n        if (type === 'pauseResume') {\n            this.pauseResumeFocused = false;\n        }\n    }\n    onRetryClick() {\n        if (this.disabled) {\n            return;\n        }\n        this.uploadService.retryFiles(this.file.uid);\n    }\n    onRemoveCancelClick() {\n        if (this.disabled) {\n            return;\n        }\n        const uid = this.file.uid;\n        if (this.file.state === FileState.Uploading) {\n            this.uploadService.cancelFiles(uid);\n        }\n        else {\n            this.uploadService.removeFiles(uid);\n        }\n    }\n    onPauseResumeClick() {\n        if (this.disabled) {\n            return;\n        }\n        const uid = this.file.uid;\n        if (this.file.state === FileState.Paused) {\n            this.uploadService.resumeFile(uid);\n        }\n        else {\n            this.uploadService.pauseFile(uid);\n        }\n    }\n    get actionButtonTitle() {\n        if (this.file.state === FileState.Uploading) {\n            return this.localization.get('cancel');\n        }\n        return this.localization.get('remove');\n    }\n    get retryButtonTitle() {\n        return this.localization.get('retry');\n    }\n    get pauseResumeButtonTitle() {\n        if (this.file.state === FileState.Uploading) {\n            return this.localization.get('pause');\n        }\n        return this.localization.get('resume');\n    }\n    get isUploading() {\n        return this.file.state === FileState.Uploading;\n    }\n    get isFailed() {\n        return this.file.state === FileState.Failed;\n    }\n    get isPaused() {\n        return this.file.state === FileState.Paused;\n    }\n    get isResumable() {\n        const service = this.uploadService;\n        const isResumable = service.async.chunk && service.chunk.resumable;\n        const isUploading = (this.file.state === FileState.Paused) || (this.file.state === FileState.Uploading);\n        return isResumable && isUploading;\n    }\n    get isActionButtonVisible() {\n        if ((this.file.state === FileState.Uploaded || this.file.state === FileState.Initial) &&\n            !this.uploadService.async.removeUrl && this.uploadService.component === 'Upload') {\n            return false;\n        }\n        return true;\n    }\n}\nFileListItemActionButtonComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-upload-file-list-item-action-button',\n                template: `\n      <strong class=\"k-upload-status\">\n        <span class=\"k-upload-pct\" *ngIf=\"isUploading || isPaused\">{{progress}}%</span>\n\n        <button type=\"button\" *ngIf=\"isFailed\" class=\"k-button k-upload-action\"\n          [ngClass]=\"{ 'k-state-focused': this.retryFocused }\"\n          [attr.tabIndex]=\"-1\"\n          (focus)=\"onFocus('retry')\"\n          (blur)=\"onBlur('retry')\"\n          (click)=\"onRetryClick()\">\n          <span class=\"k-icon k-retry k-i-refresh-sm\"\n            [attr.aria-label]=\"retryButtonTitle\"\n            [attr.title]=\"retryButtonTitle\">\n          </span>\n        </button>\n\n        <button *ngIf=\"isResumable\" type=\"button\" class=\"k-button k-upload-action\"\n          [ngClass]=\"{ 'k-state-focused': this.pauseResumeFocused }\"\n          [attr.tabIndex]=\"-1\"\n          (focus)=\"onFocus('pauseResume')\"\n          (blur)=\"onBlur('pauseResume')\"\n          (click)=\"onPauseResumeClick()\">\n          <span class=\"k-icon\"\n            [ngClass]=\"{\n              'k-i-play-sm': isPaused,\n              'k-i-pause-sm': !isPaused\n            }\"\n            [attr.aria-label]='pauseResumeButtonTitle'\n            [attr.title]='pauseResumeButtonTitle'>\n          </span>\n        </button>\n\n        <button type=\"button\" *ngIf=\"isActionButtonVisible\" class=\"k-button k-upload-action\"\n          [ngClass]=\"{ 'k-state-focused': this.actionFocused }\"\n          [attr.tabIndex]=\"-1\"\n          (focus)=\"onFocus('action')\"\n          (blur)=\"onBlur('action')\"\n          (click)=\"onRemoveCancelClick()\">\n          <span class=\"k-icon\"\n            [ngClass]=\"{\n              'k-cancel k-i-deny': isUploading,\n              'k-delete k-i-x': !isUploading\n            }\"\n            [attr.aria-label]='actionButtonTitle'\n            [attr.title]='actionButtonTitle'>\n          </span>\n        </button>\n      </strong>\n    `\n            },] },\n];\n/** @nocollapse */\nFileListItemActionButtonComponent.ctorParameters = () => [\n    { type: UploadService },\n    { type: LocalizationService }\n];\nFileListItemActionButtonComponent.propDecorators = {\n    file: [{ type: Input }],\n    disabled: [{ type: Input }],\n    progress: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nclass FileListItemBase {\n    constructor(uploadService) {\n        this.uploadService = uploadService;\n        this.progressComplete = 0;\n    }\n    subscribeUploadProgress(uploadProgressHandler) {\n        this.uploadProgressSubscription = this.uploadService.uploadProgressEvent.subscribe(uploadProgressHandler);\n    }\n    fileHasValidationErrors(file) {\n        return fileHasValidationErrors(file);\n    }\n    filesHaveValidationErrors(files) {\n        return filesHaveValidationErrors(files);\n    }\n    ngOnDestroy() {\n        this.uploadProgressSubscription.unsubscribe();\n    }\n    getFileValidationMessage(file) {\n        let validationMessage;\n        if (file.validationErrors && file.validationErrors.length > 0) {\n            validationMessage = this.localization.get(file.validationErrors[0]);\n        }\n        return validationMessage;\n    }\n    getInvalidFilesMessage() {\n        return this.localization.get('invalidFiles');\n    }\n    getTotalFilesSizeMessage(files) {\n        return getTotalFilesSizeMessage(files);\n    }\n}\n\n/**\n * @hidden\n */\nclass FileListMultipleItemsComponent extends FileListItemBase {\n    constructor(localization, uploadService) {\n        super(uploadService);\n        this.localization = localization;\n        this.subscribeUploadProgress((args) => {\n            if (args.files[0].uid === this.files[0].uid) {\n                this.progressComplete = args.percentComplete;\n            }\n        });\n    }\n    /**\n     * @hidden\n     */\n    setFileNameClasses(file) {\n        return {\n            \"k-file-name\": true,\n            \"k-file-name-invalid\": super.fileHasValidationErrors(file)\n        };\n    }\n    /**\n     * @hidden\n     */\n    get showProgress() {\n        const showProgress = this.files[0].state === FileState.Uploading || this.files[0].state === FileState.Paused;\n        return showProgress ? 'active' : 'inactive';\n    }\n    ngOnInit() {\n        this.filesHaveErrors = super.filesHaveValidationErrors(this.files);\n    }\n}\nFileListMultipleItemsComponent.decorators = [\n    { type: Component, args: [{\n                animations: [\n                    trigger('progressState', [\n                        state('active', style({ opacity: 1 })),\n                        state('inactive', style({ opacity: 0 })),\n                        transition('void => active', style({ opacity: 0 })),\n                        transition('inactive => active', style({ opacity: 1 })),\n                        transition('active => inactive', animate('1s 2s ease-out'))\n                    ])\n                ],\n                selector: 'kendo-upload-file-list-multiple-items',\n                template: `\n      <span class=\"k-progress\" [style.width]=\"progressComplete + '%'\" [@progressState]=\"showProgress\"></span>\n      <span *ngIf=\"!filesHaveErrors\" class=\"k-multiple-files-extension-wrapper\">\n        <span class=\"k-file-state\"></span>\n      </span>\n      <span *ngIf=\"filesHaveErrors\" class=\"k-multiple-files-invalid-extension-wrapper\">\n        <span class='k-file-invalid-icon'>!</span>\n        <span class=\"k-file-state\"></span>\n      </span>\n      <span class=\"k-file-name-size-wrapper\">\n        <span *ngFor=\"let file of files\"\n          [title]=\"file.name\"\n          [ngClass]=\"setFileNameClasses(file)\"\n        >\n          {{file.name}}\n        </span>\n        <span *ngIf=\"!filesHaveErrors\"\n              class=\"k-file-information\">Total: {{ files.length }} files, {{ getTotalFilesSizeMessage(files) }}</span>\n        <span *ngIf=\"filesHaveErrors\" class=\"k-file-validation-message\">{{ getInvalidFilesMessage() }}</span>\n      </span>\n      <kendo-upload-file-list-item-action-button\n        [file]='files[0]'\n        [disabled]='disabled'\n        [progress]='progressComplete'>\n      </kendo-upload-file-list-item-action-button>\n    `\n            },] },\n];\n/** @nocollapse */\nFileListMultipleItemsComponent.ctorParameters = () => [\n    { type: LocalizationService },\n    { type: UploadService }\n];\nFileListMultipleItemsComponent.propDecorators = {\n    disabled: [{ type: Input }],\n    files: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nclass FileListSingleItemComponent extends FileListItemBase {\n    constructor(localization, uploadService) {\n        super(uploadService);\n        this.localization = localization;\n        this.subscribeUploadProgress((args) => {\n            if (args.files[0].uid === this.file.uid) {\n                this.progressComplete = args.percentComplete;\n            }\n        });\n    }\n    /**\n     * @hidden\n     */\n    textFor(key) {\n        return this.localization.get(key);\n    }\n    /**\n     * @hidden\n     */\n    getFileExtension(file) {\n        return file.extension ? file.extension.substring(1) : '';\n    }\n    /**\n     * @hidden\n     */\n    get showProgress() {\n        const showProgress = this.file.state === FileState.Uploading || this.file.state === FileState.Paused;\n        return showProgress ? 'active' : 'inactive';\n    }\n}\nFileListSingleItemComponent.decorators = [\n    { type: Component, args: [{\n                animations: [\n                    trigger('progressState', [\n                        state('active', style({ opacity: 1 })),\n                        state('inactive', style({ opacity: 0 })),\n                        transition('void => active', style({ opacity: 0 })),\n                        transition('inactive => active', style({ opacity: 1 })),\n                        transition('active => inactive', animate('1s 2s ease-out'))\n                    ])\n                ],\n                selector: 'kendo-upload-file-list-single-item',\n                template: `\n      <span class=\"k-progress\" [style.width]=\"progressComplete + '%'\" [@progressState]=\"showProgress\"></span>\n      <ng-template [ngIf]='file.validationErrors && file.validationErrors.length > 0'>\n        <span class=\"k-file-invalid-extension-wrapper\">\n          <span class=\"k-file-invalid-icon\">!</span>\n          <span class=\"k-file-state\"></span>\n        </span>\n        <span class=\"k-file-name-size-wrapper\">\n          <span class=\"k-file-name k-file-name-invalid\" [title]=\"file.name\">{{ file.name }}</span>\n          <span class=\"k-file-validation-message\">{{ getFileValidationMessage(file) }}</span>\n        </span>\n      </ng-template>\n      <ng-template [ngIf]='!file.validationErrors || file.validationErrors.length === 0'>\n        <span class=\"k-file-extension-wrapper\">\n          <span class=\"k-file-extension\">{{ getFileExtension(file) }}</span>\n          <span class=\"k-file-state\"></span>\n        </span>\n        <span class=\"k-file-name-size-wrapper\">\n          <span class=\"k-file-name\" [title]=\"file.name\">{{ file.name }}</span>\n          <span class=\"k-file-size\">{{ getTotalFilesSizeMessage([file]) }}</span>\n        </span>\n      </ng-template>\n      <kendo-upload-file-list-item-action-button\n        [file]='file'\n        [disabled]='disabled'\n        [progress]='progressComplete'>\n      </kendo-upload-file-list-item-action-button>\n    `\n            },] },\n];\n/** @nocollapse */\nFileListSingleItemComponent.ctorParameters = () => [\n    { type: LocalizationService },\n    { type: UploadService }\n];\nFileListSingleItemComponent.propDecorators = {\n    disabled: [{ type: Input }],\n    file: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nclass FileSelectDirective {\n    constructor(uploadService, navigation, el) {\n        this.uploadService = uploadService;\n        this.navigation = navigation;\n        this.type = \"file\";\n        this.autocomplete = \"off\";\n        this.tabIndex = -1;\n        this.element = el;\n    }\n    get nameAttribute() {\n        return this.uploadService.async.saveField;\n    }\n    get multipleAttribute() {\n        return this.multiple ? \"multiple\" : null;\n    }\n    get dirAttribute() {\n        return this.dir;\n    }\n    get disabledAttribute() {\n        return this.disabled ? \"true\" : null;\n    }\n    onInputChange(event) {\n        const ua = navigator.userAgent;\n        const chrome = /(chrome)[ \\/]([\\w.]+)/i;\n        const safari = /(webkit)[ \\/]([\\w.]+)/i;\n        let selectedFiles = inputFiles(event.target);\n        selectedFiles = assignGuidToFiles(selectedFiles, !this.uploadService.async.batch);\n        validateFiles(selectedFiles, this.restrictions);\n        if (!this.multiple) {\n            this.uploadService.clearFiles();\n        }\n        this.uploadService.addFiles(selectedFiles);\n        /*\n        Chrome and Internet Explorer do not trigger a `change` event\n        when a file with the same name is selected a number of consecutive times.\n        As a workaround, clear the input value after handling the file.\n        */\n        const native = this.element.nativeElement;\n        if (!(!ua.match(chrome) && ua.match(safari))) {\n            native.type = \"\";\n            native.type = \"file\";\n        }\n        setTimeout(() => {\n            this.navigation.focusedIndex = -1;\n        });\n    }\n}\nFileSelectDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoFileSelect]'\n            },] },\n];\n/** @nocollapse */\nFileSelectDirective.ctorParameters = () => [\n    { type: UploadService },\n    { type: NavigationService },\n    { type: ElementRef }\n];\nFileSelectDirective.propDecorators = {\n    dir: [{ type: Input }],\n    disabled: [{ type: Input }],\n    multiple: [{ type: Input }],\n    restrictions: [{ type: Input }],\n    type: [{ type: HostBinding, args: [\"attr.type\",] }],\n    autocomplete: [{ type: HostBinding, args: [\"attr.autocomplete\",] }],\n    tabIndex: [{ type: HostBinding, args: [\"attr.tabindex\",] }],\n    nameAttribute: [{ type: HostBinding, args: [\"attr.name\",] }],\n    multipleAttribute: [{ type: HostBinding, args: [\"attr.multiple\",] }],\n    dirAttribute: [{ type: HostBinding, args: [\"attr.dir\",] }],\n    disabledAttribute: [{ type: HostBinding, args: [\"attr.disabled\",] }],\n    onInputChange: [{ type: HostListener, args: [\"change\", [\"$event\"],] }]\n};\n\n/**\n * @hidden\n */\nclass LocalizedMessagesDirective extends Messages {\n    constructor(service) {\n        super();\n        this.service = service;\n    }\n}\nLocalizedMessagesDirective.decorators = [\n    { type: Directive, args: [{\n                providers: [\n                    {\n                        provide: Messages,\n                        useExisting: forwardRef(() => LocalizedMessagesDirective) // tslint:disable-line:no-forward-ref\n                    }\n                ],\n                selector: '[kendoUploadLocalizedMessages]'\n            },] },\n];\n/** @nocollapse */\nLocalizedMessagesDirective.ctorParameters = () => [\n    { type: LocalizationService }\n];\n\n/**\n * @hidden\n */\nclass TemplateContextDirective {\n    constructor(viewContainerRef) {\n        this.viewContainerRef = viewContainerRef;\n    }\n    set templateContext(context) {\n        if (this.insertedViewRef) {\n            this.viewContainerRef.remove(this.viewContainerRef.indexOf(this.insertedViewRef));\n            this.insertedViewRef = undefined;\n        }\n        if (context.templateRef) {\n            this.insertedViewRef = this.viewContainerRef.createEmbeddedView(context.templateRef, context);\n        }\n    }\n}\nTemplateContextDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[templateContext]' // tslint:disable-line:directive-selector\n            },] },\n];\n/** @nocollapse */\nTemplateContextDirective.ctorParameters = () => [\n    { type: ViewContainerRef }\n];\nTemplateContextDirective.propDecorators = {\n    templateContext: [{ type: Input }]\n};\n\n/**\n * @hidden\n */\nconst SHARED_DECLARATIONS = [\n    DropZoneDirective,\n    FileListComponent,\n    FileListItemDirective,\n    FileListItemActionButtonComponent,\n    FileListMultipleItemsComponent,\n    FileListSingleItemComponent,\n    FileSelectDirective,\n    LocalizedMessagesDirective,\n    TemplateContextDirective\n];\n/**\n * @hidden\n */\nconst PUBLIC_DIRECTIVES = [\n    FileTemplateDirective,\n    CustomMessagesComponent\n];\n/**\n * @hidden\n */\nclass SharedModule {\n}\nSharedModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [\n                    PUBLIC_DIRECTIVES,\n                    SHARED_DECLARATIONS\n                ],\n                exports: [\n                    PUBLIC_DIRECTIVES,\n                    SHARED_DECLARATIONS,\n                    CommonModule\n                ],\n                imports: [CommonModule]\n            },] },\n];\n\nconst FILESELECT_DECLARATIONS = [\n    FileSelectComponent\n];\n/**\n * Represents the [NgModule](https://angular.io/api/core/NgModule) definition for the FileSelect component.\n */\nclass FileSelectModule {\n}\nFileSelectModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [FILESELECT_DECLARATIONS],\n                exports: [\n                    PUBLIC_DIRECTIVES,\n                    FILESELECT_DECLARATIONS\n                ],\n                imports: [SharedModule]\n            },] },\n];\n\n/* tslint:disable: no-use-before-declare */\n/**\n * @hidden\n */\nconst UPLOAD_VALUE_ACCESSOR = {\n    multi: true,\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(() => UploadComponent) // tslint:disable-line:no-forward-ref\n};\n/**\n * Represents the [Kendo UI Upload component for Angular]({% slug overview_upload %}).\n */\nclass UploadComponent {\n    constructor(uploadService, localization, navigation, _ngZone, renderer, wrapper) {\n        this.uploadService = uploadService;\n        this.localization = localization;\n        this.navigation = navigation;\n        this._ngZone = _ngZone;\n        this.renderer = renderer;\n        /**\n         * Enables the chunk functionality of the Upload.\n         *\n         * The default value is `false`.\n         */\n        this.chunkable = false;\n        /**\n         * Enables the selection of multiple files\n         * ([see example]({% slug fileprocessing_upload %}#toc-upload-of-sinlge-or-multiple-files)).\n         * If set to `false`, only one file can be selected at a time.\n         */\n        this.multiple = true;\n        /**\n         * Disables the Upload ([see example]({% slug disabledstate_upload %})).\n         * The default value is `false`.\n         */\n        this.disabled = false;\n        /**\n         * Toggles the visibility of the file list.\n         */\n        this.showFileList = true;\n        /**\n         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n         */\n        this.tabindex = 0;\n        /**\n         * @hidden\n         */\n        this.focusableId = `k-${guid()}`;\n        /**\n         * Fires when the user navigates outside the component.\n         */\n        this.onBlur = new EventEmitter();\n        /**\n         * Fires when the upload is canceled while in progress.\n         */\n        this.cancel = new EventEmitter();\n        /**\n         * Fires when the file list is about to be cleared. If prevented, the files will not be cleared.\n         */\n        this.clear = new EventEmitter();\n        /**\n         * Fires when all active uploads are completed either successfully or with errors.\n         */\n        this.complete = new EventEmitter();\n        /**\n         * Fires when an `upload` or `remove` operation has failed.\n         */\n        this.error = new EventEmitter();\n        /**\n         * Fires when the component is focused.\n         */\n        this.onFocus = new EventEmitter();\n        /**\n         * Fires when the upload of a file has been paused.\n         */\n        this.pause = new EventEmitter();\n        /**\n         * Fires when an uploaded file is about to be removed. If prevented, the files will remain in the list.\n         */\n        this.remove = new EventEmitter();\n        /**\n         * Fires when the upload of a file has been resumed.\n         */\n        this.resume = new EventEmitter();\n        /**\n         * Fires when files are selected. If prevented, the selected files will not be added to the list.\n         */\n        this.select = new EventEmitter();\n        /**\n         * Fires when an `upload` or `remove` operation is successfully completed.\n         */\n        this.success = new EventEmitter();\n        /**\n         * Fires when one or more files are about to be uploaded. If prevented, the files will neither be uploaded, nor added to the file list.\n         */\n        this.upload = new EventEmitter();\n        /**\n         * Fires when one or more files are being uploaded.\n         */\n        this.uploadProgress = new EventEmitter();\n        /**\n         * Fires when the value of the component has changed as a result of a successful `upload`, `remove` or `clear` operation.\n         */\n        this.valueChange = new EventEmitter();\n        this.hostDefaultClasses = true;\n        /**\n         * @hidden\n         */\n        this._restrictions = {\n            allowedExtensions: [],\n            maxFileSize: 0,\n            minFileSize: 0\n        };\n        this.onTouchedCallback = (_) => { };\n        this.onChangeCallback = (_) => { };\n        this.fileList = this.uploadService.files;\n        this.localizationChangeSubscription = localization.changes.subscribe(({ rtl }) => {\n            this.direction = rtl ? 'rtl' : 'ltr';\n            this.navigation.computeKeys(this.direction);\n        });\n        this.direction = localization.rtl ? 'rtl' : 'ltr';\n        this.navigation.computeKeys(this.direction);\n        this.wrapper = wrapper.nativeElement;\n        this.subscribeBlur();\n        this.subscribeFocus();\n        this.attachEventHandlers();\n    }\n    /**\n     * By default, the selected files are immediately uploaded\n     * ([see example]({% slug fileprocessing_upload %}#toc-automatic-upload-of-files)).\n     * To change this behavior, set `autoUpload` to `false`.\n     */\n    set autoUpload(autoUpload) {\n        this.uploadService.async.autoUpload = autoUpload;\n    }\n    get autoUpload() {\n        return this.uploadService.async.autoUpload;\n    }\n    /**\n     * When enabled, all files in the selection are uploaded in one request\n     * ([see example]({% slug fileprocessing_upload %}#toc-upload-of-batches-of-files)).\n     * Any files that are selected one after the other are uploaded in separate requests.\n     */\n    set batch(batch) {\n        this.uploadService.async.batch = batch;\n    }\n    get batch() {\n        return this.uploadService.async.batch;\n    }\n    /**\n     * Configures whether credentials (cookies, headers) will be sent for cross-site requests\n     * ([see example]({% slug credentials_upload %}#toc-attaching-credentials-to-requests)).\n     * The default values is `true`. Setting `withCredentials` has no effect on same-site requests.\n     * To add credentials to the request, use the `saveHeaders` or `removeHeaders` property,\n     * or the [`upload`]({% slug api_upload_uploadevent %}) event.\n     */\n    set withCredentials(withCredentials) {\n        this.uploadService.async.withCredentials = withCredentials;\n    }\n    get withCredentials() {\n        return this.uploadService.async.withCredentials;\n    }\n    /**\n     * Sets the [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) key which contains the files submitted to `saveUrl`.\n     * The default value is `files`.\n     */\n    set saveField(saveField) {\n        this.uploadService.async.saveField = saveField;\n    }\n    get saveField() {\n        return this.uploadService.async.saveField;\n    }\n    /**\n     * Configures the [`HttpHeaders`](https://angular.io/api/common/http/HttpHeaders)\n     * that are attached to each upload request.\n     */\n    set saveHeaders(saveHeaders) {\n        this.uploadService.async.saveHeaders = saveHeaders;\n    }\n    get saveHeaders() {\n        return this.uploadService.async.saveHeaders;\n    }\n    /**\n     * Sets the [`RequestMethod`](https://angular.io/api/http/RequestMethod) of the upload request.\n     * The default value is `POST`.\n     */\n    set saveMethod(saveMethod) {\n        this.uploadService.async.saveMethod = saveMethod;\n    }\n    get saveMethod() {\n        return this.uploadService.async.saveMethod;\n    }\n    /**\n     * Sets the URL of the endpoint for the upload request.\n     * The request [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) key is named after the `saveField` property.\n     * It contains the list of files to be uploaded.\n     */\n    set saveUrl(saveUrl) {\n        this.uploadService.async.saveUrl = saveUrl;\n    }\n    get saveUrl() {\n        return this.uploadService.async.saveUrl;\n    }\n    /**\n     * Sets the expected [`response type`](https://angular.io/api/common/http/HttpRequest#responseType) of the server.\n     * It is used to parse the response appropriately.\n     * The default value is `json`.\n     */\n    set responseType(responseType) {\n        this.uploadService.async.responseType = responseType;\n    }\n    get responseType() {\n        return this.uploadService.async.responseType;\n    }\n    /**\n     * Sets the [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) key\n     * which contains the list of file names that are submitted to `removeUrl`.\n     * The default value is `fileNames`.\n     */\n    set removeField(removeField) { this.uploadService.async.removeField = removeField; }\n    get removeField() { return this.uploadService.async.removeField; }\n    /**\n     * Configures the [`HttpHeaders`](https://angular.io/api/common/http/HttpHeaders)\n     * that are attached to each `remove` request.\n     */\n    set removeHeaders(removeHeaders) {\n        this.uploadService.async.removeHeaders = removeHeaders;\n    }\n    get removeHeaders() {\n        return this.uploadService.async.removeHeaders;\n    }\n    /**\n     * Sets the [`RequestMethod`](https://angular.io/api/http/RequestMethod) of the `remove` request.\n     * The default value is `POST`.\n     */\n    set removeMethod(removeMethod) {\n        this.uploadService.async.removeMethod = removeMethod;\n    }\n    get removeMethod() {\n        return this.uploadService.async.removeMethod;\n    }\n    /**\n     * Sets the URL of the endpoint for the `remove` request.\n     * The [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) request key is named after the `removeField` property.\n     * It contains the list of file names which will be removed.\n     */\n    set removeUrl(removeUrl) {\n        this.uploadService.async.removeUrl = removeUrl;\n    }\n    get removeUrl() {\n        return this.uploadService.async.removeUrl;\n    }\n    /**\n     * Specifies if the selected files are uploaded simultaneously or one by one.\n     *\n     * The default value is `true`.\n     */\n    set concurrent(concurrent) {\n        this.uploadService.async.concurrent = concurrent;\n    }\n    get concurrent() {\n        return this.uploadService.async.concurrent;\n    }\n    /**\n     * @hidden\n     */\n    set tabIndex(tabIndex) {\n        this.tabindex = tabIndex;\n    }\n    get tabIndex() {\n        return this.tabindex;\n    }\n    /**\n     * Sets the restrictions for selected files ([see example]({% slug api_upload_filerestrictions %})).\n     */\n    set restrictions(restrictions) {\n        let parsedRestrictions = Object.assign({}, this._restrictions, restrictions);\n        this._restrictions = parsedRestrictions;\n    }\n    get restrictions() {\n        return this._restrictions;\n    }\n    get hostDisabledClass() {\n        return this.disabled;\n    }\n    get dir() {\n        return this.direction;\n    }\n    ngOnInit() {\n        this.verifySettings();\n        this.renderer.removeAttribute(this.wrapper, \"tabindex\");\n        this.uploadService.setChunkSettings(this.chunkable);\n    }\n    ngOnChanges(changes) {\n        if (isChanged(\"chunkable\", changes)) {\n            const newChunkable = changes.chunkable.currentValue;\n            if (typeof newChunkable === 'boolean') {\n                this.uploadService.async.chunk = newChunkable;\n            }\n            if (typeof newChunkable === \"object\" && newChunkable !== null) {\n                this.uploadService.async.chunk = true;\n                this.uploadService.chunk = Object.assign({}, this.uploadService.chunk, newChunkable);\n            }\n        }\n    }\n    ngOnDestroy() {\n        this.fileList.clear();\n        if (this.blurSubscription) {\n            this.blurSubscription.unsubscribe();\n        }\n        if (this.wrapperFocusSubscription) {\n            this.wrapperFocusSubscription.unsubscribe();\n        }\n        if (this.selectButtonFocusSubscription) {\n            this.selectButtonFocusSubscription.unsubscribe();\n        }\n        if (this.localizationChangeSubscription) {\n            this.localizationChangeSubscription.unsubscribe();\n        }\n        if (this.subs) {\n            this.subs.unsubscribe();\n        }\n    }\n    /**\n     * @hidden\n     */\n    handleKeydown(event) {\n        if (this.disabled) {\n            return;\n        }\n        if ((event.keyCode === Keys.Enter || event.keyCode === Keys.Space) &&\n            event.target === this.fileSelectButton.nativeElement) {\n            event.preventDefault();\n            this.fileSelect.nativeElement.click();\n            return;\n        }\n        if (hasClasses(event.target, UPLOAD_CLASSES) ||\n            (!isFocusable(event.target) && !hasClasses(event.target, IGNORE_TARGET_CLASSES))) {\n            this.navigation.process(event);\n        }\n    }\n    /**\n     * @hidden\n     */\n    writeValue(newValue) {\n        let isValid = true;\n        if (newValue instanceof Array) {\n            newValue.forEach((file) => {\n                if (!validateInitialFileInfo(file)) {\n                    isValid = false;\n                }\n            });\n            if (isValid) {\n                this.uploadService.addInitialFiles(newValue);\n            }\n        }\n        if (newValue === null) {\n            this.fileList.clear();\n        }\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this.onChangeCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this.onTouchedCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n    get selectButtonTabIndex() {\n        return this.disabled ? undefined : this.tabIndex;\n    }\n    /**\n     * @hidden\n     */\n    onFileSelectButtonFocus(_event) {\n        this.renderer.addClass(this.fileSelectButton.nativeElement, 'k-state-focused');\n        if (!this.navigation.focused) {\n            this.navigation.focusedIndex = -1;\n        }\n    }\n    /**\n     * @hidden\n     */\n    onFileSelectButtonBlur(_event) {\n        this.renderer.removeClass(this.fileSelectButton.nativeElement, 'k-state-focused');\n    }\n    /**\n     * @hidden\n     */\n    get showActionButtons() {\n        let areVisible = false;\n        if (!this.autoUpload) {\n            const hasFilesToUpload = this.fileList.filesToUpload.length > 0;\n            const uploadingFiles = this.fileList.hasFileWithState([FileState.Uploading]);\n            if (this.concurrent && hasFilesToUpload) {\n                areVisible = true;\n            }\n            if (!this.concurrent && hasFilesToUpload && !uploadingFiles) {\n                areVisible = true;\n            }\n        }\n        this.navigation.actionButtonsVisible = areVisible;\n        return areVisible;\n    }\n    /**\n     * @hidden\n     */\n    get showTotalStatus() {\n        const states = [\n            FileState.Uploaded,\n            FileState.Uploading,\n            FileState.Failed,\n            FileState.Paused\n        ];\n        if (this.fileList.hasFileWithState(states)) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * @hidden\n     */\n    textFor(key) {\n        return this.localization.get(key);\n    }\n    /**\n     * Focuses the underlying input element.\n     */\n    focus() {\n        setTimeout(() => {\n            this.fileSelectButton.nativeElement.focus();\n        });\n    }\n    /**\n     * @hidden\n     * @deprecated\n     */\n    focusComponent() {\n        this.focus();\n    }\n    /**\n     * Blurs the Upload if it was previously focused.\n     */\n    blur() {\n        if (this.navigation.focused) {\n            this.navigation.focused = false;\n            document.activeElement.blur();\n            this.onBlur.emit();\n        }\n    }\n    /**\n     * @hidden\n     * @deprecated\n     */\n    blurComponent() {\n        this.blur();\n    }\n    /**\n     * Pauses the upload process of a file that is currently uploading.\n     * The `pauseFileByUid` method requires the `chunkable` option of the Upload to be enabled.\n     *\n     * @param uid - The `uid` of the file that will be paused.\n     */\n    pauseFileByUid(uid) {\n        this.uploadService.pauseFile(uid);\n    }\n    /**\n     * Resumes the upload process for a file that has been previously paused.\n     * The `resumeFileByUid` method requires the `chunkable` option of the Upload to be enabled.\n     *\n     * @param uid - The `uid` of the file that will be resumed.\n     */\n    resumeFileByUid(uid) {\n        this.uploadService.resumeFile(uid);\n    }\n    /**\n     * Triggers the removal of a file or a batch of files.\n     * @param uid - The `uid` of the file or a batch of files that will be removed.\n     */\n    removeFilesByUid(uid) {\n        this.uploadService.removeFiles(uid);\n    }\n    /**\n     * Triggers another upload attempt of an unsuccessfully uploaded file or a batch of files.\n     * @param uid - The `uid` of the file or a batch of files to be retried.\n     */\n    retryUploadByUid(uid) {\n        this.uploadService.retryFiles(uid);\n    }\n    /**\n     * Cancels the upload of a file or a batch of files.\n     * @param uid - The `uid` of the file or a batch of files that will be canceled.\n     */\n    cancelUploadByUid(uid) {\n        this.uploadService.cancelFiles(uid);\n    }\n    /**\n     * Uploads the currently selected files which pass the set restrictions.\n     */\n    uploadFiles() {\n        if (this.fileList.filesToUpload.length) {\n            this.uploadService.uploadFiles();\n        }\n    }\n    /**\n     * Visually clears all files from the UI without issuing requests to the remove handler.\n     */\n    clearFiles() {\n        this.uploadService.clearFiles();\n    }\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the component is empty.\n     */\n    isEmpty() {\n        return false;\n    }\n    verifySettings() {\n        if (isDevMode()) {\n            if (this.batch && this.chunkable !== false) {\n                throw new Error('The file chunking functionality requires the batch setting to be disabled.');\n            }\n        }\n    }\n    subscribeBlur() {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        this._ngZone.runOutsideAngular(() => {\n            this.documentClick = fromEvent(document, 'click').pipe(filter((event) => {\n                return !(this.wrapper !== event.target && this.wrapper.contains(event.target));\n            }));\n            this.blurSubscription = merge(this.documentClick, this.navigation.onTab).subscribe(() => this._ngZone.run(() => {\n                if (this.navigation.focused) {\n                    this.navigation.focused = false;\n                    this.onTouchedCallback();\n                    this.onBlur.emit();\n                }\n            }));\n        });\n    }\n    subscribeFocus() {\n        this.wrapperFocusSubscription = this.navigation.onWrapperFocus.subscribe(() => {\n            this.onFocus.emit();\n        });\n        this.selectButtonFocusSubscription = this.navigation.onSelectButtonFocus.subscribe(() => {\n            this.fileSelectButton.nativeElement.focus();\n        });\n    }\n    attachEventHandlers() {\n        this.subs = this.uploadService.cancelEvent.subscribe((args) => {\n            this.cancel.emit(args);\n        });\n        this.subs.add(this.uploadService.changeEvent.subscribe((files) => {\n            this.onChangeCallback(files);\n            this.valueChange.emit(files);\n        }));\n        this.subs.add(this.uploadService.clearEvent.subscribe((args) => {\n            this.clear.emit(args);\n        }));\n        this.subs.add(this.uploadService.completeEvent.subscribe(() => {\n            this.complete.emit();\n        }));\n        this.subs.add(this.uploadService.errorEvent.subscribe((args) => {\n            this.error.emit(args);\n        }));\n        this.subs.add(this.uploadService.pauseEvent.subscribe((args) => {\n            this.pause.emit(args);\n        }));\n        this.subs.add(this.uploadService.removeEvent.subscribe((args) => {\n            this.remove.emit(args);\n        }));\n        this.subs.add(this.uploadService.resumeEvent.subscribe((args) => {\n            this.resume.emit(args);\n        }));\n        this.subs.add(this.uploadService.selectEvent.subscribe((args) => {\n            this.select.emit(args);\n        }));\n        this.subs.add(this.uploadService.successEvent.subscribe((args) => {\n            this.success.emit(args);\n        }));\n        this.subs.add(this.uploadService.uploadEvent.subscribe((args) => {\n            this.upload.emit(args);\n        }));\n        this.subs.add(this.uploadService.uploadProgressEvent.subscribe((args) => {\n            this.uploadProgress.emit(args);\n        }));\n    }\n}\nUploadComponent.decorators = [\n    { type: Component, args: [{\n                exportAs: 'kendoUpload',\n                providers: [\n                    LocalizationService,\n                    NavigationService,\n                    UploadService,\n                    UPLOAD_VALUE_ACCESSOR,\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.upload'\n                    },\n                    {\n                        provide: KendoInput,\n                        useExisting: forwardRef(() => UploadComponent)\n                    }\n                ],\n                selector: 'kendo-upload',\n                template: `\n    <ng-container kendoUploadLocalizedMessages\n      i18n-cancel=\"kendo.upload.cancel|The text for the Cancel button\"\n      cancel=\"Cancel\"\n\n      i18n-clearSelectedFiles=\"kendo.upload.clearSelectedFiles|The text for the Clear button\"\n      clearSelectedFiles=\"Clear\"\n\n      i18n-dropFilesHere=\"kendo.upload.dropFilesHere|The drop zone hint\"\n      dropFilesHere=\"Drop files here to upload\"\n\n      i18n-headerStatusPaused=\"kendo.upload.headerStatusPaused|The header status message when the file upload is paused\"\n      headerStatusPaused=\"Paused\"\n\n      i18n-headerStatusUploaded=\"kendo.upload.headerStatusUploaded|The header status message after file upload completion\"\n      headerStatusUploaded=\"Done\"\n\n      i18n-headerStatusUploading=\"kendo.upload.headerStatusUploading|The header status message during file upload\"\n      headerStatusUploading=\"Uploading...\"\n\n      i18n-invalidFileExtension=\"kendo.upload.invalidFileExtension|The text for the invalid allowed extensions restriction message\"\n      invalidFileExtension=\"File type not allowed.\"\n\n      i18n-invalidFiles=\"kendo.upload.invalidFiles|The text for the invalid files message\"\n      invalidFiles=\"Invalid file(s). Please check file upload requirements.\"\n\n      i18n-invalidMaxFileSize=\"kendo.upload.invalidMaxFileSize|The text for the invalid max file size restriction message\"\n      invalidMaxFileSize=\"File size too large.\"\n\n      i18n-invalidMinFileSize=\"kendo.upload.invalidMinFileSize|The text for the invalid min file size restriction message\"\n      invalidMinFileSize=\"File size too small.\"\n\n      i18n-pause=\"kendo.upload.pause|The text for the Pause button\"\n      pause=\"Pause\"\n\n      i18n-remove=\"kendo.upload.remove|The text for the Remove button\"\n      remove=\"Remove\"\n\n      i18n-resume=\"kendo.upload.resume|The text for the Resume button\"\n      resume=\"Resume\"\n\n      i18n-retry=\"kendo.upload.retry|The text for the Retry button\"\n      retry=\"Retry\"\n\n      i18n-select=\"kendo.upload.select|The text for the Select button\"\n      select=\"Select files...\"\n\n      i18n-uploadSelectedFiles=\"kendo.upload.uploadSelectedFiles|The text for the Upload files button\"\n      uploadSelectedFiles=\"Upload\"\n    >\n    </ng-container>\n    <div kendoUploadDropzone\n      [restrictions]=\"restrictions\"\n      [multiple]=\"multiple\"\n      [disabled]=\"disabled\">\n        <div role=\"button\" #fileSelectButton\n             [id]=\"focusableId\"\n             [attr.aria-label]=\"textFor('select')\"\n             [attr.tabindex]=\"selectButtonTabIndex\"\n             (focus)=\"onFileSelectButtonFocus($event)\"\n             (blur)=\"onFileSelectButtonBlur($event)\"\n             class=\"k-button k-upload-button\">\n          <input #fileSelect kendoFileSelect\n            [attr.accept]=\"accept ? accept : null\"\n            [dir]=\"direction\"\n            [restrictions]=\"restrictions\"\n            [multiple]=\"multiple\"\n            [disabled]=\"disabled\" />\n          <span>{{textFor('select')}}</span>\n        </div>\n        <div class=\"k-dropzone-hint\">{{textFor('dropFilesHere')}}</div>\n        <kendo-upload-status-total *ngIf=\"showTotalStatus\"\n          [fileList]=\"fileList\">\n        </kendo-upload-status-total>\n    </div>\n    <ul kendo-upload-file-list *ngIf=\"showFileList && fileList.count > 0\"\n        class=\"k-upload-files k-reset\"\n        [disabled]=\"disabled\"\n        [fileList]=\"fileList.files\"\n        [fileTemplate]=\"fileTemplate\">\n    </ul>\n    <kendo-upload-action-buttons\n      *ngIf=\"showActionButtons\"\n      [disabled]=\"disabled\">\n    </kendo-upload-action-buttons>\n  `\n            },] },\n];\n/** @nocollapse */\nUploadComponent.ctorParameters = () => [\n    { type: UploadService },\n    { type: LocalizationService },\n    { type: NavigationService },\n    { type: NgZone },\n    { type: Renderer2 },\n    { type: ElementRef }\n];\nUploadComponent.propDecorators = {\n    autoUpload: [{ type: Input }],\n    batch: [{ type: Input }],\n    withCredentials: [{ type: Input }],\n    saveField: [{ type: Input }],\n    saveHeaders: [{ type: Input }],\n    saveMethod: [{ type: Input }],\n    saveUrl: [{ type: Input }],\n    responseType: [{ type: Input }],\n    removeField: [{ type: Input }],\n    removeHeaders: [{ type: Input }],\n    removeMethod: [{ type: Input }],\n    removeUrl: [{ type: Input }],\n    chunkable: [{ type: Input }],\n    concurrent: [{ type: Input }],\n    multiple: [{ type: Input }],\n    disabled: [{ type: Input }],\n    showFileList: [{ type: Input }],\n    tabindex: [{ type: Input }],\n    tabIndex: [{ type: Input, args: ['tabIndex',] }],\n    accept: [{ type: Input }],\n    restrictions: [{ type: Input }],\n    focusableId: [{ type: Input }],\n    fileTemplate: [{ type: ContentChild, args: [FileTemplateDirective,] }],\n    fileSelect: [{ type: ViewChild, args: ['fileSelect',] }],\n    fileSelectButton: [{ type: ViewChild, args: ['fileSelectButton',] }],\n    onBlur: [{ type: Output, args: ['blur',] }],\n    cancel: [{ type: Output }],\n    clear: [{ type: Output }],\n    complete: [{ type: Output }],\n    error: [{ type: Output }],\n    onFocus: [{ type: Output, args: ['focus',] }],\n    pause: [{ type: Output }],\n    remove: [{ type: Output }],\n    resume: [{ type: Output }],\n    select: [{ type: Output }],\n    success: [{ type: Output }],\n    upload: [{ type: Output }],\n    uploadProgress: [{ type: Output }],\n    valueChange: [{ type: Output }],\n    hostDefaultClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-upload',] }, { type: HostBinding, args: ['class.k-header',] }],\n    hostDisabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }],\n    dir: [{ type: HostBinding, args: ['attr.dir',] }],\n    handleKeydown: [{ type: HostListener, args: ['keydown', ['$event'],] }]\n};\n\n/**\n * @hidden\n */\nclass UploadActionButtonsComponent {\n    constructor(uploadService, localization, navigation) {\n        this.uploadService = uploadService;\n        this.localization = localization;\n        this.navigation = navigation;\n        this.onAction();\n        this.onFocus();\n    }\n    onAction() {\n        this.actionSubscription = this.navigation.onActionButtonAction.subscribe((button) => {\n            if (button === \"clear\") {\n                this.clearFiles();\n            }\n            else {\n                this.performUpload();\n            }\n            this.navigation.focusSelectButton();\n        });\n    }\n    onFocus() {\n        this.focusSubscription = this.navigation.onActionButtonFocus.subscribe((button) => {\n            this.focusButton(button);\n        });\n    }\n    focusButton(button) {\n        const el = (button === \"clear\") ? this.clearButton : this.uploadButton;\n        el.nativeElement.focus();\n    }\n    ngOnDestroy() {\n        this.actionSubscription.unsubscribe();\n        this.focusSubscription.unsubscribe();\n    }\n    performUpload(_event) {\n        if (!this.disabled) {\n            this.uploadService.uploadFiles();\n        }\n    }\n    clearFiles(_event) {\n        if (!this.disabled) {\n            this.uploadService.clearFiles();\n        }\n    }\n    textFor(key) {\n        return this.localization.get(key);\n    }\n    get className() {\n        return 'k-action-buttons';\n    }\n}\nUploadActionButtonsComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-upload-action-buttons',\n                template: `\n        <button #clearButton type=\"button\" class=\"k-button k-clear-selected\"\n            [attr.tabIndex]=\"-1\"\n            (click)=\"clearFiles($event)\">\n                {{textFor('clearSelectedFiles')}}\n        </button>\n        <button #uploadButton type=\"button\" class=\"k-button k-primary k-upload-selected\"\n            [attr.tabIndex]=\"-1\"\n            (click)=\"performUpload($event)\">\n                {{textFor('uploadSelectedFiles')}}\n        </button>\n    `\n            },] },\n];\n/** @nocollapse */\nUploadActionButtonsComponent.ctorParameters = () => [\n    { type: UploadService },\n    { type: LocalizationService },\n    { type: NavigationService }\n];\nUploadActionButtonsComponent.propDecorators = {\n    disabled: [{ type: Input }],\n    clearButton: [{ type: ViewChild, args: ['clearButton',] }],\n    uploadButton: [{ type: ViewChild, args: ['uploadButton',] }],\n    className: [{ type: HostBinding, args: ['class',] }]\n};\n\n/**\n * @hidden\n */\nclass UploadStatusTotalComponent {\n    constructor(localization) {\n        this.localization = localization;\n    }\n    ngDoCheck() {\n        this.isPaused = this.fileList.hasFileWithState([FileState.Paused]);\n        this.isFailed = this.fileList.hasFileWithState([FileState.Failed]);\n        this.isUploading = this.fileList.hasFileWithState([FileState.Uploading]);\n        if (this.isPaused && !this.isUploading) {\n            this.statusText = this.localization.get('headerStatusPaused');\n        }\n        else {\n            this.statusText = this.isUploading ? this.localization.get('headerStatusUploading')\n                : this.localization.get('headerStatusUploaded');\n        }\n        // this.isPaused = this.isFailed = this.isUploading = false;\n        // let currentlyUploading: boolean = this.fileList.hasFileWithState([FileState.Uploading]);\n        // if (this.fileList.hasFileWithState([FileState.Paused])) {\n        //     this.isPaused = true;\n        //     this.statusText = this.localization.get('headerStatusPaused');\n        // }\n        // if (this.isUploading !== currentlyUploading) {\n        //     this.isUploading = currentlyUploading;\n        //     this.isFailed = this.fileList.hasFileWithState([FileState.Failed]);\n        //     this.statusText = this.isUploading ? this.localization.get('headerStatusUploading')\n        //                                        : this.localization.get('headerStatusUploaded');\n        // }\n    }\n}\nUploadStatusTotalComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-upload-status-total',\n                template: `\n        <strong class=\"k-upload-status k-upload-status-total\">\n          <span class=\"k-icon\"\n            [ngClass]=\"{\n                'k-i-checkmark': !this.isUploading && !this.isFailed,\n                'k-i-exception': !this.isUploading && this.isFailed,\n                'k-i-loading': this.isUploading,\n                'k-i-pause-sm': this.isPaused\n            }\">\n          </span>\n          {{statusText}}\n        </strong>\n    `\n            },] },\n];\n/** @nocollapse */\nUploadStatusTotalComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\nUploadStatusTotalComponent.propDecorators = {\n    fileList: [{ type: Input }]\n};\n\nconst UPLOAD_DECLARATIONS = [\n    UploadComponent,\n    UploadActionButtonsComponent,\n    UploadStatusTotalComponent\n];\n/**\n * Represents the [NgModule](https://angular.io/api/core/NgModule) definition for the Upload component.\n */\nclass UploadModule {\n}\nUploadModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [UPLOAD_DECLARATIONS],\n                exports: [\n                    PUBLIC_DIRECTIVES,\n                    UPLOAD_DECLARATIONS\n                ],\n                imports: [SharedModule]\n            },] },\n];\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Uploads components.\n *\n * @example\n *\n * ```ts-no-run\n * import { UploadsModule } from '@progress/kendo-angular-upload';\n *\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { NgModule } from '@angular/core';\n *\n * import { AppComponent } from './app.component';\n *\n * _@NgModule({\n *     declarations: [AppComponent],\n *     imports:      [BrowserModule, UploadsModule],\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nclass UploadsModule {\n}\nUploadsModule.decorators = [\n    { type: NgModule, args: [{\n                exports: [\n                    FileSelectModule,\n                    UploadModule\n                ]\n            },] },\n];\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { PreventableEvent, FILESELECT_VALUE_ACCESSOR, LocalizedMessagesDirective, Messages, NavigationService, FileListItemDirective, FileListItemBase, PUBLIC_DIRECTIVES, SHARED_DECLARATIONS, SharedModule, UPLOAD_VALUE_ACCESSOR, UploadService, FileSelectModule, UploadModule, UploadsModule, UploadComponent, FileSelectComponent, FileSelectDirective, FileListComponent, FileListSingleItemComponent, FileListItemActionButtonComponent, FileListMultipleItemsComponent, FileTemplateDirective, TemplateContextDirective, UploadStatusTotalComponent, UploadActionButtonsComponent, DropZoneDirective, CustomMessagesComponent, CancelEvent, ClearEvent, ErrorEvent, PauseEvent, RemoveEvent, ResumeEvent, SelectEvent, SuccessEvent, UploadEvent, UploadProgressEvent, FileState };\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAypCC,sGAGC;;;;;;;2EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2ID,kHAGC;;;;;;;uEAIA;;;;;;;;;;;CASD,iLAKC;;;;;;;;;;4EAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAyRD,oFAsEC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBA+BA;;;;;;;;8nBAMD;;;;;;;;;;;;;;;;;;;qEAkBC;;;;;;;;;;;;;;;;;;;;CAaD,wJAYC;;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAqLD,gGAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAgBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiDD,sDAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAoBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsDD,yDAgCC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsGD,uEAsDC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkCA,cAwCC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkCD,cA0CC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmDD,4GAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAoBA;;;;;;;;;;;;;;;;;CAUD,iDAWC;;;;;;;;;;;;;;;;oFAIA;;;;;;;;;;;;;;;;;;;;CAkBD,sLAKC;;;;;;;;;;;;;;;oBAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2BD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAcC;;;;;;;;;;;CASD;;;;;;;;;;;;;;0BAUC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2lBD,6DA0GC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAsDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAqDD,4BAiBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiCD,0DAkBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAOA;;;;;;;;;;;;;CAWD;;;;;;;;;;;;;;;;;;0BAUC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4BD;;;;;;;;;;;0BAQC;;;;;;;"}