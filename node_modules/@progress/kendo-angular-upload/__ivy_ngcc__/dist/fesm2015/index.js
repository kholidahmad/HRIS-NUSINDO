/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Component, ContentChild, Directive, ElementRef, EventEmitter, HostBinding, HostListener, Injectable, Input, NgModule, NgZone, Output, Renderer2, TemplateRef, ViewChild, ViewChildren, ViewContainerRef, forwardRef, isDevMode } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { ComponentMessages, L10N_PREFIX, LocalizationService } from '@progress/kendo-angular-l10n';
import { KendoInput, Keys, guid, isChanged, isDocumentAvailable } from '@progress/kendo-angular-common';
import { fromEvent, merge } from 'rxjs';
import { filter } from 'rxjs/operators';
import { HttpClient, HttpEventType, HttpHeaders, HttpRequest, HttpResponse } from '@angular/common/http';
import { CommonModule } from '@angular/common';
import { animate, state, style, transition, trigger } from '@angular/animations';

/**
 * Lists the possible states of a file.
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common/http';
import * as ɵngcc2 from '@progress/kendo-angular-l10n';
import * as ɵngcc3 from '@angular/common';

const _c0 = ["fileSelect"];
const _c1 = ["fileSelectButton"];
var I18N_2;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The drop zone hint
     * @meaning kendo.upload.dropFilesHere
     */ 
    const MSG_EXTERNAL_88977489791049330$$DIST_FESM2015_INDEX_JS_3 = goog.getMsg("Drop files here to select");
    I18N_2 = MSG_EXTERNAL_88977489791049330$$DIST_FESM2015_INDEX_JS_3;
}
else {
    I18N_2 = $localize `:kendo.upload.dropFilesHere|The drop zone hint␟49152e310ccb32f7817cfac932777e083d282882␟88977489791049330:Drop files here to select`;
}
var I18N_4;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text for the invalid allowed extensions restriction message
     * @meaning kendo.upload.invalidFileExtension
     */ 
    const MSG_EXTERNAL_2924979995055776233$$DIST_FESM2015_INDEX_JS_5 = goog.getMsg("File type not allowed.");
    I18N_4 = MSG_EXTERNAL_2924979995055776233$$DIST_FESM2015_INDEX_JS_5;
}
else {
    I18N_4 = $localize `:kendo.upload.invalidFileExtension|The text for the invalid allowed extensions restriction message␟8292c7f6c967dcade8639d0dd477a67ad08457c7␟2924979995055776233:File type not allowed.`;
}
var I18N_6;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text for the invalid max file size restriction message
     * @meaning kendo.upload.invalidMaxFileSize
     */ 
    const MSG_EXTERNAL_6669611501469754964$$DIST_FESM2015_INDEX_JS_7 = goog.getMsg("File size too large.");
    I18N_6 = MSG_EXTERNAL_6669611501469754964$$DIST_FESM2015_INDEX_JS_7;
}
else {
    I18N_6 = $localize `:kendo.upload.invalidMaxFileSize|The text for the invalid max file size restriction message␟1d3c53a4169aceb03929a0dcdd2f4c5436aa4470␟6669611501469754964:File size too large.`;
}
var I18N_8;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text for the invalid min file size restriction message
     * @meaning kendo.upload.invalidMinFileSize
     */ 
    const MSG_EXTERNAL_4319370666600195324$$DIST_FESM2015_INDEX_JS_9 = goog.getMsg("File size too small.");
    I18N_8 = MSG_EXTERNAL_4319370666600195324$$DIST_FESM2015_INDEX_JS_9;
}
else {
    I18N_8 = $localize `:kendo.upload.invalidMinFileSize|The text for the invalid min file size restriction message␟dde6c68c96cf06aab654c8054c516d0d12f6309a␟4319370666600195324:File size too small.`;
}
var I18N_10;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text for the Remove button
     * @meaning kendo.upload.remove
     */ 
    const MSG_EXTERNAL_8941644637700654622$$DIST_FESM2015_INDEX_JS_11 = goog.getMsg("Remove");
    I18N_10 = MSG_EXTERNAL_8941644637700654622$$DIST_FESM2015_INDEX_JS_11;
}
else {
    I18N_10 = $localize `:kendo.upload.remove|The text for the Remove button␟1e81e5de447f5792cd15c18c435360a7b946ac70␟8941644637700654622:Remove`;
}
var I18N_12;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text for the Select button
     * @meaning kendo.upload.select
     */ 
    const MSG_EXTERNAL_2943392613806104166$$DIST_FESM2015_INDEX_JS_13 = goog.getMsg("Select files...");
    I18N_12 = MSG_EXTERNAL_2943392613806104166$$DIST_FESM2015_INDEX_JS_13;
}
else {
    I18N_12 = $localize `:kendo.upload.select|The text for the Select button␟24063b06532dc5303d28524d6245ba6d3eed80c1␟2943392613806104166:Select files...`;
}
const _c14 = ["dropFilesHere", I18N_2, "invalidFileExtension", I18N_4, "invalidMaxFileSize", I18N_6, "invalidMinFileSize", I18N_8, "remove", I18N_10, "select", I18N_12];
function FileSelectComponent_ul_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ul", 8);
} if (rf & 2) {
    const ctx_r291 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("disabled", ctx_r291.disabled)("fileList", ctx_r291.fileList.files)("fileTemplate", ctx_r291.fileTemplate);
} }
const _c15 = ["kendo-upload-file-list", ""];
function FileListComponent_ng_template_0_kendo_upload_file_list_single_item_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-upload-file-list-single-item", 5);
} if (rf & 2) {
    const files_r293 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r295 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("disabled", ctx_r295.disabled)("file", files_r293[0]);
} }
function FileListComponent_ng_template_0_kendo_upload_file_list_multiple_items_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-upload-file-list-multiple-items", 6);
} if (rf & 2) {
    const files_r293 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r296 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("disabled", ctx_r296.disabled)("files", files_r293);
} }
function FileListComponent_ng_template_0_3_ng_template_0_Template(rf, ctx) { }
const _c16 = function (a0, a1, a2) { return { templateRef: a0, state: a1, $implicit: a2 }; };
function FileListComponent_ng_template_0_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, FileListComponent_ng_template_0_3_ng_template_0_Template, 0, 0, "ng-template", 7);
} if (rf & 2) {
    const files_r293 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r297 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("templateContext", ɵngcc0.ɵɵpureFunction3(1, _c16, ctx_r297.fileTemplate.templateRef, files_r293[0].state, files_r293));
} }
function FileListComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li", 1);
    ɵngcc0.ɵɵtemplate(1, FileListComponent_ng_template_0_kendo_upload_file_list_single_item_1_Template, 1, 2, "kendo-upload-file-list-single-item", 2);
    ɵngcc0.ɵɵtemplate(2, FileListComponent_ng_template_0_kendo_upload_file_list_multiple_items_2_Template, 1, 2, "kendo-upload-file-list-multiple-items", 3);
    ɵngcc0.ɵɵtemplate(3, FileListComponent_ng_template_0_3_Template, 1, 5, undefined, 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const files_r293 = ctx.$implicit;
    const index_r294 = ctx.index;
    const ctx_r292 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("files", files_r293)("index", index_r294);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", files_r293.length === 1 && !ctx_r292.fileTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", files_r293.length > 1 && !ctx_r292.fileTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r292.fileTemplate);
} }
function FileListItemActionButtonComponent_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r302 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1("", ctx_r302.progress, "%");
} }
const _c17 = function (a0) { return { "k-state-focused": a0 }; };
function FileListItemActionButtonComponent_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r307 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 4);
    ɵngcc0.ɵɵlistener("focus", function FileListItemActionButtonComponent_button_2_Template_button_focus_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r307); const ctx_r306 = ɵngcc0.ɵɵnextContext(); return ctx_r306.onFocus("retry"); })("blur", function FileListItemActionButtonComponent_button_2_Template_button_blur_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r307); const ctx_r308 = ɵngcc0.ɵɵnextContext(); return ctx_r308.onBlur("retry"); })("click", function FileListItemActionButtonComponent_button_2_Template_button_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r307); const ctx_r309 = ɵngcc0.ɵɵnextContext(); return ctx_r309.onRetryClick(); });
    ɵngcc0.ɵɵelement(1, "span", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r303 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(4, _c17, ctx_r303.retryFocused));
    ɵngcc0.ɵɵattribute("tabIndex", 0 - 1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r303.retryButtonTitle)("title", ctx_r303.retryButtonTitle);
} }
const _c18 = function (a0, a1) { return { "k-i-play-sm": a0, "k-i-pause-sm": a1 }; };
function FileListItemActionButtonComponent_button_3_Template(rf, ctx) { if (rf & 1) {
    const _r311 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 4);
    ɵngcc0.ɵɵlistener("focus", function FileListItemActionButtonComponent_button_3_Template_button_focus_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r311); const ctx_r310 = ɵngcc0.ɵɵnextContext(); return ctx_r310.onFocus("pauseResume"); })("blur", function FileListItemActionButtonComponent_button_3_Template_button_blur_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r311); const ctx_r312 = ɵngcc0.ɵɵnextContext(); return ctx_r312.onBlur("pauseResume"); })("click", function FileListItemActionButtonComponent_button_3_Template_button_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r311); const ctx_r313 = ɵngcc0.ɵɵnextContext(); return ctx_r313.onPauseResumeClick(); });
    ɵngcc0.ɵɵelement(1, "span", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r304 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(5, _c17, ctx_r304.pauseResumeFocused));
    ɵngcc0.ɵɵattribute("tabIndex", 0 - 1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(7, _c18, ctx_r304.isPaused, !ctx_r304.isPaused));
    ɵngcc0.ɵɵattribute("aria-label", ctx_r304.pauseResumeButtonTitle)("title", ctx_r304.pauseResumeButtonTitle);
} }
const _c19 = function (a0, a1) { return { "k-cancel k-i-deny": a0, "k-delete k-i-x": a1 }; };
function FileListItemActionButtonComponent_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r315 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 4);
    ɵngcc0.ɵɵlistener("focus", function FileListItemActionButtonComponent_button_4_Template_button_focus_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r315); const ctx_r314 = ɵngcc0.ɵɵnextContext(); return ctx_r314.onFocus("action"); })("blur", function FileListItemActionButtonComponent_button_4_Template_button_blur_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r315); const ctx_r316 = ɵngcc0.ɵɵnextContext(); return ctx_r316.onBlur("action"); })("click", function FileListItemActionButtonComponent_button_4_Template_button_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r315); const ctx_r317 = ɵngcc0.ɵɵnextContext(); return ctx_r317.onRemoveCancelClick(); });
    ɵngcc0.ɵɵelement(1, "span", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r305 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(5, _c17, ctx_r305.actionFocused));
    ɵngcc0.ɵɵattribute("tabIndex", 0 - 1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(7, _c19, ctx_r305.isUploading, !ctx_r305.isUploading));
    ɵngcc0.ɵɵattribute("aria-label", ctx_r305.actionButtonTitle)("title", ctx_r305.actionButtonTitle);
} }
function FileListMultipleItemsComponent_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 8);
    ɵngcc0.ɵɵelement(1, "span", 9);
    ɵngcc0.ɵɵelementEnd();
} }
function FileListMultipleItemsComponent_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 10);
    ɵngcc0.ɵɵelementStart(1, "span", 11);
    ɵngcc0.ɵɵtext(2, "!");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(3, "span", 9);
    ɵngcc0.ɵɵelementEnd();
} }
function FileListMultipleItemsComponent_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 12);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const file_r323 = ctx.$implicit;
    const ctx_r320 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("title", file_r323.name)("ngClass", ctx_r320.setFileNameClasses(file_r323));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", file_r323.name, " ");
} }
function FileListMultipleItemsComponent_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 13);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r321 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate2("Total: ", ctx_r321.files.length, " files, ", ctx_r321.getTotalFilesSizeMessage(ctx_r321.files), "");
} }
function FileListMultipleItemsComponent_span_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 14);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r322 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r322.getInvalidFilesMessage());
} }
function FileListSingleItemComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 3);
    ɵngcc0.ɵɵelementStart(1, "span", 4);
    ɵngcc0.ɵɵtext(2, "!");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(3, "span", 5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "span", 6);
    ɵngcc0.ɵɵelementStart(5, "span", 7);
    ɵngcc0.ɵɵtext(6);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(7, "span", 8);
    ɵngcc0.ɵɵtext(8);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r324 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(5);
    ɵngcc0.ɵɵproperty("title", ctx_r324.file.name);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r324.file.name);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r324.getFileValidationMessage(ctx_r324.file));
} }
const _c20 = function (a0) { return [a0]; };
function FileListSingleItemComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 9);
    ɵngcc0.ɵɵelementStart(1, "span", 10);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(3, "span", 5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "span", 6);
    ɵngcc0.ɵɵelementStart(5, "span", 11);
    ɵngcc0.ɵɵtext(6);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(7, "span", 12);
    ɵngcc0.ɵɵtext(8);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r325 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r325.getFileExtension(ctx_r325.file));
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("title", ctx_r325.file.name);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r325.file.name);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r325.getTotalFilesSizeMessage(ɵngcc0.ɵɵpureFunction1(4, _c20, ctx_r325.file)));
} }
var I18N_21;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text for the Cancel button
     * @meaning kendo.upload.cancel
     */ 
    const MSG_EXTERNAL_1628868291685658590$$DIST_FESM2015_INDEX_JS_22 = goog.getMsg("Cancel");
    I18N_21 = MSG_EXTERNAL_1628868291685658590$$DIST_FESM2015_INDEX_JS_22;
}
else {
    I18N_21 = $localize `:kendo.upload.cancel|The text for the Cancel button␟262a7a2e1c2c01f72e494499e4031ca52bfb6c62␟1628868291685658590:Cancel`;
}
var I18N_23;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text for the Clear button
     * @meaning kendo.upload.clearSelectedFiles
     */ 
    const MSG_EXTERNAL_3149650400352762187$$DIST_FESM2015_INDEX_JS_24 = goog.getMsg("Clear");
    I18N_23 = MSG_EXTERNAL_3149650400352762187$$DIST_FESM2015_INDEX_JS_24;
}
else {
    I18N_23 = $localize `:kendo.upload.clearSelectedFiles|The text for the Clear button␟47d53c4c549530374586d580a1fffb90509aa114␟3149650400352762187:Clear`;
}
var I18N_25;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The drop zone hint
     * @meaning kendo.upload.dropFilesHere
     */ 
    const MSG_EXTERNAL_6841325639465061593$$DIST_FESM2015_INDEX_JS_26 = goog.getMsg("Drop files here to upload");
    I18N_25 = MSG_EXTERNAL_6841325639465061593$$DIST_FESM2015_INDEX_JS_26;
}
else {
    I18N_25 = $localize `:kendo.upload.dropFilesHere|The drop zone hint␟ed0e4f0924eb8ac2dfc0a30d0852da2f0a356e8f␟6841325639465061593:Drop files here to upload`;
}
var I18N_27;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The header status message when the file upload is paused
     * @meaning kendo.upload.headerStatusPaused
     */ 
    const MSG_EXTERNAL_3443987862990095035$$DIST_FESM2015_INDEX_JS_28 = goog.getMsg("Paused");
    I18N_27 = MSG_EXTERNAL_3443987862990095035$$DIST_FESM2015_INDEX_JS_28;
}
else {
    I18N_27 = $localize `:kendo.upload.headerStatusPaused|The header status message when the file upload is paused␟940cf4e04c5b4fd5e98b4affd35a4b2c9c3036a4␟3443987862990095035:Paused`;
}
var I18N_29;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The header status message after file upload completion
     * @meaning kendo.upload.headerStatusUploaded
     */ 
    const MSG_EXTERNAL_9210921126598204924$$DIST_FESM2015_INDEX_JS_30 = goog.getMsg("Done");
    I18N_29 = MSG_EXTERNAL_9210921126598204924$$DIST_FESM2015_INDEX_JS_30;
}
else {
    I18N_29 = $localize `:kendo.upload.headerStatusUploaded|The header status message after file upload completion␟30d5eeceb66bae90056d593fcf90eecd851b36a4␟9210921126598204924:Done`;
}
var I18N_31;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The header status message during file upload
     * @meaning kendo.upload.headerStatusUploading
     */ 
    const MSG_EXTERNAL_6336385612571616916$$DIST_FESM2015_INDEX_JS_32 = goog.getMsg("Uploading...");
    I18N_31 = MSG_EXTERNAL_6336385612571616916$$DIST_FESM2015_INDEX_JS_32;
}
else {
    I18N_31 = $localize `:kendo.upload.headerStatusUploading|The header status message during file upload␟be0775f64ce53906c132f6b5a50280ff5b948b35␟6336385612571616916:Uploading...`;
}
var I18N_33;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text for the invalid allowed extensions restriction message
     * @meaning kendo.upload.invalidFileExtension
     */ 
    const MSG_EXTERNAL_2924979995055776233$$DIST_FESM2015_INDEX_JS_34 = goog.getMsg("File type not allowed.");
    I18N_33 = MSG_EXTERNAL_2924979995055776233$$DIST_FESM2015_INDEX_JS_34;
}
else {
    I18N_33 = $localize `:kendo.upload.invalidFileExtension|The text for the invalid allowed extensions restriction message␟8292c7f6c967dcade8639d0dd477a67ad08457c7␟2924979995055776233:File type not allowed.`;
}
var I18N_35;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text for the invalid files message
     * @meaning kendo.upload.invalidFiles
     */ 
    const MSG_EXTERNAL_8253082188594027669$$DIST_FESM2015_INDEX_JS_36 = goog.getMsg("Invalid file(s). Please check file upload requirements.");
    I18N_35 = MSG_EXTERNAL_8253082188594027669$$DIST_FESM2015_INDEX_JS_36;
}
else {
    I18N_35 = $localize `:kendo.upload.invalidFiles|The text for the invalid files message␟6dd7e145884074d6d0bf5302dd13b63a02c9b949␟8253082188594027669:Invalid file(s). Please check file upload requirements.`;
}
var I18N_37;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text for the invalid max file size restriction message
     * @meaning kendo.upload.invalidMaxFileSize
     */ 
    const MSG_EXTERNAL_6669611501469754964$$DIST_FESM2015_INDEX_JS_38 = goog.getMsg("File size too large.");
    I18N_37 = MSG_EXTERNAL_6669611501469754964$$DIST_FESM2015_INDEX_JS_38;
}
else {
    I18N_37 = $localize `:kendo.upload.invalidMaxFileSize|The text for the invalid max file size restriction message␟1d3c53a4169aceb03929a0dcdd2f4c5436aa4470␟6669611501469754964:File size too large.`;
}
var I18N_39;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text for the invalid min file size restriction message
     * @meaning kendo.upload.invalidMinFileSize
     */ 
    const MSG_EXTERNAL_4319370666600195324$$DIST_FESM2015_INDEX_JS_40 = goog.getMsg("File size too small.");
    I18N_39 = MSG_EXTERNAL_4319370666600195324$$DIST_FESM2015_INDEX_JS_40;
}
else {
    I18N_39 = $localize `:kendo.upload.invalidMinFileSize|The text for the invalid min file size restriction message␟dde6c68c96cf06aab654c8054c516d0d12f6309a␟4319370666600195324:File size too small.`;
}
var I18N_41;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text for the Pause button
     * @meaning kendo.upload.pause
     */ 
    const MSG_EXTERNAL_2303075305806756763$$DIST_FESM2015_INDEX_JS_42 = goog.getMsg("Pause");
    I18N_41 = MSG_EXTERNAL_2303075305806756763$$DIST_FESM2015_INDEX_JS_42;
}
else {
    I18N_41 = $localize `:kendo.upload.pause|The text for the Pause button␟8a0a61519fec031579cf6b1c4f31c94578bd0981␟2303075305806756763:Pause`;
}
var I18N_43;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text for the Remove button
     * @meaning kendo.upload.remove
     */ 
    const MSG_EXTERNAL_8941644637700654622$$DIST_FESM2015_INDEX_JS_44 = goog.getMsg("Remove");
    I18N_43 = MSG_EXTERNAL_8941644637700654622$$DIST_FESM2015_INDEX_JS_44;
}
else {
    I18N_43 = $localize `:kendo.upload.remove|The text for the Remove button␟1e81e5de447f5792cd15c18c435360a7b946ac70␟8941644637700654622:Remove`;
}
var I18N_45;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text for the Resume button
     * @meaning kendo.upload.resume
     */ 
    const MSG_EXTERNAL_4056147860620862675$$DIST_FESM2015_INDEX_JS_46 = goog.getMsg("Resume");
    I18N_45 = MSG_EXTERNAL_4056147860620862675$$DIST_FESM2015_INDEX_JS_46;
}
else {
    I18N_45 = $localize `:kendo.upload.resume|The text for the Resume button␟f9ef89f76dd3d8c5a3184830d60e4d4f9c4dc998␟4056147860620862675:Resume`;
}
var I18N_47;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text for the Retry button
     * @meaning kendo.upload.retry
     */ 
    const MSG_EXTERNAL_8567960350691997515$$DIST_FESM2015_INDEX_JS_48 = goog.getMsg("Retry");
    I18N_47 = MSG_EXTERNAL_8567960350691997515$$DIST_FESM2015_INDEX_JS_48;
}
else {
    I18N_47 = $localize `:kendo.upload.retry|The text for the Retry button␟9150dfa816d23dfa75f231ca6f053f5e0ae26713␟8567960350691997515:Retry`;
}
var I18N_49;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text for the Select button
     * @meaning kendo.upload.select
     */ 
    const MSG_EXTERNAL_2943392613806104166$$DIST_FESM2015_INDEX_JS_50 = goog.getMsg("Select files...");
    I18N_49 = MSG_EXTERNAL_2943392613806104166$$DIST_FESM2015_INDEX_JS_50;
}
else {
    I18N_49 = $localize `:kendo.upload.select|The text for the Select button␟24063b06532dc5303d28524d6245ba6d3eed80c1␟2943392613806104166:Select files...`;
}
var I18N_51;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text for the Upload files button
     * @meaning kendo.upload.uploadSelectedFiles
     */ 
    const MSG_EXTERNAL_4936937427147701307$$DIST_FESM2015_INDEX_JS_52 = goog.getMsg("Upload");
    I18N_51 = MSG_EXTERNAL_4936937427147701307$$DIST_FESM2015_INDEX_JS_52;
}
else {
    I18N_51 = $localize `:kendo.upload.uploadSelectedFiles|The text for the Upload files button␟3449491aa76964a8dceb9ed3957b6fc4c17f568f␟4936937427147701307:Upload`;
}
const _c53 = ["cancel", I18N_21, "clearSelectedFiles", I18N_23, "dropFilesHere", I18N_25, "headerStatusPaused", I18N_27, "headerStatusUploaded", I18N_29, "headerStatusUploading", I18N_31, "invalidFileExtension", I18N_33, "invalidFiles", I18N_35, "invalidMaxFileSize", I18N_37, "invalidMinFileSize", I18N_39, "pause", I18N_41, "remove", I18N_43, "resume", I18N_45, "retry", I18N_47, "select", I18N_49, "uploadSelectedFiles", I18N_51];
function UploadComponent_kendo_upload_status_total_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-upload-status-total", 10);
} if (rf & 2) {
    const ctx_r328 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("fileList", ctx_r328.fileList);
} }
function UploadComponent_ul_12_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ul", 11);
} if (rf & 2) {
    const ctx_r329 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("disabled", ctx_r329.disabled)("fileList", ctx_r329.fileList.files)("fileTemplate", ctx_r329.fileTemplate);
} }
function UploadComponent_kendo_upload_action_buttons_13_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-upload-action-buttons", 12);
} if (rf & 2) {
    const ctx_r330 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("disabled", ctx_r330.disabled);
} }
const _c54 = ["clearButton"];
const _c55 = ["uploadButton"];
const _c56 = function (a0, a1, a2, a3) { return { "k-i-checkmark": a0, "k-i-exception": a1, "k-i-loading": a2, "k-i-pause-sm": a3 }; };
var FileState;
(function (FileState) {
    /**
     * The file upload process has failed.
     */
    FileState[FileState["Failed"] = 0] = "Failed";
    /**
     * An initially selected fake file without a set state.
     */
    FileState[FileState["Initial"] = 1] = "Initial";
    /**
     * The file is selected.
     */
    FileState[FileState["Selected"] = 2] = "Selected";
    /**
     * The file is successfully uploaded.
     */
    FileState[FileState["Uploaded"] = 3] = "Uploaded";
    /**
     * The file is in the process of uploading.
     */
    FileState[FileState["Uploading"] = 4] = "Uploading";
    /**
     * The file upload process has been paused.
     */
    FileState[FileState["Paused"] = 5] = "Paused";
})(FileState || (FileState = {}));

/**
 * @hidden
 */
class FileMap {
    constructor() {
        this._files = {};
    }
    add(file) {
        let uid = file.uid;
        if (this.has(uid)) {
            if (file.validationErrors && file.validationErrors.length > 0) {
                this._files[uid].unshift(file);
            }
            else {
                this._files[uid].push(file);
            }
        }
        else {
            this._files[uid] = [file];
        }
    }
    remove(uid) {
        if (this.has(uid)) {
            this._files[uid] = null;
            delete this._files[uid];
        }
    }
    clear() {
        let allFiles = this._files;
        for (let uid in allFiles) {
            if (allFiles.hasOwnProperty(uid)) {
                for (let file of allFiles[uid]) {
                    if (file.httpSubscription) {
                        file.httpSubscription.unsubscribe();
                    }
                }
                allFiles[uid] = null;
                delete allFiles[uid];
            }
        }
    }
    has(uid) {
        return uid in this._files;
    }
    get(uid) {
        return this._files[uid];
    }
    setFilesState(files, state$$1) {
        for (let file of files) {
            this.setFilesStateByUid(file.uid, state$$1);
        }
    }
    setFilesStateByUid(uid, state$$1) {
        this.get(uid).forEach((f) => {
            f.state = state$$1;
        });
    }
    get count() {
        return Object.getOwnPropertyNames(this._files).length;
    }
    get files() {
        let initial = this._files;
        let transformed = [];
        for (let uid in initial) {
            if (initial.hasOwnProperty(uid)) {
                transformed.push(initial[uid]);
            }
        }
        return transformed;
    }
    get filesFlat() {
        let initial = this._files;
        let transformed = [];
        for (let uid in initial) {
            if (initial.hasOwnProperty(uid)) {
                let current = initial[uid];
                current.forEach((file) => {
                    transformed.push(file);
                });
            }
        }
        return transformed;
    }
    get filesToUpload() {
        let files = this._files;
        let notUploaded = [];
        for (let uid in files) {
            if (files.hasOwnProperty(uid)) {
                let currentFiles = files[uid];
                let currentFilesValid = true;
                for (let file of currentFiles) {
                    if (file.state !== FileState.Selected || (file.validationErrors && file.validationErrors.length > 0)) {
                        currentFilesValid = false;
                    }
                }
                if (currentFilesValid) {
                    notUploaded.push(currentFiles);
                }
            }
        }
        return notUploaded;
    }
    get firstFileToUpload() {
        let files = this._files;
        for (let uid in files) {
            if (files.hasOwnProperty(uid)) {
                let currentFiles = files[uid];
                let currentFilesValid = true;
                for (let file of currentFiles) {
                    if (file.state !== FileState.Selected || (file.validationErrors && file.validationErrors.length > 0)) {
                        currentFilesValid = false;
                    }
                }
                if (currentFilesValid) {
                    return currentFiles;
                }
            }
        }
        return null;
    }
    hasFileWithState(fileStates) {
        let files = this._files;
        for (let uid in files) {
            if (files.hasOwnProperty(uid)) {
                let currentFiles = files[uid];
                for (let file of currentFiles) {
                    if (fileStates.indexOf(file.state) >= 0) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
}

/**
 * Arguments for the `cancel` event. The `cancel` event fires when
 * the user cancels the process of uploading a file or a batch of files.
 *
 * ```ts-no-run
 *  @Component({
 *    selector: 'my-upload',
 *    template: `
 *    <p>Click the <span class='k-icon k-i-cancel'></span> icon during upload to trigger the event</p>
 *    <kendo-upload
 *      [saveUrl]="uploadSaveUrl"
 *      [removeUrl]="uploadRemoveUrl"
 *      (cancel)="cancelEventHandler($event)">
 *    </kendo-upload>
 *    `
 *  })
 *  export class UploadComponent {
 *    uploadSaveUrl = 'saveUrl'; // should represent an actual API endpoint
 *    uploadRemoveUrl = 'removeUrl'; // should represent an actual API endpoint
 *
 *    cancelEventHandler(e: CancelEvent) {
 *      console.log('Canceling file upload', e.files);
 *    }
 *  }
 * ```
 */
class CancelEvent {
    /**
     * Constructs the event arguments for the `cancel` event.
     * @param files - The list of the files that were going to be uploaded.
     */
    constructor(files) {
        this.files = files;
    }
}

/**
 * @hidden
 */
class PreventableEvent {
    constructor() {
        this.prevented = false;
    }
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses the built-in behavior that follows the event.
     */
    preventDefault() {
        this.prevented = true;
    }
    /**
     * If the event is prevented by any of its subscribers, returns `true`.
     *
     * @returns `true` if the default action was prevented. Otherwise, returns `false`.
     */
    isDefaultPrevented() {
        return this.prevented;
    }
}

/**
 * Arguments for the `clear` event. The `clear` event fires when
 * the **Clear** button is clicked. At this point, the selected files are about to be cleared.
 *
 * ```ts-no-run
 *  @Component({
 *    selector: 'my-upload',
 *    template: `
 *    <kendo-upload
 *      [autoUpload]="false"
 *      [saveUrl]="uploadSaveUrl"
 *      [removeUrl]="uploadRemoveUrl"
 *      (clear)="clearEventHandler($event)">
 *    </kendo-upload>
 *    `
 *  })
 *  export class UploadComponent {
 *    uploadSaveUrl = 'saveUrl'; // should represent an actual API endpoint
 *    uploadRemoveUrl = 'removeUrl'; // should represent an actual API endpoint
 *
 *    clearEventHandler(e: ClearEvent) {
 *      console.log('Clearing the file upload');
 *    }
 *  }
 * ```
 */
class ClearEvent extends PreventableEvent {
    /**
     * Constructs the event arguments for the `clear` event.
     */
    constructor() { super(); }
}

/**
 * Arguments for the `error` event. The `error` event fires when
 * an `upload` or `remove` operation fails.
 *
 * ```ts-no-run
 *  @Component({
 *    selector: 'my-upload',
 *    template: `
 *    <kendo-upload
 *      [saveUrl]="uploadSaveUrl"
 *      [removeUrl]="uploadRemoveUrl"
 *      (error)="errorEventHandler($event)">
 *    </kendo-upload>
 *    `
 *  })
 *  export class UploadComponent {
 *    uploadSaveUrl = 'saveUrl'; // should represent an actual API endpoint
 *    uploadRemoveUrl = 'removeUrl'; // should represent an actual API endpoint
 *
 *    errorEventHandler(e: ErrorEvent) {
 *      console.log('An error occurred');
 *    }
 *  }
 * ```
 */
class ErrorEvent {
    /**
     * Constructs the event arguments for the `error` event.
     *
     * @param files - The list of the files that failed to be uploaded or removed.
     * @param operation - The operation type (`upload` or `remove`).
     * @param response - The response object returned by the server.
     */
    constructor(files, operation, response) {
        this.files = files;
        this.operation = operation;
        this.response = response;
    }
}

/**
 * Arguments for the `pause` event. The `pause` event fires when the user
 * pauses a file that is currently uploading.
 *
 * ```ts-no-run
 *  @Component({
 *    selector: 'my-upload',
 *    template: `
 *    <kendo-upload
 *      [chunkable]="true"
 *      [saveUrl]="uploadSaveUrl"
 *      [removeUrl]="uploadRemoveUrl"
 *      (pause)="pauseEventHandler($event)">
 *    </kendo-upload>
 *    `
 *  })
 *  export class UploadComponent {
 *    uploadSaveUrl = 'saveUrl'; // should represent an actual API endpoint
 *    uploadRemoveUrl = 'removeUrl'; // should represent an actual API endpoint
 *
 *    pauseEventHandler(ev: PauseEvent) {
 *      console.log('File paused');
 *    }
 *  }
 * ```
 *
 */
class PauseEvent {
    /**
     * Constructs the event arguments for the `pause` event.
     * @param file - The file that is going to be paused.
     */
    constructor(file) {
        this.file = file;
    }
}

/**
 * Arguments for the `remove` event. The `remove` event fires when an uploaded
 * or selected file is about to be removed. If you cancel the event, the removal is prevented.
 *
 * ```ts-no-run
 *  @Component({
 *    selector: 'my-upload',
 *    template: `
 *    <kendo-upload
 *      [saveUrl]="uploadSaveUrl"
 *      [removeUrl]="uploadRemoveUrl"
 *      (remove)="removeEventHandler($event)">
 *    </kendo-upload>
 *    `
 *  })
 *  export class UploadComponent {
 *    uploadSaveUrl = 'saveUrl'; // should represent an actual API endpoint
 *    uploadRemoveUrl = 'removeUrl'; // should represent an actual API endpoint
 *
 *    removeEventHandler(e: RemoveEvent) {
 *      console.log('Removing a file');
 *    }
 *  }
 * ```
 */
class RemoveEvent extends PreventableEvent {
    /**
     * Constructs the event arguments for the `remove` event.
     * @param files - The list of the files that will be removed.
     * @param headers - The headers of the request.
     */
    constructor(files, headers) {
        super();
        this.files = files;
        this.headers = headers;
    }
}

/**
 * Arguments for the `resume` event. The `resume` event fires when the user
 * resumes the upload of a file that has been previously paused.
 *
 * ```ts-no-run
 *  @Component({
 *    selector: 'my-upload',
 *    template: `
 *    <kendo-upload
 *      [chunkable]="true"
 *      [saveUrl]="uploadSaveUrl"
 *      [removeUrl]="uploadRemoveUrl"
 *      (resume)="resumeEventHandler($event)">
 *    </kendo-upload>
 *    `
 *  })
 *  export class UploadComponent {
 *    uploadSaveUrl = 'saveUrl'; // should represent an actual API endpoint
 *    uploadRemoveUrl = 'removeUrl'; // should represent an actual API endpoint
 *
 *    resumeEventHandler(ev: ResumeEvent) {
 *      console.log('File resumed');
 *    }
 *  }
 * ```
 *
 */
class ResumeEvent {
    /**
     * Constructs the event arguments for the `resume` event.
     * @param file - The file that is going to be resumed.
     */
    constructor(file) {
        this.file = file;
    }
}

/**
 * Arguments for the `select` event. The `select` event fires when the user
 * selects a file or multiple files for upload. If you cancel the event, the selection is prevented.
 *
 * ```ts-no-run
 *  @Component({
 *    selector: 'my-upload',
 *    template: `
 *    <kendo-upload
 *      [saveUrl]="uploadSaveUrl"
 *      [removeUrl]="uploadRemoveUrl"
 *      (select)="selectEventHandler($event)">
 *    </kendo-upload>
 *    `
 *  })
 *  export class UploadComponent {
 *    uploadSaveUrl = 'saveUrl'; // should represent an actual API endpoint
 *    uploadRemoveUrl = 'removeUrl'; // should represent an actual API endpoint
 *
 *    selectEventHandler(e: SelectEvent) {
 *      console.log('File selected');
 *    }
 *  }
 * ```
 */
class SelectEvent extends PreventableEvent {
    /**
     * Constructs the event arguments for the `select` event.
     * @param files - The list of the selected files.
     */
    constructor(files) {
        super();
        this.files = files;
    }
}

/**
 * Arguments for the `success` event. The `success` event fires when
 * the selected files are successfully uploaded or removed.
 *
 * ```ts-no-run
 *  @Component({
 *    selector: 'my-upload',
 *    template: `
 *    <kendo-upload
 *      [saveUrl]="uploadSaveUrl"
 *      [removeUrl]="uploadRemoveUrl"
 *      (success)="successEventHandler($event)">
 *    </kendo-upload>
 *    `
 *  })
 *  export class UploadComponent {
 *    uploadSaveUrl = 'saveUrl'; // should represent an actual API endpoint
 *    uploadRemoveUrl = 'removeUrl'; // should represent an actual API endpoint
 *
 *    successEventHandler(e: SuccessEvent) {
 *      console.log('The ' + e.operation + ' was successful!');
 *    }
 *  }
 * ```
 */
class SuccessEvent extends PreventableEvent {
    /**
     * Constructs the event arguments for the `success` event.
     * @param files - The list of the files that were uploaded or removed.
     * @param operation - The operation type (`upload` or `remove`).
     * @param response - The response object returned by the server.
     */
    constructor(files, operation, response) {
        super();
        this.files = files;
        this.operation = operation;
        this.response = response;
    }
}

/**
 * Arguments for the `upload` event. The `upload` event fires when one or more files are about
 * to be uploaded. If you cancel the event, the upload is prevented. You can add headers to the request.
 *
 * ```ts-no-run
 *  @Component({
 *    selector: 'my-upload',
 *    template: `
 *    <kendo-upload
 *      [saveUrl]="uploadSaveUrl"
 *      [removeUrl]="uploadRemoveUrl"
 *      (upload)="uploadEventHandler($event)">
 *    </kendo-upload>
 *    `
 *  })
 *  export class UploadComponent {
 *    uploadSaveUrl = 'saveUrl'; // should represent an actual API endpoint
 *    uploadRemoveUrl = 'removeUrl'; // should represent an actual API endpoint
 *
 *    uploadEventHandler(e: UploadEvent) {
 *      e.headers = e.headers.append('X-Foo', 'Bar');
 *    }
 *  }
 * ```
 */
class UploadEvent extends PreventableEvent {
    /**
     * Constructs the event arguments for the `upload` event.
     * @param files - The list of the files that will be uploaded.
     * @param headers - The headers of the request.
     */
    constructor(files, headers) {
        super();
        this.files = files;
        this.headers = headers;
    }
}

/**
 * Arguments for the `uploadprogress` event. The `uploadprogress` event
 * fires when the files are in the process of uploading.
 *
 * ```ts-no-run
 *  @Component({
 *    selector: 'my-upload',
 *    template: `
 *    <kendo-upload
 *      [saveUrl]="uploadSaveUrl"
 *      [removeUrl]="uploadRemoveUrl"
 *      (uploadProgress)="uploadProgressEventHandler($event)">
 *    </kendo-upload>
 *    `
 *  })
 *  export class UploadComponent {
 *    uploadSaveUrl = 'saveUrl'; // should represent an actual API endpoint
 *    uploadRemoveUrl = 'removeUrl'; // should represent an actual API endpoint
 *
 *    uploadProgressEventHandler(e: UploadProgressEvent) {
 *      console.log(e.files[0].name + ' is ' + e.percentComplete + ' uploaded');
 *    }
 *  }
 * ```
 */
class UploadProgressEvent {
    /**
     * Constructs the event arguments for the `uploadprogress` event.
     * @param files - The list of files that are being uploaded.
     * @param percentComplete - The portion that has been uploaded.
     */
    constructor(files, percentComplete) {
        this.files = files;
        this.percentComplete = percentComplete;
    }
}

/* tslint:disable: no-bitwise */
/**
 * @hidden
 */
const getTotalFilesSizeMessage = (files) => {
    let totalSize = 0;
    let i;
    if (typeof files[0].size === "number") {
        for (i = 0; i < files.length; i++) {
            if (files[i].size) {
                totalSize += files[i].size;
            }
        }
    }
    else {
        return "";
    }
    totalSize /= 1024;
    if (totalSize < 1024) {
        return totalSize.toFixed(2) + " KB";
    }
    else {
        return (totalSize / 1024).toFixed(2) + " MB";
    }
};
const stripPath = (name) => {
    let slashIndex = name.lastIndexOf("\\");
    return (slashIndex !== -1) ? name.substr(slashIndex + 1) : name;
};
const getFileExtension = (fileName) => {
    const rFileExtension = /\.([^\.]+)$/;
    const matches = fileName.match(rFileExtension);
    return matches ? matches[0] : "";
};
const ampRegExp = /&/g;
const ltRegExp = /</g;
const quoteRegExp = /"/g;
const aposRegExp = /'/g;
const gtRegExp = />/g;
const htmlEncode = (value) => {
    return ("" + value).replace(ampRegExp, "&amp;")
        .replace(ltRegExp, "&lt;")
        .replace(gtRegExp, "&gt;")
        .replace(quoteRegExp, "&quot;")
        .replace(aposRegExp, "&#39;");
};
/**
 * @hidden
 */
const validateInitialFileInfo = (file) => {
    if (file instanceof Object && file.hasOwnProperty("name")) {
        return true;
    }
    return false;
};
/**
 * @hidden
 */
const getInitialFileInfo = (fakeFile) => {
    fakeFile.extension = fakeFile.extension || getFileExtension(fakeFile.name);
    fakeFile.name = htmlEncode(fakeFile.name);
    fakeFile.size = fakeFile.size || 0;
    if (!fakeFile.hasOwnProperty("state")) {
        fakeFile.state = FileState.Initial;
    }
    if (!fakeFile.hasOwnProperty("uid")) {
        fakeFile.uid = guid();
    }
    return fakeFile;
};
const getFileInfo = (rawFile) => {
    const fileName = rawFile.name;
    const fileSize = rawFile.size;
    return {
        extension: getFileExtension(fileName),
        name: htmlEncode(fileName),
        rawFile: rawFile,
        size: fileSize,
        state: FileState.Selected
    };
};
/**
 * @hidden
 */
const getAllFileInfo = (rawFiles) => {
    let allFileInfo = new Array();
    let i;
    for (i = 0; i < rawFiles.length; i++) {
        allFileInfo.push(getFileInfo(rawFiles[i]));
    }
    return allFileInfo;
};
/**
 * @hidden
 */
const fileHasValidationErrors = (file) => {
    if (file.validationErrors && file.validationErrors.length > 0) {
        return true;
    }
    return false;
};
/**
 * @hidden
 */
const filesHaveValidationErrors = (files) => {
    for (let file of files) {
        if (fileHasValidationErrors(file)) {
            return true;
        }
    }
    return false;
};
/**
 * @hidden
 */
const inputFiles = (input) => {
    if (input.files) {
        return getAllFileInfo(input.files);
    }
    else {
        //Required for testing
        let fileNames = input.value.split("|").map((file, index) => {
            let fileName = file.trim();
            return {
                extension: getFileExtension(fileName),
                name: stripPath(fileName),
                rawFile: null,
                size: (index + 1) * 1000,
                state: FileState.Selected
            };
        });
        return fileNames;
    }
};
/**
 * @hidden
 */
const assignGuidToFiles = (files, isUnique) => {
    const uid = guid();
    return files.map((file) => {
        file.uid = isUnique ? guid() : uid;
        return file;
    });
};
/**
 * @hidden
 */

/**
 * @hidden
 */

const focusableRegex = /^(?:a|input|select|textarea|button|object)$/i;
/**
 * @hidden
 */
const IGNORE_TARGET_CLASSES = 'k-icon k-select k-input';
/**
 * @hidden
 */
const UPLOAD_CLASSES = 'k-upload-button k-clear-selected k-upload-selected k-upload-action';
const isVisible = (element) => {
    const rect = element.getBoundingClientRect();
    return !!(rect.width && rect.height) && window.getComputedStyle(element).visibility !== 'hidden';
};
const toClassList = (classNames) => String(classNames).trim().split(' ');
/**
 * @hidden
 */
const hasClasses = (element, classNames) => {
    const namesList = toClassList(classNames);
    return Boolean(toClassList(element.className).find((className) => namesList.indexOf(className) >= 0));
};
/**
 * @hidden
 */
const isFocusable = (element, checkVisibility = true) => {
    if (element.tagName) {
        const tagName = element.tagName.toLowerCase();
        const tabIndex = element.getAttribute('tabIndex');
        const validTabIndex = tabIndex !== null && !isNaN(tabIndex) && tabIndex > -1;
        let focusable = false;
        if (focusableRegex.test(tagName)) {
            focusable = !element.disabled;
        }
        else {
            focusable = validTabIndex;
        }
        return focusable && (!checkVisibility || isVisible(element));
    }
    return false;
};

/**
 * @hidden
 */
class ChunkMap {
    constructor() {
        this._files = {};
    }
    add(uid, totalChunks) {
        const initialChunkInfo = {
            index: 0,
            position: 0,
            retries: 0,
            totalChunks: totalChunks
        };
        this._files[uid] = initialChunkInfo;
        return initialChunkInfo;
    }
    remove(uid) {
        if (this.has(uid)) {
            this._files[uid] = null;
            delete this._files[uid];
        }
    }
    has(uid) {
        return uid in this._files;
    }
    get(uid) {
        return this._files[uid];
    }
}

/**
 * @hidden
 */
class UploadService {
    constructor(http$$1) {
        this.http = http$$1;
        this.cancelEvent = new EventEmitter();
        this.clearEvent = new EventEmitter();
        this.completeEvent = new EventEmitter();
        this.errorEvent = new EventEmitter();
        this.pauseEvent = new EventEmitter();
        this.removeEvent = new EventEmitter();
        this.resumeEvent = new EventEmitter();
        this.selectEvent = new EventEmitter();
        this.successEvent = new EventEmitter();
        this.uploadEvent = new EventEmitter();
        this.uploadProgressEvent = new EventEmitter();
        /**
         * Required for the `ControlValueAccessor` integration
         */
        this.changeEvent = new EventEmitter();
        /**
         * Default async settings
         */
        this.async = {
            autoUpload: true,
            batch: false,
            chunk: false,
            concurrent: true,
            removeField: "fileNames",
            removeHeaders: new HttpHeaders(),
            removeMethod: "POST",
            removeUrl: "",
            responseType: "json",
            saveField: "files",
            saveHeaders: new HttpHeaders(),
            saveMethod: "POST",
            saveUrl: "",
            withCredentials: true
        };
        /**
         * Default chunk settings
         */
        this.chunk = {
            autoRetryAfter: 100,
            size: 1024 * 1024,
            maxAutoRetries: 1,
            resumable: true
        };
        this.component = 'Upload';
        this.chunkMap = new ChunkMap();
        this.fileList = new FileMap();
    }
    get files() {
        return this.fileList;
    }
    setChunkSettings(settings) {
        if (settings !== false) {
            this.async.chunk = true;
            if (typeof settings === "object") {
                this.chunk = Object.assign({}, this.chunk, settings);
            }
        }
    }
    onChange() {
        let files = this.fileList.filesFlat.filter((file) => {
            return file.state === FileState.Initial ||
                file.state === FileState.Uploaded;
        });
        this.changeEvent.emit(files.length > 0 ? files : null);
    }
    addFiles(files) {
        let selectEventArgs = new SelectEvent(files);
        this.selectEvent.emit(selectEventArgs);
        if (!selectEventArgs.isDefaultPrevented()) {
            for (let file of files) {
                this.fileList.add(file);
            }
            if (this.async.autoUpload) {
                this.uploadFiles();
            }
        }
        if (this.component === 'FileSelect') {
            this.changeEvent.emit(this.fileList.filesFlat);
        }
    }
    addInitialFiles(initialFiles) {
        this.fileList.clear();
        initialFiles.forEach((file) => {
            let fakeFile = getInitialFileInfo(file);
            this.fileList.add(fakeFile);
        });
    }
    resumeFile(uid) {
        const fileToResume = this.fileList.get(uid);
        this.resumeEvent.emit(new ResumeEvent(fileToResume[0]));
        this.fileList.setFilesStateByUid(uid, FileState.Uploading);
        this._uploadFiles([fileToResume]);
    }
    pauseFile(uid) {
        let pausedFile = this.fileList.get(uid)[0];
        this.pauseEvent.emit(new PauseEvent(pausedFile));
        this.fileList.setFilesStateByUid(uid, FileState.Paused);
    }
    removeFiles(uid) {
        let removedFiles = this.fileList.get(uid);
        // Clone the Headers so that the default ones are not overridden
        let removeEventArgs = new RemoveEvent(removedFiles, this.cloneRequestHeaders(this.async.removeHeaders));
        this.removeEvent.emit(removeEventArgs);
        if (!removeEventArgs.isDefaultPrevented()) {
            if (this.component === 'Upload' &&
                (removedFiles[0].state === FileState.Uploaded ||
                    removedFiles[0].state === FileState.Initial)) {
                this.performRemove(removedFiles, removeEventArgs);
            }
            else {
                this.fileList.remove(uid);
                if (this.component === 'FileSelect') {
                    this.changeEvent.emit(this.fileList.filesFlat);
                }
            }
        }
    }
    cancelFiles(uid) {
        let canceledFiles = this.fileList.get(uid);
        let cancelEventArgs = new CancelEvent(canceledFiles);
        this.cancelEvent.emit(cancelEventArgs);
        for (let file of canceledFiles) {
            if (file.httpSubscription) {
                file.httpSubscription.unsubscribe();
            }
        }
        this.fileList.remove(uid);
        this.checkAllComplete();
    }
    clearFiles() {
        let clearEventArgs = new ClearEvent();
        this.clearEvent.emit(clearEventArgs);
        if (!clearEventArgs.isDefaultPrevented()) {
            let triggerChange = this.fileList.hasFileWithState([
                FileState.Initial,
                FileState.Uploaded
            ]);
            this.fileList.clear();
            if (triggerChange) {
                this.onChange();
            }
        }
    }
    uploadFiles() {
        let filesToUpload = [];
        if (this.async.concurrent) {
            filesToUpload = this.fileList.filesToUpload;
        }
        if (!this.async.concurrent && !this.fileList.hasFileWithState([FileState.Uploading])) {
            filesToUpload = [this.fileList.firstFileToUpload];
        }
        if (filesToUpload && filesToUpload.length > 0) {
            this._uploadFiles(filesToUpload);
        }
    }
    retryFiles(uid) {
        let filesToRetry = [this.fileList.get(uid)];
        if (filesToRetry) {
            this._uploadFiles(filesToRetry);
        }
    }
    _uploadFiles(allFiles) {
        for (let filesToUpload of allFiles) {
            if (filesToUpload[0].state === FileState.Paused) {
                return;
            }
            // Clone the Headers so that the default ones are not overridden
            let uploadEventArgs = new UploadEvent(filesToUpload, this.cloneRequestHeaders(this.async.saveHeaders));
            this.uploadEvent.emit(uploadEventArgs);
            if (!uploadEventArgs.isDefaultPrevented()) {
                this.fileList.setFilesState(filesToUpload, FileState.Uploading);
                let httpSubcription = this.performUpload(filesToUpload, uploadEventArgs);
                filesToUpload.forEach((file) => {
                    file.httpSubscription = httpSubcription;
                });
            }
            else {
                this.fileList.remove(filesToUpload[0].uid);
            }
        }
    }
    performRemove(files, removeEventArgs) {
        const async = this.async;
        let fileNames = files.map((file) => {
            return file.name;
        });
        let formData = this.populateRemoveFormData(fileNames, removeEventArgs.data);
        let options = this.populateRequestOptions(removeEventArgs.headers);
        let removeRequest = new HttpRequest(async.removeMethod, async.removeUrl, formData, options);
        this.http.request(removeRequest)
            .subscribe(success => {
            this.onSuccess(success, files, "remove");
        }, error => {
            this.onError(error, files, "remove");
        });
    }
    performUpload(files, uploadEventArgs) {
        const async = this.async;
        let formData = this.populateUploadFormData(files, uploadEventArgs.data);
        let options = this.populateRequestOptions(uploadEventArgs.headers);
        let uploadRequest = new HttpRequest(async.saveMethod, async.saveUrl, formData, options);
        let httpSubscription = this.http.request(uploadRequest)
            .subscribe(event => {
            if (event.type === HttpEventType.UploadProgress && !this.async.chunk) {
                this.onProgress(event, files);
            }
            else if (event instanceof HttpResponse) {
                this.onSuccess(event, files, "upload");
                this.checkAllComplete();
            }
        }, error => {
            this.onError(error, files, "upload");
            this.checkAllComplete();
        });
        return httpSubscription;
    }
    onSuccess(successResponse, files, operation) {
        if (operation === "upload" && this.async.chunk) {
            this.onChunkProgress(files);
            if (this.isChunkUploadComplete(files[0].uid)) {
                this.removeChunkInfo(files[0].uid);
            }
            else {
                this.updateChunkInfo(files[0].uid);
                this._uploadFiles([files]);
                return;
            }
        }
        const successArgs = new SuccessEvent(files, operation, successResponse);
        this.successEvent.emit(successArgs);
        if (operation === "upload") {
            this.fileList.setFilesState(files, successArgs.isDefaultPrevented() ? FileState.Failed : FileState.Uploaded);
        }
        else {
            if (!successArgs.isDefaultPrevented()) {
                this.fileList.remove(files[0].uid);
            }
        }
        if (!successArgs.isDefaultPrevented()) {
            this.onChange();
        }
    }
    onError(errorResponse, files, operation) {
        if (operation === "upload" && this.async.chunk) {
            const maxRetries = this.chunk.maxAutoRetries;
            const chunkInfo = this.chunkMap.get(files[0].uid);
            if (chunkInfo.retries < maxRetries) {
                chunkInfo.retries += 1;
                setTimeout(() => {
                    this.retryFiles(files[0].uid);
                }, this.chunk.autoRetryAfter);
                return;
            }
        }
        const errorArgs = new ErrorEvent(files, operation, errorResponse);
        this.errorEvent.emit(errorArgs);
        if (operation === "upload") {
            this.fileList.setFilesState(files, FileState.Failed);
        }
    }
    onProgress(event, files) {
        const percentComplete = Math.round(100 * event.loaded / event.total);
        const progressArgs = new UploadProgressEvent(files, percentComplete < 100 ? percentComplete : 100);
        this.uploadProgressEvent.emit(progressArgs);
    }
    onChunkProgress(files) {
        const chunkInfo = this.chunkMap.get(files[0].uid);
        let percentComplete = 0;
        if (chunkInfo) {
            if (chunkInfo.index === chunkInfo.totalChunks - 1) {
                percentComplete = 100;
            }
            else {
                percentComplete = Math.round(((chunkInfo.index + 1) / chunkInfo.totalChunks) * 100);
            }
        }
        const progressArgs = new UploadProgressEvent(files, percentComplete < 100 ? percentComplete : 100);
        this.uploadProgressEvent.emit(progressArgs);
    }
    checkAllComplete() {
        if (!this.fileList.hasFileWithState([
            FileState.Selected,
            FileState.Uploading,
            FileState.Paused
        ])) {
            this.completeEvent.emit();
        }
        else if (this.shouldUploadNextFile()) {
            this.uploadFiles();
        }
    }
    shouldUploadNextFile() {
        return !this.async.concurrent &&
            this.fileList.hasFileWithState([FileState.Selected]) &&
            !this.fileList.hasFileWithState([FileState.Uploading]);
    }
    cloneRequestHeaders(headers) {
        let cloned = {};
        if (headers) {
            headers.keys().forEach((key) => {
                cloned[key] = headers.get(key);
            });
        }
        return new HttpHeaders(cloned);
    }
    populateRequestOptions(headers) {
        return {
            headers: headers,
            reportProgress: true,
            responseType: this.async.responseType,
            withCredentials: this.async.withCredentials
        };
    }
    populateUploadFormData(files, clientData) {
        const saveField = this.async.saveField;
        let data = new FormData();
        this.populateClientFormData(data, clientData);
        if (this.async.chunk) {
            data.append(saveField, this.getNextChunk(files[0]));
            data.append("metadata", this.getChunkMetadata(files[0]));
        }
        else {
            for (let file of files) {
                data.append(saveField, file.rawFile);
            }
        }
        return data;
    }
    populateRemoveFormData(fileNames, clientData) {
        let data = new FormData();
        this.populateClientFormData(data, clientData);
        for (let fileName of fileNames) {
            data.append(this.async.removeField, fileName);
        }
        return data;
    }
    populateClientFormData(data, clientData) {
        for (var key in clientData) {
            if (clientData.hasOwnProperty(key)) {
                data.append(key, clientData[key]);
            }
        }
    }
    /* Chunking Helper Methods Section */
    getNextChunk(file) {
        const info = this.getChunkInfo(file);
        const newPosition = info.position + this.chunk.size;
        return file.rawFile.slice(info.position, newPosition);
    }
    getChunkInfo(file) {
        let chunkInfo = this.chunkMap.get(file.uid);
        if (!chunkInfo) {
            const totalChunks = Math.ceil(file.size / this.chunk.size);
            chunkInfo = this.chunkMap.add(file.uid, totalChunks);
        }
        return chunkInfo;
    }
    updateChunkInfo(uid) {
        const chunkInfo = this.chunkMap.get(uid);
        if (chunkInfo.index < chunkInfo.totalChunks - 1) {
            chunkInfo.index += 1;
            chunkInfo.position += this.chunk.size;
            chunkInfo.retries = 0;
        }
    }
    removeChunkInfo(uid) {
        this.chunkMap.remove(uid);
    }
    getChunkMetadata(file) {
        const chunkInfo = this.chunkMap.get(file.uid);
        const chunkMetadata = {
            chunkIndex: chunkInfo.index,
            contentType: file.rawFile.type,
            fileName: file.name,
            fileSize: file.size,
            fileUid: file.uid,
            totalChunks: chunkInfo.totalChunks
        };
        return JSON.stringify(chunkMetadata);
    }
    isChunkUploadComplete(uid) {
        const chunkInfo = this.chunkMap.get(uid);
        if (chunkInfo) {
            return chunkInfo.index + 1 === chunkInfo.totalChunks;
        }
        return false;
    }
}
UploadService.ɵfac = function UploadService_Factory(t) { return new (t || UploadService)(ɵngcc0.ɵɵinject(ɵngcc1.HttpClient)); };
UploadService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: UploadService, factory: UploadService.ɵfac });
/** @nocollapse */
UploadService.ctorParameters = () => [
    { type: HttpClient }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(UploadService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.HttpClient }]; }, null); })();

/**
 * @hidden
 */
class NavigationService {
    constructor(uploadService) {
        this.uploadService = uploadService;
        this.onActionButtonAction = new EventEmitter();
        this.onActionButtonFocus = new EventEmitter();
        this.onFileAction = new EventEmitter();
        this.onFileFocus = new EventEmitter();
        this.onTab = new EventEmitter();
        this.onWrapperFocus = new EventEmitter();
        this.onSelectButtonFocus = new EventEmitter();
        this.actionButtonsVisible = false;
        this.focused = false;
        this._focusedIndex = -1;
    }
    action(event) {
        const key = event.keyCode;
        return this.keyBindings[key];
    }
    process(event) {
        const handler = this.action(event);
        if (handler) {
            handler(event.shiftKey);
        }
    }
    computeKeys(direction) {
        this.keyBindings = {
            [Keys.Enter]: () => this.handleEnter(),
            [Keys.Escape]: () => this.handleEscape(),
            [Keys.Delete]: () => this.handleDelete(),
            [Keys.Tab]: (shifted) => this.handleTab(shifted),
            [Keys.ArrowUp]: () => this.handleUp(),
            [Keys.ArrowDown]: () => this.handleDown(),
            [this.invertKeys(direction, Keys.ArrowLeft, Keys.ArrowRight)]: () => this.handleLeft(),
            [this.invertKeys(direction, Keys.ArrowRight, Keys.ArrowLeft)]: () => this.handleRight()
        };
    }
    invertKeys(direction, original, inverted) {
        return direction === 'rtl' ? inverted : original;
    }
    focusSelectButton() {
        this.focused = true;
        this._focusedIndex = -1;
        this.onSelectButtonFocus.emit();
    }
    handleEnter() {
        if (this.lastIndex >= 0) {
            if (this.focusedIndex <= this.lastFileIndex) {
                this.onFileAction.emit(Keys.Enter);
                return;
            }
            if (this.actionButtonsVisible && this.focusedIndex <= this.lastIndex) {
                this.onActionButtonAction.emit(this.focusedIndex < this.lastIndex ? "clear" : "upload");
            }
        }
    }
    handleDelete() {
        if (this.focusedIndex >= 0 && this.focusedIndex <= this.lastFileIndex) {
            this.onFileAction.emit(Keys.Delete);
        }
    }
    handleEscape() {
        if (this.focusedIndex >= 0 && this.focusedIndex <= this.lastFileIndex) {
            this.onFileAction.emit(Keys.Escape);
        }
    }
    handleLeft() {
        if (this.actionButtonsVisible && this.focusedIndex === this.lastIndex) {
            this.focusedIndex -= 1;
            this.onActionButtonFocus.emit("clear");
        }
    }
    handleRight() {
        if (this.actionButtonsVisible && this.focusedIndex === this.lastIndex - 1) {
            this.focusedIndex += 1;
            this.onActionButtonFocus.emit("upload");
        }
    }
    handleTab(shifted) {
        if (this.focusedIndex >= 0 && shifted) {
            this.focusedIndex = -1;
            return;
        }
        this.onTab.emit();
    }
    handleDown() {
        if (this.lastIndex >= 0 && this.focusedIndex < this.lastIndex) {
            if (this.focusedIndex < this.lastFileIndex) {
                this.focusedIndex += 1;
                this.onFileFocus.emit(this.focusedIndex);
                return;
            }
            if (this.actionButtonsVisible && this.focusedIndex === this.lastFileIndex) {
                this.focusedIndex += 1;
                this.onActionButtonFocus.emit("clear");
            }
        }
    }
    handleUp() {
        if (this.lastIndex >= 0 && this.focusedIndex > -1) {
            this.focusedIndex -= 1;
            if (this.focusedIndex === -1) {
                this.onSelectButtonFocus.emit();
                return;
            }
            if (this.focusedIndex <= this.lastFileIndex) {
                this.onFileFocus.emit(this.focusedIndex);
                return;
            }
            if (this.actionButtonsVisible && this.focusedIndex <= this.lastIndex) {
                this.focusedIndex = this.lastFileIndex;
                this.onFileFocus.emit(this.focusedIndex);
            }
        }
    }
    get focusedIndex() {
        return this._focusedIndex;
    }
    set focusedIndex(index) {
        if (!this.focused) {
            this.onWrapperFocus.emit();
        }
        this._focusedIndex = index;
        this.focused = true;
        if (this._focusedIndex >= 0 && this._focusedIndex <= this.lastFileIndex) {
            this.onFileFocus.emit(index);
        }
    }
    get lastFileIndex() {
        return this.actionButtonsVisible ? this.lastIndex - 2 : this.lastIndex;
    }
    get lastIndex() {
        const fileCount = this.uploadService.files.count;
        return this.actionButtonsVisible ? fileCount + 1 : fileCount - 1;
    }
}
NavigationService.ɵfac = function NavigationService_Factory(t) { return new (t || NavigationService)(ɵngcc0.ɵɵinject(UploadService)); };
NavigationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NavigationService, factory: NavigationService.ɵfac });
/** @nocollapse */
NavigationService.ctorParameters = () => [
    { type: UploadService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NavigationService, [{
        type: Injectable
    }], function () { return [{ type: UploadService }]; }, null); })();

/**
 * Used to customize the rendering of the files in the list ([see example]({% slug templates_upload %})).
 */
class FileTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
FileTemplateDirective.ɵfac = function FileTemplateDirective_Factory(t) { return new (t || FileTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
FileTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FileTemplateDirective, selectors: [["", "kendoUploadFileTemplate", ""], ["", "kendoFileSelectFileTemplate", ""]] });
/** @nocollapse */
FileTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FileTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoUploadFileTemplate], [kendoFileSelectFileTemplate]' // tslint:disable-line:directive-selector-prefix
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();

/**
 * @hidden
 */
const FILESELECT_VALUE_ACCESSOR = {
    multi: true,
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => FileSelectComponent) // tslint:disable-line:no-forward-ref
};
class FileSelectComponent {
    constructor(uploadService, localization, navigation, ngZone, renderer, wrapper) {
        this.uploadService = uploadService;
        this.localization = localization;
        this.navigation = navigation;
        this.ngZone = ngZone;
        this.renderer = renderer;
        /**
         * Disables the FileSelect.
         * The default value is `false`.
         */
        this.disabled = false;
        /**
         * Enables the selection of multiple files
         * ([see example]({% slug fileprocessing_upload %}#toc-upload-of-sinlge-or-multiple-files)).
         * If set to `false`, only one file can be selected at a time.
         */
        this.multiple = true;
        /**
         * Toggles the visibility of the file list.
         */
        this.showFileList = true;
        /**
         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the FileSelect.
         */
        this.tabindex = 0;
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        /**
         * Fires when the user navigates outside the component.
         */
        this.onBlur = new EventEmitter();
        /**
         * Fires when the component is focused.
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires when files are selected. If prevented, the selected files will not be added to the list.
         */
        this.select = new EventEmitter();
        /**
         * Fires when a file is about to be removed. If prevented, the file will remain in the list.
         */
        this.remove = new EventEmitter();
        /**
         * Fires when the value of the component has changed as a result of a successful `select` or `remove` operation.
         */
        this.valueChange = new EventEmitter();
        this.hostDefaultClasses = true;
        /**
         * @hidden
         */
        this._restrictions = {
            allowedExtensions: [],
            maxFileSize: 0,
            minFileSize: 0
        };
        this.onTouchedCallback = (_) => { };
        this.onChangeCallback = (_) => { };
        this.wrapper = wrapper.nativeElement;
        this.direction = localization.rtl ? 'rtl' : 'ltr';
        this.navigation.computeKeys(this.direction);
        this.fileList = this.uploadService.files;
        this.localizationChangeSubscription = localization.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
            this.navigation.computeKeys(this.direction);
        });
        this.subscribeBlur();
        this.subscribeFocus();
        this.attachEventHandlers();
        this.setDefaultSettings();
    }
    /**
     * Sets the `name` attribute of the `input` element of the FileSelect.
     */
    set name(name) {
        this.uploadService.async.saveField = name;
    }
    get name() {
        return this.uploadService.async.saveField;
    }
    /**
     * Sets the restrictions for selected files.
     */
    set restrictions(restrictions) {
        let parsedRestrictions = Object.assign({}, this._restrictions, restrictions);
        this._restrictions = parsedRestrictions;
    }
    get restrictions() {
        return this._restrictions;
    }
    get hostDisabledClass() {
        return this.disabled;
    }
    get dir() {
        return this.direction;
    }
    ngOnInit() {
        this.renderer.removeAttribute(this.wrapper, "tabindex");
    }
    /**
     * @hidden
     */
    textFor(key) {
        return this.localization.get(key);
    }
    /**
     * Focuses the underlying input element.
     */
    focus() {
        setTimeout(() => {
            this.fileSelectButton.nativeElement.focus();
        });
    }
    ngOnDestroy() {
        this.fileList.clear();
        if (this.blurSubscription) {
            this.blurSubscription.unsubscribe();
        }
        if (this.wrapperFocusSubscription) {
            this.wrapperFocusSubscription.unsubscribe();
        }
        if (this.selectButtonFocusSubscription) {
            this.selectButtonFocusSubscription.unsubscribe();
        }
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
        if (this.subs) {
            this.subs.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    handleKeydown(event) {
        if (this.disabled) {
            return;
        }
        if ((event.keyCode === Keys.Enter || event.keyCode === Keys.Space) &&
            event.target === this.fileSelectButton.nativeElement) {
            event.preventDefault();
            this.fileSelect.nativeElement.click();
            return;
        }
        if (hasClasses(event.target, UPLOAD_CLASSES) ||
            (!isFocusable(event.target) && !hasClasses(event.target, IGNORE_TARGET_CLASSES))) {
            this.navigation.process(event);
        }
    }
    /**
     * @hidden
     */
    writeValue(newValue) {
        let isValid = true;
        if (newValue instanceof Array) {
            newValue.forEach((file) => {
                if (!validateInitialFileInfo(file)) {
                    isValid = false;
                }
            });
            if (isValid) {
                this.uploadService.addInitialFiles(newValue);
            }
        }
        if (newValue === null) {
            this.fileList.clear();
        }
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * Removes specific file from the file list.
     */
    removeFileByUid(uid) {
        this.uploadService.removeFiles(uid);
    }
    /**
     * Visually clears all files from the UI.
     */
    clearFiles() {
        this.uploadService.clearFiles();
    }
    /**
     * @hidden
     * Used to determine if the component is empty.
     */
    isEmpty() {
        return false;
    }
    /**
     * @hidden
     */
    get selectButtonTabIndex() {
        return this.disabled ? undefined : this.tabindex;
    }
    /**
     * @hidden
     */
    onFileSelectButtonFocus(_event) {
        this.renderer.addClass(this.fileSelectButton.nativeElement, 'k-state-focused');
        if (!this.navigation.focused) {
            this.navigation.focusedIndex = -1;
        }
    }
    /**
     * @hidden
     */
    onFileSelectButtonBlur(_event) {
        this.renderer.removeClass(this.fileSelectButton.nativeElement, 'k-state-focused');
    }
    subscribeBlur() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            this.documentClick = fromEvent(document, 'click').pipe(filter((event) => {
                return !(this.wrapper !== event.target && this.wrapper.contains(event.target));
            }));
            this.blurSubscription = merge(this.documentClick, this.navigation.onTab).subscribe(() => this.ngZone.run(() => {
                if (this.navigation.focused) {
                    this.navigation.focused = false;
                    this.onTouchedCallback();
                    this.onBlur.emit();
                }
            }));
        });
    }
    subscribeFocus() {
        this.wrapperFocusSubscription = this.navigation.onWrapperFocus.subscribe(() => {
            this.onFocus.emit();
        });
        this.selectButtonFocusSubscription = this.navigation.onSelectButtonFocus.subscribe(() => {
            this.fileSelectButton.nativeElement.focus();
        });
    }
    attachEventHandlers() {
        this.subs = this.uploadService.changeEvent.subscribe((files) => {
            const rawFiles = files.map(file => file.rawFile);
            this.onChangeCallback(rawFiles);
            this.valueChange.emit(rawFiles);
        });
        this.subs.add(this.uploadService.removeEvent.subscribe((args) => {
            this.remove.emit(args);
        }));
        this.subs.add(this.uploadService.selectEvent.subscribe((args) => {
            this.select.emit(args);
        }));
    }
    setDefaultSettings() {
        this.uploadService.async.autoUpload = false;
        this.uploadService.component = 'FileSelect';
    }
}
FileSelectComponent.ɵfac = function FileSelectComponent_Factory(t) { return new (t || FileSelectComponent)(ɵngcc0.ɵɵdirectiveInject(UploadService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
FileSelectComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FileSelectComponent, selectors: [["kendo-fileselect"]], contentQueries: function FileSelectComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, FileTemplateDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.fileTemplate = _t.first);
    } }, viewQuery: function FileSelectComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
        ɵngcc0.ɵɵviewQuery(_c1, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.fileSelect = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.fileSelectButton = _t.first);
    } }, hostVars: 9, hostBindings: function FileSelectComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function FileSelectComponent_keydown_HostBindingHandler($event) { return ctx.handleKeydown($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.dir);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.hostDefaultClasses)("k-upload", ctx.hostDefaultClasses)("k-header", ctx.hostDefaultClasses)("k-state-disabled", ctx.hostDisabledClass);
    } }, inputs: { disabled: "disabled", multiple: "multiple", showFileList: "showFileList", tabindex: "tabindex", focusableId: "focusableId", name: "name", restrictions: "restrictions", accept: "accept" }, outputs: { onBlur: "blur", onFocus: "focus", select: "select", remove: "remove", valueChange: "valueChange" }, exportAs: ["kendoFileSelect"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            NavigationService,
            UploadService,
            FILESELECT_VALUE_ACCESSOR,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.fileselect'
            },
            {
                provide: KendoInput,
                useExisting: forwardRef(() => FileSelectComponent)
            }
        ])], decls: 12, vars: 14, consts: [["kendoUploadLocalizedMessages", "", 6, "dropFilesHere", "invalidFileExtension", "invalidMaxFileSize", "invalidMinFileSize", "remove", "select"], ["kendoUploadDropzone", "", 3, "restrictions", "multiple", "disabled"], ["role", "button", 1, "k-button", "k-upload-button", 3, "id", "focus", "blur"], ["fileSelectButton", ""], ["kendoFileSelect", "", 3, "dir", "restrictions", "multiple", "disabled"], ["fileSelect", ""], [1, "k-dropzone-hint"], ["kendo-upload-file-list", "", "class", "k-upload-files k-reset", 3, "disabled", "fileList", "fileTemplate", 4, "ngIf"], ["kendo-upload-file-list", "", 1, "k-upload-files", "k-reset", 3, "disabled", "fileList", "fileTemplate"]], template: function FileSelectComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵi18nAttributes(1, _c14);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵelementStart(3, "div", 2, 3);
        ɵngcc0.ɵɵlistener("focus", function FileSelectComponent_Template_div_focus_3_listener($event) { return ctx.onFileSelectButtonFocus($event); })("blur", function FileSelectComponent_Template_div_blur_3_listener($event) { return ctx.onFileSelectButtonBlur($event); });
        ɵngcc0.ɵɵelement(5, "input", 4, 5);
        ɵngcc0.ɵɵelementStart(7, "span");
        ɵngcc0.ɵɵtext(8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(9, "div", 6);
        ɵngcc0.ɵɵtext(10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(11, FileSelectComponent_ul_11_Template, 1, 3, "ul", 7);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("restrictions", ctx.restrictions)("multiple", ctx.multiple)("disabled", ctx.disabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("id", ctx.focusableId);
        ɵngcc0.ɵɵattribute("aria-label", ctx.textFor("select"))("tabindex", ctx.selectButtonTabIndex);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("dir", ctx.direction)("restrictions", ctx.restrictions)("multiple", ctx.multiple)("disabled", ctx.disabled);
        ɵngcc0.ɵɵattribute("accept", ctx.accept ? ctx.accept : null);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.textFor("select"));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.textFor("dropFilesHere"));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showFileList && ctx.fileList.count > 0);
    } }, directives: function () { return [LocalizedMessagesDirective,
        DropZoneDirective,
        FileSelectDirective, ɵngcc3.NgIf, FileListComponent]; }, encapsulation: 2 });
/** @nocollapse */
FileSelectComponent.ctorParameters = () => [
    { type: UploadService },
    { type: LocalizationService },
    { type: NavigationService },
    { type: NgZone },
    { type: Renderer2 },
    { type: ElementRef }
];
FileSelectComponent.propDecorators = {
    accept: [{ type: Input }],
    disabled: [{ type: Input }],
    multiple: [{ type: Input }],
    name: [{ type: Input }],
    showFileList: [{ type: Input }],
    tabindex: [{ type: Input }],
    restrictions: [{ type: Input }],
    focusableId: [{ type: Input }],
    fileTemplate: [{ type: ContentChild, args: [FileTemplateDirective,] }],
    fileSelect: [{ type: ViewChild, args: ['fileSelect',] }],
    fileSelectButton: [{ type: ViewChild, args: ['fileSelectButton',] }],
    onBlur: [{ type: Output, args: ['blur',] }],
    onFocus: [{ type: Output, args: ['focus',] }],
    select: [{ type: Output }],
    remove: [{ type: Output }],
    valueChange: [{ type: Output }],
    hostDefaultClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-upload',] }, { type: HostBinding, args: ['class.k-header',] }],
    hostDisabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }],
    dir: [{ type: HostBinding, args: ['attr.dir',] }],
    handleKeydown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FileSelectComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoFileSelect',
                providers: [
                    LocalizationService,
                    NavigationService,
                    UploadService,
                    FILESELECT_VALUE_ACCESSOR,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.fileselect'
                    },
                    {
                        provide: KendoInput,
                        useExisting: forwardRef(() => FileSelectComponent)
                    }
                ],
                selector: 'kendo-fileselect',
                template: `
        <ng-container kendoUploadLocalizedMessages
            i18n-dropFilesHere="kendo.upload.dropFilesHere|The drop zone hint"
            dropFilesHere="Drop files here to select"

            i18n-invalidFileExtension="kendo.upload.invalidFileExtension|The text for the invalid allowed extensions restriction message"
            invalidFileExtension="File type not allowed."

            i18n-invalidMaxFileSize="kendo.upload.invalidMaxFileSize|The text for the invalid max file size restriction message"
            invalidMaxFileSize="File size too large."

            i18n-invalidMinFileSize="kendo.upload.invalidMinFileSize|The text for the invalid min file size restriction message"
            invalidMinFileSize="File size too small."

            i18n-remove="kendo.upload.remove|The text for the Remove button"
            remove="Remove"

            i18n-select="kendo.upload.select|The text for the Select button"
            select="Select files..."
        >
        </ng-container>
        <div kendoUploadDropzone
            [restrictions]="restrictions"
            [multiple]="multiple"
            [disabled]="disabled">
            <div role="button" #fileSelectButton
                [id]="focusableId"
                [attr.aria-label]="textFor('select')"
                [attr.tabindex]="selectButtonTabIndex"
                (focus)="onFileSelectButtonFocus($event)"
                (blur)="onFileSelectButtonBlur($event)"
                class="k-button k-upload-button">
                <input #fileSelect kendoFileSelect
                    [attr.accept]="accept ? accept : null"
                    [dir]="direction"
                    [restrictions]="restrictions"
                    [multiple]="multiple"
                    [disabled]="disabled" />
                <span>{{textFor('select')}}</span>
            </div>
            <div class="k-dropzone-hint">{{textFor('dropFilesHere')}}</div>
        </div>
        <ul kendo-upload-file-list
            class="k-upload-files k-reset"
            *ngIf="showFileList && fileList.count > 0"
            [disabled]="disabled"
            [fileList]="fileList.files"
            [fileTemplate]="fileTemplate">
        </ul>
    `
            }]
    }], function () { return [{ type: UploadService }, { type: ɵngcc2.LocalizationService }, { type: NavigationService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { disabled: [{
            type: Input
        }], multiple: [{
            type: Input
        }], showFileList: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], focusableId: [{
            type: Input
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], select: [{
            type: Output
        }], remove: [{
            type: Output
        }], valueChange: [{
            type: Output
        }], hostDefaultClasses: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-upload']
        }, {
            type: HostBinding,
            args: ['class.k-header']
        }], name: [{
            type: Input
        }], restrictions: [{
            type: Input
        }], hostDisabledClass: [{
            type: HostBinding,
            args: ['class.k-state-disabled']
        }], dir: [{
            type: HostBinding,
            args: ['attr.dir']
        }], handleKeydown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], accept: [{
            type: Input
        }], fileTemplate: [{
            type: ContentChild,
            args: [FileTemplateDirective]
        }], fileSelect: [{
            type: ViewChild,
            args: ['fileSelect']
        }], fileSelectButton: [{
            type: ViewChild,
            args: ['fileSelectButton']
        }] }); })();

/**
 * @hidden
 */
class Messages extends ComponentMessages {
}
Messages.ɵfac = function Messages_Factory(t) { return ɵMessages_BaseFactory(t || Messages); };
Messages.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: Messages, inputs: { cancel: "cancel", clearSelectedFiles: "clearSelectedFiles", dropFilesHere: "dropFilesHere", headerStatusPaused: "headerStatusPaused", headerStatusUploaded: "headerStatusUploaded", headerStatusUploading: "headerStatusUploading", invalidFileExtension: "invalidFileExtension", invalidFiles: "invalidFiles", invalidMaxFileSize: "invalidMaxFileSize", invalidMinFileSize: "invalidMinFileSize", pause: "pause", remove: "remove", resume: "resume", retry: "retry", select: "select", uploadSelectedFiles: "uploadSelectedFiles" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
Messages.propDecorators = {
    cancel: [{ type: Input }],
    clearSelectedFiles: [{ type: Input }],
    dropFilesHere: [{ type: Input }],
    headerStatusPaused: [{ type: Input }],
    headerStatusUploaded: [{ type: Input }],
    headerStatusUploading: [{ type: Input }],
    invalidFileExtension: [{ type: Input }],
    invalidFiles: [{ type: Input }],
    invalidMaxFileSize: [{ type: Input }],
    invalidMinFileSize: [{ type: Input }],
    pause: [{ type: Input }],
    remove: [{ type: Input }],
    resume: [{ type: Input }],
    retry: [{ type: Input }],
    select: [{ type: Input }],
    uploadSelectedFiles: [{ type: Input }]
};
const ɵMessages_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(Messages);

/**
 * Custom component messages override default component messages.
 */
class CustomMessagesComponent extends Messages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
}
CustomMessagesComponent.ɵfac = function CustomMessagesComponent_Factory(t) { return new (t || CustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
CustomMessagesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CustomMessagesComponent, selectors: [["kendo-upload-messages"], ["kendo-fileselect-messages"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: Messages,
                useExisting: forwardRef(() => CustomMessagesComponent) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function CustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
CustomMessagesComponent.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: Messages,
                        useExisting: forwardRef(() => CustomMessagesComponent) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-upload-messages, kendo-fileselect-messages',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, null); })();

const INVALIDMAXFILESIZE = "invalidMaxFileSize";
const INVALIDMINFILESIZE = "invalidMinFileSize";
const INVALIDFILEEXTENSION = "invalidFileExtension";
const validateFileExtension = (file, allowedExtensions) => {
    if (allowedExtensions.length > 0) {
        if (allowedExtensions.indexOf(file.extension.toLowerCase()) < 0) {
            file.validationErrors = file.validationErrors || [];
            if (file.validationErrors.indexOf(INVALIDFILEEXTENSION) < 0) {
                file.validationErrors.push(INVALIDFILEEXTENSION);
            }
        }
    }
};
const validateFileSize = (file, minFileSize, maxFileSize) => {
    if (minFileSize !== 0 && file.size < minFileSize) {
        file.validationErrors = file.validationErrors || [];
        if (file.validationErrors.indexOf(INVALIDMINFILESIZE) < 0) {
            file.validationErrors.push(INVALIDMINFILESIZE);
        }
    }
    if (maxFileSize !== 0 && file.size > maxFileSize) {
        file.validationErrors = file.validationErrors || [];
        if (file.validationErrors.indexOf(INVALIDMAXFILESIZE) < 0) {
            file.validationErrors.push(INVALIDMAXFILESIZE);
        }
    }
};
const parseAllowedExtensions = (extensions) => {
    const allowedExtensions = extensions.map((ext) => {
        var parsedExt = (ext.substring(0, 1) === ".") ? ext : ("." + ext);
        return parsedExt.toLowerCase();
    });
    return allowedExtensions;
};
/**
 * @hidden
 */
const validateFiles = (files, restrictionInfo) => {
    const allowedExtensions = parseAllowedExtensions(restrictionInfo.allowedExtensions);
    const maxFileSize = restrictionInfo.maxFileSize;
    const minFileSize = restrictionInfo.minFileSize;
    let i;
    for (i = 0; i < files.length; i++) {
        validateFileExtension(files[i], allowedExtensions);
        validateFileSize(files[i], minFileSize, maxFileSize);
    }
};

/**
 * @hidden
 */
class DropZoneDirective {
    constructor(element, uploadService, _ngZone, renderer) {
        this.element = element;
        this.uploadService = uploadService;
        this._ngZone = _ngZone;
        this.renderer = renderer;
        this.hideIntervalDocument = null;
        this.hideIntervalElement = null;
        this.state = {
            active: "k-dropzone k-dropzone-active",
            hovered: "k-dropzone k-dropzone-active k-dropzone-hovered",
            inactive: "k-dropzone"
        };
        this.element = element;
        this.setClasses(this.state.inactive);
        if (!isDocumentAvailable()) {
            return;
        }
        this._ngZone.runOutsideAngular(() => {
            this.unsubscribeDocumentDragEnter = this.renderer.listen('document', 'dragenter', () => this.onDocumentDragEnter());
            this.unsubscribeDocumentDragOver = this.renderer.listen('document', 'dragover', () => this.onDocumentDragOver());
        });
    }
    ngOnDestroy() {
        this._ngZone.runOutsideAngular(() => {
            if (this.unsubscribeDocumentDragEnter) {
                this.unsubscribeDocumentDragEnter();
            }
            if (this.unsubscribeDocumentDragOver) {
                this.unsubscribeDocumentDragOver();
            }
        });
    }
    /**
     * @hidden
     */
    onDocumentDragEnter() {
        if (this.lastDragElement) {
            if (this.calculateTimeDiff(this.lastDragElement) > 100) {
                this.setClasses(this.state.active);
            }
        }
        else {
            this.setClasses(this.state.active);
        }
        this.lastDragDocument = new Date();
        if (!this.hideIntervalDocument) {
            this.hideIntervalDocument = setInterval(() => {
                if (this.calculateTimeDiff(this.lastDragDocument) < 100) {
                    return;
                }
                this.setClasses(this.state.inactive);
                clearInterval(this.hideIntervalDocument);
                this.hideIntervalDocument = null;
            }, 100);
        }
        return false;
    }
    /**
     * @hidden
     */
    onDocumentDragOver() {
        this.lastDragDocument = new Date();
        return false;
    }
    /**
     * @hidden
     */
    onElementDragEnterListener() {
        this.setClasses(this.state.hovered);
        this.lastDragElement = new Date();
        if (!this.hideIntervalElement) {
            this.hideIntervalElement = setInterval(() => {
                if (this.calculateTimeDiff(this.lastDragElement) < 100) {
                    return;
                }
                if (this.lastDrop) {
                    let diff = this.calculateTimeDiff(this.lastDrop);
                    this.setClasses(diff > 200 ? this.state.active : this.state.inactive);
                }
                else {
                    this.setClasses(this.state.active);
                }
                clearInterval(this.hideIntervalElement);
                this.hideIntervalElement = null;
            }, 100);
        }
        return false;
    }
    /**
     * @hidden
     */
    onElementDragOverListener() {
        this.lastDragElement = new Date();
        return false;
    }
    /**
     * @hidden
     */
    onDropListener(event) {
        this.lastDrop = new Date();
        let droppedFiles = event.dataTransfer.files;
        if (droppedFiles.length > 0 && !this.disabled) {
            let files = getAllFileInfo(droppedFiles);
            files = assignGuidToFiles(files, !this.uploadService.async.batch);
            if (!this.multiple) {
                files.splice(1, files.length - 1);
                this.uploadService.clearFiles();
            }
            validateFiles(files, this.restrictions);
            this.uploadService.addFiles(files);
        }
        return false;
    }
    calculateTimeDiff(prevEvent) {
        return new Date().getTime() - prevEvent.getTime();
    }
    setClasses(classes) {
        if (!this.disabled) {
            this.element.nativeElement.className = classes;
        }
    }
    /**
     * @hidden
     */
    get initialClassName() {
        return true;
    }
}
DropZoneDirective.ɵfac = function DropZoneDirective_Factory(t) { return new (t || DropZoneDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(UploadService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
DropZoneDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DropZoneDirective, selectors: [["", "kendoUploadDropzone", ""]], hostVars: 2, hostBindings: function DropZoneDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("dragenter", function DropZoneDirective_dragenter_HostBindingHandler($event) { return ctx.onElementDragEnterListener(); })("dragover", function DropZoneDirective_dragover_HostBindingHandler($event) { return ctx.onElementDragOverListener(); })("drop", function DropZoneDirective_drop_HostBindingHandler($event) { return ctx.onDropListener($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-dropzone", ctx.initialClassName);
    } }, inputs: { disabled: "disabled", multiple: "multiple", restrictions: "restrictions" } });
/** @nocollapse */
DropZoneDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: UploadService },
    { type: NgZone },
    { type: Renderer2 }
];
DropZoneDirective.propDecorators = {
    disabled: [{ type: Input }],
    multiple: [{ type: Input }],
    restrictions: [{ type: Input }],
    onElementDragEnterListener: [{ type: HostListener, args: ['dragenter',] }],
    onElementDragOverListener: [{ type: HostListener, args: ['dragover',] }],
    onDropListener: [{ type: HostListener, args: ['drop', ['$event'],] }],
    initialClassName: [{ type: HostBinding, args: ['class.k-dropzone',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DropZoneDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoUploadDropzone]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: UploadService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }]; }, { onElementDragEnterListener: [{
            type: HostListener,
            args: ['dragenter']
        }], onElementDragOverListener: [{
            type: HostListener,
            args: ['dragover']
        }], onDropListener: [{
            type: HostListener,
            args: ['drop', ['$event']]
        }], initialClassName: [{
            type: HostBinding,
            args: ['class.k-dropzone']
        }], disabled: [{
            type: Input
        }], multiple: [{
            type: Input
        }], restrictions: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
class FileListItemDirective {
    constructor(el, navigationService) {
        this.navigationService = navigationService;
        this.fileClass = true;
        this.focused = false;
        this.element = el;
    }
    focus() {
        this.element.nativeElement.focus();
    }
    get uidAttribute() {
        return this.files[0].uid;
    }
    get tabIndex() {
        return "-1";
    }
    get kFileError() {
        return this.files[0].state === FileState.Failed;
    }
    get kFileInvalid() {
        return filesHaveValidationErrors(this.files);
    }
    get kFileProgress() {
        return this.files[0].state === FileState.Uploading ||
            this.files[0].state === FileState.Paused;
    }
    get kFileSuccess() {
        return this.files[0].state === FileState.Uploaded ||
            this.files[0].state === FileState.Initial;
    }
    get kStateFocused() {
        return this.focused;
    }
    onFocus() {
        this.focused = true;
    }
    onBlur() {
        this.focused = false;
    }
    onClick(event) {
        if (!isFocusable(event.target) && !hasClasses(event.target, IGNORE_TARGET_CLASSES)) {
            this.navigationService.focusedIndex = this.index;
        }
    }
}
FileListItemDirective.ɵfac = function FileListItemDirective_Factory(t) { return new (t || FileListItemDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NavigationService)); };
FileListItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FileListItemDirective, selectors: [["", "kendoUploadFileListItem", ""]], hostVars: 14, hostBindings: function FileListItemDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focus", function FileListItemDirective_focus_HostBindingHandler($event) { return ctx.onFocus(); })("blur", function FileListItemDirective_blur_HostBindingHandler($event) { return ctx.onBlur(); })("click", function FileListItemDirective_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("data-uid", ctx.uidAttribute)("tabIndex", ctx.tabIndex);
        ɵngcc0.ɵɵclassProp("k-file", ctx.fileClass)("k-file-error", ctx.kFileError)("k-file-invalid", ctx.kFileInvalid)("k-file-progress", ctx.kFileProgress)("k-file-success", ctx.kFileSuccess)("k-state-focused", ctx.kStateFocused);
    } }, inputs: { files: "files", index: "index" } });
/** @nocollapse */
FileListItemDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NavigationService }
];
FileListItemDirective.propDecorators = {
    files: [{ type: Input }],
    index: [{ type: Input }],
    fileClass: [{ type: HostBinding, args: ['class.k-file',] }],
    uidAttribute: [{ type: HostBinding, args: ['attr.data-uid',] }],
    tabIndex: [{ type: HostBinding, args: ['attr.tabIndex',] }],
    kFileError: [{ type: HostBinding, args: ['class.k-file-error',] }],
    kFileInvalid: [{ type: HostBinding, args: ['class.k-file-invalid',] }],
    kFileProgress: [{ type: HostBinding, args: ['class.k-file-progress',] }],
    kFileSuccess: [{ type: HostBinding, args: ['class.k-file-success',] }],
    kStateFocused: [{ type: HostBinding, args: ['class.k-state-focused',] }],
    onFocus: [{ type: HostListener, args: ["focus",] }],
    onBlur: [{ type: HostListener, args: ["blur",] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FileListItemDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoUploadFileListItem]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: NavigationService }]; }, { fileClass: [{
            type: HostBinding,
            args: ['class.k-file']
        }], uidAttribute: [{
            type: HostBinding,
            args: ['attr.data-uid']
        }], tabIndex: [{
            type: HostBinding,
            args: ['attr.tabIndex']
        }], kFileError: [{
            type: HostBinding,
            args: ['class.k-file-error']
        }], kFileInvalid: [{
            type: HostBinding,
            args: ['class.k-file-invalid']
        }], kFileProgress: [{
            type: HostBinding,
            args: ['class.k-file-progress']
        }], kFileSuccess: [{
            type: HostBinding,
            args: ['class.k-file-success']
        }], kStateFocused: [{
            type: HostBinding,
            args: ['class.k-state-focused']
        }], onFocus: [{
            type: HostListener,
            args: ["focus"]
        }], onBlur: [{
            type: HostListener,
            args: ["blur"]
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], files: [{
            type: Input
        }], index: [{
            type: Input
        }] }); })();

/* tslint:disable:component-selector */
/**
 * @hidden
 */
class FileListComponent {
    constructor(uploadService, navigation) {
        this.uploadService = uploadService;
        this.navigation = navigation;
        this.onItemFocus();
        this.onItemAction();
    }
    onItemFocus() {
        this.focusSubscription = this.navigation.onFileFocus.subscribe((index) => {
            this.fileListItems.toArray()[index].focus();
        });
    }
    onItemAction() {
        this.actionSubscription = this.navigation.onFileAction.subscribe((key) => {
            this.itemActionHandler(key);
        });
    }
    itemActionHandler(key) {
        let index = this.navigation.focusedIndex;
        let item = this.fileListItems.toArray()[index];
        let uid = item.uidAttribute;
        let files = this.uploadService.files.get(uid);
        if (key === Keys.Escape && files[0].state === FileState.Uploading) {
            this.uploadService.cancelFiles(uid);
            this.navigation.focusSelectButton();
            return;
        }
        if (key === Keys.Enter && files[0].state === FileState.Failed) {
            this.uploadService.retryFiles(uid);
            return;
        }
        if (key === Keys.Delete) {
            if (files[0].state === FileState.Uploading) {
                this.uploadService.cancelFiles(uid);
            }
            else if (this.hasDelete(item)) {
                this.uploadService.removeFiles(uid);
            }
            this.navigation.focusSelectButton();
        }
    }
    hasDelete(item) {
        return item.element.nativeElement.getElementsByClassName('k-delete').length > 0;
    }
    ngOnDestroy() {
        this.focusSubscription.unsubscribe();
        this.actionSubscription.unsubscribe();
    }
}
FileListComponent.ɵfac = function FileListComponent_Factory(t) { return new (t || FileListComponent)(ɵngcc0.ɵɵdirectiveInject(UploadService), ɵngcc0.ɵɵdirectiveInject(NavigationService)); };
FileListComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FileListComponent, selectors: [["", "kendo-upload-file-list", ""]], viewQuery: function FileListComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(FileListItemDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.fileListItems = _t);
    } }, inputs: { disabled: "disabled", fileList: "fileList", fileTemplate: "fileTemplate" }, attrs: _c15, decls: 1, vars: 1, consts: [["ngFor", "", 3, "ngForOf"], ["kendoUploadFileListItem", "", 3, "files", "index"], ["class", "k-file-single", 3, "disabled", "file", 4, "ngIf"], ["class", "k-file-multiple", 3, "disabled", "files", 4, "ngIf"], [4, "ngIf"], [1, "k-file-single", 3, "disabled", "file"], [1, "k-file-multiple", 3, "disabled", "files"], [3, "templateContext"]], template: function FileListComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, FileListComponent_ng_template_0_Template, 4, 5, "ng-template", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.fileList);
    } }, directives: function () { return [ɵngcc3.NgForOf, FileListItemDirective, ɵngcc3.NgIf, FileListSingleItemComponent,
        FileListMultipleItemsComponent,
        TemplateContextDirective]; }, encapsulation: 2 });
/** @nocollapse */
FileListComponent.ctorParameters = () => [
    { type: UploadService },
    { type: NavigationService }
];
FileListComponent.propDecorators = {
    disabled: [{ type: Input }],
    fileList: [{ type: Input }],
    fileTemplate: [{ type: Input }],
    fileListItems: [{ type: ViewChildren, args: [FileListItemDirective,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FileListComponent, [{
        type: Component,
        args: [{
                selector: '[kendo-upload-file-list]',
                template: `
    <ng-template ngFor
      [ngForOf]="fileList"
      let-files
      let-index="index">
      <li kendoUploadFileListItem [files]='files' [index]='index'>
          <kendo-upload-file-list-single-item
            class='k-file-single'
            *ngIf='files.length === 1 && !fileTemplate'
            [disabled]='disabled'
            [file]='files[0]'>
          </kendo-upload-file-list-single-item>
          <kendo-upload-file-list-multiple-items
            class='k-file-multiple'
            *ngIf='files.length > 1 && !fileTemplate'
            [disabled]='disabled'
            [files]='files'>
          </kendo-upload-file-list-multiple-items>
          <ng-template *ngIf="fileTemplate"
              [templateContext]="{
                templateRef: fileTemplate.templateRef,
                state: files[0].state,
                $implicit: files
              }"></ng-template>
      </li>
    </ng-template>
    `
            }]
    }], function () { return [{ type: UploadService }, { type: NavigationService }]; }, { disabled: [{
            type: Input
        }], fileList: [{
            type: Input
        }], fileTemplate: [{
            type: Input
        }], fileListItems: [{
            type: ViewChildren,
            args: [FileListItemDirective]
        }] }); })();

/**
 * @hidden
 */
class FileListItemActionButtonComponent {
    constructor(uploadService, localization) {
        this.uploadService = uploadService;
        this.localization = localization;
        this.actionFocused = false;
        this.retryFocused = false;
        this.pauseResumeFocused = false;
    }
    onFocus(type) {
        if (type === 'action') {
            this.actionFocused = true;
        }
        if (type === 'retry') {
            this.retryFocused = true;
        }
        if (type === 'pauseResume') {
            this.pauseResumeFocused = true;
        }
    }
    onBlur(type) {
        if (type === 'retry') {
            this.retryFocused = false;
        }
        if (type === 'action') {
            this.actionFocused = false;
        }
        if (type === 'pauseResume') {
            this.pauseResumeFocused = false;
        }
    }
    onRetryClick() {
        if (this.disabled) {
            return;
        }
        this.uploadService.retryFiles(this.file.uid);
    }
    onRemoveCancelClick() {
        if (this.disabled) {
            return;
        }
        const uid = this.file.uid;
        if (this.file.state === FileState.Uploading) {
            this.uploadService.cancelFiles(uid);
        }
        else {
            this.uploadService.removeFiles(uid);
        }
    }
    onPauseResumeClick() {
        if (this.disabled) {
            return;
        }
        const uid = this.file.uid;
        if (this.file.state === FileState.Paused) {
            this.uploadService.resumeFile(uid);
        }
        else {
            this.uploadService.pauseFile(uid);
        }
    }
    get actionButtonTitle() {
        if (this.file.state === FileState.Uploading) {
            return this.localization.get('cancel');
        }
        return this.localization.get('remove');
    }
    get retryButtonTitle() {
        return this.localization.get('retry');
    }
    get pauseResumeButtonTitle() {
        if (this.file.state === FileState.Uploading) {
            return this.localization.get('pause');
        }
        return this.localization.get('resume');
    }
    get isUploading() {
        return this.file.state === FileState.Uploading;
    }
    get isFailed() {
        return this.file.state === FileState.Failed;
    }
    get isPaused() {
        return this.file.state === FileState.Paused;
    }
    get isResumable() {
        const service = this.uploadService;
        const isResumable = service.async.chunk && service.chunk.resumable;
        const isUploading = (this.file.state === FileState.Paused) || (this.file.state === FileState.Uploading);
        return isResumable && isUploading;
    }
    get isActionButtonVisible() {
        if ((this.file.state === FileState.Uploaded || this.file.state === FileState.Initial) &&
            !this.uploadService.async.removeUrl && this.uploadService.component === 'Upload') {
            return false;
        }
        return true;
    }
}
FileListItemActionButtonComponent.ɵfac = function FileListItemActionButtonComponent_Factory(t) { return new (t || FileListItemActionButtonComponent)(ɵngcc0.ɵɵdirectiveInject(UploadService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
FileListItemActionButtonComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FileListItemActionButtonComponent, selectors: [["kendo-upload-file-list-item-action-button"]], inputs: { file: "file", disabled: "disabled", progress: "progress" }, decls: 5, vars: 4, consts: [[1, "k-upload-status"], ["class", "k-upload-pct", 4, "ngIf"], ["type", "button", "class", "k-button k-upload-action", 3, "ngClass", "focus", "blur", "click", 4, "ngIf"], [1, "k-upload-pct"], ["type", "button", 1, "k-button", "k-upload-action", 3, "ngClass", "focus", "blur", "click"], [1, "k-icon", "k-retry", "k-i-refresh-sm"], [1, "k-icon", 3, "ngClass"]], template: function FileListItemActionButtonComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "strong", 0);
        ɵngcc0.ɵɵtemplate(1, FileListItemActionButtonComponent_span_1_Template, 2, 1, "span", 1);
        ɵngcc0.ɵɵtemplate(2, FileListItemActionButtonComponent_button_2_Template, 2, 6, "button", 2);
        ɵngcc0.ɵɵtemplate(3, FileListItemActionButtonComponent_button_3_Template, 2, 10, "button", 2);
        ɵngcc0.ɵɵtemplate(4, FileListItemActionButtonComponent_button_4_Template, 2, 10, "button", 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isUploading || ctx.isPaused);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isFailed);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isResumable);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isActionButtonVisible);
    } }, directives: [ɵngcc3.NgIf, ɵngcc3.NgClass], encapsulation: 2 });
/** @nocollapse */
FileListItemActionButtonComponent.ctorParameters = () => [
    { type: UploadService },
    { type: LocalizationService }
];
FileListItemActionButtonComponent.propDecorators = {
    file: [{ type: Input }],
    disabled: [{ type: Input }],
    progress: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FileListItemActionButtonComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-upload-file-list-item-action-button',
                template: `
      <strong class="k-upload-status">
        <span class="k-upload-pct" *ngIf="isUploading || isPaused">{{progress}}%</span>

        <button type="button" *ngIf="isFailed" class="k-button k-upload-action"
          [ngClass]="{ 'k-state-focused': this.retryFocused }"
          [attr.tabIndex]="-1"
          (focus)="onFocus('retry')"
          (blur)="onBlur('retry')"
          (click)="onRetryClick()">
          <span class="k-icon k-retry k-i-refresh-sm"
            [attr.aria-label]="retryButtonTitle"
            [attr.title]="retryButtonTitle">
          </span>
        </button>

        <button *ngIf="isResumable" type="button" class="k-button k-upload-action"
          [ngClass]="{ 'k-state-focused': this.pauseResumeFocused }"
          [attr.tabIndex]="-1"
          (focus)="onFocus('pauseResume')"
          (blur)="onBlur('pauseResume')"
          (click)="onPauseResumeClick()">
          <span class="k-icon"
            [ngClass]="{
              'k-i-play-sm': isPaused,
              'k-i-pause-sm': !isPaused
            }"
            [attr.aria-label]='pauseResumeButtonTitle'
            [attr.title]='pauseResumeButtonTitle'>
          </span>
        </button>

        <button type="button" *ngIf="isActionButtonVisible" class="k-button k-upload-action"
          [ngClass]="{ 'k-state-focused': this.actionFocused }"
          [attr.tabIndex]="-1"
          (focus)="onFocus('action')"
          (blur)="onBlur('action')"
          (click)="onRemoveCancelClick()">
          <span class="k-icon"
            [ngClass]="{
              'k-cancel k-i-deny': isUploading,
              'k-delete k-i-x': !isUploading
            }"
            [attr.aria-label]='actionButtonTitle'
            [attr.title]='actionButtonTitle'>
          </span>
        </button>
      </strong>
    `
            }]
    }], function () { return [{ type: UploadService }, { type: ɵngcc2.LocalizationService }]; }, { file: [{
            type: Input
        }], disabled: [{
            type: Input
        }], progress: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
class FileListItemBase {
    constructor(uploadService) {
        this.uploadService = uploadService;
        this.progressComplete = 0;
    }
    subscribeUploadProgress(uploadProgressHandler) {
        this.uploadProgressSubscription = this.uploadService.uploadProgressEvent.subscribe(uploadProgressHandler);
    }
    fileHasValidationErrors(file) {
        return fileHasValidationErrors(file);
    }
    filesHaveValidationErrors(files) {
        return filesHaveValidationErrors(files);
    }
    ngOnDestroy() {
        this.uploadProgressSubscription.unsubscribe();
    }
    getFileValidationMessage(file) {
        let validationMessage;
        if (file.validationErrors && file.validationErrors.length > 0) {
            validationMessage = this.localization.get(file.validationErrors[0]);
        }
        return validationMessage;
    }
    getInvalidFilesMessage() {
        return this.localization.get('invalidFiles');
    }
    getTotalFilesSizeMessage(files) {
        return getTotalFilesSizeMessage(files);
    }
}
FileListItemBase.ɵfac = function FileListItemBase_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
FileListItemBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FileListItemBase });


/**
 * @hidden
 */
class FileListMultipleItemsComponent extends FileListItemBase {
    constructor(localization, uploadService) {
        super(uploadService);
        this.localization = localization;
        this.subscribeUploadProgress((args) => {
            if (args.files[0].uid === this.files[0].uid) {
                this.progressComplete = args.percentComplete;
            }
        });
    }
    /**
     * @hidden
     */
    setFileNameClasses(file) {
        return {
            "k-file-name": true,
            "k-file-name-invalid": super.fileHasValidationErrors(file)
        };
    }
    /**
     * @hidden
     */
    get showProgress() {
        const showProgress = this.files[0].state === FileState.Uploading || this.files[0].state === FileState.Paused;
        return showProgress ? 'active' : 'inactive';
    }
    ngOnInit() {
        this.filesHaveErrors = super.filesHaveValidationErrors(this.files);
    }
}
FileListMultipleItemsComponent.ɵfac = function FileListMultipleItemsComponent_Factory(t) { return new (t || FileListMultipleItemsComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(UploadService)); };
FileListMultipleItemsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FileListMultipleItemsComponent, selectors: [["kendo-upload-file-list-multiple-items"]], inputs: { disabled: "disabled", files: "files" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 8, vars: 11, consts: [[1, "k-progress"], ["class", "k-multiple-files-extension-wrapper", 4, "ngIf"], ["class", "k-multiple-files-invalid-extension-wrapper", 4, "ngIf"], [1, "k-file-name-size-wrapper"], [3, "title", "ngClass", 4, "ngFor", "ngForOf"], ["class", "k-file-information", 4, "ngIf"], ["class", "k-file-validation-message", 4, "ngIf"], [3, "file", "disabled", "progress"], [1, "k-multiple-files-extension-wrapper"], [1, "k-file-state"], [1, "k-multiple-files-invalid-extension-wrapper"], [1, "k-file-invalid-icon"], [3, "title", "ngClass"], [1, "k-file-information"], [1, "k-file-validation-message"]], template: function FileListMultipleItemsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "span", 0);
        ɵngcc0.ɵɵtemplate(1, FileListMultipleItemsComponent_span_1_Template, 2, 0, "span", 1);
        ɵngcc0.ɵɵtemplate(2, FileListMultipleItemsComponent_span_2_Template, 4, 0, "span", 2);
        ɵngcc0.ɵɵelementStart(3, "span", 3);
        ɵngcc0.ɵɵtemplate(4, FileListMultipleItemsComponent_span_4_Template, 2, 3, "span", 4);
        ɵngcc0.ɵɵtemplate(5, FileListMultipleItemsComponent_span_5_Template, 2, 2, "span", 5);
        ɵngcc0.ɵɵtemplate(6, FileListMultipleItemsComponent_span_6_Template, 2, 1, "span", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(7, "kendo-upload-file-list-item-action-button", 7);
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.progressComplete + "%");
        ɵngcc0.ɵɵproperty("@progressState", ctx.showProgress);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.filesHaveErrors);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.filesHaveErrors);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.files);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.filesHaveErrors);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.filesHaveErrors);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("file", ctx.files[0])("disabled", ctx.disabled)("progress", ctx.progressComplete);
    } }, directives: [ɵngcc3.NgIf, ɵngcc3.NgForOf, FileListItemActionButtonComponent, ɵngcc3.NgClass], encapsulation: 2, data: { animation: [
            trigger('progressState', [
                state('active', style({ opacity: 1 })),
                state('inactive', style({ opacity: 0 })),
                transition('void => active', style({ opacity: 0 })),
                transition('inactive => active', style({ opacity: 1 })),
                transition('active => inactive', animate('1s 2s ease-out'))
            ])
        ] } });
/** @nocollapse */
FileListMultipleItemsComponent.ctorParameters = () => [
    { type: LocalizationService },
    { type: UploadService }
];
FileListMultipleItemsComponent.propDecorators = {
    disabled: [{ type: Input }],
    files: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FileListMultipleItemsComponent, [{
        type: Component,
        args: [{
                animations: [
                    trigger('progressState', [
                        state('active', style({ opacity: 1 })),
                        state('inactive', style({ opacity: 0 })),
                        transition('void => active', style({ opacity: 0 })),
                        transition('inactive => active', style({ opacity: 1 })),
                        transition('active => inactive', animate('1s 2s ease-out'))
                    ])
                ],
                selector: 'kendo-upload-file-list-multiple-items',
                template: `
      <span class="k-progress" [style.width]="progressComplete + '%'" [@progressState]="showProgress"></span>
      <span *ngIf="!filesHaveErrors" class="k-multiple-files-extension-wrapper">
        <span class="k-file-state"></span>
      </span>
      <span *ngIf="filesHaveErrors" class="k-multiple-files-invalid-extension-wrapper">
        <span class='k-file-invalid-icon'>!</span>
        <span class="k-file-state"></span>
      </span>
      <span class="k-file-name-size-wrapper">
        <span *ngFor="let file of files"
          [title]="file.name"
          [ngClass]="setFileNameClasses(file)"
        >
          {{file.name}}
        </span>
        <span *ngIf="!filesHaveErrors"
              class="k-file-information">Total: {{ files.length }} files, {{ getTotalFilesSizeMessage(files) }}</span>
        <span *ngIf="filesHaveErrors" class="k-file-validation-message">{{ getInvalidFilesMessage() }}</span>
      </span>
      <kendo-upload-file-list-item-action-button
        [file]='files[0]'
        [disabled]='disabled'
        [progress]='progressComplete'>
      </kendo-upload-file-list-item-action-button>
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }, { type: UploadService }]; }, { disabled: [{
            type: Input
        }], files: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
class FileListSingleItemComponent extends FileListItemBase {
    constructor(localization, uploadService) {
        super(uploadService);
        this.localization = localization;
        this.subscribeUploadProgress((args) => {
            if (args.files[0].uid === this.file.uid) {
                this.progressComplete = args.percentComplete;
            }
        });
    }
    /**
     * @hidden
     */
    textFor(key) {
        return this.localization.get(key);
    }
    /**
     * @hidden
     */
    getFileExtension(file) {
        return file.extension ? file.extension.substring(1) : '';
    }
    /**
     * @hidden
     */
    get showProgress() {
        const showProgress = this.file.state === FileState.Uploading || this.file.state === FileState.Paused;
        return showProgress ? 'active' : 'inactive';
    }
}
FileListSingleItemComponent.ɵfac = function FileListSingleItemComponent_Factory(t) { return new (t || FileListSingleItemComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(UploadService)); };
FileListSingleItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FileListSingleItemComponent, selectors: [["kendo-upload-file-list-single-item"]], inputs: { disabled: "disabled", file: "file" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 4, vars: 8, consts: [[1, "k-progress"], [3, "ngIf"], [3, "file", "disabled", "progress"], [1, "k-file-invalid-extension-wrapper"], [1, "k-file-invalid-icon"], [1, "k-file-state"], [1, "k-file-name-size-wrapper"], [1, "k-file-name", "k-file-name-invalid", 3, "title"], [1, "k-file-validation-message"], [1, "k-file-extension-wrapper"], [1, "k-file-extension"], [1, "k-file-name", 3, "title"], [1, "k-file-size"]], template: function FileListSingleItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "span", 0);
        ɵngcc0.ɵɵtemplate(1, FileListSingleItemComponent_ng_template_1_Template, 9, 3, "ng-template", 1);
        ɵngcc0.ɵɵtemplate(2, FileListSingleItemComponent_ng_template_2_Template, 9, 6, "ng-template", 1);
        ɵngcc0.ɵɵelement(3, "kendo-upload-file-list-item-action-button", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.progressComplete + "%");
        ɵngcc0.ɵɵproperty("@progressState", ctx.showProgress);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.file.validationErrors && ctx.file.validationErrors.length > 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.file.validationErrors || ctx.file.validationErrors.length === 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("file", ctx.file)("disabled", ctx.disabled)("progress", ctx.progressComplete);
    } }, directives: [ɵngcc3.NgIf, FileListItemActionButtonComponent], encapsulation: 2, data: { animation: [
            trigger('progressState', [
                state('active', style({ opacity: 1 })),
                state('inactive', style({ opacity: 0 })),
                transition('void => active', style({ opacity: 0 })),
                transition('inactive => active', style({ opacity: 1 })),
                transition('active => inactive', animate('1s 2s ease-out'))
            ])
        ] } });
/** @nocollapse */
FileListSingleItemComponent.ctorParameters = () => [
    { type: LocalizationService },
    { type: UploadService }
];
FileListSingleItemComponent.propDecorators = {
    disabled: [{ type: Input }],
    file: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FileListSingleItemComponent, [{
        type: Component,
        args: [{
                animations: [
                    trigger('progressState', [
                        state('active', style({ opacity: 1 })),
                        state('inactive', style({ opacity: 0 })),
                        transition('void => active', style({ opacity: 0 })),
                        transition('inactive => active', style({ opacity: 1 })),
                        transition('active => inactive', animate('1s 2s ease-out'))
                    ])
                ],
                selector: 'kendo-upload-file-list-single-item',
                template: `
      <span class="k-progress" [style.width]="progressComplete + '%'" [@progressState]="showProgress"></span>
      <ng-template [ngIf]='file.validationErrors && file.validationErrors.length > 0'>
        <span class="k-file-invalid-extension-wrapper">
          <span class="k-file-invalid-icon">!</span>
          <span class="k-file-state"></span>
        </span>
        <span class="k-file-name-size-wrapper">
          <span class="k-file-name k-file-name-invalid" [title]="file.name">{{ file.name }}</span>
          <span class="k-file-validation-message">{{ getFileValidationMessage(file) }}</span>
        </span>
      </ng-template>
      <ng-template [ngIf]='!file.validationErrors || file.validationErrors.length === 0'>
        <span class="k-file-extension-wrapper">
          <span class="k-file-extension">{{ getFileExtension(file) }}</span>
          <span class="k-file-state"></span>
        </span>
        <span class="k-file-name-size-wrapper">
          <span class="k-file-name" [title]="file.name">{{ file.name }}</span>
          <span class="k-file-size">{{ getTotalFilesSizeMessage([file]) }}</span>
        </span>
      </ng-template>
      <kendo-upload-file-list-item-action-button
        [file]='file'
        [disabled]='disabled'
        [progress]='progressComplete'>
      </kendo-upload-file-list-item-action-button>
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }, { type: UploadService }]; }, { disabled: [{
            type: Input
        }], file: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
class FileSelectDirective {
    constructor(uploadService, navigation, el) {
        this.uploadService = uploadService;
        this.navigation = navigation;
        this.type = "file";
        this.autocomplete = "off";
        this.tabIndex = -1;
        this.element = el;
    }
    get nameAttribute() {
        return this.uploadService.async.saveField;
    }
    get multipleAttribute() {
        return this.multiple ? "multiple" : null;
    }
    get dirAttribute() {
        return this.dir;
    }
    get disabledAttribute() {
        return this.disabled ? "true" : null;
    }
    onInputChange(event) {
        const ua = navigator.userAgent;
        const chrome = /(chrome)[ \/]([\w.]+)/i;
        const safari = /(webkit)[ \/]([\w.]+)/i;
        let selectedFiles = inputFiles(event.target);
        selectedFiles = assignGuidToFiles(selectedFiles, !this.uploadService.async.batch);
        validateFiles(selectedFiles, this.restrictions);
        if (!this.multiple) {
            this.uploadService.clearFiles();
        }
        this.uploadService.addFiles(selectedFiles);
        /*
        Chrome and Internet Explorer do not trigger a `change` event
        when a file with the same name is selected a number of consecutive times.
        As a workaround, clear the input value after handling the file.
        */
        const native = this.element.nativeElement;
        if (!(!ua.match(chrome) && ua.match(safari))) {
            native.type = "";
            native.type = "file";
        }
        setTimeout(() => {
            this.navigation.focusedIndex = -1;
        });
    }
}
FileSelectDirective.ɵfac = function FileSelectDirective_Factory(t) { return new (t || FileSelectDirective)(ɵngcc0.ɵɵdirectiveInject(UploadService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
FileSelectDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FileSelectDirective, selectors: [["", "kendoFileSelect", ""]], hostVars: 7, hostBindings: function FileSelectDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("change", function FileSelectDirective_change_HostBindingHandler($event) { return ctx.onInputChange($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("type", ctx.type)("autocomplete", ctx.autocomplete)("tabindex", ctx.tabIndex)("name", ctx.nameAttribute)("multiple", ctx.multipleAttribute)("dir", ctx.dirAttribute)("disabled", ctx.disabledAttribute);
    } }, inputs: { dir: "dir", disabled: "disabled", multiple: "multiple", restrictions: "restrictions" } });
/** @nocollapse */
FileSelectDirective.ctorParameters = () => [
    { type: UploadService },
    { type: NavigationService },
    { type: ElementRef }
];
FileSelectDirective.propDecorators = {
    dir: [{ type: Input }],
    disabled: [{ type: Input }],
    multiple: [{ type: Input }],
    restrictions: [{ type: Input }],
    type: [{ type: HostBinding, args: ["attr.type",] }],
    autocomplete: [{ type: HostBinding, args: ["attr.autocomplete",] }],
    tabIndex: [{ type: HostBinding, args: ["attr.tabindex",] }],
    nameAttribute: [{ type: HostBinding, args: ["attr.name",] }],
    multipleAttribute: [{ type: HostBinding, args: ["attr.multiple",] }],
    dirAttribute: [{ type: HostBinding, args: ["attr.dir",] }],
    disabledAttribute: [{ type: HostBinding, args: ["attr.disabled",] }],
    onInputChange: [{ type: HostListener, args: ["change", ["$event"],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FileSelectDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoFileSelect]'
            }]
    }], function () { return [{ type: UploadService }, { type: NavigationService }, { type: ɵngcc0.ElementRef }]; }, { type: [{
            type: HostBinding,
            args: ["attr.type"]
        }], autocomplete: [{
            type: HostBinding,
            args: ["attr.autocomplete"]
        }], tabIndex: [{
            type: HostBinding,
            args: ["attr.tabindex"]
        }], nameAttribute: [{
            type: HostBinding,
            args: ["attr.name"]
        }], multipleAttribute: [{
            type: HostBinding,
            args: ["attr.multiple"]
        }], dirAttribute: [{
            type: HostBinding,
            args: ["attr.dir"]
        }], disabledAttribute: [{
            type: HostBinding,
            args: ["attr.disabled"]
        }], onInputChange: [{
            type: HostListener,
            args: ["change", ["$event"]]
        }], dir: [{
            type: Input
        }], disabled: [{
            type: Input
        }], multiple: [{
            type: Input
        }], restrictions: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
class LocalizedMessagesDirective extends Messages {
    constructor(service) {
        super();
        this.service = service;
    }
}
LocalizedMessagesDirective.ɵfac = function LocalizedMessagesDirective_Factory(t) { return new (t || LocalizedMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
LocalizedMessagesDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LocalizedMessagesDirective, selectors: [["", "kendoUploadLocalizedMessages", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: Messages,
                useExisting: forwardRef(() => LocalizedMessagesDirective) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
LocalizedMessagesDirective.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LocalizedMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: Messages,
                        useExisting: forwardRef(() => LocalizedMessagesDirective) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: '[kendoUploadLocalizedMessages]'
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, null); })();

/**
 * @hidden
 */
class TemplateContextDirective {
    constructor(viewContainerRef) {
        this.viewContainerRef = viewContainerRef;
    }
    set templateContext(context) {
        if (this.insertedViewRef) {
            this.viewContainerRef.remove(this.viewContainerRef.indexOf(this.insertedViewRef));
            this.insertedViewRef = undefined;
        }
        if (context.templateRef) {
            this.insertedViewRef = this.viewContainerRef.createEmbeddedView(context.templateRef, context);
        }
    }
}
TemplateContextDirective.ɵfac = function TemplateContextDirective_Factory(t) { return new (t || TemplateContextDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
TemplateContextDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TemplateContextDirective, selectors: [["", "templateContext", ""]], inputs: { templateContext: "templateContext" } });
/** @nocollapse */
TemplateContextDirective.ctorParameters = () => [
    { type: ViewContainerRef }
];
TemplateContextDirective.propDecorators = {
    templateContext: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TemplateContextDirective, [{
        type: Directive,
        args: [{
                selector: '[templateContext]' // tslint:disable-line:directive-selector
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }]; }, { templateContext: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
const SHARED_DECLARATIONS = [
    DropZoneDirective,
    FileListComponent,
    FileListItemDirective,
    FileListItemActionButtonComponent,
    FileListMultipleItemsComponent,
    FileListSingleItemComponent,
    FileSelectDirective,
    LocalizedMessagesDirective,
    TemplateContextDirective
];
/**
 * @hidden
 */
const PUBLIC_DIRECTIVES = [
    FileTemplateDirective,
    CustomMessagesComponent
];
/**
 * @hidden
 */
class SharedModule {
}
SharedModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: SharedModule });
SharedModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function SharedModule_Factory(t) { return new (t || SharedModule)(); }, imports: [[CommonModule],
        CommonModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SharedModule, { declarations: function () { return [FileTemplateDirective,
        CustomMessagesComponent,
        DropZoneDirective,
        FileListComponent,
        FileListItemDirective,
        FileListItemActionButtonComponent,
        FileListMultipleItemsComponent,
        FileListSingleItemComponent,
        FileSelectDirective,
        LocalizedMessagesDirective,
        TemplateContextDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [FileTemplateDirective,
        CustomMessagesComponent,
        DropZoneDirective,
        FileListComponent,
        FileListItemDirective,
        FileListItemActionButtonComponent,
        FileListMultipleItemsComponent,
        FileListSingleItemComponent,
        FileSelectDirective,
        LocalizedMessagesDirective,
        TemplateContextDirective,
        CommonModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SharedModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    PUBLIC_DIRECTIVES,
                    SHARED_DECLARATIONS
                ],
                exports: [
                    PUBLIC_DIRECTIVES,
                    SHARED_DECLARATIONS,
                    CommonModule
                ],
                imports: [CommonModule]
            }]
    }], null, null); })();

const FILESELECT_DECLARATIONS = [
    FileSelectComponent
];
/**
 * Represents the [NgModule](https://angular.io/api/core/NgModule) definition for the FileSelect component.
 */
class FileSelectModule {
}
FileSelectModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: FileSelectModule });
FileSelectModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function FileSelectModule_Factory(t) { return new (t || FileSelectModule)(); }, imports: [[SharedModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FileSelectModule, { declarations: [FileSelectComponent], imports: [SharedModule], exports: [FileTemplateDirective,
        CustomMessagesComponent,
        FileSelectComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FileSelectModule, [{
        type: NgModule,
        args: [{
                declarations: [FILESELECT_DECLARATIONS],
                exports: [
                    PUBLIC_DIRECTIVES,
                    FILESELECT_DECLARATIONS
                ],
                imports: [SharedModule]
            }]
    }], null, null); })();

/* tslint:disable: no-use-before-declare */
/**
 * @hidden
 */
const UPLOAD_VALUE_ACCESSOR = {
    multi: true,
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => UploadComponent) // tslint:disable-line:no-forward-ref
};
/**
 * Represents the [Kendo UI Upload component for Angular]({% slug overview_upload %}).
 */
class UploadComponent {
    constructor(uploadService, localization, navigation, _ngZone, renderer, wrapper) {
        this.uploadService = uploadService;
        this.localization = localization;
        this.navigation = navigation;
        this._ngZone = _ngZone;
        this.renderer = renderer;
        /**
         * Enables the chunk functionality of the Upload.
         *
         * The default value is `false`.
         */
        this.chunkable = false;
        /**
         * Enables the selection of multiple files
         * ([see example]({% slug fileprocessing_upload %}#toc-upload-of-sinlge-or-multiple-files)).
         * If set to `false`, only one file can be selected at a time.
         */
        this.multiple = true;
        /**
         * Disables the Upload ([see example]({% slug disabledstate_upload %})).
         * The default value is `false`.
         */
        this.disabled = false;
        /**
         * Toggles the visibility of the file list.
         */
        this.showFileList = true;
        /**
         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        this.tabindex = 0;
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        /**
         * Fires when the user navigates outside the component.
         */
        this.onBlur = new EventEmitter();
        /**
         * Fires when the upload is canceled while in progress.
         */
        this.cancel = new EventEmitter();
        /**
         * Fires when the file list is about to be cleared. If prevented, the files will not be cleared.
         */
        this.clear = new EventEmitter();
        /**
         * Fires when all active uploads are completed either successfully or with errors.
         */
        this.complete = new EventEmitter();
        /**
         * Fires when an `upload` or `remove` operation has failed.
         */
        this.error = new EventEmitter();
        /**
         * Fires when the component is focused.
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires when the upload of a file has been paused.
         */
        this.pause = new EventEmitter();
        /**
         * Fires when an uploaded file is about to be removed. If prevented, the files will remain in the list.
         */
        this.remove = new EventEmitter();
        /**
         * Fires when the upload of a file has been resumed.
         */
        this.resume = new EventEmitter();
        /**
         * Fires when files are selected. If prevented, the selected files will not be added to the list.
         */
        this.select = new EventEmitter();
        /**
         * Fires when an `upload` or `remove` operation is successfully completed.
         */
        this.success = new EventEmitter();
        /**
         * Fires when one or more files are about to be uploaded. If prevented, the files will neither be uploaded, nor added to the file list.
         */
        this.upload = new EventEmitter();
        /**
         * Fires when one or more files are being uploaded.
         */
        this.uploadProgress = new EventEmitter();
        /**
         * Fires when the value of the component has changed as a result of a successful `upload`, `remove` or `clear` operation.
         */
        this.valueChange = new EventEmitter();
        this.hostDefaultClasses = true;
        /**
         * @hidden
         */
        this._restrictions = {
            allowedExtensions: [],
            maxFileSize: 0,
            minFileSize: 0
        };
        this.onTouchedCallback = (_) => { };
        this.onChangeCallback = (_) => { };
        this.fileList = this.uploadService.files;
        this.localizationChangeSubscription = localization.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
            this.navigation.computeKeys(this.direction);
        });
        this.direction = localization.rtl ? 'rtl' : 'ltr';
        this.navigation.computeKeys(this.direction);
        this.wrapper = wrapper.nativeElement;
        this.subscribeBlur();
        this.subscribeFocus();
        this.attachEventHandlers();
    }
    /**
     * By default, the selected files are immediately uploaded
     * ([see example]({% slug fileprocessing_upload %}#toc-automatic-upload-of-files)).
     * To change this behavior, set `autoUpload` to `false`.
     */
    set autoUpload(autoUpload) {
        this.uploadService.async.autoUpload = autoUpload;
    }
    get autoUpload() {
        return this.uploadService.async.autoUpload;
    }
    /**
     * When enabled, all files in the selection are uploaded in one request
     * ([see example]({% slug fileprocessing_upload %}#toc-upload-of-batches-of-files)).
     * Any files that are selected one after the other are uploaded in separate requests.
     */
    set batch(batch) {
        this.uploadService.async.batch = batch;
    }
    get batch() {
        return this.uploadService.async.batch;
    }
    /**
     * Configures whether credentials (cookies, headers) will be sent for cross-site requests
     * ([see example]({% slug credentials_upload %}#toc-attaching-credentials-to-requests)).
     * The default values is `true`. Setting `withCredentials` has no effect on same-site requests.
     * To add credentials to the request, use the `saveHeaders` or `removeHeaders` property,
     * or the [`upload`]({% slug api_upload_uploadevent %}) event.
     */
    set withCredentials(withCredentials) {
        this.uploadService.async.withCredentials = withCredentials;
    }
    get withCredentials() {
        return this.uploadService.async.withCredentials;
    }
    /**
     * Sets the [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) key which contains the files submitted to `saveUrl`.
     * The default value is `files`.
     */
    set saveField(saveField) {
        this.uploadService.async.saveField = saveField;
    }
    get saveField() {
        return this.uploadService.async.saveField;
    }
    /**
     * Configures the [`HttpHeaders`](https://angular.io/api/common/http/HttpHeaders)
     * that are attached to each upload request.
     */
    set saveHeaders(saveHeaders) {
        this.uploadService.async.saveHeaders = saveHeaders;
    }
    get saveHeaders() {
        return this.uploadService.async.saveHeaders;
    }
    /**
     * Sets the [`RequestMethod`](https://angular.io/api/http/RequestMethod) of the upload request.
     * The default value is `POST`.
     */
    set saveMethod(saveMethod) {
        this.uploadService.async.saveMethod = saveMethod;
    }
    get saveMethod() {
        return this.uploadService.async.saveMethod;
    }
    /**
     * Sets the URL of the endpoint for the upload request.
     * The request [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) key is named after the `saveField` property.
     * It contains the list of files to be uploaded.
     */
    set saveUrl(saveUrl) {
        this.uploadService.async.saveUrl = saveUrl;
    }
    get saveUrl() {
        return this.uploadService.async.saveUrl;
    }
    /**
     * Sets the expected [`response type`](https://angular.io/api/common/http/HttpRequest#responseType) of the server.
     * It is used to parse the response appropriately.
     * The default value is `json`.
     */
    set responseType(responseType) {
        this.uploadService.async.responseType = responseType;
    }
    get responseType() {
        return this.uploadService.async.responseType;
    }
    /**
     * Sets the [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) key
     * which contains the list of file names that are submitted to `removeUrl`.
     * The default value is `fileNames`.
     */
    set removeField(removeField) { this.uploadService.async.removeField = removeField; }
    get removeField() { return this.uploadService.async.removeField; }
    /**
     * Configures the [`HttpHeaders`](https://angular.io/api/common/http/HttpHeaders)
     * that are attached to each `remove` request.
     */
    set removeHeaders(removeHeaders) {
        this.uploadService.async.removeHeaders = removeHeaders;
    }
    get removeHeaders() {
        return this.uploadService.async.removeHeaders;
    }
    /**
     * Sets the [`RequestMethod`](https://angular.io/api/http/RequestMethod) of the `remove` request.
     * The default value is `POST`.
     */
    set removeMethod(removeMethod) {
        this.uploadService.async.removeMethod = removeMethod;
    }
    get removeMethod() {
        return this.uploadService.async.removeMethod;
    }
    /**
     * Sets the URL of the endpoint for the `remove` request.
     * The [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) request key is named after the `removeField` property.
     * It contains the list of file names which will be removed.
     */
    set removeUrl(removeUrl) {
        this.uploadService.async.removeUrl = removeUrl;
    }
    get removeUrl() {
        return this.uploadService.async.removeUrl;
    }
    /**
     * Specifies if the selected files are uploaded simultaneously or one by one.
     *
     * The default value is `true`.
     */
    set concurrent(concurrent) {
        this.uploadService.async.concurrent = concurrent;
    }
    get concurrent() {
        return this.uploadService.async.concurrent;
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    /**
     * Sets the restrictions for selected files ([see example]({% slug api_upload_filerestrictions %})).
     */
    set restrictions(restrictions) {
        let parsedRestrictions = Object.assign({}, this._restrictions, restrictions);
        this._restrictions = parsedRestrictions;
    }
    get restrictions() {
        return this._restrictions;
    }
    get hostDisabledClass() {
        return this.disabled;
    }
    get dir() {
        return this.direction;
    }
    ngOnInit() {
        this.verifySettings();
        this.renderer.removeAttribute(this.wrapper, "tabindex");
        this.uploadService.setChunkSettings(this.chunkable);
    }
    ngOnChanges(changes) {
        if (isChanged("chunkable", changes)) {
            const newChunkable = changes.chunkable.currentValue;
            if (typeof newChunkable === 'boolean') {
                this.uploadService.async.chunk = newChunkable;
            }
            if (typeof newChunkable === "object" && newChunkable !== null) {
                this.uploadService.async.chunk = true;
                this.uploadService.chunk = Object.assign({}, this.uploadService.chunk, newChunkable);
            }
        }
    }
    ngOnDestroy() {
        this.fileList.clear();
        if (this.blurSubscription) {
            this.blurSubscription.unsubscribe();
        }
        if (this.wrapperFocusSubscription) {
            this.wrapperFocusSubscription.unsubscribe();
        }
        if (this.selectButtonFocusSubscription) {
            this.selectButtonFocusSubscription.unsubscribe();
        }
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
        if (this.subs) {
            this.subs.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    handleKeydown(event) {
        if (this.disabled) {
            return;
        }
        if ((event.keyCode === Keys.Enter || event.keyCode === Keys.Space) &&
            event.target === this.fileSelectButton.nativeElement) {
            event.preventDefault();
            this.fileSelect.nativeElement.click();
            return;
        }
        if (hasClasses(event.target, UPLOAD_CLASSES) ||
            (!isFocusable(event.target) && !hasClasses(event.target, IGNORE_TARGET_CLASSES))) {
            this.navigation.process(event);
        }
    }
    /**
     * @hidden
     */
    writeValue(newValue) {
        let isValid = true;
        if (newValue instanceof Array) {
            newValue.forEach((file) => {
                if (!validateInitialFileInfo(file)) {
                    isValid = false;
                }
            });
            if (isValid) {
                this.uploadService.addInitialFiles(newValue);
            }
        }
        if (newValue === null) {
            this.fileList.clear();
        }
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     */
    get selectButtonTabIndex() {
        return this.disabled ? undefined : this.tabIndex;
    }
    /**
     * @hidden
     */
    onFileSelectButtonFocus(_event) {
        this.renderer.addClass(this.fileSelectButton.nativeElement, 'k-state-focused');
        if (!this.navigation.focused) {
            this.navigation.focusedIndex = -1;
        }
    }
    /**
     * @hidden
     */
    onFileSelectButtonBlur(_event) {
        this.renderer.removeClass(this.fileSelectButton.nativeElement, 'k-state-focused');
    }
    /**
     * @hidden
     */
    get showActionButtons() {
        let areVisible = false;
        if (!this.autoUpload) {
            const hasFilesToUpload = this.fileList.filesToUpload.length > 0;
            const uploadingFiles = this.fileList.hasFileWithState([FileState.Uploading]);
            if (this.concurrent && hasFilesToUpload) {
                areVisible = true;
            }
            if (!this.concurrent && hasFilesToUpload && !uploadingFiles) {
                areVisible = true;
            }
        }
        this.navigation.actionButtonsVisible = areVisible;
        return areVisible;
    }
    /**
     * @hidden
     */
    get showTotalStatus() {
        const states = [
            FileState.Uploaded,
            FileState.Uploading,
            FileState.Failed,
            FileState.Paused
        ];
        if (this.fileList.hasFileWithState(states)) {
            return true;
        }
        return false;
    }
    /**
     * @hidden
     */
    textFor(key) {
        return this.localization.get(key);
    }
    /**
     * Focuses the underlying input element.
     */
    focus() {
        setTimeout(() => {
            this.fileSelectButton.nativeElement.focus();
        });
    }
    /**
     * @hidden
     * @deprecated
     */
    focusComponent() {
        this.focus();
    }
    /**
     * Blurs the Upload if it was previously focused.
     */
    blur() {
        if (this.navigation.focused) {
            this.navigation.focused = false;
            document.activeElement.blur();
            this.onBlur.emit();
        }
    }
    /**
     * @hidden
     * @deprecated
     */
    blurComponent() {
        this.blur();
    }
    /**
     * Pauses the upload process of a file that is currently uploading.
     * The `pauseFileByUid` method requires the `chunkable` option of the Upload to be enabled.
     *
     * @param uid - The `uid` of the file that will be paused.
     */
    pauseFileByUid(uid) {
        this.uploadService.pauseFile(uid);
    }
    /**
     * Resumes the upload process for a file that has been previously paused.
     * The `resumeFileByUid` method requires the `chunkable` option of the Upload to be enabled.
     *
     * @param uid - The `uid` of the file that will be resumed.
     */
    resumeFileByUid(uid) {
        this.uploadService.resumeFile(uid);
    }
    /**
     * Triggers the removal of a file or a batch of files.
     * @param uid - The `uid` of the file or a batch of files that will be removed.
     */
    removeFilesByUid(uid) {
        this.uploadService.removeFiles(uid);
    }
    /**
     * Triggers another upload attempt of an unsuccessfully uploaded file or a batch of files.
     * @param uid - The `uid` of the file or a batch of files to be retried.
     */
    retryUploadByUid(uid) {
        this.uploadService.retryFiles(uid);
    }
    /**
     * Cancels the upload of a file or a batch of files.
     * @param uid - The `uid` of the file or a batch of files that will be canceled.
     */
    cancelUploadByUid(uid) {
        this.uploadService.cancelFiles(uid);
    }
    /**
     * Uploads the currently selected files which pass the set restrictions.
     */
    uploadFiles() {
        if (this.fileList.filesToUpload.length) {
            this.uploadService.uploadFiles();
        }
    }
    /**
     * Visually clears all files from the UI without issuing requests to the remove handler.
     */
    clearFiles() {
        this.uploadService.clearFiles();
    }
    /**
     * @hidden
     * Used by the TextBoxContainer to determine if the component is empty.
     */
    isEmpty() {
        return false;
    }
    verifySettings() {
        if (isDevMode()) {
            if (this.batch && this.chunkable !== false) {
                throw new Error('The file chunking functionality requires the batch setting to be disabled.');
            }
        }
    }
    subscribeBlur() {
        if (!isDocumentAvailable()) {
            return;
        }
        this._ngZone.runOutsideAngular(() => {
            this.documentClick = fromEvent(document, 'click').pipe(filter((event) => {
                return !(this.wrapper !== event.target && this.wrapper.contains(event.target));
            }));
            this.blurSubscription = merge(this.documentClick, this.navigation.onTab).subscribe(() => this._ngZone.run(() => {
                if (this.navigation.focused) {
                    this.navigation.focused = false;
                    this.onTouchedCallback();
                    this.onBlur.emit();
                }
            }));
        });
    }
    subscribeFocus() {
        this.wrapperFocusSubscription = this.navigation.onWrapperFocus.subscribe(() => {
            this.onFocus.emit();
        });
        this.selectButtonFocusSubscription = this.navigation.onSelectButtonFocus.subscribe(() => {
            this.fileSelectButton.nativeElement.focus();
        });
    }
    attachEventHandlers() {
        this.subs = this.uploadService.cancelEvent.subscribe((args) => {
            this.cancel.emit(args);
        });
        this.subs.add(this.uploadService.changeEvent.subscribe((files) => {
            this.onChangeCallback(files);
            this.valueChange.emit(files);
        }));
        this.subs.add(this.uploadService.clearEvent.subscribe((args) => {
            this.clear.emit(args);
        }));
        this.subs.add(this.uploadService.completeEvent.subscribe(() => {
            this.complete.emit();
        }));
        this.subs.add(this.uploadService.errorEvent.subscribe((args) => {
            this.error.emit(args);
        }));
        this.subs.add(this.uploadService.pauseEvent.subscribe((args) => {
            this.pause.emit(args);
        }));
        this.subs.add(this.uploadService.removeEvent.subscribe((args) => {
            this.remove.emit(args);
        }));
        this.subs.add(this.uploadService.resumeEvent.subscribe((args) => {
            this.resume.emit(args);
        }));
        this.subs.add(this.uploadService.selectEvent.subscribe((args) => {
            this.select.emit(args);
        }));
        this.subs.add(this.uploadService.successEvent.subscribe((args) => {
            this.success.emit(args);
        }));
        this.subs.add(this.uploadService.uploadEvent.subscribe((args) => {
            this.upload.emit(args);
        }));
        this.subs.add(this.uploadService.uploadProgressEvent.subscribe((args) => {
            this.uploadProgress.emit(args);
        }));
    }
}
UploadComponent.ɵfac = function UploadComponent_Factory(t) { return new (t || UploadComponent)(ɵngcc0.ɵɵdirectiveInject(UploadService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
UploadComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: UploadComponent, selectors: [["kendo-upload"]], contentQueries: function UploadComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, FileTemplateDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.fileTemplate = _t.first);
    } }, viewQuery: function UploadComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
        ɵngcc0.ɵɵviewQuery(_c1, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.fileSelect = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.fileSelectButton = _t.first);
    } }, hostVars: 9, hostBindings: function UploadComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function UploadComponent_keydown_HostBindingHandler($event) { return ctx.handleKeydown($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.dir);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.hostDefaultClasses)("k-upload", ctx.hostDefaultClasses)("k-header", ctx.hostDefaultClasses)("k-state-disabled", ctx.hostDisabledClass);
    } }, inputs: { chunkable: "chunkable", multiple: "multiple", disabled: "disabled", showFileList: "showFileList", tabindex: "tabindex", focusableId: "focusableId", autoUpload: "autoUpload", batch: "batch", withCredentials: "withCredentials", saveField: "saveField", saveHeaders: "saveHeaders", saveMethod: "saveMethod", saveUrl: "saveUrl", responseType: "responseType", removeField: "removeField", removeHeaders: "removeHeaders", removeMethod: "removeMethod", removeUrl: "removeUrl", concurrent: "concurrent", tabIndex: "tabIndex", restrictions: "restrictions", accept: "accept" }, outputs: { onBlur: "blur", cancel: "cancel", clear: "clear", complete: "complete", error: "error", onFocus: "focus", pause: "pause", remove: "remove", resume: "resume", select: "select", success: "success", upload: "upload", uploadProgress: "uploadProgress", valueChange: "valueChange" }, exportAs: ["kendoUpload"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            NavigationService,
            UploadService,
            UPLOAD_VALUE_ACCESSOR,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.upload'
            },
            {
                provide: KendoInput,
                useExisting: forwardRef(() => UploadComponent)
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature()], decls: 14, vars: 16, consts: [["kendoUploadLocalizedMessages", "", 6, "cancel", "clearSelectedFiles", "dropFilesHere", "headerStatusPaused", "headerStatusUploaded", "headerStatusUploading", "invalidFileExtension", "invalidFiles", "invalidMaxFileSize", "invalidMinFileSize", "pause", "remove", "resume", "retry", "select", "uploadSelectedFiles"], ["kendoUploadDropzone", "", 3, "restrictions", "multiple", "disabled"], ["role", "button", 1, "k-button", "k-upload-button", 3, "id", "focus", "blur"], ["fileSelectButton", ""], ["kendoFileSelect", "", 3, "dir", "restrictions", "multiple", "disabled"], ["fileSelect", ""], [1, "k-dropzone-hint"], [3, "fileList", 4, "ngIf"], ["kendo-upload-file-list", "", "class", "k-upload-files k-reset", 3, "disabled", "fileList", "fileTemplate", 4, "ngIf"], [3, "disabled", 4, "ngIf"], [3, "fileList"], ["kendo-upload-file-list", "", 1, "k-upload-files", "k-reset", 3, "disabled", "fileList", "fileTemplate"], [3, "disabled"]], template: function UploadComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵi18nAttributes(1, _c53);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵelementStart(3, "div", 2, 3);
        ɵngcc0.ɵɵlistener("focus", function UploadComponent_Template_div_focus_3_listener($event) { return ctx.onFileSelectButtonFocus($event); })("blur", function UploadComponent_Template_div_blur_3_listener($event) { return ctx.onFileSelectButtonBlur($event); });
        ɵngcc0.ɵɵelement(5, "input", 4, 5);
        ɵngcc0.ɵɵelementStart(7, "span");
        ɵngcc0.ɵɵtext(8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(9, "div", 6);
        ɵngcc0.ɵɵtext(10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(11, UploadComponent_kendo_upload_status_total_11_Template, 1, 1, "kendo-upload-status-total", 7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(12, UploadComponent_ul_12_Template, 1, 3, "ul", 8);
        ɵngcc0.ɵɵtemplate(13, UploadComponent_kendo_upload_action_buttons_13_Template, 1, 1, "kendo-upload-action-buttons", 9);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("restrictions", ctx.restrictions)("multiple", ctx.multiple)("disabled", ctx.disabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("id", ctx.focusableId);
        ɵngcc0.ɵɵattribute("aria-label", ctx.textFor("select"))("tabindex", ctx.selectButtonTabIndex);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("dir", ctx.direction)("restrictions", ctx.restrictions)("multiple", ctx.multiple)("disabled", ctx.disabled);
        ɵngcc0.ɵɵattribute("accept", ctx.accept ? ctx.accept : null);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.textFor("select"));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.textFor("dropFilesHere"));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showTotalStatus);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showFileList && ctx.fileList.count > 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showActionButtons);
    } }, directives: function () { return [LocalizedMessagesDirective,
        DropZoneDirective,
        FileSelectDirective, ɵngcc3.NgIf, UploadStatusTotalComponent,
        FileListComponent,
        UploadActionButtonsComponent]; }, encapsulation: 2 });
/** @nocollapse */
UploadComponent.ctorParameters = () => [
    { type: UploadService },
    { type: LocalizationService },
    { type: NavigationService },
    { type: NgZone },
    { type: Renderer2 },
    { type: ElementRef }
];
UploadComponent.propDecorators = {
    autoUpload: [{ type: Input }],
    batch: [{ type: Input }],
    withCredentials: [{ type: Input }],
    saveField: [{ type: Input }],
    saveHeaders: [{ type: Input }],
    saveMethod: [{ type: Input }],
    saveUrl: [{ type: Input }],
    responseType: [{ type: Input }],
    removeField: [{ type: Input }],
    removeHeaders: [{ type: Input }],
    removeMethod: [{ type: Input }],
    removeUrl: [{ type: Input }],
    chunkable: [{ type: Input }],
    concurrent: [{ type: Input }],
    multiple: [{ type: Input }],
    disabled: [{ type: Input }],
    showFileList: [{ type: Input }],
    tabindex: [{ type: Input }],
    tabIndex: [{ type: Input, args: ['tabIndex',] }],
    accept: [{ type: Input }],
    restrictions: [{ type: Input }],
    focusableId: [{ type: Input }],
    fileTemplate: [{ type: ContentChild, args: [FileTemplateDirective,] }],
    fileSelect: [{ type: ViewChild, args: ['fileSelect',] }],
    fileSelectButton: [{ type: ViewChild, args: ['fileSelectButton',] }],
    onBlur: [{ type: Output, args: ['blur',] }],
    cancel: [{ type: Output }],
    clear: [{ type: Output }],
    complete: [{ type: Output }],
    error: [{ type: Output }],
    onFocus: [{ type: Output, args: ['focus',] }],
    pause: [{ type: Output }],
    remove: [{ type: Output }],
    resume: [{ type: Output }],
    select: [{ type: Output }],
    success: [{ type: Output }],
    upload: [{ type: Output }],
    uploadProgress: [{ type: Output }],
    valueChange: [{ type: Output }],
    hostDefaultClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-upload',] }, { type: HostBinding, args: ['class.k-header',] }],
    hostDisabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }],
    dir: [{ type: HostBinding, args: ['attr.dir',] }],
    handleKeydown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(UploadComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoUpload',
                providers: [
                    LocalizationService,
                    NavigationService,
                    UploadService,
                    UPLOAD_VALUE_ACCESSOR,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.upload'
                    },
                    {
                        provide: KendoInput,
                        useExisting: forwardRef(() => UploadComponent)
                    }
                ],
                selector: 'kendo-upload',
                template: `
    <ng-container kendoUploadLocalizedMessages
      i18n-cancel="kendo.upload.cancel|The text for the Cancel button"
      cancel="Cancel"

      i18n-clearSelectedFiles="kendo.upload.clearSelectedFiles|The text for the Clear button"
      clearSelectedFiles="Clear"

      i18n-dropFilesHere="kendo.upload.dropFilesHere|The drop zone hint"
      dropFilesHere="Drop files here to upload"

      i18n-headerStatusPaused="kendo.upload.headerStatusPaused|The header status message when the file upload is paused"
      headerStatusPaused="Paused"

      i18n-headerStatusUploaded="kendo.upload.headerStatusUploaded|The header status message after file upload completion"
      headerStatusUploaded="Done"

      i18n-headerStatusUploading="kendo.upload.headerStatusUploading|The header status message during file upload"
      headerStatusUploading="Uploading..."

      i18n-invalidFileExtension="kendo.upload.invalidFileExtension|The text for the invalid allowed extensions restriction message"
      invalidFileExtension="File type not allowed."

      i18n-invalidFiles="kendo.upload.invalidFiles|The text for the invalid files message"
      invalidFiles="Invalid file(s). Please check file upload requirements."

      i18n-invalidMaxFileSize="kendo.upload.invalidMaxFileSize|The text for the invalid max file size restriction message"
      invalidMaxFileSize="File size too large."

      i18n-invalidMinFileSize="kendo.upload.invalidMinFileSize|The text for the invalid min file size restriction message"
      invalidMinFileSize="File size too small."

      i18n-pause="kendo.upload.pause|The text for the Pause button"
      pause="Pause"

      i18n-remove="kendo.upload.remove|The text for the Remove button"
      remove="Remove"

      i18n-resume="kendo.upload.resume|The text for the Resume button"
      resume="Resume"

      i18n-retry="kendo.upload.retry|The text for the Retry button"
      retry="Retry"

      i18n-select="kendo.upload.select|The text for the Select button"
      select="Select files..."

      i18n-uploadSelectedFiles="kendo.upload.uploadSelectedFiles|The text for the Upload files button"
      uploadSelectedFiles="Upload"
    >
    </ng-container>
    <div kendoUploadDropzone
      [restrictions]="restrictions"
      [multiple]="multiple"
      [disabled]="disabled">
        <div role="button" #fileSelectButton
             [id]="focusableId"
             [attr.aria-label]="textFor('select')"
             [attr.tabindex]="selectButtonTabIndex"
             (focus)="onFileSelectButtonFocus($event)"
             (blur)="onFileSelectButtonBlur($event)"
             class="k-button k-upload-button">
          <input #fileSelect kendoFileSelect
            [attr.accept]="accept ? accept : null"
            [dir]="direction"
            [restrictions]="restrictions"
            [multiple]="multiple"
            [disabled]="disabled" />
          <span>{{textFor('select')}}</span>
        </div>
        <div class="k-dropzone-hint">{{textFor('dropFilesHere')}}</div>
        <kendo-upload-status-total *ngIf="showTotalStatus"
          [fileList]="fileList">
        </kendo-upload-status-total>
    </div>
    <ul kendo-upload-file-list *ngIf="showFileList && fileList.count > 0"
        class="k-upload-files k-reset"
        [disabled]="disabled"
        [fileList]="fileList.files"
        [fileTemplate]="fileTemplate">
    </ul>
    <kendo-upload-action-buttons
      *ngIf="showActionButtons"
      [disabled]="disabled">
    </kendo-upload-action-buttons>
  `
            }]
    }], function () { return [{ type: UploadService }, { type: ɵngcc2.LocalizationService }, { type: NavigationService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { chunkable: [{
            type: Input
        }], multiple: [{
            type: Input
        }], disabled: [{
            type: Input
        }], showFileList: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], focusableId: [{
            type: Input
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], cancel: [{
            type: Output
        }], clear: [{
            type: Output
        }], complete: [{
            type: Output
        }], error: [{
            type: Output
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], pause: [{
            type: Output
        }], remove: [{
            type: Output
        }], resume: [{
            type: Output
        }], select: [{
            type: Output
        }], success: [{
            type: Output
        }], upload: [{
            type: Output
        }], uploadProgress: [{
            type: Output
        }], valueChange: [{
            type: Output
        }], hostDefaultClasses: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-upload']
        }, {
            type: HostBinding,
            args: ['class.k-header']
        }], autoUpload: [{
            type: Input
        }], batch: [{
            type: Input
        }], withCredentials: [{
            type: Input
        }], saveField: [{
            type: Input
        }], saveHeaders: [{
            type: Input
        }], saveMethod: [{
            type: Input
        }], saveUrl: [{
            type: Input
        }], responseType: [{
            type: Input
        }], removeField: [{
            type: Input
        }], removeHeaders: [{
            type: Input
        }], removeMethod: [{
            type: Input
        }], removeUrl: [{
            type: Input
        }], concurrent: [{
            type: Input
        }], tabIndex: [{
            type: Input,
            args: ['tabIndex']
        }], restrictions: [{
            type: Input
        }], hostDisabledClass: [{
            type: HostBinding,
            args: ['class.k-state-disabled']
        }], dir: [{
            type: HostBinding,
            args: ['attr.dir']
        }], handleKeydown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], accept: [{
            type: Input
        }], fileTemplate: [{
            type: ContentChild,
            args: [FileTemplateDirective]
        }], fileSelect: [{
            type: ViewChild,
            args: ['fileSelect']
        }], fileSelectButton: [{
            type: ViewChild,
            args: ['fileSelectButton']
        }] }); })();

/**
 * @hidden
 */
class UploadActionButtonsComponent {
    constructor(uploadService, localization, navigation) {
        this.uploadService = uploadService;
        this.localization = localization;
        this.navigation = navigation;
        this.onAction();
        this.onFocus();
    }
    onAction() {
        this.actionSubscription = this.navigation.onActionButtonAction.subscribe((button) => {
            if (button === "clear") {
                this.clearFiles();
            }
            else {
                this.performUpload();
            }
            this.navigation.focusSelectButton();
        });
    }
    onFocus() {
        this.focusSubscription = this.navigation.onActionButtonFocus.subscribe((button) => {
            this.focusButton(button);
        });
    }
    focusButton(button) {
        const el = (button === "clear") ? this.clearButton : this.uploadButton;
        el.nativeElement.focus();
    }
    ngOnDestroy() {
        this.actionSubscription.unsubscribe();
        this.focusSubscription.unsubscribe();
    }
    performUpload(_event) {
        if (!this.disabled) {
            this.uploadService.uploadFiles();
        }
    }
    clearFiles(_event) {
        if (!this.disabled) {
            this.uploadService.clearFiles();
        }
    }
    textFor(key) {
        return this.localization.get(key);
    }
    get className() {
        return 'k-action-buttons';
    }
}
UploadActionButtonsComponent.ɵfac = function UploadActionButtonsComponent_Factory(t) { return new (t || UploadActionButtonsComponent)(ɵngcc0.ɵɵdirectiveInject(UploadService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(NavigationService)); };
UploadActionButtonsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: UploadActionButtonsComponent, selectors: [["kendo-upload-action-buttons"]], viewQuery: function UploadActionButtonsComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c54, true);
        ɵngcc0.ɵɵviewQuery(_c55, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.clearButton = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.uploadButton = _t.first);
    } }, hostVars: 2, hostBindings: function UploadActionButtonsComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.className);
    } }, inputs: { disabled: "disabled" }, decls: 6, vars: 4, consts: [["type", "button", 1, "k-button", "k-clear-selected", 3, "click"], ["clearButton", ""], ["type", "button", 1, "k-button", "k-primary", "k-upload-selected", 3, "click"], ["uploadButton", ""]], template: function UploadActionButtonsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "button", 0, 1);
        ɵngcc0.ɵɵlistener("click", function UploadActionButtonsComponent_Template_button_click_0_listener($event) { return ctx.clearFiles($event); });
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "button", 2, 3);
        ɵngcc0.ɵɵlistener("click", function UploadActionButtonsComponent_Template_button_click_3_listener($event) { return ctx.performUpload($event); });
        ɵngcc0.ɵɵtext(5);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabIndex", 0 - 1);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.textFor("clearSelectedFiles"), " ");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("tabIndex", 0 - 1);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.textFor("uploadSelectedFiles"), " ");
    } }, encapsulation: 2 });
/** @nocollapse */
UploadActionButtonsComponent.ctorParameters = () => [
    { type: UploadService },
    { type: LocalizationService },
    { type: NavigationService }
];
UploadActionButtonsComponent.propDecorators = {
    disabled: [{ type: Input }],
    clearButton: [{ type: ViewChild, args: ['clearButton',] }],
    uploadButton: [{ type: ViewChild, args: ['uploadButton',] }],
    className: [{ type: HostBinding, args: ['class',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(UploadActionButtonsComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-upload-action-buttons',
                template: `
        <button #clearButton type="button" class="k-button k-clear-selected"
            [attr.tabIndex]="-1"
            (click)="clearFiles($event)">
                {{textFor('clearSelectedFiles')}}
        </button>
        <button #uploadButton type="button" class="k-button k-primary k-upload-selected"
            [attr.tabIndex]="-1"
            (click)="performUpload($event)">
                {{textFor('uploadSelectedFiles')}}
        </button>
    `
            }]
    }], function () { return [{ type: UploadService }, { type: ɵngcc2.LocalizationService }, { type: NavigationService }]; }, { className: [{
            type: HostBinding,
            args: ['class']
        }], disabled: [{
            type: Input
        }], clearButton: [{
            type: ViewChild,
            args: ['clearButton']
        }], uploadButton: [{
            type: ViewChild,
            args: ['uploadButton']
        }] }); })();

/**
 * @hidden
 */
class UploadStatusTotalComponent {
    constructor(localization) {
        this.localization = localization;
    }
    ngDoCheck() {
        this.isPaused = this.fileList.hasFileWithState([FileState.Paused]);
        this.isFailed = this.fileList.hasFileWithState([FileState.Failed]);
        this.isUploading = this.fileList.hasFileWithState([FileState.Uploading]);
        if (this.isPaused && !this.isUploading) {
            this.statusText = this.localization.get('headerStatusPaused');
        }
        else {
            this.statusText = this.isUploading ? this.localization.get('headerStatusUploading')
                : this.localization.get('headerStatusUploaded');
        }
        // this.isPaused = this.isFailed = this.isUploading = false;
        // let currentlyUploading: boolean = this.fileList.hasFileWithState([FileState.Uploading]);
        // if (this.fileList.hasFileWithState([FileState.Paused])) {
        //     this.isPaused = true;
        //     this.statusText = this.localization.get('headerStatusPaused');
        // }
        // if (this.isUploading !== currentlyUploading) {
        //     this.isUploading = currentlyUploading;
        //     this.isFailed = this.fileList.hasFileWithState([FileState.Failed]);
        //     this.statusText = this.isUploading ? this.localization.get('headerStatusUploading')
        //                                        : this.localization.get('headerStatusUploaded');
        // }
    }
}
UploadStatusTotalComponent.ɵfac = function UploadStatusTotalComponent_Factory(t) { return new (t || UploadStatusTotalComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
UploadStatusTotalComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: UploadStatusTotalComponent, selectors: [["kendo-upload-status-total"]], inputs: { fileList: "fileList" }, decls: 3, vars: 7, consts: [[1, "k-upload-status", "k-upload-status-total"], [1, "k-icon", 3, "ngClass"]], template: function UploadStatusTotalComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "strong", 0);
        ɵngcc0.ɵɵelement(1, "span", 1);
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction4(2, _c56, !ctx.isUploading && !ctx.isFailed, !ctx.isUploading && ctx.isFailed, ctx.isUploading, ctx.isPaused));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.statusText, " ");
    } }, directives: [ɵngcc3.NgClass], encapsulation: 2 });
/** @nocollapse */
UploadStatusTotalComponent.ctorParameters = () => [
    { type: LocalizationService }
];
UploadStatusTotalComponent.propDecorators = {
    fileList: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(UploadStatusTotalComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-upload-status-total',
                template: `
        <strong class="k-upload-status k-upload-status-total">
          <span class="k-icon"
            [ngClass]="{
                'k-i-checkmark': !this.isUploading && !this.isFailed,
                'k-i-exception': !this.isUploading && this.isFailed,
                'k-i-loading': this.isUploading,
                'k-i-pause-sm': this.isPaused
            }">
          </span>
          {{statusText}}
        </strong>
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, { fileList: [{
            type: Input
        }] }); })();

const UPLOAD_DECLARATIONS = [
    UploadComponent,
    UploadActionButtonsComponent,
    UploadStatusTotalComponent
];
/**
 * Represents the [NgModule](https://angular.io/api/core/NgModule) definition for the Upload component.
 */
class UploadModule {
}
UploadModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: UploadModule });
UploadModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function UploadModule_Factory(t) { return new (t || UploadModule)(); }, imports: [[SharedModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(UploadModule, { declarations: [UploadComponent,
        UploadActionButtonsComponent,
        UploadStatusTotalComponent], imports: [SharedModule], exports: [FileTemplateDirective,
        CustomMessagesComponent,
        UploadComponent,
        UploadActionButtonsComponent,
        UploadStatusTotalComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(UploadModule, [{
        type: NgModule,
        args: [{
                declarations: [UPLOAD_DECLARATIONS],
                exports: [
                    PUBLIC_DIRECTIVES,
                    UPLOAD_DECLARATIONS
                ],
                imports: [SharedModule]
            }]
    }], null, null); })();

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Uploads components.
 *
 * @example
 *
 * ```ts-no-run
 * import { UploadsModule } from '@progress/kendo-angular-upload';
 *
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 * import { NgModule } from '@angular/core';
 *
 * import { AppComponent } from './app.component';
 *
 * _@NgModule({
 *     declarations: [AppComponent],
 *     imports:      [BrowserModule, UploadsModule],
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
class UploadsModule {
}
UploadsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: UploadsModule });
UploadsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function UploadsModule_Factory(t) { return new (t || UploadsModule)(); }, imports: [FileSelectModule,
        UploadModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(UploadsModule, { exports: [FileSelectModule,
        UploadModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(UploadsModule, [{
        type: NgModule,
        args: [{
                exports: [
                    FileSelectModule,
                    UploadModule
                ]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { PreventableEvent, FILESELECT_VALUE_ACCESSOR, LocalizedMessagesDirective, Messages, NavigationService, FileListItemDirective, FileListItemBase, PUBLIC_DIRECTIVES, SHARED_DECLARATIONS, SharedModule, UPLOAD_VALUE_ACCESSOR, UploadService, FileSelectModule, UploadModule, UploadsModule, UploadComponent, FileSelectComponent, FileSelectDirective, FileListComponent, FileListSingleItemComponent, FileListItemActionButtonComponent, FileListMultipleItemsComponent, FileTemplateDirective, TemplateContextDirective, UploadStatusTotalComponent, UploadActionButtonsComponent, DropZoneDirective, CustomMessagesComponent, CancelEvent, ClearEvent, ErrorEvent, PauseEvent, RemoveEvent, ResumeEvent, SelectEvent, SuccessEvent, UploadEvent, UploadProgressEvent, FileState };

//# sourceMappingURL=index.js.map