/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Injectable, Directive, TemplateRef, Optional, isDevMode, Component, SkipSelf, Host, ElementRef, Input, ViewChild, HostBinding, ViewChildren, ContentChildren, EventEmitter, Output, ContentChild, HostListener, Renderer2, ChangeDetectorRef, NgZone, Inject, QueryList, NgModule, ViewEncapsulation } from '@angular/core';
import { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import { Keys, hasObservers, DraggableDirective, DraggableModule } from '@progress/kendo-angular-common';
import { trigger, state, style, transition, animate, AUTO_STYLE, AnimationBuilder } from '@angular/animations';
import { Subject, BehaviorSubject, Subscription, of } from 'rxjs';
import { take, tap, filter, switchMap, delay, takeUntil, map } from 'rxjs/operators';
import { CommonModule } from '@angular/common';

/**
 * Represents the expand modes of the PanelBar.
 * By default, the expand mode is set to `multiple`.
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '@progress/kendo-angular-l10n';
import * as ɵngcc3 from '@progress/kendo-angular-common';
import * as ɵngcc4 from '@angular/animations';

const _c0 = ["header"];
const _c1 = ["contentWrapper"];
function PanelBarItemComponent_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 7);
} if (rf & 2) {
    const ctx_r81 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r81.iconClasses);
} }
function PanelBarItemComponent_img_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "img", 8);
} if (rf & 2) {
    const ctx_r82 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("src", ctx_r82.imageUrl, ɵngcc0.ɵɵsanitizeUrl);
} }
function PanelBarItemComponent_ng_template_5_Template(rf, ctx) { }
function PanelBarItemComponent_span_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span");
} if (rf & 2) {
    const ctx_r84 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("k-icon", true)("k-i-arrow-n", ctx_r84.expanded)("k-panelbar-collapse", ctx_r84.expanded)("k-i-arrow-s", !ctx_r84.expanded)("k-panelbar-expand", !ctx_r84.expanded);
} }
function PanelBarItemComponent_div_7_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 12);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r87 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("overflow", ctx_r87.contentOverflow)("height", ctx_r87.contentHeight);
} }
function PanelBarItemComponent_div_7_div_3_ng_template_1_Template(rf, ctx) { }
const _c2 = function (a0, a1, a2, a3, a4, a5) { return { title: a0, id: a1, icon: a2, imageUrl: a3, disabled: a4, content: a5 }; };
const _c3 = function (a0) { return { $implicit: a0 }; };
function PanelBarItemComponent_div_7_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 13);
    ɵngcc0.ɵɵtemplate(1, PanelBarItemComponent_div_7_div_3_ng_template_1_Template, 0, 0, "ng-template", 14);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r88 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("overflow", ctx_r88.contentOverflow)("height", ctx_r88.contentHeight);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r88.contentTemplate.first.templateRef)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(13, _c3, ɵngcc0.ɵɵpureFunction6(6, _c2, ctx_r88.title, ctx_r88.id, ctx_r88.icon, ctx_r88.imageUrl, ctx_r88.disabled, ctx_r88.content)));
} }
function PanelBarItemComponent_div_7_div_4_ng_container_1_kendo_panelbar_item_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-panelbar-item", 17);
} if (rf & 2) {
    const item_r93 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r94 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("title", item_r93.title)("id", item_r93.id)("icon", item_r93.icon)("iconClass", item_r93.iconClass)("imageUrl", item_r93.imageUrl)("selected", !!item_r93.selected)("expanded", !!item_r93.expanded)("disabled", !!item_r93.disabled)("template", ctx_r94.template)("items", item_r93.children)("content", item_r93.content);
} }
function PanelBarItemComponent_div_7_div_4_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, PanelBarItemComponent_div_7_div_4_ng_container_1_kendo_panelbar_item_1_Template, 1, 11, "kendo-panelbar-item", 16);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r93 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !item_r93.hidden);
} }
function PanelBarItemComponent_div_7_div_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 12);
    ɵngcc0.ɵɵtemplate(1, PanelBarItemComponent_div_7_div_4_ng_container_1_Template, 2, 1, "ng-container", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r89 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("overflow", ctx_r89.contentOverflow)("height", ctx_r89.contentHeight);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r89.items);
} }
function PanelBarItemComponent_div_7_div_5_ng_template_1_Template(rf, ctx) { }
function PanelBarItemComponent_div_7_div_5_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r97 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r97.content);
} }
function PanelBarItemComponent_div_7_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 13);
    ɵngcc0.ɵɵtemplate(1, PanelBarItemComponent_div_7_div_5_ng_template_1_Template, 0, 0, "ng-template", 14);
    ɵngcc0.ɵɵtemplate(2, PanelBarItemComponent_div_7_div_5_ng_template_2_Template, 1, 1, "ng-template", 18);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r90 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("overflow", ctx_r90.contentOverflow)("height", ctx_r90.contentHeight);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r90.template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(14, _c3, ɵngcc0.ɵɵpureFunction6(7, _c2, ctx_r90.title, ctx_r90.id, ctx_r90.icon, ctx_r90.imageUrl, ctx_r90.disabled, ctx_r90.content)));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r90.template);
} }
function PanelBarItemComponent_div_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", null, 9);
    ɵngcc0.ɵɵtemplate(2, PanelBarItemComponent_div_7_div_2_Template, 2, 4, "div", 10);
    ɵngcc0.ɵɵtemplate(3, PanelBarItemComponent_div_7_div_3_Template, 2, 15, "div", 11);
    ɵngcc0.ɵɵtemplate(4, PanelBarItemComponent_div_7_div_4_Template, 2, 5, "div", 10);
    ɵngcc0.ɵɵtemplate(5, PanelBarItemComponent_div_7_div_5_Template, 3, 16, "div", 11);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r85 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@toggle", ctx_r85.state);
    ɵngcc0.ɵɵattribute("role", "group")("aria-hidden", !ctx_r85.disabled && !ctx_r85.expanded);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r85.hasChildItems && !(ctx_r85.items == null ? null : ctx_r85.items.length));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r85.hasContent && !ctx_r85.content);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r85.hasItems);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r85.content);
} }
const _c4 = [[["kendo-panelbar-item"]]];
const _c5 = ["kendo-panelbar-item"];
function PanelBarComponent_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 0, ["*ngIf", "contentChildItems && !items"]);
} }
function PanelBarComponent_ng_template_1_ng_container_0_kendo_panelbar_item_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-panelbar-item", 4);
} if (rf & 2) {
    const item_r101 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r102 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("title", item_r101.title)("id", item_r101.id)("icon", item_r101.icon)("iconClass", item_r101.iconClass)("imageUrl", item_r101.imageUrl)("selected", !!item_r101.selected)("expanded", !!item_r101.expanded)("disabled", !!item_r101.disabled)("template", ctx_r102.templateRef)("items", item_r101.children)("content", item_r101.content);
} }
function PanelBarComponent_ng_template_1_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, PanelBarComponent_ng_template_1_ng_container_0_kendo_panelbar_item_1_Template, 1, 11, "kendo-panelbar-item", 3);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r101 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !item_r101.hidden);
} }
function PanelBarComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, PanelBarComponent_ng_template_1_ng_container_0_Template, 2, 1, "ng-container", 2);
} if (rf & 2) {
    const ctx_r99 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r99.items);
} }
function SplitterPaneComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementContainerEnd();
} }
function SplitterPaneComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 2);
} }
const _c6 = ["*"];
function SplitterComponent_ng_container_1_kendo_splitter_bar_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-splitter-bar", 2);
} if (rf & 2) {
    const index_r108 = ɵngcc0.ɵɵnextContext().index;
    const ctx_r110 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("index", index_r108)("orientation", ctx_r110.orientation);
} }
function SplitterComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, SplitterComponent_ng_container_1_kendo_splitter_bar_1_Template, 1, 2, "kendo-splitter-bar", 1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const last_r109 = ctx.last;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !last_r109);
} }
const _c7 = [[["kendo-splitter-pane"]]];
const _c8 = ["kendo-splitter-pane"];
const _c9 = ["tablist"];
const _c10 = ["tabHeadingContainer"];
function TabStripComponent_ng_container_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function TabStripComponent_ng_container_0_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function TabStripComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, TabStripComponent_ng_container_0_ng_container_1_Template, 1, 0, "ng-container", 3);
    ɵngcc0.ɵɵtemplate(2, TabStripComponent_ng_container_0_ng_container_2_Template, 1, 0, "ng-container", 3);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r114 = ɵngcc0.ɵɵreference(3);
    const _r116 = ɵngcc0.ɵɵreference(5);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r114);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r116);
} }
function TabStripComponent_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function TabStripComponent_ng_container_1_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function TabStripComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, TabStripComponent_ng_container_1_ng_container_1_Template, 1, 0, "ng-container", 3);
    ɵngcc0.ɵɵtemplate(2, TabStripComponent_ng_container_1_ng_container_2_Template, 1, 0, "ng-container", 3);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r116 = ɵngcc0.ɵɵreference(5);
    const _r114 = ɵngcc0.ɵɵreference(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r116);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r114);
} }
function TabStripComponent_ng_template_2_li_2_ng_template_4_Template(rf, ctx) { }
function TabStripComponent_ng_template_2_li_2_Template(rf, ctx) { if (rf & 1) {
    const _r129 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 7, 8);
    ɵngcc0.ɵɵlistener("click", function TabStripComponent_ng_template_2_li_2_Template_li_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r129); const i_r125 = ctx.index; const ctx_r128 = ɵngcc0.ɵɵnextContext(2); return ctx_r128.onTabClick($event, i_r125); });
    ɵngcc0.ɵɵelementStart(2, "span", 9);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵtemplate(4, TabStripComponent_ng_template_2_li_2_ng_template_4_Template, 0, 0, "ng-template", 10);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tab_r124 = ctx.$implicit;
    const i_r125 = ctx.index;
    const ctx_r123 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵclassProp("k-item", true)("k-state-default", true)("k-state-active", tab_r124.active)("k-state-disabled", tab_r124.disabled);
    ɵngcc0.ɵɵproperty("id", ctx_r123.tabId(i_r125))("tabIndex", tab_r124.active ? 0 : 0 - 1)("ngClass", tab_r124.cssClass);
    ɵngcc0.ɵɵattribute("aria-selected", tab_r124.active)("aria-controls", ctx_r123.tabPanelId(i_r125))("aria-disabled", tab_r124.disabled);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(tab_r124.title);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", tab_r124.tabTitle == null ? null : tab_r124.tabTitle.templateRef);
} }
function TabStripComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    const _r131 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ul", 4, 5);
    ɵngcc0.ɵɵlistener("keydown", function TabStripComponent_ng_template_2_Template_ul_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r131); const ctx_r130 = ɵngcc0.ɵɵnextContext(); return ctx_r130.onKeyDown($event); });
    ɵngcc0.ɵɵtemplate(2, TabStripComponent_ng_template_2_li_2_Template, 5, 16, "li", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r115 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("justify-content", ctx_r115.tabsAlignment);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r115.tabs);
} }
function TabStripComponent_ng_template_4_ng_template_0_div_0_ng_template_1_Template(rf, ctx) { }
function TabStripComponent_ng_template_4_ng_template_0_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 13);
    ɵngcc0.ɵɵtemplate(1, TabStripComponent_ng_template_4_ng_template_0_div_0_ng_template_1_Template, 0, 0, "ng-template", 10);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r137 = ɵngcc0.ɵɵnextContext();
    const tab_r133 = ctx_r137.$implicit;
    const i_r134 = ctx_r137.index;
    const ctx_r135 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("@state", tab_r133.active && ctx_r135._animate ? "active" : "inactive")("ngClass", ctx_r135.contentClass(tab_r133.active))("tabIndex", 0)("id", ctx_r135.tabPanelId(i_r134));
    ɵngcc0.ɵɵattribute("aria-hidden", !tab_r133.active)("aria-expanded", tab_r133.active)("aria-labelledby", ctx_r135.tabId(i_r134))("aria-disabled", tab_r133.disabled);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", tab_r133.tabContent == null ? null : tab_r133.tabContent.templateRef);
} }
function TabStripComponent_ng_template_4_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TabStripComponent_ng_template_4_ng_template_0_div_0_Template, 2, 9, "div", 12);
} if (rf & 2) {
    const tab_r133 = ctx.$implicit;
    const ctx_r132 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngIf", tab_r133.active || ctx_r132.keepTabContent);
} }
function TabStripComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TabStripComponent_ng_template_4_ng_template_0_Template, 1, 1, "ng-template", 11);
} if (rf & 2) {
    const ctx_r117 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r117.tabs);
} }
function DrawerComponent_div_0_ng_container_1_1_ng_template_0_Template(rf, ctx) { }
function DrawerComponent_div_0_ng_container_1_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, DrawerComponent_div_0_ng_container_1_1_ng_template_0_Template, 0, 0, "ng-template", 4);
} if (rf & 2) {
    const ctx_r141 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r141.headerTemplate == null ? null : ctx_r141.headerTemplate.templateRef);
} }
function DrawerComponent_div_0_ng_container_1_3_ng_template_0_Template(rf, ctx) { }
function DrawerComponent_div_0_ng_container_1_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, DrawerComponent_div_0_ng_container_1_3_ng_template_0_Template, 0, 0, "ng-template", 4);
} if (rf & 2) {
    const ctx_r142 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r142.footerTemplate == null ? null : ctx_r142.footerTemplate.templateRef);
} }
function DrawerComponent_div_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, DrawerComponent_div_0_ng_container_1_1_Template, 1, 1, undefined, 2);
    ɵngcc0.ɵɵelement(2, "ul", 3);
    ɵngcc0.ɵɵtemplate(3, DrawerComponent_div_0_ng_container_1_3_Template, 1, 1, undefined, 2);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r139 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r139.headerTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("items", ctx_r139.items)("mini", ctx_r139.mini)("expanded", ctx_r139.expanded)("itemTemplate", ctx_r139.itemTemplate == null ? null : ctx_r139.itemTemplate.templateRef);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r139.footerTemplate);
} }
function DrawerComponent_div_0_2_ng_template_0_Template(rf, ctx) { }
function DrawerComponent_div_0_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, DrawerComponent_div_0_2_ng_template_0_Template, 0, 0, "ng-template", 4);
} if (rf & 2) {
    const ctx_r140 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r140.drawerTemplate == null ? null : ctx_r140.drawerTemplate.templateRef);
} }
function DrawerComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵtemplate(1, DrawerComponent_div_0_ng_container_1_Template, 4, 6, "ng-container", 2);
    ɵngcc0.ɵɵtemplate(2, DrawerComponent_div_0_2_Template, 1, 1, undefined, 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r138 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("width", ctx_r138.drawerWidth, "px");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r138.drawerTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r138.drawerTemplate);
} }
function AvatarComponent_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 0, ["*ngIf", "customAvatar"]);
} }
function AvatarComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "div", 1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r147 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("width", ctx_r147.width)("height", ctx_r147.height)("background-image", ctx_r147.imageUrl, ɵngcc0.ɵɵdefaultStyleSanitizer);
    ɵngcc0.ɵɵproperty("ngStyle", ctx_r147.cssStyle);
} }
function AvatarComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "span", 1);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r148 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngStyle", ctx_r148.cssStyle);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r148.initials.substring(0, 2));
} }
function AvatarComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "span", 2);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r149 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngStyle", ctx_r149.cssStyle)("ngClass", ctx_r149.iconClasses());
} }
function CardActionsComponent_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 0, ["*ngIf", "!actions"]);
} }
function CardActionsComponent_ng_container_1_button_1_Template(rf, ctx) { if (rf & 1) {
    const _r156 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 2);
    ɵngcc0.ɵɵlistener("click", function CardActionsComponent_ng_container_1_button_1_Template_button_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r156); const action_r154 = ctx.$implicit; const ctx_r155 = ɵngcc0.ɵɵnextContext(2); return ctx_r155.onClick(action_r154); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const action_r154 = ctx.$implicit;
    ɵngcc0.ɵɵclassProp("k-primary", action_r154.primary)("k-flat", action_r154.flat);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", action_r154.text, " ");
} }
function CardActionsComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, CardActionsComponent_ng_container_1_button_1_Template, 2, 5, "button", 1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r151 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r151.actions);
} }
function CardActionsComponent_2_ng_template_0_Template(rf, ctx) { }
function CardActionsComponent_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, CardActionsComponent_2_ng_template_0_Template, 0, 0, "ng-template", 3);
} if (rf & 2) {
    const ctx_r152 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r152.actions);
} }
function DrawerContainerComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r160 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵlistener("click", function DrawerContainerComponent_div_0_Template_div_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r160); const ctx_r159 = ɵngcc0.ɵɵnextContext(); return ctx_r159.closeDrawer(); });
    ɵngcc0.ɵɵelementEnd();
} }
const _c11 = ["kendoDrawerItem", ""];
function DrawerItemComponent_0_ng_template_0_Template(rf, ctx) { }
function DrawerItemComponent_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, DrawerItemComponent_0_ng_template_0_Template, 0, 0, "ng-template", 2);
} if (rf & 2) {
    const ctx_r161 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r161.itemTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c3, ctx_r161.item));
} }
function DrawerItemComponent_ng_template_1_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "span", 4);
    ɵngcc0.ɵɵelementStart(2, "span", 5);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r165 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r165.iconClasses(ctx_r165.item.icon));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r165.item.text);
} }
function DrawerItemComponent_ng_template_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "span", 4);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r166 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r166.iconClasses(ctx_r166.item.icon));
} }
function DrawerItemComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, DrawerItemComponent_ng_template_1_ng_container_0_Template, 4, 2, "ng-container", 3);
    ɵngcc0.ɵɵtemplate(1, DrawerItemComponent_ng_template_1_ng_container_1_Template, 2, 1, "ng-container", 3);
} if (rf & 2) {
    const ctx_r163 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r163.expanded);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r163.mini && !ctx_r163.expanded);
} }
const _c12 = ["kendoDrawerList", ""];
function DrawerListComponent_ng_container_0_li_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "li", 3);
} if (rf & 2) {
    const ctx_r172 = ɵngcc0.ɵɵnextContext();
    const item_r168 = ctx_r172.$implicit;
    const idx_r169 = ctx_r172.index;
    const ctx_r170 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("item", item_r168)("index", idx_r169)("mini", ctx_r170.mini)("expanded", ctx_r170.expanded)("itemTemplate", ctx_r170.itemTemplate)("ngClass", item_r168.cssClass)("ngStyle", item_r168.cssStyle);
    ɵngcc0.ɵɵattribute("data-kendo-drawer-index", idx_r169);
} }
function DrawerListComponent_ng_container_0_li_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li", 4);
    ɵngcc0.ɵɵtext(1, " \u00A0 ");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r168 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("ngClass", item_r168.cssClass)("ngStyle", item_r168.cssStyle);
} }
function DrawerListComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, DrawerListComponent_ng_container_0_li_1_Template, 1, 8, "li", 1);
    ɵngcc0.ɵɵtemplate(2, DrawerListComponent_ng_container_0_li_2_Template, 2, 2, "li", 2);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r168 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !item_r168.separator);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", item_r168.separator);
} }
var PanelBarExpandMode;
(function (PanelBarExpandMode) {
    /**
     * Allows you to expand only one item at a time.
     * When you expand an item, the item that was previously expanded is coll.
     */
    PanelBarExpandMode[PanelBarExpandMode["Single"] = 0] = "Single";
    /**
     * Allows you to expand only one item at a time and requires you to set the `height` property.
     * The expanded area occupies the entire height of the PanelBar.
     */
    PanelBarExpandMode[PanelBarExpandMode["Full"] = 1] = "Full";
    /**
     * The default mode of the PanelBar.
     * Allows you to expand more than one item at a time. Items can also be toggled.
     */
    PanelBarExpandMode[PanelBarExpandMode["Multiple"] = 2] = "Multiple";
    /**
     * By default, the expand mode is set to `multiple`.
     */
    PanelBarExpandMode[PanelBarExpandMode["Default"] = 2] = "Default";
})(PanelBarExpandMode || (PanelBarExpandMode = {}));

/**
 * @hidden
 */
let nextPanelbarId = 0;
/**
 * @hidden
 */
class PanelBarService {
    constructor() {
        this.parentSource = new Subject();
        this.keepContentSource = new BehaviorSubject(false);
        this.childSource = new Subject();
        this.parent$ = this.parentSource.asObservable();
        this.children$ = this.childSource.asObservable();
        this.keepContent$ = this.keepContentSource.asObservable();
        this.pbId = nextPanelbarId++;
    }
    onKeepContent(keepContent) {
        this.keepContentSource.next(keepContent);
    }
    onSelect(event) {
        this.childSource.next(event);
    }
    onFocus() {
        this.parentSource.next(true);
    }
    onBlur() {
        this.parentSource.next(false);
    }
}
PanelBarService.ɵfac = function PanelBarService_Factory(t) { return new (t || PanelBarService)(); };
PanelBarService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: PanelBarService, factory: PanelBarService.ɵfac });
/** @nocollapse */
PanelBarService.ctorParameters = () => [];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PanelBarService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * Represents the content template of the declaratively initialized PanelBar items.
 * The content can be expanded or collapsed through the item.
 */
class PanelBarContentDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
PanelBarContentDirective.ɵfac = function PanelBarContentDirective_Factory(t) { return new (t || PanelBarContentDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
PanelBarContentDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: PanelBarContentDirective, selectors: [["", "kendoPanelBarContent", ""]] });
/** @nocollapse */
PanelBarContentDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PanelBarContentDirective, [{
        type: Directive,
        args: [{
                selector: "[kendoPanelBarContent]"
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();

/**
 * Represents the template directive of the PanelBar which helps to customize the item title
 * ([more information and example]({% slug templates_panelbar %}#toc-customizing-the-appearance-of-the-title)).
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *        <kendo-panelbar>
 *            <kendo-panelbar-item [title]="'Paris'" [expanded]="true">
 *                <ng-template kendoPanelBarItemTitle>
 *                    Additional Content
 *                </ng-template>
 *            </kendo-panelbar-item>
 *        </kendo-panelbar>
 *     `
 * })
 *
 * class AppComponent {}
 *
 * ```
 */
class PanelBarItemTitleDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
PanelBarItemTitleDirective.ɵfac = function PanelBarItemTitleDirective_Factory(t) { return new (t || PanelBarItemTitleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
PanelBarItemTitleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: PanelBarItemTitleDirective, selectors: [["", "kendoPanelBarItemTitle", ""]] });
/** @nocollapse */
PanelBarItemTitleDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PanelBarItemTitleDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoPanelBarItemTitle]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * @hidden
 */
const ITEM_INDEX = 'data-kendo-drawer-index';

/**
 * @hidden
 */
const isPresent = (value) => value !== null && value !== undefined;

const focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;
/**
 * @hidden
 */
const isFocusable = (element) => {
    if (element.tagName) {
        const tagName = element.tagName.toLowerCase();
        const tabIndex = element.getAttribute('tabIndex');
        const skipTab = tabIndex === '-1';
        let focusable = tabIndex !== null && !skipTab;
        if (focusableRegex.test(tagName)) {
            focusable = !element.disabled && !skipTab;
        }
        return focusable;
    }
    return false;
};
/**
 * @hidden
 */
const closestInScope = (target, predicate, scope) => {
    while (target && target !== scope && !predicate(target)) {
        target = target.parentNode;
    }
    if (target !== scope) {
        return target;
    }
};
/**
 * @hidden
 */
const itemIndex = (item) => +item.getAttribute(ITEM_INDEX);
/**
 *
 * @hidden
 */
const hasItemIndex = (item) => isPresent(item.getAttribute(ITEM_INDEX));
/**
 * @hidden
 */
const closestItem = (target, scope) => closestInScope(target, hasItemIndex, scope);

/**
 * @hidden
 */
let nextId = 0;
/**
 * Represents the items of the PanelBar.
 */
class PanelBarItemComponent {
    constructor(parent, eventService, element) {
        this.parent = parent;
        this.eventService = eventService;
        this.element = element;
        /**
         * Sets the title of the PanelBar item ([see example]({% slug items_panelbar %}#toc-titles)).
         */
        this.title = 'Untitled';
        /**
         * Allows the component to set the `"id"` property to each item.
         * Used to set the `id` attributes of the nested elements and to enable the WAI-ARIA support.
         */
        this.id = `default-${nextId++}`;
        /**
         * Defines the icon that will be rendered next to the title ([see example]({% slug items_panelbar %}#toc-title-icons)).
         */
        this.icon = '';
        /**
         * Defines  the icon that will be rendered next to the title by using a custom CSS class
         * ([see example]({% slug items_panelbar %}#toc-title-icons)).
         */
        this.iconClass = '';
        /**
         * Defines the location of the image that will be displayed next to the title
         * ([see example]({% slug items_panelbar %}#toc-title-images)).
         */
        this.imageUrl = '';
        /**
         * When set to `true`, disables a PanelBar item ([see example]({% slug items_panelbar %}#toc-disabled-state)).
         */
        this.disabled = false;
        /**
         * Sets the selected state of a PanelBar item ([see example]({% slug items_panelbar %}#toc-selected-state)).
         */
        this.selected = false;
        this.keepContent = false;
        this.hasChildItems = false;
        this.hasItems = false;
        this.hasContent = false;
        this.state = "inactive";
        this.role = "treeitem";
        this.titleAttribute = null; // tslint:disable-line
        this.focused = false;
        this.wrapperFocused = false;
        this.subscriptions = new Subscription(() => { });
        this._expanded = false;
        this.subscriptions.add(eventService.parent$.subscribe(focused => this.onWrapperFocusChange(focused)));
        this.subscriptions.add(eventService.keepContent$.subscribe(keepContent => this.keepContent = keepContent));
        this.wrapperFocused = parent ? parent.focused : false;
    }
    /**
     * When set to `true`, expands the PanelBar item ([see example]({% slug items_panelbar %}#toc-expanded-state)).
     */
    set expanded(value) {
        const activeState = this.animate ? "active" : "activeWithoutAnimation";
        this.state = value ? activeState : "inactive";
        if (!this.keepContent) {
            this.toggleExpandedChildAnimations(value);
        }
        this._expanded = value;
    }
    get expanded() {
        return this._expanded;
    }
    get animate() {
        return this.eventService.animate;
    }
    get kItemClass() {
        return true;
    }
    get kStateDefaultClass() {
        return !this.disabled;
    }
    get kStateDisabledClass() {
        return this.disabled;
    }
    get kStateExpandedClass() {
        return !this.disabled && this.expanded && (this.hasChildItems || this.hasContent);
    }
    get itemId() {
        return 'k-panelbar-' + this.eventService.pbId + '-item-' + this.id;
    }
    get ariaExpanded() {
        return (this.hasChildItems || this.hasContent) ? !this.disabled && this.expanded : null;
    }
    get ariaSelected() {
        return !this.disabled && this.selected;
    }
    get ariaDisabled() {
        return this.disabled ? true : null;
    }
    /**
     * @hidden
     */
    get titleTemplate() {
        return this.titleTemplates.length > 0 ? this.titleTemplates.toArray()[0].templateRef : undefined;
    }
    /**
     * @hidden
     */
    headerHeight() {
        return this.element.nativeElement.offsetHeight - (this.contentWrapper ? this.contentWrapper.nativeElement.offsetHeight : 0);
    }
    /**
     * @hidden
     */
    ngAfterContentChecked() {
        this.hasItems = this.items && this.items.filter(item => !item.hidden).length > 0;
        this.hasChildItems = this.contentItems.length > 1 || this.hasItems;
        this.hasContent = (this.contentTemplate !== undefined && this.contentTemplate.length > 0) ||
            this.content !== undefined;
        this.validateConfiguration();
    }
    /**
     * @hidden
     */
    ngAfterViewChecked() {
        if (this.items) {
            this.childrenItems = this.viewChildItems.toArray();
        }
        else {
            this.childrenItems = this.contentItems.filter(item => item !== this);
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    /**
     * @hidden
     */
    onItemAction() {
        if (!this.disabled) {
            this.eventService.onSelect(this);
        }
    }
    /**
     * @hidden
     */
    onItemClick(e) {
        if (!isFocusable(e.target)) {
            this.onItemAction();
        }
    }
    /**
     * @hidden
     */
    get iconClasses() {
        let icon = this.icon ? 'k-i-' + this.icon : null;
        return {
            [icon || this.iconClass]: true
        };
    }
    /**
     * @hidden
     */
    serialize() {
        return {
            content: this.content,
            disabled: this.disabled,
            expanded: this.expanded,
            focused: this.focused,
            icon: this.icon,
            iconClass: this.iconClass,
            id: this.id,
            imageUrl: this.imageUrl,
            selected: this.selected,
            title: this.title
        };
    }
    /**
     * @hidden
     */
    subTreeViewItems() {
        let subTree = [];
        this.viewChildItems.forEach(item => {
            subTree = subTree.concat(item.subTreeViewItems());
            subTree.push(item);
        });
        return subTree;
    }
    /**
     * @hidden
     */
    validateConfiguration() {
        if (isDevMode()) {
            if (this.content && (this.contentTemplate !== undefined && this.contentTemplate.length > 0)) {
                throw new Error("Invalid configuration: mixed template components and component property.");
            }
        }
    }
    /**
     * @hidden
     */
    toggleAnimationState(value) {
        if (!this.animate) {
            return;
        }
        this.state = value ? 'active' : 'activeWithoutAnimation';
    }
    /**
     * @hidden
     */
    toggleExpandedChildAnimations(value) {
        if (this.childrenItems) {
            this.childrenItems.forEach(child => {
                if (child.expanded) {
                    child.toggleAnimationState(value);
                    child.toggleExpandedChildAnimations(value);
                }
            });
        }
    }
    onWrapperFocusChange(focused) {
        this.wrapperFocused = focused;
    }
}
PanelBarItemComponent.ɵfac = function PanelBarItemComponent_Factory(t) { return new (t || PanelBarItemComponent)(ɵngcc0.ɵɵdirectiveInject(PanelBarItemComponent, 13), ɵngcc0.ɵɵdirectiveInject(PanelBarService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
PanelBarItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PanelBarItemComponent, selectors: [["kendo-panelbar-item"]], contentQueries: function PanelBarItemComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, PanelBarItemComponent, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, PanelBarContentDirective, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, PanelBarItemTitleDirective, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentItems = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentTemplate = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.titleTemplates = _t);
    } }, viewQuery: function PanelBarItemComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
        ɵngcc0.ɵɵviewQuery(_c1, true);
        ɵngcc0.ɵɵviewQuery(PanelBarItemComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.header = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentWrapper = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.viewChildItems = _t);
    } }, hostVars: 14, hostBindings: function PanelBarItemComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("id", ctx.itemId);
        ɵngcc0.ɵɵattribute("role", ctx.role)("title", ctx.titleAttribute)("aria-expanded", ctx.ariaExpanded)("aria-selected", ctx.ariaSelected)("aria-disabled", ctx.ariaDisabled);
        ɵngcc0.ɵɵclassProp("k-item", ctx.kItemClass)("k-state-default", ctx.kStateDefaultClass)("k-state-disabled", ctx.kStateDisabledClass)("k-state-expanded", ctx.kStateExpandedClass);
    } }, inputs: { title: "title", id: "id", icon: "icon", iconClass: "iconClass", imageUrl: "imageUrl", disabled: "disabled", selected: "selected", expanded: "expanded", content: "content", items: "items", template: "template" }, exportAs: ["kendoPanelbarItem"], ngContentSelectors: _c5, decls: 8, vars: 14, consts: [[3, "click"], ["header", ""], ["class", "k-icon", 3, "ngClass", 4, "ngIf"], ["class", "k-image", "alt", "", 3, "src", 4, "ngIf"], [3, "ngTemplateOutlet"], [3, "k-icon", "k-i-arrow-n", "k-panelbar-collapse", "k-i-arrow-s", "k-panelbar-expand", 4, "ngIf"], [4, "ngIf"], [1, "k-icon", 3, "ngClass"], ["alt", "", 1, "k-image", 3, "src"], ["contentWrapper", ""], ["class", "k-panel k-group", 3, "overflow", "height", 4, "ngIf"], ["class", "k-content", 3, "overflow", "height", 4, "ngIf"], [1, "k-panel", "k-group"], [1, "k-content"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [4, "ngFor", "ngForOf"], [3, "title", "id", "icon", "iconClass", "imageUrl", "selected", "expanded", "disabled", "template", "items", "content", 4, "ngIf"], [3, "title", "id", "icon", "iconClass", "imageUrl", "selected", "expanded", "disabled", "template", "items", "content"], [3, "ngIf"]], template: function PanelBarItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c4);
        ɵngcc0.ɵɵelementStart(0, "span", 0, 1);
        ɵngcc0.ɵɵlistener("click", function PanelBarItemComponent_Template_span_click_0_listener($event) { return ctx.onItemClick($event); });
        ɵngcc0.ɵɵtemplate(2, PanelBarItemComponent_span_2_Template, 1, 1, "span", 2);
        ɵngcc0.ɵɵtemplate(3, PanelBarItemComponent_img_3_Template, 1, 1, "img", 3);
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵtemplate(5, PanelBarItemComponent_ng_template_5_Template, 0, 0, "ng-template", 4);
        ɵngcc0.ɵɵtemplate(6, PanelBarItemComponent_span_6_Template, 1, 10, "span", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, PanelBarItemComponent_div_7_Template, 6, 7, "div", 6);
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-link", true)("k-header", !ctx.parent)("k-state-selected", !ctx.disabled && ctx.selected)("k-state-focused", !ctx.disabled && ctx.focused && ctx.wrapperFocused);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.icon || ctx.iconClass);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.imageUrl);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.title, " ");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.titleTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasChildItems || ctx.hasContent);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.keepContent || !ctx.disabled && ctx.expanded && (ctx.hasChildItems || ctx.hasContent));
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet, ɵngcc1.NgClass, ɵngcc1.NgForOf, PanelBarItemComponent], encapsulation: 2, data: { animation: [
            trigger('toggle', [
                state('inactive', style({ display: 'none' })),
                transition('* => active', [
                    style({ overflow: 'hidden', display: 'block', height: 0 }),
                    animate(200, style({ height: AUTO_STYLE }))
                ]),
                transition('active => *', [
                    style({ overflow: 'hidden', height: '*' }),
                    animate(200, style({ height: 0, display: 'none' }))
                ])
            ])
        ] } });
/** @nocollapse */
PanelBarItemComponent.ctorParameters = () => [
    { type: PanelBarItemComponent, decorators: [{ type: SkipSelf }, { type: Host }, { type: Optional }] },
    { type: PanelBarService },
    { type: ElementRef }
];
PanelBarItemComponent.propDecorators = {
    title: [{ type: Input }],
    id: [{ type: Input }],
    icon: [{ type: Input }],
    iconClass: [{ type: Input }],
    imageUrl: [{ type: Input }],
    disabled: [{ type: Input }],
    expanded: [{ type: Input }],
    selected: [{ type: Input }],
    content: [{ type: Input }],
    items: [{ type: Input }],
    template: [{ type: Input }],
    header: [{ type: ViewChild, args: ['header', {},] }],
    contentWrapper: [{ type: ViewChild, args: ['contentWrapper', {},] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    titleAttribute: [{ type: HostBinding, args: ['attr.title',] }],
    kItemClass: [{ type: HostBinding, args: ['class.k-item',] }],
    kStateDefaultClass: [{ type: HostBinding, args: ['class.k-state-default',] }],
    kStateDisabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }],
    kStateExpandedClass: [{ type: HostBinding, args: ['class.k-state-expanded',] }],
    itemId: [{ type: HostBinding, args: ['id',] }],
    ariaExpanded: [{ type: HostBinding, args: ['attr.aria-expanded',] }],
    ariaSelected: [{ type: HostBinding, args: ['attr.aria-selected',] }],
    ariaDisabled: [{ type: HostBinding, args: ['attr.aria-disabled',] }],
    viewChildItems: [{ type: ViewChildren, args: [PanelBarItemComponent,] }],
    contentItems: [{ type: ContentChildren, args: [PanelBarItemComponent,] }],
    contentTemplate: [{ type: ContentChildren, args: [PanelBarContentDirective, { descendants: false },] }],
    titleTemplates: [{ type: ContentChildren, args: [PanelBarItemTitleDirective, { descendants: false },] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PanelBarItemComponent, [{
        type: Component,
        args: [{
                animations: [
                    trigger('toggle', [
                        state('inactive', style({ display: 'none' })),
                        transition('* => active', [
                            style({ overflow: 'hidden', display: 'block', height: 0 }),
                            animate(200, style({ height: AUTO_STYLE }))
                        ]),
                        transition('active => *', [
                            style({ overflow: 'hidden', height: '*' }),
                            animate(200, style({ height: 0, display: 'none' }))
                        ])
                    ])
                ],
                exportAs: 'kendoPanelbarItem',
                selector: "kendo-panelbar-item",
                template: `<span
                #header
                [class.k-link]="true"
                [class.k-header]="!parent"
                [class.k-state-selected]="!disabled && selected"
                [class.k-state-focused]="!disabled && focused && wrapperFocused"
                (click)="onItemClick($event)">
            <span
                *ngIf="icon || iconClass"
                class="k-icon"
                [ngClass]="iconClasses">
            </span>
            <img
                *ngIf="imageUrl"
                class="k-image"
                [src]="imageUrl"
                alt="">
            {{title}}
            <ng-template [ngTemplateOutlet]="titleTemplate"></ng-template>
            <span *ngIf="hasChildItems || hasContent"
                [class.k-icon]="true"
                [class.k-i-arrow-n]="expanded"
                [class.k-panelbar-collapse]="expanded"
                [class.k-i-arrow-s]="!expanded"
                [class.k-panelbar-expand]="!expanded">
            </span>
        </span>
        <div #contentWrapper
            *ngIf="keepContent || (!disabled && expanded && (hasChildItems || hasContent))"
            [@toggle]="state"
            [attr.role]="'group'"
            [attr.aria-hidden]="!disabled && !expanded">
            <div
                *ngIf="hasChildItems && !items?.length"
                [style.overflow]="contentOverflow"
                [style.height]="contentHeight"
                class="k-panel k-group">
                    <ng-content select="kendo-panelbar-item"></ng-content>
            </div>
            <div
                *ngIf="hasContent && !content"
                [style.overflow]="contentOverflow"
                [style.height]="contentHeight"
                class="k-content">
                <ng-template
                    [ngTemplateOutlet]="contentTemplate.first.templateRef"
                    [ngTemplateOutletContext]="{
                        $implicit: {
                            title: title,
                            id: id,
                            icon: icon,
                            imageUrl: imageUrl,
                            disabled: disabled,
                            content: content
                        }
                    }">
                </ng-template>
            </div>
            <div *ngIf="hasItems"
                [style.overflow]="contentOverflow"
                [style.height]="contentHeight"
                class="k-panel k-group">
                <ng-container *ngFor="let item of items">
                    <kendo-panelbar-item *ngIf="!item.hidden"
                        [title]="item.title"
                        [id]="item.id"
                        [icon]="item.icon"
                        [iconClass]="item.iconClass"
                        [imageUrl]="item.imageUrl"
                        [selected]="!!item.selected"
                        [expanded]="!!item.expanded"
                        [disabled]="!!item.disabled"
                        [template]="template"
                        [items]="item.children"
                        [content]="item.content">
                    </kendo-panelbar-item>
                </ng-container>
            </div>
            <div
                *ngIf="content"
                [style.overflow]="contentOverflow"
                [style.height]="contentHeight"
                class="k-content">
                <ng-template
                    [ngTemplateOutlet]="template"
                    [ngTemplateOutletContext]="{
                        $implicit: {
                            title: title,
                            id: id,
                            icon: icon,
                            imageUrl: imageUrl,
                            disabled: disabled,
                            content: content
                        }
                    }">
                </ng-template>
                <ng-template [ngIf]="!template">{{content}}</ng-template>
            </div>
        </div>`
            }]
    }], function () { return [{ type: PanelBarItemComponent, decorators: [{
                type: SkipSelf
            }, {
                type: Host
            }, {
                type: Optional
            }] }, { type: PanelBarService }, { type: ɵngcc0.ElementRef }]; }, { title: [{
            type: Input
        }], id: [{
            type: Input
        }], icon: [{
            type: Input
        }], iconClass: [{
            type: Input
        }], imageUrl: [{
            type: Input
        }], disabled: [{
            type: Input
        }], selected: [{
            type: Input
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], titleAttribute: [{
            type: HostBinding,
            args: ['attr.title']
        }], expanded: [{
            type: Input
        }], kItemClass: [{
            type: HostBinding,
            args: ['class.k-item']
        }], kStateDefaultClass: [{
            type: HostBinding,
            args: ['class.k-state-default']
        }], kStateDisabledClass: [{
            type: HostBinding,
            args: ['class.k-state-disabled']
        }], kStateExpandedClass: [{
            type: HostBinding,
            args: ['class.k-state-expanded']
        }], itemId: [{
            type: HostBinding,
            args: ['id']
        }], ariaExpanded: [{
            type: HostBinding,
            args: ['attr.aria-expanded']
        }], ariaSelected: [{
            type: HostBinding,
            args: ['attr.aria-selected']
        }], ariaDisabled: [{
            type: HostBinding,
            args: ['attr.aria-disabled']
        }], content: [{
            type: Input
        }], items: [{
            type: Input
        }], template: [{
            type: Input
        }], header: [{
            type: ViewChild,
            args: ['header', {}]
        }], contentWrapper: [{
            type: ViewChild,
            args: ['contentWrapper', {}]
        }], viewChildItems: [{
            type: ViewChildren,
            args: [PanelBarItemComponent]
        }], contentItems: [{
            type: ContentChildren,
            args: [PanelBarItemComponent]
        }], contentTemplate: [{
            type: ContentChildren,
            args: [PanelBarContentDirective, { descendants: false }]
        }], titleTemplates: [{
            type: ContentChildren,
            args: [PanelBarItemTitleDirective, { descendants: false }]
        }] }); })();

/**
 * Represents the template directive of the PanelBar which helps to customize the item content.
 */
class PanelBarItemTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
PanelBarItemTemplateDirective.ɵfac = function PanelBarItemTemplateDirective_Factory(t) { return new (t || PanelBarItemTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
PanelBarItemTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: PanelBarItemTemplateDirective, selectors: [["", "kendoPanelBarItemTemplate", ""]] });
/** @nocollapse */
PanelBarItemTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PanelBarItemTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoPanelBarItemTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

let nextId$1 = 0;
const parsePanelBarItems = (data) => {
    return data.map((item) => {
        if (!item.id) {
            item.id = `default-${nextId$1++}`;
        }
        if (item.children) {
            item.children = parsePanelBarItems(item.children);
        }
        return item;
    });
};
var util = {
    parsePanelBarItems
};

/**
 * Represents the [Kendo UI PanelBar component for Angular]({% slug overview_panelbar %}).
 */
// TODO: add styles as input prop
class PanelBarComponent {
    constructor(elementRef, eventService, localization) {
        this.localization = localization;
        /**
         * Sets the expand mode of the PanelBar through the `PanelBarExpandMode` enum ([see example]({% slug expandmodes_panelbar %})).
         *
         * The available modes are:
         * - `"single"`&mdash;Expands only one item at a time. Expanding an item collapses the item that was previously expanded.
         * - `"multiple"`&mdash;The default mode of the PanelBar.
         * Expands more than one item at a time. Items can also be toggled.
         * - `"full"`&mdash;Expands only one item at a time.
         * The expanded area occupies the entire height of the PanelBar. Requires you to set the `height` property.
         */
        this.expandMode = PanelBarExpandMode.Default;
        /**
         * Allows the PanelBar to modify the selected state of the items.
         */
        this.selectable = true;
        /**
         * Sets the animate state of the PanelBar ([see example]({% slug animations_panelbar %})).
         */
        this.animate = true;
        /**
         * Sets the height of the component when the `"full"` expand mode is used.
         * This option is ignored in the `"multiple"` and `"single"` expand modes.
         */
        this.height = "400px";
        /**
         * Fires each time the user interacts with a PanelBar item
         * ([see example]({% slug routing_panelbar %}#toc-getting-the-selected-item)).
         * The event data contains all items that are modified.
         */
        this.stateChange = new EventEmitter();
        this.tabIndex = 0;
        this.role = "tree";
        this.activeDescendant = "";
        this.isViewInit = true;
        this.focused = false;
        this._keepItemContent = false;
        this.updateChildrenHeight = () => {
            let childrenHeight = 0;
            const panelbarHeight = this.elementRef.nativeElement.offsetHeight;
            const contentOverflow = this.expandMode === PanelBarExpandMode.Full ? 'auto' : 'visible';
            this.childrenItems.forEach(item => {
                childrenHeight += item.headerHeight();
            });
            this.childrenItems.forEach(item => {
                item.contentHeight = PanelBarExpandMode.Full === this.expandMode ? (panelbarHeight - childrenHeight) + "px" : 'auto';
                item.contentOverflow = contentOverflow;
            });
        };
        this.keyBindings = this.computedKeys;
        this.elementRef = elementRef;
        this.eventService = eventService;
        this.eventService.children$.subscribe(event => this.onItemAction(event));
    }
    /**
     * When set to `true`, the PanelBar renders the content of all items and they are persisted in the DOM
     * ([see example]({% slug templates_panelbar %}#toc-collections)).
     * By default, this option is set to `false`.
     */
    get keepItemContent() {
        return this._keepItemContent;
    }
    set keepItemContent(keepItemContent) {
        this._keepItemContent = keepItemContent;
        this.eventService.onKeepContent(keepItemContent);
    }
    /**
     * Sets the items of the PanelBar as an array of `PanelBarItemModel` instances
     * ([see example]({% slug items_panelbar %})).
     */
    set items(data) {
        if (data) {
            this._items = util.parsePanelBarItems(data);
        }
    }
    get items() {
        return this._items;
    }
    get hostHeight() {
        return this.expandMode === PanelBarExpandMode.Full ? this.height : 'auto';
    }
    get overflow() {
        return this.expandMode === PanelBarExpandMode.Full ? "hidden" : "visible";
    }
    get dir() {
        return this.localization.rtl ? 'rtl' : 'ltr';
    }
    /**
     * @hidden
     */
    invertKeys(original, inverted) {
        return this.localization.rtl ? inverted : original;
    }
    get computedKeys() {
        return {
            [Keys.Space]: () => this.selectFocusedItem(),
            [Keys.Enter]: () => this.selectFocusedItem(),
            [Keys.ArrowUp]: () => this.focusPreviousItem(),
            [this.invertKeys(Keys.ArrowLeft, Keys.ArrowRight)]: () => this.collapseItem(),
            [Keys.ArrowDown]: () => this.focusNextItem(),
            [this.invertKeys(Keys.ArrowRight, Keys.ArrowLeft)]: () => this.expandItem(),
            [Keys.End]: () => this.focusLastItem(),
            [Keys.Home]: () => this.focusFirstItem()
        };
    }
    ngOnDestroy() {
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
    }
    ngOnInit() {
        this.localizationChangeSubscription = this.localization
            .changes.subscribe(() => this.keyBindings = this.computedKeys);
        this.eventService.animate = this.animate;
    }
    ngAfterViewChecked() {
        if (this.items) {
            this.childrenItems = this.viewChildItems.toArray();
            this.allItems = this.viewItems;
        }
        else {
            this.childrenItems = this.contentChildItems.toArray();
            this.allItems = this.contentItems.toArray();
        }
        if (this.isViewInit && this.childrenItems.length) {
            this.isViewInit = false;
            setTimeout(() => this.updateChildrenHeight());
        }
        this.validateConfiguration();
    }
    ngOnChanges(changes) {
        if (changes['height'] || changes['expandMode'] || changes["items"]) { // tslint:disable-line
            if (this.childrenItems) {
                setTimeout(this.updateChildrenHeight);
            }
        }
        if (changes.animate) {
            this.eventService.animate = this.animate;
        }
    }
    get templateRef() {
        return this.template ? this.template.templateRef : undefined;
    }
    /**
     * @hidden
     */
    onComponentClick(event) {
        const itemClicked = this.visibleItems().some((item) => {
            return item.header.nativeElement.contains(event.target);
        });
        if (!this.focused && itemClicked) {
            this.elementRef.nativeElement.focus();
        }
    }
    /**
     * @hidden
     */
    onComponentFocus() {
        this.eventService.onFocus();
        this.focused = true;
        if (this.allItems.length > 0) {
            const visibleItems = this.visibleItems();
            const focusedItems = visibleItems.filter(item => item.focused);
            if (!focusedItems.length && visibleItems.length > 0) {
                visibleItems[0].focused = true;
                this.activeDescendant = visibleItems[0].itemId;
            }
        }
    }
    /**
     * @hidden
     */
    onComponentBlur() {
        this.eventService.onBlur();
        this.focused = false;
        this.activeDescendant = "";
    }
    /**
     * @hidden
     */
    onComponentKeyDown(event) {
        if (event.target === this.elementRef.nativeElement) {
            if (event.keyCode === Keys.Space || event.keyCode === Keys.ArrowUp || event.keyCode === Keys.ArrowDown ||
                event.keyCode === Keys.ArrowLeft || event.keyCode === Keys.ArrowRight || event.keyCode === Keys.Home ||
                event.keyCode === Keys.End || event.keyCode === Keys.PageUp || event.keyCode === Keys.PageDown) {
                event.preventDefault();
            }
            const handler = this.keyBindings[event.keyCode];
            //TODO: check if next item is disabled and skip operation?
            if (handler) {
                handler();
            }
        }
    }
    get viewItems() {
        let treeItems = [];
        this.viewChildItems.toArray().forEach(item => {
            treeItems.push(item);
            treeItems = treeItems.concat(item.subTreeViewItems());
        });
        return treeItems;
    }
    validateConfiguration() {
        if (isDevMode()) {
            if (this.items && (this.contentItems && this.contentItems.length > 0)) {
                throw new Error("Invalid configuration: mixed template components and items property.");
            }
        }
    }
    onItemAction(item) {
        if (!item) {
            return;
        }
        let modifiedItems = new Array();
        this.allItems
            .forEach((currentItem) => {
            let selectedState = currentItem === item;
            let focusedState = selectedState;
            selectedState = this.selectable ? selectedState : currentItem.selected;
            if (currentItem.selected !== selectedState || currentItem.focused !== focusedState) {
                currentItem.selected = selectedState;
                currentItem.focused = focusedState;
                this.activeDescendant = focusedState ? currentItem.itemId : "";
                modifiedItems.push(currentItem);
            }
        });
        if (this.expandMode === PanelBarExpandMode.Multiple) {
            if (item.hasChildItems || item.hasContent) {
                item.expanded = !item.expanded;
            }
            if (modifiedItems.indexOf(item) < 0) {
                modifiedItems.push(item);
            }
        }
        else {
            let siblings = item.parent ? item.parent.childrenItems : this.childrenItems;
            if (item.hasChildItems || item.hasContent) {
                siblings
                    .forEach((currentItem) => {
                    let expandedState = currentItem === item;
                    if (currentItem.expanded !== expandedState) {
                        currentItem.expanded = expandedState;
                        if (modifiedItems.indexOf(currentItem) < 0) {
                            modifiedItems.push(currentItem);
                        }
                    }
                });
            }
        }
        if (modifiedItems.length > 0) {
            this.stateChange.emit(modifiedItems.map(currentItem => currentItem.serialize()));
        }
    }
    get hostClasses() {
        return true;
    }
    isVisible(item) {
        const visibleItems = this.visibleItems();
        return visibleItems.some(i => i === item);
    }
    getVisibleParent(item) {
        const visibleItems = this.visibleItems();
        if (!item.parent) {
            return item;
        }
        return visibleItems.some(i => i === item.parent) ? item.parent : this.getVisibleParent(item.parent);
    }
    focusItem(action) {
        const visibleItems = this.visibleItems();
        let currentIndex = visibleItems.findIndex(item => item.focused);
        let currentItem = visibleItems[currentIndex];
        let nextItem;
        if (currentIndex === -1) {
            let focusedItem = this.allItems.find(item => item.focused);
            focusedItem.focused = false;
            currentItem = this.getVisibleParent(focusedItem);
            currentIndex = visibleItems.findIndex(item => item === currentItem);
        }
        switch (action) {
            case "lastItem":
                nextItem = visibleItems[visibleItems.length - 1];
                break;
            case "firstItem":
                nextItem = visibleItems[0];
                break;
            case "nextItem":
                nextItem = visibleItems[currentIndex < visibleItems.length - 1 ? currentIndex + 1 : 0];
                break;
            case "previousItem":
                nextItem = visibleItems[currentIndex > 0 ? currentIndex - 1 : visibleItems.length - 1];
                break;
            default:
        }
        if (currentItem && nextItem && currentItem !== nextItem) {
            this.moveFocus(currentItem, nextItem);
        }
    }
    moveFocus(from, to) {
        from.focused = false;
        to.focused = true;
        this.activeDescendant = to.itemId;
        const modifiedItems = new Array(from.serialize(), to.serialize());
        this.stateChange.emit(modifiedItems);
    }
    focusLastItem() {
        this.focusItem("lastItem");
    }
    focusFirstItem() {
        this.focusItem("firstItem");
    }
    focusNextItem() {
        this.focusItem("nextItem");
    }
    focusPreviousItem() {
        this.focusItem("previousItem");
    }
    expandItem() {
        let currentItem = this.allItems.filter(item => item.focused)[0];
        if (!this.isVisible(currentItem)) {
            currentItem.focused = false;
            currentItem = this.getVisibleParent(currentItem);
        }
        if (currentItem.hasChildItems || currentItem.hasContent) {
            if (!currentItem.expanded) {
                this.onItemAction(currentItem);
            }
            else if (currentItem.hasChildItems) {
                const firstChildIndex = currentItem.childrenItems.findIndex(item => !item.disabled);
                if (firstChildIndex > -1) {
                    this.moveFocus(currentItem, currentItem.childrenItems[firstChildIndex]);
                }
            }
        }
    }
    collapseItem() {
        const currentItem = this.allItems.filter(item => item.focused)[0];
        if (currentItem.expanded) {
            this.onItemAction(currentItem);
        }
        else if (currentItem.parent) {
            this.moveFocus(currentItem, currentItem.parent);
        }
    }
    selectFocusedItem() {
        let focusedItem = this.allItems.filter(item => item.focused)[0];
        if (!this.isVisible(focusedItem)) {
            focusedItem.focused = false;
            focusedItem = this.getVisibleParent(focusedItem);
        }
        if (focusedItem) {
            focusedItem.onItemAction();
        }
    }
    visibleItems() {
        return this.flatVisibleItems(this.childrenItems);
    }
    flatVisibleItems(listOfItems = new Array(), flattedItems = new Array()) {
        listOfItems.forEach(item => {
            if (!item.disabled) {
                flattedItems.push(item);
                if (item.expanded && item.hasChildItems) {
                    this.flatVisibleItems(item.childrenItems, flattedItems);
                }
            }
        });
        return flattedItems;
    }
}
PanelBarComponent.ɵfac = function PanelBarComponent_Factory(t) { return new (t || PanelBarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(PanelBarService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
PanelBarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PanelBarComponent, selectors: [["kendo-panelbar"]], contentQueries: function PanelBarComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, PanelBarItemTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, PanelBarItemComponent, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, PanelBarItemComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.template = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentItems = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentChildItems = _t);
    } }, viewQuery: function PanelBarComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(PanelBarItemComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.viewChildItems = _t);
    } }, hostVars: 12, hostBindings: function PanelBarComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function PanelBarComponent_click_HostBindingHandler($event) { return ctx.onComponentClick($event); })("focus", function PanelBarComponent_focus_HostBindingHandler($event) { return ctx.onComponentFocus(); })("blur", function PanelBarComponent_blur_HostBindingHandler($event) { return ctx.onComponentBlur(); })("keydown", function PanelBarComponent_keydown_HostBindingHandler($event) { return ctx.onComponentKeyDown($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabIndex", ctx.tabIndex)("role", ctx.role)("aria-activedescendant", ctx.activeDescendant)("dir", ctx.dir);
        ɵngcc0.ɵɵstyleProp("height", ctx.hostHeight)("overflow", ctx.overflow);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.hostClasses)("k-panelbar", ctx.hostClasses);
    } }, inputs: { expandMode: "expandMode", selectable: "selectable", animate: "animate", height: "height", keepItemContent: "keepItemContent", items: "items" }, outputs: { stateChange: "stateChange" }, exportAs: ["kendoPanelbar"], features: [ɵngcc0.ɵɵProvidersFeature([
            PanelBarService,
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.panelbar'
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature()], ngContentSelectors: _c5, decls: 2, vars: 2, consts: [[4, "ngIf"], [3, "ngIf"], [4, "ngFor", "ngForOf"], [3, "title", "id", "icon", "iconClass", "imageUrl", "selected", "expanded", "disabled", "template", "items", "content", 4, "ngIf"], [3, "title", "id", "icon", "iconClass", "imageUrl", "selected", "expanded", "disabled", "template", "items", "content"]], template: function PanelBarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c4);
        ɵngcc0.ɵɵtemplate(0, PanelBarComponent_0_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵtemplate(1, PanelBarComponent_ng_template_1_Template, 1, 1, "ng-template", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.contentChildItems && !ctx.items);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.items == null ? null : ctx.items.length);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgForOf, PanelBarItemComponent], encapsulation: 2 });
/** @nocollapse */
PanelBarComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PanelBarService },
    { type: LocalizationService }
];
PanelBarComponent.propDecorators = {
    expandMode: [{ type: Input }],
    selectable: [{ type: Input }],
    animate: [{ type: Input }],
    height: [{ type: Input }],
    keepItemContent: [{ type: Input }],
    items: [{ type: Input }],
    stateChange: [{ type: Output }],
    tabIndex: [{ type: HostBinding, args: ['attr.tabIndex',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    activeDescendant: [{ type: HostBinding, args: ['attr.aria-activedescendant',] }],
    hostHeight: [{ type: HostBinding, args: ['style.height',] }],
    overflow: [{ type: HostBinding, args: ['style.overflow',] }],
    dir: [{ type: HostBinding, args: ['attr.dir',] }],
    template: [{ type: ContentChild, args: [PanelBarItemTemplateDirective,] }],
    contentItems: [{ type: ContentChildren, args: [PanelBarItemComponent, { descendants: true },] }],
    contentChildItems: [{ type: ContentChildren, args: [PanelBarItemComponent,] }],
    viewChildItems: [{ type: ViewChildren, args: [PanelBarItemComponent,] }],
    onComponentClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    onComponentFocus: [{ type: HostListener, args: ['focus',] }],
    onComponentBlur: [{ type: HostListener, args: ['blur',] }],
    onComponentKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }],
    hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-panelbar',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PanelBarComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoPanelbar',
                providers: [
                    PanelBarService,
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.panelbar'
                    }
                ],
                selector: 'kendo-panelbar',
                template: `
        <ng-content *ngIf="contentChildItems && !items" select="kendo-panelbar-item"></ng-content>
        <ng-template [ngIf]="items?.length">
            <ng-container *ngFor="let item of items">
                <kendo-panelbar-item *ngIf="!item.hidden"
                     [title]="item.title"
                     [id]="item.id"
                     [icon]="item.icon"
                     [iconClass]="item.iconClass"
                     [imageUrl]="item.imageUrl"
                     [selected]="!!item.selected"
                     [expanded]="!!item.expanded"
                     [disabled]="!!item.disabled"
                     [template]="templateRef"
                     [items]="item.children"
                     [content]="item.content"
                >
                </kendo-panelbar-item>
            </ng-container>
        </ng-template>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: PanelBarService }, { type: ɵngcc2.LocalizationService }]; }, { expandMode: [{
            type: Input
        }], selectable: [{
            type: Input
        }], animate: [{
            type: Input
        }], height: [{
            type: Input
        }], stateChange: [{
            type: Output
        }], tabIndex: [{
            type: HostBinding,
            args: ['attr.tabIndex']
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], activeDescendant: [{
            type: HostBinding,
            args: ['attr.aria-activedescendant']
        }], keepItemContent: [{
            type: Input
        }], items: [{
            type: Input
        }], hostHeight: [{
            type: HostBinding,
            args: ['style.height']
        }], overflow: [{
            type: HostBinding,
            args: ['style.overflow']
        }], dir: [{
            type: HostBinding,
            args: ['attr.dir']
        }], onComponentClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], onComponentFocus: [{
            type: HostListener,
            args: ['focus']
        }], onComponentBlur: [{
            type: HostListener,
            args: ['blur']
        }], onComponentKeyDown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-panelbar']
        }], template: [{
            type: ContentChild,
            args: [PanelBarItemTemplateDirective]
        }], contentItems: [{
            type: ContentChildren,
            args: [PanelBarItemComponent, { descendants: true }]
        }], contentChildItems: [{
            type: ContentChildren,
            args: [PanelBarItemComponent]
        }], viewChildItems: [{
            type: ViewChildren,
            args: [PanelBarItemComponent]
        }] }); })();

/**
 * Represents the pane component of the Splitter.
 */
class SplitterPaneComponent {
    constructor(element, renderer, cdr) {
        this.element = element;
        this.renderer = renderer;
        this.cdr = cdr;
        /**
         * Specifies if the user is allowed to resize the pane and provide space for other panes.
         */
        this.resizable = true;
        /**
         * Specifies if the user is allowed to hide the pane and provide space for other panes.
         */
        this.collapsible = false;
        /**
         * Specifies if overflowing content is scrollable or hidden.
         */
        this.scrollable = true;
        /**
         * Specifies if the pane is initially collapsed.
         */
        this.collapsed = false;
        /**
         * @hidden
         */
        this.orientation = 'horizontal';
        /**
         * @hidden
         */
        this.containsSplitter = false;
        /**
         * @hidden
         */
        this.overlayContent = false;
        /**
         * Fires each time the user resizes the Splitter pane.
         * The event data contains the new pane size.
         * Allows a two-way binding of the pane `size` property.
         */
        this.sizeChange = new EventEmitter();
        /**
         * Fires each time the `collapsed` property changes.
         * The event data contains the new property state.
         * Allows a two-way binding of the `collapsed` pane property.
         */
        this.collapsedChange = new EventEmitter();
        this.hostClass = true;
        /**
         * @hidden
         */
        this.forceExpand = false;
    }
    /**
     * @hidden
     */
    set order(paneOrder) {
        this._order = paneOrder;
        this.setOrderStyles();
    }
    get order() {
        return this._order;
    }
    /**
     * Sets the initial size of the pane.
     * Has to be between the `min` and `max` properties.
     */
    set size(newSize) {
        this._size = newSize;
        const element = this.element.nativeElement;
        this.renderer.setStyle(element, '-ms-flex-preferred-size', newSize);
        this.renderer.setStyle(element, 'flex-basis', newSize);
        if (this.staticPaneClass) {
            this.renderer.addClass(element, 'k-pane-static');
        }
        else {
            this.renderer.removeClass(element, 'k-pane-static');
        }
    }
    get size() {
        return this._size;
    }
    get isHidden() {
        return this.collapsed;
    }
    get styleDisplayFlex() {
        return this.containsSplitter;
    }
    get staticPaneClass() {
        if (this.forceExpand) {
            return false;
        }
        return !this.resizable && !this.collapsible || this.fixedSize;
    }
    get scrollablePaneClass() {
        return this.scrollable;
    }
    get fixedSize() {
        return this.size && this.size.length > 0;
    }
    ngAfterViewChecked() {
        const element = this.element.nativeElement;
        if (this.isHidden) {
            this.renderer.addClass(element, 'k-state-hidden');
            this.renderer.addClass(element, 'hidden');
        }
        else {
            this.renderer.removeClass(element, 'k-state-hidden');
            this.renderer.removeClass(element, 'hidden');
        }
    }
    /**
     * @hidden
     */
    get computedSize() {
        if (this.orientation === 'vertical') {
            return this.element.nativeElement.offsetHeight;
        }
        else {
            return this.element.nativeElement.offsetWidth;
        }
    }
    /**
     * @hidden
     */
    toggleOverlay(show) {
        this.overlayContent = show;
        this.cdr.detectChanges();
    }
    /**
     * @hidden
     */
    detectChanges() {
        this.cdr.detectChanges();
    }
    /**
     * @hidden
     */
    setOrderStyles() {
        const element = this.element.nativeElement;
        this.renderer.setStyle(element, '-ms-flex-order', this.order);
        this.renderer.setStyle(element, 'order', this.order);
    }
}
SplitterPaneComponent.ɵfac = function SplitterPaneComponent_Factory(t) { return new (t || SplitterPaneComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
SplitterPaneComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SplitterPaneComponent, selectors: [["kendo-splitter-pane"]], hostVars: 8, hostBindings: function SplitterPaneComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-pane", ctx.hostClass)("k-pane-flex", ctx.styleDisplayFlex)("k-pane-static", ctx.staticPaneClass)("k-scrollable", ctx.scrollablePaneClass);
    } }, inputs: { resizable: "resizable", collapsible: "collapsible", scrollable: "scrollable", collapsed: "collapsed", orientation: "orientation", containsSplitter: "containsSplitter", overlayContent: "overlayContent", order: "order", size: "size", min: "min", max: "max" }, outputs: { sizeChange: "sizeChange", collapsedChange: "collapsedChange" }, exportAs: ["kendoSplitterPane"], ngContentSelectors: _c6, decls: 2, vars: 2, consts: [[4, "ngIf"], ["class", "k-splitter-overlay k-overlay", 4, "ngIf"], [1, "k-splitter-overlay", "k-overlay"]], template: function SplitterPaneComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, SplitterPaneComponent_ng_container_0_Template, 2, 0, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(1, SplitterPaneComponent_div_1_Template, 1, 0, "div", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.collapsed);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.overlayContent);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2 });
/** @nocollapse */
SplitterPaneComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
SplitterPaneComponent.propDecorators = {
    order: [{ type: Input }],
    size: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    resizable: [{ type: Input }],
    collapsible: [{ type: Input }],
    scrollable: [{ type: Input }],
    collapsed: [{ type: Input }],
    orientation: [{ type: Input }],
    containsSplitter: [{ type: Input }],
    overlayContent: [{ type: Input }],
    sizeChange: [{ type: Output }],
    collapsedChange: [{ type: Output }],
    styleDisplayFlex: [{ type: HostBinding, args: ['class.k-pane-flex',] }],
    hostClass: [{ type: HostBinding, args: ['class.k-pane',] }],
    staticPaneClass: [{ type: HostBinding, args: ['class.k-pane-static',] }],
    scrollablePaneClass: [{ type: HostBinding, args: ['class.k-scrollable',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SplitterPaneComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoSplitterPane',
                selector: 'kendo-splitter-pane',
                template: `
        <ng-container *ngIf="!collapsed"><ng-content></ng-content></ng-container>
        <div *ngIf="overlayContent" class="k-splitter-overlay k-overlay"></div>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }]; }, { resizable: [{
            type: Input
        }], collapsible: [{
            type: Input
        }], scrollable: [{
            type: Input
        }], collapsed: [{
            type: Input
        }], orientation: [{
            type: Input
        }], containsSplitter: [{
            type: Input
        }], overlayContent: [{
            type: Input
        }], sizeChange: [{
            type: Output
        }], collapsedChange: [{
            type: Output
        }], hostClass: [{
            type: HostBinding,
            args: ['class.k-pane']
        }], order: [{
            type: Input
        }], size: [{
            type: Input
        }], styleDisplayFlex: [{
            type: HostBinding,
            args: ['class.k-pane-flex']
        }], staticPaneClass: [{
            type: HostBinding,
            args: ['class.k-pane-static']
        }], scrollablePaneClass: [{
            type: HostBinding,
            args: ['class.k-scrollable']
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }] }); })();

const SIZING_DOC_LINK = 'https://www.telerik.com/kendo-angular-ui/components/layout/splitter/panes/#toc-size';
/**
 * @hidden
 */
class SplitterService {
    constructor(zone) {
        this.zone = zone;
        this.layoutChange = new EventEmitter();
        this.containerSize = () => { };
    }
    tryToggle(paneIndex) {
        const pane = this.pane(paneIndex);
        if (pane.collapsible) {
            pane.collapsed = !pane.collapsed;
            pane.collapsedChange.emit(pane.collapsed);
            this.emit(this.layoutChange, {});
            if (pane.collapsed) {
                pane.detectChanges();
            }
        }
        const notCollapsed = this.panes.filter(p => !p.collapsed);
        const allHaveFixedSize = notCollapsed.every(p => p.fixedSize);
        notCollapsed[notCollapsed.length - 1].forceExpand = allHaveFixedSize ? true : false;
        return pane.collapsible;
    }
    toggleContentOverlay(index, show) {
        this.pane(index).toggleOverlay(show);
        this.pane(index + 1).toggleOverlay(show);
    }
    dragState(splitbarIndex) {
        let prev = this.pane(splitbarIndex);
        let next = this.pane(splitbarIndex + 1);
        const total = prev.computedSize + next.computedSize;
        const px = s => this.toPixels(s);
        return {
            prev: {
                index: splitbarIndex,
                initialSize: prev.computedSize,
                min: px(prev.min) || total - px(next.max) || 0,
                max: px(prev.max) || total - px(next.min) || total
            },
            next: {
                index: splitbarIndex + 1,
                initialSize: next.computedSize,
                min: px(next.min) || total - px(prev.max) || 0,
                max: px(next.max) || total - px(prev.min) || total
            }
        };
    }
    setSize(state$$1, delta) {
        const clamp = (min, max, v) => Math.min(max, Math.max(min, v));
        const resize = (paneState, change) => {
            const pane = this.pane(paneState.index);
            const splitterSize = this.containerSize();
            const newSize = clamp(paneState.min, paneState.max, paneState.initialSize + change);
            let size = "";
            if (this.isPercent(pane.size)) {
                size = (100 * newSize / splitterSize) + "%";
            }
            else {
                size = newSize + "px";
            }
            pane.size = size;
            this.emit(pane.sizeChange, size);
        };
        const prev = this.pane(state$$1.prev.index);
        const next = this.pane(state$$1.next.index);
        // determine which pane to resize
        if (prev.fixedSize && next.fixedSize) {
            // resizing both panes
            resize(state$$1.prev, delta);
            resize(state$$1.next, -delta);
        }
        else if (next.collapsible || next.fixedSize) {
            // resizing next
            resize(state$$1.next, -delta);
        }
        else {
            // resizing prev
            resize(state$$1.prev, delta);
        }
        this.emit(this.layoutChange, {});
    }
    isDraggable(splitBarIndex) {
        const prev = this.pane(splitBarIndex);
        const next = this.pane(splitBarIndex + 1);
        const betweenResizablePanes = prev.resizable && next.resizable;
        const nearCollapsedPane = prev.collapsed || next.collapsed;
        return betweenResizablePanes && !nearCollapsedPane;
    }
    isStatic(splitBarIndex) {
        const prev = this.pane(splitBarIndex);
        const next = this.pane(splitBarIndex + 1);
        const betweenResizablePanes = prev.resizable && next.resizable;
        const nearCollapsiblePane = prev.collapsible || next.collapsible;
        return !betweenResizablePanes && !nearCollapsiblePane;
    }
    pane(index) {
        if (!this.panes) {
            throw new Error("Panes not initialized");
        }
        if (index < 0 || index >= this.panes.length) {
            throw new Error("Index out of range");
        }
        return this.panes[index];
    }
    configure({ panes, orientation, containerSize }) {
        this.panes = panes;
        this.panes.forEach((pane, index) => {
            pane.order = index * 2;
            pane.orientation = orientation;
        });
        if (isDevMode()) {
            const allFixed = panes.length && !panes.some(pane => !pane.fixedSize);
            if (allFixed) {
                throw new Error(`
                    The Splitter should have at least one pane without a set size.
                    See ${SIZING_DOC_LINK} for more information.
                `);
            }
        }
        this.containerSize = containerSize;
    }
    isPercent(size) {
        return /%$/.test(size);
    }
    toPixels(size) {
        let result = parseFloat(size);
        if (this.isPercent(size)) {
            result = (this.containerSize() * result / 100);
        }
        return result;
    }
    emit(emitter, args) {
        if (emitter.observers.length) {
            this.zone.run(() => emitter.emit(args));
        }
    }
}
SplitterService.ɵfac = function SplitterService_Factory(t) { return new (t || SplitterService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
SplitterService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: SplitterService, factory: SplitterService.ɵfac });
/** @nocollapse */
SplitterService.ctorParameters = () => [
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SplitterService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, null); })();

/**
 * Represents the [Kendo UI Splitter component for Angular]({% slug overview_splitter %}).
 *
 * ```ts-preview
 *
 *  @Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-splitter style="height: 280px;">
 *
 *          <kendo-splitter-pane [collapsible]="true" size="30%">
 *            <h3>Inner splitter / left pane</h3>
 *            <p>Resizable and collapsible.</p>
 *          </kendo-splitter-pane>
 *
 *          <kendo-splitter-pane>
 *            <h3>Inner splitter / center pane</h3>
 *            <p>Resizable only.</p>
 *          </kendo-splitter-pane>
 *
 *          <kendo-splitter-pane [collapsible]="true" size="30%">
 *            <h3>Inner splitter / right pane</h3>
 *            <p>Resizable and collapsible.</p>
 *          </kendo-splitter-pane>
 *
 *        </kendo-splitter>
 *      `,
 *    styles: [ `
 *        h3 { font-size: 1.2em; }
 *        h3, p { margin: 10px; padding: 0; }
 *    ` ]
 *  })
 *  class AppComponent {}
 * ```
 */
class SplitterComponent {
    constructor(element, splitterService, localization, enclosingPane) {
        this.element = element;
        this.splitterService = splitterService;
        this.localization = localization;
        /**
         * Specifies the orientation of the panes within the Splitter.
         * Panes in a horizontal Splitter are placed horizontally.
         * Panes in a vertical Splitter are placed vertically.
         */
        this.orientation = 'horizontal';
        this.ariaRole = 'splitter';
        if (enclosingPane) {
            enclosingPane.containsSplitter = true;
        }
        // the handler only runs in NgZone if there are bound handlers
        // this line merges both streams
        this.layoutChange = this.splitterService.layoutChange;
        this.configure = this.configure.bind(this);
    }
    get hostClasses() {
        return true;
    }
    get horizontalHostClasses() {
        return this.orientation === 'horizontal';
    }
    get verticalHostClasses() {
        return this.orientation === 'vertical';
    }
    get dir() {
        return this.direction;
    }
    ngAfterContentInit() {
        this.reconfigure();
    }
    ngOnChanges(changes) {
        if (changes.orientation && !changes.orientation.isFirstChange()) {
            this.reconfigure();
        }
    }
    ngOnDestroy() {
        this.unsubscribeChanges();
    }
    reconfigure() {
        this.unsubscribeChanges();
        this.configure();
        this.paneChangesSubscription = this.panes.changes.subscribe(this.configure);
    }
    unsubscribeChanges() {
        if (this.paneChangesSubscription) {
            this.paneChangesSubscription.unsubscribe();
            this.paneChangesSubscription = null;
        }
    }
    configure() {
        this.splitterService.configure({
            panes: this.panes.toArray(),
            orientation: this.orientation,
            containerSize: () => {
                if (this.orientation === 'vertical') {
                    return this.element.nativeElement.clientHeight;
                }
                else {
                    return this.element.nativeElement.clientWidth;
                }
            }
        });
    }
    get direction() {
        return this.localization.rtl ? 'rtl' : 'ltr';
    }
}
SplitterComponent.ɵfac = function SplitterComponent_Factory(t) { return new (t || SplitterComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(SplitterService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(SplitterPaneComponent, 9)); };
SplitterComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SplitterComponent, selectors: [["kendo-splitter"]], contentQueries: function SplitterComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, SplitterPaneComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.panes = _t);
    } }, hostVars: 12, hostBindings: function SplitterComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.ariaRole)("dir", ctx.dir);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.hostClasses)("k-splitter", ctx.hostClasses)("k-splitter-flex", ctx.hostClasses)("k-splitter-horizontal", ctx.horizontalHostClasses)("k-splitter-vertical", ctx.verticalHostClasses);
    } }, inputs: { orientation: "orientation" }, outputs: { layoutChange: "layoutChange" }, exportAs: ["kendoSplitter"], features: [ɵngcc0.ɵɵProvidersFeature([
            SplitterService,
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.spliter'
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature()], ngContentSelectors: _c8, decls: 2, vars: 1, consts: [[4, "ngFor", "ngForOf"], ["kendoDraggable", "", 3, "index", "orientation", 4, "ngIf"], ["kendoDraggable", "", 3, "index", "orientation"]], template: function SplitterComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c7);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, SplitterComponent_ng_container_1_Template, 2, 1, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.panes);
    } }, directives: function () { return [ɵngcc1.NgForOf, ɵngcc1.NgIf, SplitterBarComponent, ɵngcc3.DraggableDirective]; }, encapsulation: 2 });
/** @nocollapse */
SplitterComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: SplitterService },
    { type: LocalizationService },
    { type: SplitterPaneComponent, decorators: [{ type: Optional }, { type: Host }, { type: Inject, args: [SplitterPaneComponent,] }] }
];
SplitterComponent.propDecorators = {
    orientation: [{ type: Input }],
    layoutChange: [{ type: Output }],
    hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-splitter',] }, { type: HostBinding, args: ['class.k-splitter-flex',] }],
    horizontalHostClasses: [{ type: HostBinding, args: ['class.k-splitter-horizontal',] }],
    verticalHostClasses: [{ type: HostBinding, args: ['class.k-splitter-vertical',] }],
    dir: [{ type: HostBinding, args: ['attr.dir',] }],
    ariaRole: [{ type: HostBinding, args: ['attr.role',] }],
    panes: [{ type: ContentChildren, args: [SplitterPaneComponent,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SplitterComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoSplitter',
                selector: 'kendo-splitter',
                providers: [
                    SplitterService,
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.spliter'
                    }
                ],
                template: `
      <ng-content select="kendo-splitter-pane"></ng-content>
      <ng-container *ngFor="
        let pane of panes;
        let index = index;
        let last = last;
      ">
        <kendo-splitter-bar
          kendoDraggable
          *ngIf="!last"
          [index]="index"
          [orientation]="orientation">
        </kendo-splitter-bar>
      </ng-container>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: SplitterService }, { type: ɵngcc2.LocalizationService }, { type: SplitterPaneComponent, decorators: [{
                type: Optional
            }, {
                type: Host
            }, {
                type: Inject,
                args: [SplitterPaneComponent]
            }] }]; }, { orientation: [{
            type: Input
        }], ariaRole: [{
            type: HostBinding,
            args: ['attr.role']
        }], layoutChange: [{
            type: Output
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-splitter']
        }, {
            type: HostBinding,
            args: ['class.k-splitter-flex']
        }], horizontalHostClasses: [{
            type: HostBinding,
            args: ['class.k-splitter-horizontal']
        }], verticalHostClasses: [{
            type: HostBinding,
            args: ['class.k-splitter-vertical']
        }], dir: [{
            type: HostBinding,
            args: ['attr.dir']
        }], panes: [{
            type: ContentChildren,
            args: [SplitterPaneComponent]
        }] }); })();

/**
 * Represents the content template of the Kendo UI TabStrip.
 * To define the template, nest a `<ng-template>` tag with the `kendoTabContent` inside the component tag.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *         <kendo-tabstrip [ngStyle]="{'width': '400px'}" [animate]="true">
 *           <kendo-tabstrip-tab [title]="'Paris'" [selected]="true">
 *             <ng-template kendoTabContent>
 *               <h3>Content 1</h3>
 *             </ng-template>
 *           </kendo-tabstrip-tab>
 *
 *           <kendo-tabstrip-tab [title]="'Sofia'">
 *             <ng-template kendoTabContent>
 *               <h3>Content 2</h3>
 *             </ng-template>
 *           </kendo-tabstrip-tab>
 *         </kendo-tabstrip>
 *     `
 * })
 *
 * class AppComponent {}
 *
 * ```
 */
class TabContentDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
TabContentDirective.ɵfac = function TabContentDirective_Factory(t) { return new (t || TabContentDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
TabContentDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TabContentDirective, selectors: [["", "kendoTabContent", ""]] });
/** @nocollapse */
TabContentDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TabContentDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTabContent]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();

/**
 * Represents the title template of the Kendo UI TabStrip.
 * To define the template, nest a `<ng-template>` tag with the `kendoTabTitle` directive inside the component tag.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *         <kendo-tabstrip [ngStyle]="{'width': '400px'}" [animate]="true">
 *           <kendo-tabstrip-tab [title]="'Paris'" [selected]="true">
 *             <ng-template kendoTabTitle>
 *               Title
 *             </ng-template>
 *             <ng-template kendoTabContent>
 *               <h3>Content 1</h3>
 *             </ng-template>
 *           </kendo-tabstrip-tab>
 *
 *           <kendo-tabstrip-tab [title]="'Sofia'">
 *             <ng-template kendoTabContent>
 *               <h3>Content 2</h3>
 *             </ng-template>
 *           </kendo-tabstrip-tab>
 *         </kendo-tabstrip>
 *     `
 * })
 *
 * class AppComponent {}
 *
 * ```
 */
class TabTitleDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
TabTitleDirective.ɵfac = function TabTitleDirective_Factory(t) { return new (t || TabTitleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
TabTitleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TabTitleDirective, selectors: [["", "kendoTabTitle", ""]] });
/** @nocollapse */
TabTitleDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TabTitleDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTabTitle]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();

/**
 * Represents the tab component of the TabStrip.
 */
class TabStripTabComponent {
    constructor() {
        this.active = false;
        this._tabContent = new QueryList();
    }
    get tabContent() {
        return this._tabContent.first;
    }
    ngAfterContentInit() {
        this.active = this.selected;
    }
    ngOnChanges(changes) {
        if (changes['selected'] && !changes['selected'].isFirstChange()) { // tslint:disable-line
            this.active = this.selected;
        }
    }
}
TabStripTabComponent.ɵfac = function TabStripTabComponent_Factory(t) { return new (t || TabStripTabComponent)(); };
TabStripTabComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TabStripTabComponent, selectors: [["kendo-tabstrip-tab"]], contentQueries: function TabStripTabComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, TabTitleDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, TabContentDirective, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabTitle = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._tabContent = _t);
    } }, inputs: { title: "title", disabled: "disabled", cssClass: "cssClass", selected: "selected" }, exportAs: ["kendoTabStripTab"], features: [ɵngcc0.ɵɵNgOnChangesFeature()], decls: 0, vars: 0, template: function TabStripTabComponent_Template(rf, ctx) { }, encapsulation: 2 });
TabStripTabComponent.propDecorators = {
    title: [{ type: Input }],
    disabled: [{ type: Input }],
    cssClass: [{ type: Input }],
    selected: [{ type: Input }],
    _tabContent: [{ type: ContentChildren, args: [TabContentDirective,] }],
    tabTitle: [{ type: ContentChild, args: [TabTitleDirective,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TabStripTabComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoTabStripTab',
                selector: 'kendo-tabstrip-tab',
                template: ``
            }]
    }], function () { return []; }, { _tabContent: [{
            type: ContentChildren,
            args: [TabContentDirective]
        }], title: [{
            type: Input
        }], disabled: [{
            type: Input
        }], cssClass: [{
            type: Input
        }], selected: [{
            type: Input
        }], tabTitle: [{
            type: ContentChild,
            args: [TabTitleDirective]
        }] }); })();

/**
 * @hidden
 */
class PreventableEvent {
    /**
     * @hidden
     */
    constructor(args) {
        this.prevented = false;
        Object.assign(this, args);
    }
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses
     * the built-in behavior that follows the event.
     */
    preventDefault() {
        this.prevented = true;
    }
    /**
     * Returns `true` if the event was prevented
     * by any of its subscribers.
     *
     * @returns `true` if the default action was prevented.
     * Otherwise, returns `false`.
     */
    isDefaultPrevented() {
        return this.prevented;
    }
}

/**
 * Arguments for the `select` event of the TabStrip.
 * The `select` event fires when a tab is selected (clicked).
 */
class SelectEvent extends PreventableEvent {
    /**
     * Constructs the event arguments for the `select` event.
     * @param index - The index of the selected tab.
     * @param title - The title of the selected tab.
     */
    constructor(index, title) {
        super();
        this.index = index;
        this.title = title;
    }
}

/**
 * Represents the [Kendo UI TabStrip component for Angular]({% slug overview_tabstrip %}).
 */
class TabStripComponent {
    constructor(localization, renderer, wrapper) {
        this.localization = localization;
        this.renderer = renderer;
        this.wrapper = wrapper;
        /**
         * Enables the tab animation.
         */
        this.animate = true;
        /**
         * Sets the position of the tabs. Defaults to `top`.
         */
        this.tabPosition = 'top';
        /**
         * When set to `true`, the component renders all tabs and they are persisted in the DOM.
         * By default, `keepTabContent` is `false`.
         */
        this.keepTabContent = false;
        /**
         * Fires each time the user selects a tab ([see example]({% slug overview_tabstrip %}#toc-basic-usage)).
         * The event data contains the index of the selected tab and its title.
         */
        this.tabSelect = new EventEmitter();
        this.hostClasses = true;
        /**
         * @hidden
         */
        this._animate = false;
        this.keyBindings = this.computedKeys;
    }
    /**
     * Sets the height of the TabStrip.
     */
    set height(value) {
        this._height = value;
        this.renderer.setStyle(this.wrapper.nativeElement, 'height', value);
    }
    get height() {
        return this._height;
    }
    get tabsAtTop() {
        return this.tabPosition === 'top';
    }
    get tabsAtRight() {
        return this.tabPosition === 'right';
    }
    get tabsAtBottom() {
        return this.tabPosition === 'bottom';
    }
    get tabsAtLeft() {
        return this.tabPosition === 'left';
    }
    get dir() {
        return this.localization.rtl ? 'rtl' : 'ltr';
    }
    /**
     * @hidden
     */
    contentClass(active) {
        const visible = !this.keepTabContent || active;
        return visible ? 'k-content k-state-active' : 'k-content';
    }
    get computedKeys() {
        return {
            [this.invertKeys(Keys.ArrowLeft, Keys.ArrowRight)]: (selectedIndex) => this.prevNavigatableIndex(selectedIndex),
            [this.invertKeys(Keys.ArrowRight, Keys.ArrowLeft)]: (selectedIndex) => this.nextNavigatableIndex(selectedIndex),
            [this.invertKeys(Keys.ArrowDown, Keys.ArrowUp)]: (selectedIndex) => this.nextNavigatableIndex(selectedIndex),
            [this.invertKeys(Keys.ArrowUp, Keys.ArrowDown)]: (selectedIndex) => this.prevNavigatableIndex(selectedIndex),
            [Keys.Home]: () => this.firstNavigatableIndex(),
            [Keys.End]: () => this.lastNavigatableIndex()
        };
    }
    /**
     * @hidden
     */
    get tabsAlignment() {
        return {
            start: 'flex-start',
            end: 'flex-end',
            center: 'center',
            justify: 'space-between'
        }[this.tabAlignment];
    }
    /**
     * @hidden
     */
    invertKeys(original, inverted) {
        return this.localization.rtl ? inverted : original;
    }
    /**
     * @hidden
     */
    onKeyDown(event) {
        if (event.currentTarget !== this.tablist.nativeElement) {
            return;
        }
        const isHorizontal = this.tabPosition === 'top' || this.tabPosition === 'bottom';
        const isArrowUp = event.keyCode === Keys.ArrowUp;
        const isArrowDown = event.keyCode === Keys.ArrowDown;
        const isArrowLeft = event.keyCode === Keys.ArrowLeft;
        const isArrowRight = event.keyCode === Keys.ArrowRight;
        if (isHorizontal && (isArrowUp || isArrowDown)) {
            return;
        }
        if (!isHorizontal && (isArrowLeft || isArrowRight)) {
            return;
        }
        if (event.keyCode === Keys.Space || isArrowUp || isArrowDown || isArrowLeft || isArrowRight || event.keyCode === Keys.Home ||
            event.keyCode === Keys.End || event.keyCode === Keys.PageUp || event.keyCode === Keys.PageDown) {
            event.preventDefault();
        }
        const selectedIndex = this.tabs.toArray().findIndex(tab => tab.active && !tab.disabled);
        if (selectedIndex === -1) {
            this.selectTab(this.firstNavigatableIndex());
        }
        else {
            const getTabIndex = this.keyBindings[event.keyCode];
            if (getTabIndex) {
                const nextIndex = getTabIndex(selectedIndex);
                if (selectedIndex !== nextIndex) {
                    this.selectTab(getTabIndex(selectedIndex));
                }
            }
        }
    }
    /**
     * @hidden
     */
    tabPanelId(id) {
        return 'k-tabstrip-tabpanel-' + id;
    }
    /**
     * @hidden
     */
    tabId(id) {
        return 'k-tabstrip-tab-' + id;
    }
    /**
     * Allows the user to select a tab programmatically.
     * @param {number} index - The index of the tab that will be selected.
     */
    selectTab(index) {
        const tab = this.tabs.toArray()[index];
        if (!tab || Boolean(tab.disabled)) {
            return;
        }
        this.tabHeadingContainers.toArray()[index].nativeElement.focus();
        this.emitEvent(tab, index);
    }
    /**
     * @hidden
     */
    onTabClick(originalEvent, tabIndex) {
        if (isFocusable(originalEvent.target)) {
            return;
        }
        this.selectTab(tabIndex);
    }
    ngOnInit() {
        this.localizationChangeSubscription = this.localization
            .changes.subscribe(() => this.keyBindings = this.computedKeys);
    }
    ngOnDestroy() {
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
    }
    firstNavigatableIndex() {
        const tabs = this.tabs.toArray();
        for (let i = 0; i < tabs.length; i++) {
            if (!tabs[i].disabled) {
                return i;
            }
        }
    }
    lastNavigatableIndex() {
        const tabs = this.tabs.toArray();
        for (let i = tabs.length - 1; i > 0; i--) {
            if (!tabs[i].disabled) {
                return i;
            }
        }
    }
    prevNavigatableIndex(selectedIndex) {
        if (selectedIndex - 1 < 0) {
            return this.lastNavigatableIndex();
        }
        const tabs = this.tabs.toArray();
        for (let i = selectedIndex - 1; i > -1; i--) {
            if (!tabs[i].disabled) {
                return i;
            }
            if (i === 0) {
                return this.lastNavigatableIndex();
            }
        }
        return selectedIndex;
    }
    nextNavigatableIndex(selectedIndex) {
        if (selectedIndex + 1 >= this.tabs.length) {
            return this.firstNavigatableIndex();
        }
        const tabs = this.tabs.toArray();
        for (let i = selectedIndex + 1; i < tabs.length; i++) {
            if (!tabs[i].disabled) {
                return i;
            }
            if (i + 1 === tabs.length) {
                return this.firstNavigatableIndex();
            }
        }
    }
    emitEvent(tab, selectedIndex) {
        const selectArgs = new SelectEvent(selectedIndex, tab.title);
        this.tabSelect.emit(selectArgs);
        if (!selectArgs.isDefaultPrevented() && !tab.active) {
            this._animate = this.animate;
            this.deactivateAll();
            tab.active = true;
        }
    }
    deactivateAll() {
        this.tabs.forEach((tab) => {
            tab.active = false;
        });
    }
}
TabStripComponent.ɵfac = function TabStripComponent_Factory(t) { return new (t || TabStripComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
TabStripComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TabStripComponent, selectors: [["kendo-tabstrip"]], contentQueries: function TabStripComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, TabStripTabComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabs = _t);
    } }, viewQuery: function TabStripComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c9, true);
        ɵngcc0.ɵɵviewQuery(_c10, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tablist = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabHeadingContainers = _t);
    } }, hostVars: 17, hostBindings: function TabStripComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.dir);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.hostClasses)("k-tabstrip", ctx.hostClasses)("k-floatwrap", ctx.hostClasses)("k-header", ctx.hostClasses)("k-tabstrip-top", ctx.tabsAtTop)("k-tabstrip-right", ctx.tabsAtRight)("k-tabstrip-bottom", ctx.tabsAtBottom)("k-tabstrip-left", ctx.tabsAtLeft);
    } }, inputs: { animate: "animate", tabPosition: "tabPosition", keepTabContent: "keepTabContent", height: "height", tabAlignment: "tabAlignment" }, outputs: { tabSelect: "tabSelect" }, exportAs: ["kendoTabStrip"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.tabstrip'
            }
        ])], decls: 6, vars: 2, consts: [[4, "ngIf"], ["heading", ""], ["content", ""], [4, "ngTemplateOutlet"], ["role", "tablist", 1, "k-reset", "k-tabstrip-items", 3, "keydown"], ["tablist", ""], ["role", "tab", 3, "id", "tabIndex", "ngClass", "k-item", "k-state-default", "k-state-active", "k-state-disabled", "click", 4, "ngFor", "ngForOf"], ["role", "tab", 3, "id", "tabIndex", "ngClass", "click"], ["tabHeadingContainer", ""], [1, "k-link"], [3, "ngTemplateOutlet"], ["ngFor", "", 3, "ngForOf"], ["role", "tabpanel", 3, "ngClass", "tabIndex", "id", 4, "ngIf"], ["role", "tabpanel", 3, "ngClass", "tabIndex", "id"]], template: function TabStripComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, TabStripComponent_ng_container_0_Template, 3, 2, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(1, TabStripComponent_ng_container_1_Template, 3, 2, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(2, TabStripComponent_ng_template_2_Template, 3, 3, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, TabStripComponent_ng_template_4_Template, 1, 1, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.tabsAtBottom);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.tabsAtBottom);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet, ɵngcc1.NgForOf, ɵngcc1.NgClass], encapsulation: 2, data: { animation: [
            trigger('state', [
                state('active', style({ opacity: 1 })),
                transition('* => active', [
                    style({ opacity: 0 }),
                    animate('400ms ease-in')
                ])
            ])
        ] } });
/** @nocollapse */
TabStripComponent.ctorParameters = () => [
    { type: LocalizationService },
    { type: Renderer2 },
    { type: ElementRef }
];
TabStripComponent.propDecorators = {
    height: [{ type: Input }],
    animate: [{ type: Input }],
    tabAlignment: [{ type: Input }],
    tabPosition: [{ type: Input }],
    keepTabContent: [{ type: Input }],
    tablist: [{ type: ViewChild, args: ['tablist',] }],
    tabSelect: [{ type: Output }],
    hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-tabstrip',] }, { type: HostBinding, args: ['class.k-floatwrap',] }, { type: HostBinding, args: ['class.k-header',] }],
    tabsAtTop: [{ type: HostBinding, args: ['class.k-tabstrip-top',] }],
    tabsAtRight: [{ type: HostBinding, args: ['class.k-tabstrip-right',] }],
    tabsAtBottom: [{ type: HostBinding, args: ['class.k-tabstrip-bottom',] }],
    tabsAtLeft: [{ type: HostBinding, args: ['class.k-tabstrip-left',] }],
    dir: [{ type: HostBinding, args: ['attr.dir',] }],
    tabs: [{ type: ContentChildren, args: [TabStripTabComponent,] }],
    tabHeadingContainers: [{ type: ViewChildren, args: ['tabHeadingContainer',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TabStripComponent, [{
        type: Component,
        args: [{
                animations: [
                    trigger('state', [
                        state('active', style({ opacity: 1 })),
                        transition('* => active', [
                            style({ opacity: 0 }),
                            animate('400ms ease-in')
                        ])
                    ])
                ],
                providers: [
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.tabstrip'
                    }
                ],
                exportAs: 'kendoTabStrip',
                selector: 'kendo-tabstrip',
                template: `
        <ng-container *ngIf="!tabsAtBottom">
            <ng-container *ngTemplateOutlet="heading">
            </ng-container>
            <ng-container *ngTemplateOutlet="content">
            </ng-container>
        </ng-container>

        <ng-container *ngIf="tabsAtBottom">
            <ng-container *ngTemplateOutlet="content">
            </ng-container>
            <ng-container *ngTemplateOutlet="heading">
            </ng-container>
        </ng-container>

        <ng-template #heading>
            <ul
                class="k-reset k-tabstrip-items"
                [style.justifyContent]="tabsAlignment"
                role="tablist"
                (keydown)="onKeyDown($event)"
                #tablist
            >
                <li *ngFor="let tab of tabs; let i = index;" (click)="onTabClick($event, i)"
                    #tabHeadingContainer
                    role="tab"
                    [id]="tabId(i)"
                    [tabIndex]="tab.active ? 0 : -1"
                    [ngClass]="tab.cssClass"
                    [class.k-item]="true"
                    [class.k-state-default]="true"
                    [class.k-state-active]="tab.active"
                    [class.k-state-disabled]="tab.disabled"
                    [attr.aria-selected]="tab.active"
                    [attr.aria-controls]="tabPanelId(i)"
                    [attr.aria-disabled]="tab.disabled"
                ><span class="k-link">{{ tab.title }}<ng-template [ngTemplateOutlet]="tab.tabTitle?.templateRef"></ng-template></span></li>
            </ul>
        </ng-template>
        <ng-template #content>
            <ng-template ngFor let-tab [ngForOf]="tabs" let-i="index">
                <div
                    [@state]="tab.active && _animate ? 'active' : 'inactive'"
                    *ngIf="tab.active || keepTabContent"
                    [ngClass]="contentClass(tab.active)"
                    [tabIndex]="0"
                    role="tabpanel"
                    [id]="tabPanelId(i)"
                    [attr.aria-hidden]="!tab.active"
                    [attr.aria-expanded]="tab.active"
                    [attr.aria-labelledby]="tabId(i)"
                    [attr.aria-disabled]="tab.disabled"
                >
                    <ng-template [ngTemplateOutlet]="tab.tabContent?.templateRef"></ng-template>
                </div>
            </ng-template>
        </ng-template>
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { animate: [{
            type: Input
        }], tabPosition: [{
            type: Input
        }], keepTabContent: [{
            type: Input
        }], tabSelect: [{
            type: Output
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-tabstrip']
        }, {
            type: HostBinding,
            args: ['class.k-floatwrap']
        }, {
            type: HostBinding,
            args: ['class.k-header']
        }], height: [{
            type: Input
        }], tabsAtTop: [{
            type: HostBinding,
            args: ['class.k-tabstrip-top']
        }], tabsAtRight: [{
            type: HostBinding,
            args: ['class.k-tabstrip-right']
        }], tabsAtBottom: [{
            type: HostBinding,
            args: ['class.k-tabstrip-bottom']
        }], tabsAtLeft: [{
            type: HostBinding,
            args: ['class.k-tabstrip-left']
        }], dir: [{
            type: HostBinding,
            args: ['attr.dir']
        }], tabAlignment: [{
            type: Input
        }], tablist: [{
            type: ViewChild,
            args: ['tablist']
        }], tabs: [{
            type: ContentChildren,
            args: [TabStripTabComponent]
        }], tabHeadingContainers: [{
            type: ViewChildren,
            args: ['tabHeadingContainer']
        }] }); })();

/**
 * Represents a template that defines the content of the Drawer.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoDrawerTemplate` directive inside the `<kendo-drawer>` tag.
 * Using this template directive will override all other templates,
 * for example, `kendoDrawerHeaderTemplate` and `kendoDrawerItemTemplate`.
 */
class DrawerTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
DrawerTemplateDirective.ɵfac = function DrawerTemplateDirective_Factory(t) { return new (t || DrawerTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
DrawerTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DrawerTemplateDirective, selectors: [["", "kendoDrawerTemplate", ""]] });
/** @nocollapse */
DrawerTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DrawerTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDrawerTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Represents a template that defines the item content of the Drawer.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoDrawerItemTemplate` directive inside the `<kendo-drawer>` tag.
 */
class DrawerItemTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
DrawerItemTemplateDirective.ɵfac = function DrawerItemTemplateDirective_Factory(t) { return new (t || DrawerItemTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
DrawerItemTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DrawerItemTemplateDirective, selectors: [["", "kendoDrawerItemTemplate", ""]] });
/** @nocollapse */
DrawerItemTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DrawerItemTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDrawerItemTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Represents a template that defines the header content of the Drawer.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoDrawerHeaderTemplate` directive inside the `<kendo-drawer>` tag.
 */
class DrawerHeaderTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
DrawerHeaderTemplateDirective.ɵfac = function DrawerHeaderTemplateDirective_Factory(t) { return new (t || DrawerHeaderTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
DrawerHeaderTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DrawerHeaderTemplateDirective, selectors: [["", "kendoDrawerHeaderTemplate", ""]] });
/** @nocollapse */
DrawerHeaderTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DrawerHeaderTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDrawerHeaderTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Represents a template that defines the footer content of the Drawer.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoDrawerFooterTemplate` directive inside the `<kendo-drawer>` tag.
 */
class DrawerFooterTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
DrawerFooterTemplateDirective.ɵfac = function DrawerFooterTemplateDirective_Factory(t) { return new (t || DrawerFooterTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
DrawerFooterTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DrawerFooterTemplateDirective, selectors: [["", "kendoDrawerFooterTemplate", ""]] });
/** @nocollapse */
DrawerFooterTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DrawerFooterTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDrawerFooterTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * @hidden
 */
function miniExpandPush(duration, width, miniWidth) {
    return [
        style({ overflow: 'hidden', flexBasis: `${miniWidth}px` }),
        animate(`${duration}ms ease-in`, style({ flexBasis: `${width}px` }))
    ];
}
/**
 * @hidden
 */
function miniCollapsePush(duration, width, miniWidth) {
    return [
        style({ overflow: 'hidden', flexBasis: `${width}px` }),
        animate(`${duration}ms ease-in`, style({ flexBasis: `${miniWidth}px` }))
    ];
}
/**
 * @hidden
 *
 */
function miniExpandOverlay(duration, width, miniWidth) {
    return [
        style({ width: `${miniWidth}px` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', width: `${width}px` }))
    ];
}
/**
 * @hidden
 */
function expandPush(duration, width) {
    return [
        style({ overflow: 'hidden', flexBasis: '0px' }),
        animate(`${duration}ms ease-in`, style({ flexBasis: `${width}px` }))
    ];
}
/**
 * @hidden
 */
function collapsePush(duration, width) {
    return [
        style({ flexBasis: `${width}px` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', flexBasis: `0px` }))
    ];
}
/**
 * @hidden
 */
function expandRTLOverlay(duration) {
    return [
        style({ transform: `translateX(100%)` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', transform: `translateX(0)` }))
    ];
}
/**
 * @hidden
 */
function expandOverlay(duration, position) {
    const translateDir = position !== 'end' ? `-100%` : `100%`;
    return [
        style({ transform: `translateX(${translateDir})` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', transform: `translateX(0)` }))
    ];
}
/**
 * @hidden
 */
function miniCollapseOverlay(duration, width, miniWidth) {
    return [
        style({ width: `${width}px` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', width: `${miniWidth}px` }))
    ];
}
/**
 * @hidden
 */
function collapseOverlay(duration, position) {
    const translateDir = position !== 'end' ? '-100%' : '100%';
    return [
        style({ transform: `translateX(0)` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', transform: `translateX(${translateDir})` }))
    ];
}
/**
 * @hidden
 */
function collapseRTLOverlay(duration) {
    return [
        style({ transform: `translateX(0)` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', transform: `translateX(100%)` }))
    ];
}
/**
 * @hidden
 */
function expandAnimation(settings) {
    const duration = settings.animation.duration;
    const width = settings.width;
    const miniWidth = settings.miniWidth;
    const mode = settings.mode;
    const mini = settings.mini;
    const rtl = settings.rtl;
    const position = settings.position;
    if (mini && mode === 'push') {
        return miniExpandPush(duration, width, miniWidth);
    }
    if (!mini && mode === 'push') {
        return expandPush(duration, width);
    }
    if (!mini && mode === 'overlay') {
        return rtl ? expandRTLOverlay(duration) : expandOverlay(duration, position);
    }
    if (mini && mode === 'overlay') {
        return miniExpandOverlay(duration, width, miniWidth);
    }
}
/**
 * @hidden
 */
function collapseAnimation(settings) {
    const duration = settings.animation.duration;
    const width = settings.width;
    const miniWidth = settings.miniWidth;
    const mode = settings.mode;
    const mini = settings.mini;
    const rtl = settings.rtl;
    const position = settings.position;
    if (mini && mode === 'push') {
        return miniCollapsePush(duration, width, miniWidth);
    }
    if (!mini && mode === 'push') {
        return collapsePush(duration, width);
    }
    if (!mini && mode === 'overlay') {
        return rtl ? collapseRTLOverlay(duration) : collapseOverlay(duration, position);
    }
    if (mini && mode === 'overlay') {
        return miniCollapseOverlay(duration, width, miniWidth);
    }
}

/**
 * Arguments for the `select` event of the Drawer.
 */
class DrawerSelectEvent extends PreventableEvent {
}

/**
 * @hidden
 */
class DrawerService {
    constructor() {
        this.selectedIndices = [];
    }
    emit(event, args) {
        const drawer = this.owner;
        const eventArgs = new DrawerSelectEvent(Object.assign({}, args, { sender: drawer }));
        if (hasObservers(drawer[event])) {
            drawer[event].emit(eventArgs);
        }
        return eventArgs.isDefaultPrevented();
    }
    onSelect(selectedIdx) {
        this.selectedIndices = [selectedIdx];
        const drawer = this.owner;
        if (drawer.autoCollapse && !drawer.minimized) {
            drawer.toggle(false);
        }
    }
    initSelection() {
        const items = this.owner.items;
        this.selectedIndices = [];
        for (let i = 0; i < items.length; i++) {
            if (items[i].selected) {
                this.selectedIndices.push(i);
            }
        }
    }
}
DrawerService.ɵfac = function DrawerService_Factory(t) { return new (t || DrawerService)(); };
DrawerService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DrawerService, factory: DrawerService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DrawerService, [{
        type: Injectable
    }], function () { return []; }, null); })();

const DEFAULT_ANIMATION = { type: 'slide', duration: 200 };
/**
 * Represents the [Kendo UI Drawer component for Angular]({% slug overview_drawer %}).
 *
 * @example
 * ```ts-preview
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-drawer [items]="items">
 *        </kendo-drawer>
 *    `
 * })
 * class AppComponent {
 *    public items: any[] = [{ text: 'Inbox', icon: 'k-i-inbox' }];
 * }
 * ```
 */
class DrawerComponent {
    constructor(element, builder, localizationService, drawerService) {
        this.element = element;
        this.builder = builder;
        this.localizationService = localizationService;
        this.drawerService = drawerService;
        this.hostClasses = true;
        /**
         * Specifies the mode in which the Drawer will be displayed.
         *
         * The possible values are:
         * * (Default) `overlay`
         * * `push`
         */
        this.mode = 'overlay';
        /**
         * Specifies the position of the Drawer
         * ([see example]({% slug positioning_drawer %})).
         *
         * The possible values are:
         * * (Default) `start`
         * * `end`
         */
        this.position = 'start';
        /**
         * Enables the mini (compact) view of the Drawer which is displayed when the component is collapsed
         * ([see example]({% slug expandmodespositions_drawer %}#toc-mini-view)).
         */
        this.mini = false;
        /**
         * Specifies the state of the Drawer.
         */
        this.expanded = false;
        /**
         * Defines the width of the Drawer when it is expanded.
         * Defaults to `240`.
         */
        this.width = 240;
        /**
         * Defines the width of the Drawer when the mini view is enabled
         * and the component is collapsed. Defaults to `60`.
         */
        this.miniWidth = 50;
        /**
         * Specifies if the Drawer will be automatically collapsed when an item
         * or the overlay is clicked. Defaults to `true`.
         */
        this.autoCollapse = true;
        /**
         * Specifies the animation settings of the Drawer.
         * ([see example]({% slug interaction_drawer %}#toc-toggling-between-states)).
         *
         * The possible values are:
         * * Boolean
         *    * (Default) `true`
         *    * `false`
         * * `DrawerAnimation`
         *    * (Default) `type?: 'slide'`
         *    * `duration`&mdash;Accepts a number in milliseconds. Defaults to `300ms`.
         */
        this.animation = DEFAULT_ANIMATION;
        /**
         * Fires when the Drawer is expanded and its animation is complete.
         */
        this.expand = new EventEmitter();
        /**
         * Fires when the Drawer is collapsed and its animation is complete.
         */
        this.collapse = new EventEmitter();
        /**
         * Fires when a Drawer item is selected. This event is preventable.
         */
        this.select = new EventEmitter();
        /**
         * Fires when the `expanded` property of the component was updated.
         * Used to provide a two-way binding for the `expanded` property.
         */
        this.expandedChange = new EventEmitter();
        this.animationEnd = new EventEmitter();
        this.rtl = false;
        this._items = [];
        this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({ rtl }) => {
            this.rtl = rtl;
            this.direction = this.rtl ? 'rtl' : 'ltr';
        });
        this.drawerService.owner = this;
    }
    get startPositionClass() {
        return this.position === 'start';
    }
    get endPositionClass() {
        return this.position === 'end';
    }
    get overlayTransofrmStyles() {
        if (this.mode === 'push') {
            return;
        }
        if (this.expanded || this.minimized) {
            return `translateX(0px)`;
        }
        return `translateX(-100%)`;
    }
    get flexStyles() {
        if (this.mode === 'overlay') {
            return;
        }
        if (!this.expanded && !this.minimized) {
            return 0;
        }
        return this.drawerWidth;
    }
    /**
     * The collection of items that will be rendered in the Drawer.
     */
    set items(items) {
        if (isPresent(items) && items.length > 0) {
            this._items = items;
            this.drawerService.initSelection();
        }
    }
    get items() {
        return this._items;
    }
    ngOnDestroy() {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    get minimized() {
        return this.mini && !this.expanded;
    }
    /**
     * @hidden
     */
    get drawerWidth() {
        return this.minimized ? this.miniWidth : this.width;
    }
    /**
     * Toggles the visibility of the Drawer.
     *
     * @param expanded? - Boolean. Specifies if the Drawer will be expanded or collapsed.
     */
    toggle(expanded) {
        const previous = this.expanded;
        const current = isPresent(expanded) ? expanded : !previous;
        if (current === previous) {
            return;
        }
        if (current === true) {
            this.setExpanded(true);
        }
        else if (current === false && !this.animation) {
            this.setExpanded(false);
        }
        if (this.animation) {
            this.animationEnd.pipe(take(1))
                .subscribe(() => { this.onAnimationEnd(current); });
            this.animate(current);
        }
        else {
            this[current ? 'expand' : 'collapse'].emit();
        }
    }
    onAnimationEnd(currentExpanded) {
        if (currentExpanded) {
            this.expand.emit();
        }
        else {
            this.setExpanded(false);
            this.collapse.emit();
        }
    }
    setExpanded(value) {
        this.expanded = value;
        this.expandedChange.emit(value);
    }
    animate(expanded) {
        const settings = {
            mode: this.mode,
            mini: this.mini,
            miniWidth: this.miniWidth,
            width: this.width,
            rtl: this.rtl,
            position: this.position,
            animation: (typeof this.animation !== 'boolean') ? this.animation : DEFAULT_ANIMATION
        };
        const animation = expanded ? expandAnimation(settings) : collapseAnimation(settings);
        const player = this.createPlayer(animation, this.element.nativeElement);
        player.play();
    }
    createPlayer(animation, animatedElement) {
        const factory = this.builder.build(animation);
        let player = factory.create(animatedElement);
        player.onDone(() => {
            if (player) {
                this.animationEnd.emit();
                player.destroy();
                player = null;
            }
        });
        return player;
    }
}
DrawerComponent.ɵfac = function DrawerComponent_Factory(t) { return new (t || DrawerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.AnimationBuilder), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(DrawerService)); };
DrawerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DrawerComponent, selectors: [["kendo-drawer"]], contentQueries: function DrawerComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, DrawerTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, DrawerFooterTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, DrawerHeaderTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, DrawerItemTemplateDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.drawerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.itemTemplate = _t.first);
    } }, hostVars: 13, hostBindings: function DrawerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵstyleProp("transform", ctx.overlayTransofrmStyles)("flex-basis", ctx.flexStyles, "px");
        ɵngcc0.ɵɵclassProp("k-widget", ctx.hostClasses)("k-drawer", ctx.hostClasses)("k-drawer-start", ctx.startPositionClass)("k-drawer-end", ctx.endPositionClass);
    } }, inputs: { mode: "mode", position: "position", mini: "mini", expanded: "expanded", width: "width", miniWidth: "miniWidth", autoCollapse: "autoCollapse", animation: "animation", items: "items" }, outputs: { expand: "expand", collapse: "collapse", select: "select", expandedChange: "expandedChange" }, exportAs: ["kendoDrawer"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            DrawerService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.drawer'
            }
        ])], decls: 1, vars: 1, consts: [["class", "k-drawer-wrapper", 3, "width", 4, "ngIf"], [1, "k-drawer-wrapper"], [4, "ngIf"], ["kendoDrawerList", "", 1, "k-drawer-items", 3, "items", "mini", "expanded", "itemTemplate"], [3, "ngTemplateOutlet"]], template: function DrawerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, DrawerComponent_div_0_Template, 3, 4, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.expanded || ctx.mini);
    } }, directives: function () { return [ɵngcc1.NgIf, DrawerListComponent, ɵngcc1.NgTemplateOutlet]; }, encapsulation: 2 });
/** @nocollapse */
DrawerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: AnimationBuilder },
    { type: LocalizationService },
    { type: DrawerService }
];
DrawerComponent.propDecorators = {
    hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-drawer',] }],
    startPositionClass: [{ type: HostBinding, args: ['class.k-drawer-start',] }],
    endPositionClass: [{ type: HostBinding, args: ['class.k-drawer-end',] }],
    overlayTransofrmStyles: [{ type: HostBinding, args: ['style.transform',] }],
    flexStyles: [{ type: HostBinding, args: ['style.flexBasis.px',] }],
    mode: [{ type: Input }],
    position: [{ type: Input }],
    mini: [{ type: Input }],
    expanded: [{ type: Input }],
    width: [{ type: Input }],
    miniWidth: [{ type: Input }],
    autoCollapse: [{ type: Input }],
    items: [{ type: Input }],
    direction: [{ type: HostBinding, args: ['attr.dir',] }],
    animation: [{ type: Input }],
    expand: [{ type: Output }],
    collapse: [{ type: Output }],
    select: [{ type: Output }],
    expandedChange: [{ type: Output }],
    drawerTemplate: [{ type: ContentChild, args: [DrawerTemplateDirective,] }],
    footerTemplate: [{ type: ContentChild, args: [DrawerFooterTemplateDirective,] }],
    headerTemplate: [{ type: ContentChild, args: [DrawerHeaderTemplateDirective,] }],
    itemTemplate: [{ type: ContentChild, args: [DrawerItemTemplateDirective,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DrawerComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoDrawer',
                providers: [
                    LocalizationService,
                    DrawerService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.drawer'
                    }
                ],
                selector: 'kendo-drawer',
                template: `
        <div class="k-drawer-wrapper" *ngIf="expanded || mini" [style.width.px]="drawerWidth">
            <ng-container *ngIf="!drawerTemplate">
                <ng-template *ngIf="headerTemplate"
                    [ngTemplateOutlet]="headerTemplate?.templateRef">
                </ng-template>

                <ul kendoDrawerList
                    [items]="items" [mini]="mini" [expanded]="expanded"
                    [itemTemplate]="itemTemplate?.templateRef"
                    class="k-drawer-items">
                </ul>

                <ng-template *ngIf="footerTemplate"
                    [ngTemplateOutlet]="footerTemplate?.templateRef">
                </ng-template>
            </ng-container>

            <ng-template *ngIf="drawerTemplate"
                [ngTemplateOutlet]="drawerTemplate?.templateRef">
            </ng-template>
        </div>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc4.AnimationBuilder }, { type: ɵngcc2.LocalizationService }, { type: DrawerService }]; }, { hostClasses: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-drawer']
        }], mode: [{
            type: Input
        }], position: [{
            type: Input
        }], mini: [{
            type: Input
        }], expanded: [{
            type: Input
        }], width: [{
            type: Input
        }], miniWidth: [{
            type: Input
        }], autoCollapse: [{
            type: Input
        }], animation: [{
            type: Input
        }], expand: [{
            type: Output
        }], collapse: [{
            type: Output
        }], select: [{
            type: Output
        }], expandedChange: [{
            type: Output
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], startPositionClass: [{
            type: HostBinding,
            args: ['class.k-drawer-start']
        }], endPositionClass: [{
            type: HostBinding,
            args: ['class.k-drawer-end']
        }], overlayTransofrmStyles: [{
            type: HostBinding,
            args: ['style.transform']
        }], flexStyles: [{
            type: HostBinding,
            args: ['style.flexBasis.px']
        }], items: [{
            type: Input
        }], drawerTemplate: [{
            type: ContentChild,
            args: [DrawerTemplateDirective]
        }], footerTemplate: [{
            type: ContentChild,
            args: [DrawerFooterTemplateDirective]
        }], headerTemplate: [{
            type: ContentChild,
            args: [DrawerHeaderTemplateDirective]
        }], itemTemplate: [{
            type: ContentChild,
            args: [DrawerItemTemplateDirective]
        }] }); })();

/**
 * Displays images, icons or initials representing people or other entities.
 */
class AvatarComponent {
    constructor() {
        this.hostClass = true;
        /**
         * Sets the shape for the avatar.
         *
         * Possible values are:
         * * (Default) `square`
         * * `circle`
         * * `rounded`
         *
         */
        this.shape = 'square';
        /**
         * Sets the width of the avatar.
         */
        this.width = '32px';
        /**
         * Sets the height of the avatar.
         */
        this.height = '32px';
    }
    /**
     * @hidden
     */
    get circleClass() {
        return this.shape === 'circle';
    }
    /**
     * @hidden
     */
    get roundedClass() {
        return this.shape === 'rounded';
    }
    /**
     * @hidden
     */
    get squareClass() {
        return this.shape === 'square';
    }
    /**
     * @hidden
     */
    get avatarWidth() {
        return this.width;
    }
    /**
     * @hidden
     */
    get avatarHeight() {
        return this.height;
    }
    /**
     * @hidden
     */
    get initialsAvatar() {
        return Boolean(this.initials);
    }
    /**
     * @hidden
     */
    get imageAvatar() {
        return Boolean(this.imageSrc);
    }
    /**
     * @hidden
     */
    get iconAvatar() {
        return Boolean(this.icon || this.iconClass);
    }
    /**
     * @hidden
     */
    get imageUrl() {
        return `url(${this.imageSrc})`;
    }
    ngOnInit() {
        this.verifyProperties();
    }
    /**
     * @hidden
     */
    iconClasses() {
        if (this.icon) {
            return `k-icon k-i-${this.icon}`;
        }
        if (this.iconClass) {
            return `${this.iconClass}`;
        }
    }
    /**
     * @hidden
     */
    get customAvatar() {
        return !(this.imageSrc || this.initials || this.icon || this.iconClass);
    }
    verifyProperties() {
        if (!isDevMode()) {
            return;
        }
        const inputs = [this.icon || this.iconClass, this.imageSrc, this.initials];
        const inputsLength = inputs.filter((value) => value).length;
        if (inputsLength > 1) {
            throw new Error(`
                Invalid property configuration given.
                The kendo-avatar component can accept only one of:
                icon, imageSrc or initials properties.
            `);
        }
    }
}
AvatarComponent.ɵfac = function AvatarComponent_Factory(t) { return new (t || AvatarComponent)(); };
AvatarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AvatarComponent, selectors: [["kendo-avatar"]], hostVars: 18, hostBindings: function AvatarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.avatarWidth)("height", ctx.avatarHeight);
        ɵngcc0.ɵɵclassProp("k-avatar", ctx.hostClass)("k-avatar-circle", ctx.circleClass)("k-avatar-rounded", ctx.roundedClass)("k-avatar-square", ctx.squareClass)("k-avatar-initials", ctx.initialsAvatar)("k-avatar-image", ctx.imageAvatar)("k-avatar-icon", ctx.iconAvatar);
    } }, inputs: { shape: "shape", width: "width", height: "height", iconClass: "iconClass", cssStyle: "cssStyle", initials: "initials", icon: "icon", imageSrc: "imageSrc" }, ngContentSelectors: _c6, decls: 4, vars: 4, consts: [[4, "ngIf"], [3, "ngStyle"], [3, "ngStyle", "ngClass"]], template: function AvatarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, AvatarComponent_0_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵtemplate(1, AvatarComponent_ng_container_1_Template, 2, 7, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(2, AvatarComponent_ng_container_2_Template, 3, 2, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(3, AvatarComponent_ng_container_3_Template, 2, 2, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.customAvatar);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.imageSrc);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.initials);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.icon || ctx.iconClass);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgStyle, ɵngcc1.NgClass], encapsulation: 2 });
AvatarComponent.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class.k-avatar',] }],
    shape: [{ type: Input }],
    circleClass: [{ type: HostBinding, args: ['class.k-avatar-circle',] }],
    roundedClass: [{ type: HostBinding, args: ['class.k-avatar-rounded',] }],
    squareClass: [{ type: HostBinding, args: ['class.k-avatar-square',] }],
    iconClass: [{ type: Input }],
    width: [{ type: Input }],
    avatarWidth: [{ type: HostBinding, args: ['style.width',] }],
    height: [{ type: Input }],
    avatarHeight: [{ type: HostBinding, args: ['style.height',] }],
    initialsAvatar: [{ type: HostBinding, args: ['class.k-avatar-initials',] }],
    imageAvatar: [{ type: HostBinding, args: ['class.k-avatar-image',] }],
    iconAvatar: [{ type: HostBinding, args: ['class.k-avatar-icon',] }],
    cssStyle: [{ type: Input }],
    initials: [{ type: Input }],
    icon: [{ type: Input }],
    imageSrc: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvatarComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-avatar',
                template: `
        <ng-content *ngIf="customAvatar"></ng-content>

        <ng-container *ngIf="imageSrc">
            <div [style.width]="width" [style.height]="height" [ngStyle]="cssStyle" [style.backgroundImage]="imageUrl"></div>
        </ng-container>

        <ng-container *ngIf="initials">
            <span [ngStyle]="cssStyle">{{ initials.substring(0, 2) }}</span>
        </ng-container>

        <ng-container *ngIf="icon || iconClass">
            <span [ngStyle]="cssStyle" [ngClass]="iconClasses()"></span>
        </ng-container>
    `
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-avatar']
        }], shape: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], circleClass: [{
            type: HostBinding,
            args: ['class.k-avatar-circle']
        }], roundedClass: [{
            type: HostBinding,
            args: ['class.k-avatar-rounded']
        }], squareClass: [{
            type: HostBinding,
            args: ['class.k-avatar-square']
        }], avatarWidth: [{
            type: HostBinding,
            args: ['style.width']
        }], avatarHeight: [{
            type: HostBinding,
            args: ['style.height']
        }], initialsAvatar: [{
            type: HostBinding,
            args: ['class.k-avatar-initials']
        }], imageAvatar: [{
            type: HostBinding,
            args: ['class.k-avatar-image']
        }], iconAvatar: [{
            type: HostBinding,
            args: ['class.k-avatar-icon']
        }], iconClass: [{
            type: Input
        }], cssStyle: [{
            type: Input
        }], initials: [{
            type: Input
        }], icon: [{
            type: Input
        }], imageSrc: [{
            type: Input
        }] }); })();

/**
 * Represents the [Kendo UI Card component for Angular]({% slug overview_card %})
 */
class CardComponent {
    constructor(localizationService) {
        this.localizationService = localizationService;
        this.hostClass = true;
        /**
         * Specifies the layout of the Card content.
         *
         * The possible values are:
         * * (Default) `vertical`
         * * `horizontal`
         *
         */
        this.orientation = 'vertical';
        /**
         * Defines the width of the Card.
         * Defaults to `285px`.
         */
        this.width = '285px';
        this.rtl = false;
        this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({ rtl }) => {
            this.rtl = rtl;
            this.direction = this.rtl ? 'rtl' : 'ltr';
        });
    }
    get widthStyle() {
        return this.width;
    }
    get vertical() {
        return this.orientation === 'vertical';
    }
    get horizontal() {
        return this.orientation === 'horizontal';
    }
    ngOnDestroy() {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    }
}
CardComponent.ɵfac = function CardComponent_Factory(t) { return new (t || CardComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
CardComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CardComponent, selectors: [["kendo-card"]], hostVars: 11, hostBindings: function CardComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵstyleProp("width", ctx.widthStyle);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.hostClass)("k-card", ctx.hostClass)("k-card-vertical", ctx.vertical)("k-card-horizontal", ctx.horizontal);
    } }, inputs: { orientation: "orientation", width: "width" }, features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.card.component'
            }
        ])], ngContentSelectors: _c6, decls: 1, vars: 0, template: function CardComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/** @nocollapse */
CardComponent.ctorParameters = () => [
    { type: LocalizationService }
];
CardComponent.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-card',] }],
    widthStyle: [{ type: HostBinding, args: ['style.width',] }],
    vertical: [{ type: HostBinding, args: ['class.k-card-vertical',] }],
    horizontal: [{ type: HostBinding, args: ['class.k-card-horizontal',] }],
    direction: [{ type: HostBinding, args: ['attr.dir',] }],
    orientation: [{ type: Input }],
    width: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CardComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-card',
                providers: [
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.card.component'
                    }
                ],
                template: `
        <ng-content></ng-content>
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-card']
        }], orientation: [{
            type: Input
        }], width: [{
            type: Input
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], widthStyle: [{
            type: HostBinding,
            args: ['style.width']
        }], vertical: [{
            type: HostBinding,
            args: ['class.k-card-vertical']
        }], horizontal: [{
            type: HostBinding,
            args: ['class.k-card-horizontal']
        }] }); })();

/**
 * Specifies the content in the Card header.
 */
class CardHeaderComponent {
    constructor() {
        this.hostClass = true;
    }
}
CardHeaderComponent.ɵfac = function CardHeaderComponent_Factory(t) { return new (t || CardHeaderComponent)(); };
CardHeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CardHeaderComponent, selectors: [["kendo-card-header"]], hostVars: 2, hostBindings: function CardHeaderComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-card-header", ctx.hostClass);
    } }, ngContentSelectors: _c6, decls: 1, vars: 0, template: function CardHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
CardHeaderComponent.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class.k-card-header',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CardHeaderComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-card-header',
                template: `
        <ng-content></ng-content>
    `
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-card-header']
        }] }); })();

/**
 * Specifies the content in the Card body.
 */
class CardBodyComponent {
    constructor() {
        this.hostClass = true;
    }
}
CardBodyComponent.ɵfac = function CardBodyComponent_Factory(t) { return new (t || CardBodyComponent)(); };
CardBodyComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CardBodyComponent, selectors: [["kendo-card-body"]], hostVars: 2, hostBindings: function CardBodyComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-card-body", ctx.hostClass);
    } }, ngContentSelectors: _c6, decls: 1, vars: 0, template: function CardBodyComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
CardBodyComponent.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class.k-card-body',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CardBodyComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-card-body',
                template: `
        <ng-content></ng-content>
    `
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-card-body']
        }] }); })();

/**
 * Specifies the content in the Card footer.
 */
class CardFooterComponent {
    constructor() {
        this.hostClass = true;
    }
}
CardFooterComponent.ɵfac = function CardFooterComponent_Factory(t) { return new (t || CardFooterComponent)(); };
CardFooterComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CardFooterComponent, selectors: [["kendo-card-footer"]], hostVars: 2, hostBindings: function CardFooterComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-card-footer", ctx.hostClass);
    } }, ngContentSelectors: _c6, decls: 1, vars: 0, template: function CardFooterComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
CardFooterComponent.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class.k-card-footer',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CardFooterComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-card-footer',
                template: `
        <ng-content></ng-content>
    `
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-card-footer']
        }] }); })();

/**
 * Specifies the action buttons of the Card.
 * * ([see example]({% slug actions_card %})).
 */
class CardActionsComponent {
    constructor() {
        this.hostClass = true;
        /**
         * Specifies the layout of the Card action buttons.
         *
         * * The possible values are:
         * * (Default) `horizontal`
         * * `vertical`
         *
         */
        this.orientation = 'horizontal';
        /**
         * Specifies the layout of the Card action buttons.
         *
         * The possible values are:
         * * (Default) `start`
         * * `center`
         * * `end`
         * * `stretched`
         *
         */
        this.layout = 'start';
        /**
         * Fires when the user clicks an action button.
         */
        this.action = new EventEmitter();
    }
    get stretchedClass() {
        return this.layout === 'stretched';
    }
    get startClass() {
        return this.layout === 'start';
    }
    get endClass() {
        return this.layout === 'end';
    }
    get centerClass() {
        return this.layout === 'center';
    }
    get verticalClass() {
        return this.orientation === 'vertical';
    }
    get horizontalClass() {
        return this.orientation === 'horizontal';
    }
    /**
     * @hidden
     */
    onClick(action) {
        this.action.emit(action);
    }
    /**
     * @hidden
     */
    actionTemplate() {
        return this.actions instanceof TemplateRef;
    }
}
CardActionsComponent.ɵfac = function CardActionsComponent_Factory(t) { return new (t || CardActionsComponent)(); };
CardActionsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CardActionsComponent, selectors: [["kendo-card-actions"]], hostVars: 14, hostBindings: function CardActionsComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-card-actions", ctx.hostClass)("k-card-actions-stretched", ctx.stretchedClass)("k-card-actions-start", ctx.startClass)("k-card-actions-end", ctx.endClass)("k-card-actions-center", ctx.centerClass)("k-card-actions-vertical", ctx.verticalClass)("k-card-actions-horizontal", ctx.horizontalClass);
    } }, inputs: { orientation: "orientation", layout: "layout", actions: "actions" }, outputs: { action: "action" }, ngContentSelectors: _c6, decls: 3, vars: 3, consts: [[4, "ngIf"], ["type", "button", "class", "k-button", 3, "k-primary", "k-flat", "click", 4, "ngFor", "ngForOf"], ["type", "button", 1, "k-button", 3, "click"], [3, "ngTemplateOutlet"]], template: function CardActionsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, CardActionsComponent_0_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵtemplate(1, CardActionsComponent_ng_container_1_Template, 2, 1, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(2, CardActionsComponent_2_Template, 1, 1, undefined, 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.actions);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.actionTemplate());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.actionTemplate());
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgForOf, ɵngcc1.NgTemplateOutlet], encapsulation: 2 });
CardActionsComponent.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class.k-card-actions',] }],
    stretchedClass: [{ type: HostBinding, args: ['class.k-card-actions-stretched',] }],
    startClass: [{ type: HostBinding, args: ['class.k-card-actions-start',] }],
    endClass: [{ type: HostBinding, args: ['class.k-card-actions-end',] }],
    centerClass: [{ type: HostBinding, args: ['class.k-card-actions-center',] }],
    verticalClass: [{ type: HostBinding, args: ['class.k-card-actions-vertical',] }],
    horizontalClass: [{ type: HostBinding, args: ['class.k-card-actions-horizontal',] }],
    orientation: [{ type: Input }],
    layout: [{ type: Input }],
    actions: [{ type: Input }],
    action: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CardActionsComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-card-actions',
                template: `
        <ng-content *ngIf="!actions"></ng-content>

        <ng-container *ngIf="!actionTemplate()">
            <button type="button"
                class="k-button"
                [class.k-primary]="action.primary"
                [class.k-flat]="action.flat"
                (click)="onClick(action)"
                *ngFor="let action of actions"
            >
                {{ action.text }}
            </button>
        </ng-container>

        <ng-template [ngTemplateOutlet]="actions" *ngIf="actionTemplate()"></ng-template>
    `
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-card-actions']
        }], orientation: [{
            type: Input
        }], layout: [{
            type: Input
        }], action: [{
            type: Output
        }], stretchedClass: [{
            type: HostBinding,
            args: ['class.k-card-actions-stretched']
        }], startClass: [{
            type: HostBinding,
            args: ['class.k-card-actions-start']
        }], endClass: [{
            type: HostBinding,
            args: ['class.k-card-actions-end']
        }], centerClass: [{
            type: HostBinding,
            args: ['class.k-card-actions-center']
        }], verticalClass: [{
            type: HostBinding,
            args: ['class.k-card-actions-vertical']
        }], horizontalClass: [{
            type: HostBinding,
            args: ['class.k-card-actions-horizontal']
        }], actions: [{
            type: Input
        }] }); })();

/**
 * Specifies a separator in the content of the Card.
 */
class CardSeparatorDirective {
    constructor() {
        this.hostClass = true;
        /**
         * Specifies the orientation of the Card separator.
         *
         * The possible values are:
         * (Default) `horizontal`
         * `vertical`
         */
        this.orientation = 'horizontal';
    }
    get verticalClass() {
        return this.orientation === 'vertical';
    }
    get horizontalClass() {
        return this.orientation === 'horizontal';
    }
}
CardSeparatorDirective.ɵfac = function CardSeparatorDirective_Factory(t) { return new (t || CardSeparatorDirective)(); };
CardSeparatorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CardSeparatorDirective, selectors: [["", "kendoCardSeparator", ""]], hostVars: 8, hostBindings: function CardSeparatorDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("color", ctx.color);
        ɵngcc0.ɵɵclassProp("k-card-separator", ctx.hostClass)("k-separator-vertical", ctx.verticalClass)("k-separator-horizontal", ctx.horizontalClass);
    } }, inputs: { orientation: "orientation", color: "color" } });
CardSeparatorDirective.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class.k-card-separator',] }],
    verticalClass: [{ type: HostBinding, args: ['class.k-separator-vertical',] }],
    horizontalClass: [{ type: HostBinding, args: ['class.k-separator-horizontal',] }],
    color: [{ type: HostBinding, args: ['style.color',] }, { type: Input }],
    orientation: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CardSeparatorDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoCardSeparator]'
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-card-separator']
        }], orientation: [{
            type: Input
        }], verticalClass: [{
            type: HostBinding,
            args: ['class.k-separator-vertical']
        }], horizontalClass: [{
            type: HostBinding,
            args: ['class.k-separator-horizontal']
        }], color: [{
            type: HostBinding,
            args: ['style.color']
        }, {
            type: Input
        }] }); })();

/**
 * Specifies the text and styles for the title of the Card.
 */
class CardTitleDirective {
    constructor() {
        this.hostClass = true;
    }
}
CardTitleDirective.ɵfac = function CardTitleDirective_Factory(t) { return new (t || CardTitleDirective)(); };
CardTitleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CardTitleDirective, selectors: [["", "kendoCardTitle", ""]], hostVars: 2, hostBindings: function CardTitleDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-card-title", ctx.hostClass);
    } } });
CardTitleDirective.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class.k-card-title',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CardTitleDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoCardTitle]'
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-card-title']
        }] }); })();

/**
 * Specifies the text and styles for the subtitle of the Card.
 */
class CardSubtitleDirective {
    constructor() {
        this.hostClass = true;
    }
}
CardSubtitleDirective.ɵfac = function CardSubtitleDirective_Factory(t) { return new (t || CardSubtitleDirective)(); };
CardSubtitleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CardSubtitleDirective, selectors: [["", "kendoCardSubtitle", ""]], hostVars: 2, hostBindings: function CardSubtitleDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-card-subtitle", ctx.hostClass);
    } } });
CardSubtitleDirective.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class.k-card-subtitle',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CardSubtitleDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoCardSubtitle]'
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-card-subtitle']
        }] }); })();

/**
 * Specifies any media that will be displayed and aligned in the Card.
 */
class CardMediaDirective {
    constructor() {
        this.hostClass = true;
    }
}
CardMediaDirective.ɵfac = function CardMediaDirective_Factory(t) { return new (t || CardMediaDirective)(); };
CardMediaDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CardMediaDirective, selectors: [["", "kendoCardMedia", ""]], hostVars: 2, hostBindings: function CardMediaDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-card-media", ctx.hostClass);
    } } });
CardMediaDirective.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class.k-card-media',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CardMediaDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoCardMedia]'
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-card-media']
        }] }); })();

/**
 * The settings of the Card action buttons.
 */
class CardAction {
}

const exportedModules = [
    PanelBarComponent,
    PanelBarItemComponent,
    PanelBarContentDirective,
    PanelBarItemTemplateDirective,
    PanelBarItemTitleDirective
];
const declarations = [
    ...exportedModules
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the PanelBar component.
 *
 * The module registers:
 * - `PanelBarComponent`&mdash;The `PanelBar` component class.
 * - `PanelBarItemComponent`&mdash;The `PanelBarItem` component class.
 * - `PanelBarContentComponent`&mdash;The `PanelBarContent` component class.
 * - `PanelBarItemTemplateDirective&mdash;The `PanelBarItemTemplate` directive.
 * - `PanelBarItemTitleDirective&mdash;The `PanelBarItemTitle` directive.
 */
class PanelBarModule {
}
PanelBarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: PanelBarModule });
PanelBarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function PanelBarModule_Factory(t) { return new (t || PanelBarModule)(); }, imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PanelBarModule, { declarations: function () { return [PanelBarComponent,
        PanelBarItemComponent,
        PanelBarContentDirective,
        PanelBarItemTemplateDirective,
        PanelBarItemTitleDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [PanelBarComponent,
        PanelBarItemComponent,
        PanelBarContentDirective,
        PanelBarItemTemplateDirective,
        PanelBarItemTitleDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PanelBarModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations],
                exports: [exportedModules],
                imports: [CommonModule]
            }]
    }], null, null); })();

const stopPropagation = ({ originalEvent: event }) => {
    event.stopPropagation();
    event.preventDefault();
};
const preventOnDblClick = release => mouseDown => of(mouseDown).pipe(delay(150), takeUntil(release));
const classFromObject = classes => Object.keys(classes).filter(c => classes[c]).join(' ');
const createMoveStream = (draggable) => mouseDown => draggable.kendoDrag
    .pipe(takeUntil(draggable.kendoRelease), map(({ pageX, pageY }) => ({
    originalX: mouseDown.pageX,
    originalY: mouseDown.pageY,
    pageX,
    pageY
})));
/**
 * @hidden
 */
class SplitterBarComponent {
    constructor(draggable, splitter, localization) {
        this.draggable = draggable;
        this.splitter = splitter;
        this.localization = localization;
        this.orientation = 'horizontal';
        this.index = 0;
        this.ariaRole = 'separator';
        this.focused = false;
        this.subscriptions = new Subscription();
    }
    get direction() {
        return this.localization.rtl ? 'rtl' : 'ltr';
    }
    get tabIndex() {
        return this.splitter.isStatic(this.index) ? -1 : 0;
    }
    get hostClasses() {
        const isHorizontal = this.orientation === 'horizontal';
        const isDraggable = this.splitter.isDraggable(this.index);
        const isStatic = this.splitter.isStatic(this.index);
        return classFromObject({
            'k-state-focused': this.focused,
            'k-splitbar': true,
            'k-splitbar-horizontal': isHorizontal,
            'k-splitbar-vertical': !isHorizontal,
            'k-splitbar-draggable-horizontal': isHorizontal && isDraggable,
            'k-splitbar-draggable-vertical': !isHorizontal && isDraggable,
            'k-splitbar-static-horizontal': isHorizontal && isStatic,
            'k-splitbar-static-vertical': !isHorizontal && isStatic
        });
    }
    get touchAction() {
        if (this.splitter.isDraggable(this.index)) {
            return 'none';
        }
    }
    get order() {
        return 2 * this.index + 1;
    }
    collapseAny() {
        this.tryToggleNearest();
    }
    onFocusIn() {
        this.focused = true;
    }
    onFocusOut() {
        this.focused = false;
    }
    onKeyDown(event) {
        const keyCode = event && event.keyCode;
        const isHorizontal = this.orientation === 'horizontal';
        const resize = delta => {
            event.preventDefault();
            const state$$1 = this.splitter.dragState(this.index);
            this.splitter.setSize(state$$1, delta);
        };
        if (keyCode === Keys.Enter) {
            event.preventDefault();
            this.tryToggleNearest();
        }
        else if (isHorizontal && keyCode === Keys.ArrowLeft) {
            resize(-10);
        }
        else if (isHorizontal && keyCode === Keys.ArrowRight) {
            resize(10);
        }
        else if (!isHorizontal && keyCode === Keys.ArrowUp) {
            resize(-10);
        }
        else if (!isHorizontal && keyCode === Keys.ArrowDown) {
            resize(10);
        }
    }
    ngOnInit() {
        let state$$1;
        const listener = this.draggable.kendoPress.pipe(tap(stopPropagation), filter(() => this.splitter.isDraggable(this.index)), tap(() => state$$1 = this.splitter.dragState(this.index)), tap(() => this.splitter.toggleContentOverlay(this.index, true)), switchMap(preventOnDblClick(this.draggable.kendoRelease)), switchMap(createMoveStream(this.draggable))).subscribe(({ pageX, pageY, originalX, originalY }) => {
            let delta;
            if (this.orientation === 'vertical') {
                delta = pageY - originalY;
            }
            else if (this.direction === 'rtl') {
                delta = originalX - pageX;
            }
            else {
                delta = pageX - originalX;
            }
            this.splitter.setSize(state$$1, delta);
        });
        this.subscriptions.add(listener);
        this.subscriptions.add(this.draggable.kendoRelease.subscribe(() => this.splitter.toggleContentOverlay(this.index, false)));
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    togglePrevious() {
        this.splitter.tryToggle(this.index);
    }
    toggleNext() {
        this.splitter.tryToggle(this.index + 1);
    }
    previousArrowClass() {
        const pane = this.splitter.pane(this.index);
        const nextPane = this.splitter.pane(this.index + 1);
        const isCollapsible = pane.collapsible;
        const isCollapsed = pane.collapsed;
        const isHorizontal = this.orientation === 'horizontal';
        return classFromObject({
            'k-icon': true,
            'k-hidden': !isCollapsible || nextPane.isHidden,
            'k-collapse-prev': isCollapsible,
            'k-i-arrow-60-left': isCollapsible && isHorizontal && !isCollapsed,
            'k-i-arrow-60-right': isCollapsible && isHorizontal && isCollapsed,
            'k-i-arrow-60-up': isCollapsible && !isHorizontal && !isCollapsed,
            'k-i-arrow-60-down': isCollapsible && !isHorizontal && isCollapsed
        });
    }
    nextArrowClass() {
        const pane = this.splitter.pane(this.index + 1);
        const prevPane = this.splitter.pane(this.index);
        const isCollapsible = pane.collapsible;
        const isCollapsed = pane.collapsed;
        const isHorizontal = this.orientation === 'horizontal';
        return classFromObject({
            'k-icon': true,
            'k-hidden': !isCollapsible || prevPane.isHidden,
            'k-collapse-next': isCollapsible,
            'k-i-arrow-60-right': isCollapsible && isHorizontal && !isCollapsed,
            'k-i-arrow-60-left': isCollapsible && isHorizontal && isCollapsed,
            'k-i-arrow-60-down': isCollapsible && !isHorizontal && !isCollapsed,
            'k-i-arrow-60-up': isCollapsible && !isHorizontal && isCollapsed
        });
    }
    tryToggleNearest() {
        const prev = this.index;
        const next = this.index + 1;
        if (!this.splitter.tryToggle(prev)) {
            this.splitter.tryToggle(next);
        }
    }
}
SplitterBarComponent.ɵfac = function SplitterBarComponent_Factory(t) { return new (t || SplitterBarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.DraggableDirective, 1), ɵngcc0.ɵɵdirectiveInject(SplitterService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
SplitterBarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SplitterBarComponent, selectors: [["kendo-splitter-bar"]], hostVars: 13, hostBindings: function SplitterBarComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("dblclick", function SplitterBarComponent_dblclick_HostBindingHandler($event) { return ctx.collapseAny(); })("focusin", function SplitterBarComponent_focusin_HostBindingHandler($event) { return ctx.onFocusIn(); })("focusout", function SplitterBarComponent_focusout_HostBindingHandler($event) { return ctx.onFocusOut(); })("keydown", function SplitterBarComponent_keydown_HostBindingHandler($event) { return ctx.onKeyDown($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-orientation", ctx.orientation)("role", ctx.ariaRole)("tabindex", ctx.tabIndex);
        ɵngcc0.ɵɵclassMap(ctx.hostClasses);
        ɵngcc0.ɵɵstyleProp("touch-action", ctx.touchAction)("-ms-flex-order", ctx.order)("order", ctx.order);
        ɵngcc0.ɵɵclassProp("k-state-focused", ctx.focused);
    } }, inputs: { orientation: "orientation", index: "index" }, decls: 3, vars: 4, consts: [[3, "click"], [1, "k-resize-handle"]], template: function SplitterBarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("click", function SplitterBarComponent_Template_div_click_0_listener($event) { return ctx.togglePrevious(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 0);
        ɵngcc0.ɵɵlistener("click", function SplitterBarComponent_Template_div_click_2_listener($event) { return ctx.toggleNext(); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.previousArrowClass());
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵclassMap(ctx.nextArrowClass());
    } }, encapsulation: 2 });
/** @nocollapse */
SplitterBarComponent.ctorParameters = () => [
    { type: DraggableDirective, decorators: [{ type: Host }] },
    { type: SplitterService },
    { type: LocalizationService }
];
SplitterBarComponent.propDecorators = {
    orientation: [{ type: Input }, { type: HostBinding, args: ['attr.aria-orientation',] }],
    index: [{ type: Input }],
    ariaRole: [{ type: HostBinding, args: ['attr.role',] }],
    focused: [{ type: HostBinding, args: ['class.k-state-focused',] }],
    tabIndex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    hostClasses: [{ type: HostBinding, args: ['class',] }],
    touchAction: [{ type: HostBinding, args: ['style.touch-action',] }],
    order: [{ type: HostBinding, args: ['style.-ms-flex-order',] }, { type: HostBinding, args: ['style.order',] }],
    collapseAny: [{ type: HostListener, args: ['dblclick',] }],
    onFocusIn: [{ type: HostListener, args: ['focusin',] }],
    onFocusOut: [{ type: HostListener, args: ['focusout',] }],
    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SplitterBarComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-splitter-bar',
                template: `
      <div [class]="previousArrowClass()" (click)="togglePrevious()"></div>
      <div class="k-resize-handle"></div>
      <div [class]="nextArrowClass()" (click)="toggleNext()"></div>
    `
            }]
    }], function () { return [{ type: ɵngcc3.DraggableDirective, decorators: [{
                type: Host
            }] }, { type: SplitterService }, { type: ɵngcc2.LocalizationService }]; }, { orientation: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.aria-orientation']
        }], index: [{
            type: Input
        }], ariaRole: [{
            type: HostBinding,
            args: ['attr.role']
        }], focused: [{
            type: HostBinding,
            args: ['class.k-state-focused']
        }], tabIndex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], hostClasses: [{
            type: HostBinding,
            args: ['class']
        }], touchAction: [{
            type: HostBinding,
            args: ['style.touch-action']
        }], order: [{
            type: HostBinding,
            args: ['style.-ms-flex-order']
        }, {
            type: HostBinding,
            args: ['style.order']
        }], collapseAny: [{
            type: HostListener,
            args: ['dblclick']
        }], onFocusIn: [{
            type: HostListener,
            args: ['focusin']
        }], onFocusOut: [{
            type: HostListener,
            args: ['focusout']
        }], onKeyDown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }] }); })();

const exportedModules$1 = [
    SplitterComponent,
    SplitterPaneComponent
];
const declarations$1 = [
    SplitterBarComponent,
    ...exportedModules$1
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Splitter component.
 *
 * The module registers:
 * - `SplitterComponent`&mdash;The `Splitter` component class.
 * - `SplitterPaneComponent`&mdash;The `SplitterPane` component class.
 */
class SplitterModule {
}
SplitterModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: SplitterModule });
SplitterModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function SplitterModule_Factory(t) { return new (t || SplitterModule)(); }, imports: [[
            CommonModule,
            DraggableModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SplitterModule, { declarations: function () { return [SplitterBarComponent,
        SplitterComponent,
        SplitterPaneComponent]; }, imports: function () { return [CommonModule,
        DraggableModule]; }, exports: function () { return [SplitterComponent,
        SplitterPaneComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SplitterModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations$1],
                exports: [exportedModules$1],
                imports: [
                    CommonModule,
                    DraggableModule
                ]
            }]
    }], null, null); })();

const exportedModules$2 = [
    TabStripComponent,
    TabStripTabComponent,
    TabContentDirective,
    TabTitleDirective
];
const declarations$2 = [
    ...exportedModules$2
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the TabStrip component.
 *
 * The module registers:
 * - `TabStripComponent`&mdash;The `TabStrip` component class.
 * - `TabStripTabComponent`&mdash;The `TabStripTab` component class.
 * - `TabContentDirective`&mdash;The tab content directive used on the `<ng-template>` tag.
 * - `TabTitleDirective`&mdash;The tab title directive used on the `<ng-template>` tag.
 */
class TabStripModule {
}
TabStripModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TabStripModule });
TabStripModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function TabStripModule_Factory(t) { return new (t || TabStripModule)(); }, imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TabStripModule, { declarations: function () { return [TabStripComponent,
        TabStripTabComponent,
        TabContentDirective,
        TabTitleDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [TabStripComponent,
        TabStripTabComponent,
        TabContentDirective,
        TabTitleDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TabStripModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations$2],
                exports: [exportedModules$2],
                imports: [CommonModule]
            }]
    }], null, null); })();

/**
 * @hidden
 */
class DrawerContainerComponent {
    constructor(localizationService) {
        this.localizationService = localizationService;
        this.rtl = false;
        this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({ rtl }) => {
            this.rtl = rtl;
            this.direction = this.rtl ? 'rtl' : 'ltr';
        });
    }
    get hostClass() {
        return true;
    }
    get overlayClass() {
        return this.drawer.mode === 'overlay';
    }
    get miniClass() {
        return this.drawer.mini;
    }
    get pushClass() {
        return this.drawer.mode === 'push';
    }
    get isExpandedClass() {
        return this.drawer.expanded;
    }
    ngOnDestroy() {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    }
    get overlay() {
        return isPresent(this.drawer) &&
            this.drawer.expanded &&
            this.drawer.mode === 'overlay';
    }
    /**
     * @hidden
     */
    closeDrawer() {
        if (this.overlay && this.drawer.autoCollapse) {
            this.drawer.toggle(false);
        }
    }
}
DrawerContainerComponent.ɵfac = function DrawerContainerComponent_Factory(t) { return new (t || DrawerContainerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
DrawerContainerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DrawerContainerComponent, selectors: [["kendo-drawer-container"]], contentQueries: function DrawerContainerComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, DrawerComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.drawer = _t.first);
    } }, hostVars: 11, hostBindings: function DrawerContainerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-drawer-container", ctx.hostClass)("k-drawer-overlay", ctx.overlayClass)("k-drawer-mini", ctx.miniClass)("k-drawer-push", ctx.pushClass)("k-drawer-expanded", ctx.isExpandedClass);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.drawer.container'
            }
        ])], ngContentSelectors: _c6, decls: 2, vars: 1, consts: [["class", "k-overlay", 3, "click", 4, "ngIf"], [1, "k-overlay", 3, "click"]], template: function DrawerContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, DrawerContainerComponent_div_0_Template, 1, 0, "div", 0);
        ɵngcc0.ɵɵprojection(1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.overlay);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2 });
/** @nocollapse */
DrawerContainerComponent.ctorParameters = () => [
    { type: LocalizationService }
];
DrawerContainerComponent.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class.k-drawer-container',] }],
    overlayClass: [{ type: HostBinding, args: ['class.k-drawer-overlay',] }],
    miniClass: [{ type: HostBinding, args: ['class.k-drawer-mini',] }],
    pushClass: [{ type: HostBinding, args: ['class.k-drawer-push',] }],
    isExpandedClass: [{ type: HostBinding, args: ['class.k-drawer-expanded',] }],
    direction: [{ type: HostBinding, args: ['attr.dir',] }],
    drawer: [{ type: ContentChild, args: [DrawerComponent,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DrawerContainerComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-drawer-container',
                providers: [
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.drawer.container'
                    }
                ],
                template: `
        <div class="k-overlay" *ngIf="overlay" (click)="closeDrawer()"></div>
        <ng-content></ng-content>
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, { direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], hostClass: [{
            type: HostBinding,
            args: ['class.k-drawer-container']
        }], overlayClass: [{
            type: HostBinding,
            args: ['class.k-drawer-overlay']
        }], miniClass: [{
            type: HostBinding,
            args: ['class.k-drawer-mini']
        }], pushClass: [{
            type: HostBinding,
            args: ['class.k-drawer-push']
        }], isExpandedClass: [{
            type: HostBinding,
            args: ['class.k-drawer-expanded']
        }], drawer: [{
            type: ContentChild,
            args: [DrawerComponent]
        }] }); })();

/**
 * @hidden
 */
class DrawerContentComponent {
    constructor() {
        this.hostClasses = true;
    }
}
DrawerContentComponent.ɵfac = function DrawerContentComponent_Factory(t) { return new (t || DrawerContentComponent)(); };
DrawerContentComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DrawerContentComponent, selectors: [["kendo-drawer-content"]], hostVars: 2, hostBindings: function DrawerContentComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-drawer-content", ctx.hostClasses);
    } }, ngContentSelectors: _c6, decls: 1, vars: 0, template: function DrawerContentComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/** @nocollapse */
DrawerContentComponent.ctorParameters = () => [];
DrawerContentComponent.propDecorators = {
    hostClasses: [{ type: HostBinding, args: ['class.k-drawer-content',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DrawerContentComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-drawer-content',
                template: `
        <ng-content></ng-content>
    `,
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return []; }, { hostClasses: [{
            type: HostBinding,
            args: ['class.k-drawer-content']
        }] }); })();

/**
 * @hidden
 */
class DrawerItemComponent {
    constructor(drawer) {
        this.drawer = drawer;
    }
    get disabledClass() {
        return this.item.disabled;
    }
    get selectedClass() {
        return this.drawer.selectedIndices.indexOf(this.index) >= 0;
    }
    /**
     * @hidden
     */
    iconClasses(icon) {
        return `k-icon ${icon}`;
    }
}
DrawerItemComponent.ɵfac = function DrawerItemComponent_Factory(t) { return new (t || DrawerItemComponent)(ɵngcc0.ɵɵdirectiveInject(DrawerService)); };
DrawerItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DrawerItemComponent, selectors: [["", "kendoDrawerItem", ""]], hostVars: 4, hostBindings: function DrawerItemComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-state-disabled", ctx.disabledClass)("k-state-selected", ctx.selectedClass);
    } }, inputs: { item: "item", index: "index", itemTemplate: "itemTemplate", mini: "mini", expanded: "expanded", disabled: "disabled", cssClass: "cssClass", cssStyle: "cssStyle" }, attrs: _c11, decls: 3, vars: 2, consts: [[4, "ngIf", "ngIfElse"], ["defaultTemplate", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [4, "ngIf"], [3, "ngClass"], [1, "k-item-text"]], template: function DrawerItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, DrawerItemComponent_0_Template, 1, 4, undefined, 0);
        ɵngcc0.ɵɵtemplate(1, DrawerItemComponent_ng_template_1_Template, 2, 2, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r162 = ɵngcc0.ɵɵreference(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.itemTemplate)("ngIfElse", _r162);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet, ɵngcc1.NgClass], encapsulation: 2 });
/** @nocollapse */
DrawerItemComponent.ctorParameters = () => [
    { type: DrawerService }
];
DrawerItemComponent.propDecorators = {
    item: [{ type: Input }],
    index: [{ type: Input }],
    itemTemplate: [{ type: Input }],
    mini: [{ type: Input }],
    expanded: [{ type: Input }],
    disabled: [{ type: Input }],
    cssClass: [{ type: Input }],
    cssStyle: [{ type: Input }],
    disabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }],
    selectedClass: [{ type: HostBinding, args: ['class.k-state-selected',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DrawerItemComponent, [{
        type: Component,
        args: [{
                selector: '[kendoDrawerItem]',
                template: `
        <ng-template *ngIf="itemTemplate; else defaultTemplate"
            [ngTemplateOutlet]="itemTemplate"
            [ngTemplateOutletContext]="{ $implicit: item }">
        </ng-template>

        <ng-template #defaultTemplate>
            <ng-container *ngIf="expanded">
                <span [ngClass]="iconClasses(item.icon)"></span>
                <span class="k-item-text">{{ item.text }}</span>
            </ng-container>
            <ng-container *ngIf="mini && !expanded">
                <span [ngClass]="iconClasses(item.icon)"></span>
            </ng-container>
        </ng-template>
    `
            }]
    }], function () { return [{ type: DrawerService }]; }, { disabledClass: [{
            type: HostBinding,
            args: ['class.k-state-disabled']
        }], selectedClass: [{
            type: HostBinding,
            args: ['class.k-state-selected']
        }], item: [{
            type: Input
        }], index: [{
            type: Input
        }], itemTemplate: [{
            type: Input
        }], mini: [{
            type: Input
        }], expanded: [{
            type: Input
        }], disabled: [{
            type: Input
        }], cssClass: [{
            type: Input
        }], cssStyle: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
class DrawerListComponent {
    constructor(drawerService, renderer, ngZone, changeDetector, element) {
        this.drawerService = drawerService;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.element = element;
    }
    ngOnInit() {
        this.initialSelection();
        this.initDomEvents();
    }
    ngOnDestroy() {
        if (this.clickSubscription) {
            this.clickSubscription();
        }
    }
    initialSelection() {
        /* Differentiates a user selected item */
        if (this.drawerService.selectedIndices.length === 0) {
            this.drawerService.initSelection();
        }
    }
    initDomEvents() {
        if (!this.element) {
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            const nativeElement = this.element.nativeElement;
            this.clickSubscription = this.renderer.listen(nativeElement, 'click', this.clickHandler.bind(this));
        });
    }
    clickHandler(e) {
        // if (isFocusable(e.target) && !hasClass(e.target, 'k-drawer-item')) {
        //     return;
        // }
        const itemIdx = this.getDrawerItemIndex(e.target);
        const item = this.items[itemIdx];
        if (!item) {
            return;
        }
        if (item.disabled) {
            e.preventDefault();
            return;
        }
        const args = {
            index: itemIdx,
            item: item,
            originalEvent: e
        };
        this.ngZone.run(() => {
            if (!this.drawerService.emit('select', args)) {
                this.drawerService.onSelect(itemIdx);
                this.changeDetector.detectChanges();
            }
        });
    }
    getDrawerItemIndex(target) {
        const item = closestItem(target, this.element.nativeElement);
        if (item) {
            return itemIndex(item);
        }
    }
}
DrawerListComponent.ɵfac = function DrawerListComponent_Factory(t) { return new (t || DrawerListComponent)(ɵngcc0.ɵɵdirectiveInject(DrawerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
DrawerListComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DrawerListComponent, selectors: [["", "kendoDrawerList", ""]], inputs: { items: "items", itemTemplate: "itemTemplate", mini: "mini", expanded: "expanded" }, attrs: _c12, decls: 1, vars: 1, consts: [[4, "ngFor", "ngForOf"], ["kendoDrawerItem", "", "class", "k-drawer-item", 3, "item", "index", "mini", "expanded", "itemTemplate", "ngClass", "ngStyle", 4, "ngIf"], ["class", "k-drawer-item k-drawer-separator", 3, "ngClass", "ngStyle", 4, "ngIf"], ["kendoDrawerItem", "", 1, "k-drawer-item", 3, "item", "index", "mini", "expanded", "itemTemplate", "ngClass", "ngStyle"], [1, "k-drawer-item", "k-drawer-separator", 3, "ngClass", "ngStyle"]], template: function DrawerListComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, DrawerListComponent_ng_container_0_Template, 3, 2, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.items);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgIf, DrawerItemComponent, ɵngcc1.NgClass, ɵngcc1.NgStyle], encapsulation: 2 });
/** @nocollapse */
DrawerListComponent.ctorParameters = () => [
    { type: DrawerService },
    { type: Renderer2 },
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
DrawerListComponent.propDecorators = {
    items: [{ type: Input }],
    itemTemplate: [{ type: Input }],
    mini: [{ type: Input }],
    expanded: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DrawerListComponent, [{
        type: Component,
        args: [{
                selector: '[kendoDrawerList]',
                template: `
        <ng-container *ngFor="let item of items; let idx = index">
            <li *ngIf="!item.separator" kendoDrawerItem
                class="k-drawer-item"
                [item]="item"
                [index]="idx"
                [mini]="mini"
                [expanded]="expanded"
                [itemTemplate]="itemTemplate"
                [attr.${ITEM_INDEX}]="idx"
                [ngClass]="item.cssClass"
                [ngStyle]="item.cssStyle">
            </li>

            <li *ngIf="item.separator"
                class="k-drawer-item k-drawer-separator"
                [ngClass]="item.cssClass"
                [ngStyle]="item.cssStyle">
                &nbsp;
            </li>
        </ng-container>
    `
            }]
    }], function () { return [{ type: DrawerService }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }]; }, { items: [{
            type: Input
        }], itemTemplate: [{
            type: Input
        }], mini: [{
            type: Input
        }], expanded: [{
            type: Input
        }] }); })();

const templateDirectives = [
    DrawerTemplateDirective,
    DrawerHeaderTemplateDirective,
    DrawerFooterTemplateDirective,
    DrawerItemTemplateDirective
];
const exportedModules$3 = [
    DrawerComponent,
    DrawerContainerComponent,
    DrawerContentComponent,
    ...templateDirectives
];
const declarations$3 = [
    DrawerItemComponent,
    DrawerListComponent,
    ...exportedModules$3
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Drawer component.
 */
class DrawerModule {
}
DrawerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: DrawerModule });
DrawerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function DrawerModule_Factory(t) { return new (t || DrawerModule)(); }, imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DrawerModule, { declarations: function () { return [DrawerItemComponent,
        DrawerListComponent,
        DrawerComponent,
        DrawerContainerComponent,
        DrawerContentComponent,
        DrawerTemplateDirective,
        DrawerHeaderTemplateDirective,
        DrawerFooterTemplateDirective,
        DrawerItemTemplateDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [DrawerComponent,
        DrawerContainerComponent,
        DrawerContentComponent,
        DrawerTemplateDirective,
        DrawerHeaderTemplateDirective,
        DrawerFooterTemplateDirective,
        DrawerItemTemplateDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DrawerModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations$3],
                exports: [exportedModules$3],
                imports: [CommonModule]
            }]
    }], null, null); })();

const cardDirectives = [
    CardTitleDirective,
    CardSubtitleDirective,
    CardSeparatorDirective,
    CardMediaDirective
];
const exportedModules$4 = [
    CardComponent,
    CardHeaderComponent,
    CardBodyComponent,
    CardFooterComponent,
    CardActionsComponent,
    ...cardDirectives
];
const declarations$4 = [...exportedModules$4];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Card component.
 */
class CardModule {
}
CardModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: CardModule });
CardModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function CardModule_Factory(t) { return new (t || CardModule)(); }, imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CardModule, { declarations: function () { return [CardComponent,
        CardHeaderComponent,
        CardBodyComponent,
        CardFooterComponent,
        CardActionsComponent,
        CardTitleDirective,
        CardSubtitleDirective,
        CardSeparatorDirective,
        CardMediaDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [CardComponent,
        CardHeaderComponent,
        CardBodyComponent,
        CardFooterComponent,
        CardActionsComponent,
        CardTitleDirective,
        CardSubtitleDirective,
        CardSeparatorDirective,
        CardMediaDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CardModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations$4],
                exports: [exportedModules$4],
                imports: [CommonModule]
            }]
    }], null, null); })();

const exportedModules$5 = [
    AvatarComponent
];
const declarations$5 = [
    ...exportedModules$5
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Avatar component.
 */
class AvatarModule {
}
AvatarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: AvatarModule });
AvatarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function AvatarModule_Factory(t) { return new (t || AvatarModule)(); }, imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AvatarModule, { declarations: function () { return [AvatarComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [AvatarComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvatarModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations$5],
                exports: [exportedModules$5],
                imports: [CommonModule]
            }]
    }], null, null); })();

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Layout components.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Layout module
 * import { LayoutModule } from '@progress/kendo-angular-layout';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, LayoutModule], // import Layout module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
class LayoutModule {
}
LayoutModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: LayoutModule });
LayoutModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function LayoutModule_Factory(t) { return new (t || LayoutModule)(); }, imports: [PanelBarModule,
        SplitterModule,
        TabStripModule,
        DrawerModule,
        AvatarModule,
        CardModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(LayoutModule, { exports: [PanelBarModule,
        SplitterModule,
        TabStripModule,
        DrawerModule,
        AvatarModule,
        CardModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LayoutModule, [{
        type: NgModule,
        args: [{
                exports: [
                    PanelBarModule,
                    SplitterModule,
                    TabStripModule,
                    DrawerModule,
                    AvatarModule,
                    CardModule
                ]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { PreventableEvent, DrawerContainerComponent, DrawerContentComponent, DrawerService, DrawerItemComponent, DrawerListComponent, ITEM_INDEX, PanelBarService, SplitterBarComponent, SplitterService, PanelBarComponent, PanelBarItemComponent, PanelBarContentDirective, PanelBarItemTemplateDirective, PanelBarItemTitleDirective, PanelBarExpandMode, SplitterComponent, SplitterPaneComponent, TabStripComponent, TabStripTabComponent, TabContentDirective, TabTitleDirective, SelectEvent, DrawerComponent, DrawerSelectEvent, AvatarComponent, CardComponent, CardHeaderComponent, CardBodyComponent, CardFooterComponent, CardActionsComponent, CardSeparatorDirective, CardTitleDirective, CardSubtitleDirective, CardMediaDirective, CardAction, LayoutModule, PanelBarModule, SplitterModule, TabStripModule, DrawerModule, AvatarModule, CardModule, DrawerTemplateDirective, DrawerItemTemplateDirective, DrawerHeaderTemplateDirective, DrawerFooterTemplateDirective };

//# sourceMappingURL=index.js.map