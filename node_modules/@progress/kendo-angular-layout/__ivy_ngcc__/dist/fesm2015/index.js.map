{"version":3,"file":"index.js","sources":["D:/project/projek_angular/hris_rni/node_modules/@progress/kendo-angular-layout/dist/fesm2015/index.js"],"sourcesContent":["/**-----------------------------------------------------------------------------------------\n* Copyright Â© 2020 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport { Injectable, Directive, TemplateRef, Optional, isDevMode, Component, SkipSelf, Host, ElementRef, Input, ViewChild, HostBinding, ViewChildren, ContentChildren, EventEmitter, Output, ContentChild, HostListener, Renderer2, ChangeDetectorRef, NgZone, Inject, QueryList, NgModule, ViewEncapsulation } from '@angular/core';\nimport { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';\nimport { Keys, hasObservers, DraggableDirective, DraggableModule } from '@progress/kendo-angular-common';\nimport { trigger, state, style, transition, animate, AUTO_STYLE, AnimationBuilder } from '@angular/animations';\nimport { Subject, BehaviorSubject, Subscription, of } from 'rxjs';\nimport { take, tap, filter, switchMap, delay, takeUntil, map } from 'rxjs/operators';\nimport { CommonModule } from '@angular/common';\n\n/**\n * Represents the expand modes of the PanelBar.\n * By default, the expand mode is set to `multiple`.\n */\nvar PanelBarExpandMode;\n(function (PanelBarExpandMode) {\n    /**\n     * Allows you to expand only one item at a time.\n     * When you expand an item, the item that was previously expanded is coll.\n     */\n    PanelBarExpandMode[PanelBarExpandMode[\"Single\"] = 0] = \"Single\";\n    /**\n     * Allows you to expand only one item at a time and requires you to set the `height` property.\n     * The expanded area occupies the entire height of the PanelBar.\n     */\n    PanelBarExpandMode[PanelBarExpandMode[\"Full\"] = 1] = \"Full\";\n    /**\n     * The default mode of the PanelBar.\n     * Allows you to expand more than one item at a time. Items can also be toggled.\n     */\n    PanelBarExpandMode[PanelBarExpandMode[\"Multiple\"] = 2] = \"Multiple\";\n    /**\n     * By default, the expand mode is set to `multiple`.\n     */\n    PanelBarExpandMode[PanelBarExpandMode[\"Default\"] = 2] = \"Default\";\n})(PanelBarExpandMode || (PanelBarExpandMode = {}));\n\n/**\n * @hidden\n */\nlet nextPanelbarId = 0;\n/**\n * @hidden\n */\nclass PanelBarService {\n    constructor() {\n        this.parentSource = new Subject();\n        this.keepContentSource = new BehaviorSubject(false);\n        this.childSource = new Subject();\n        this.parent$ = this.parentSource.asObservable();\n        this.children$ = this.childSource.asObservable();\n        this.keepContent$ = this.keepContentSource.asObservable();\n        this.pbId = nextPanelbarId++;\n    }\n    onKeepContent(keepContent) {\n        this.keepContentSource.next(keepContent);\n    }\n    onSelect(event) {\n        this.childSource.next(event);\n    }\n    onFocus() {\n        this.parentSource.next(true);\n    }\n    onBlur() {\n        this.parentSource.next(false);\n    }\n}\nPanelBarService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nPanelBarService.ctorParameters = () => [];\n\n/**\n * Represents the content template of the declaratively initialized PanelBar items.\n * The content can be expanded or collapsed through the item.\n */\nclass PanelBarContentDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nPanelBarContentDirective.decorators = [\n    { type: Directive, args: [{\n                selector: \"[kendoPanelBarContent]\"\n            },] },\n];\n/** @nocollapse */\nPanelBarContentDirective.ctorParameters = () => [\n    { type: TemplateRef }\n];\n\n/**\n * Represents the template directive of the PanelBar which helps to customize the item title\n * ([more information and example]({% slug templates_panelbar %}#toc-customizing-the-appearance-of-the-title)).\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *        <kendo-panelbar>\n *            <kendo-panelbar-item [title]=\"'Paris'\" [expanded]=\"true\">\n *                <ng-template kendoPanelBarItemTitle>\n *                    Additional Content\n *                </ng-template>\n *            </kendo-panelbar-item>\n *        </kendo-panelbar>\n *     `\n * })\n *\n * class AppComponent {}\n *\n * ```\n */\nclass PanelBarItemTitleDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nPanelBarItemTitleDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoPanelBarItemTitle]'\n            },] },\n];\n/** @nocollapse */\nPanelBarItemTitleDirective.ctorParameters = () => [\n    { type: TemplateRef, decorators: [{ type: Optional }] }\n];\n\n/**\n * @hidden\n */\nconst ITEM_INDEX = 'data-kendo-drawer-index';\n\n/**\n * @hidden\n */\nconst isPresent = (value) => value !== null && value !== undefined;\n\nconst focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;\n/**\n * @hidden\n */\nconst isFocusable = (element) => {\n    if (element.tagName) {\n        const tagName = element.tagName.toLowerCase();\n        const tabIndex = element.getAttribute('tabIndex');\n        const skipTab = tabIndex === '-1';\n        let focusable = tabIndex !== null && !skipTab;\n        if (focusableRegex.test(tagName)) {\n            focusable = !element.disabled && !skipTab;\n        }\n        return focusable;\n    }\n    return false;\n};\n/**\n * @hidden\n */\nconst closestInScope = (target, predicate, scope) => {\n    while (target && target !== scope && !predicate(target)) {\n        target = target.parentNode;\n    }\n    if (target !== scope) {\n        return target;\n    }\n};\n/**\n * @hidden\n */\nconst itemIndex = (item) => +item.getAttribute(ITEM_INDEX);\n/**\n *\n * @hidden\n */\nconst hasItemIndex = (item) => isPresent(item.getAttribute(ITEM_INDEX));\n/**\n * @hidden\n */\nconst closestItem = (target, scope) => closestInScope(target, hasItemIndex, scope);\n\n/**\n * @hidden\n */\nlet nextId = 0;\n/**\n * Represents the items of the PanelBar.\n */\nclass PanelBarItemComponent {\n    constructor(parent, eventService, element) {\n        this.parent = parent;\n        this.eventService = eventService;\n        this.element = element;\n        /**\n         * Sets the title of the PanelBar item ([see example]({% slug items_panelbar %}#toc-titles)).\n         */\n        this.title = 'Untitled';\n        /**\n         * Allows the component to set the `\"id\"` property to each item.\n         * Used to set the `id` attributes of the nested elements and to enable the WAI-ARIA support.\n         */\n        this.id = `default-${nextId++}`;\n        /**\n         * Defines the icon that will be rendered next to the title ([see example]({% slug items_panelbar %}#toc-title-icons)).\n         */\n        this.icon = '';\n        /**\n         * Defines  the icon that will be rendered next to the title by using a custom CSS class\n         * ([see example]({% slug items_panelbar %}#toc-title-icons)).\n         */\n        this.iconClass = '';\n        /**\n         * Defines the location of the image that will be displayed next to the title\n         * ([see example]({% slug items_panelbar %}#toc-title-images)).\n         */\n        this.imageUrl = '';\n        /**\n         * When set to `true`, disables a PanelBar item ([see example]({% slug items_panelbar %}#toc-disabled-state)).\n         */\n        this.disabled = false;\n        /**\n         * Sets the selected state of a PanelBar item ([see example]({% slug items_panelbar %}#toc-selected-state)).\n         */\n        this.selected = false;\n        this.keepContent = false;\n        this.hasChildItems = false;\n        this.hasItems = false;\n        this.hasContent = false;\n        this.state = \"inactive\";\n        this.role = \"treeitem\";\n        this.titleAttribute = null; // tslint:disable-line\n        this.focused = false;\n        this.wrapperFocused = false;\n        this.subscriptions = new Subscription(() => { });\n        this._expanded = false;\n        this.subscriptions.add(eventService.parent$.subscribe(focused => this.onWrapperFocusChange(focused)));\n        this.subscriptions.add(eventService.keepContent$.subscribe(keepContent => this.keepContent = keepContent));\n        this.wrapperFocused = parent ? parent.focused : false;\n    }\n    /**\n     * When set to `true`, expands the PanelBar item ([see example]({% slug items_panelbar %}#toc-expanded-state)).\n     */\n    set expanded(value) {\n        const activeState = this.animate ? \"active\" : \"activeWithoutAnimation\";\n        this.state = value ? activeState : \"inactive\";\n        if (!this.keepContent) {\n            this.toggleExpandedChildAnimations(value);\n        }\n        this._expanded = value;\n    }\n    get expanded() {\n        return this._expanded;\n    }\n    get animate() {\n        return this.eventService.animate;\n    }\n    get kItemClass() {\n        return true;\n    }\n    get kStateDefaultClass() {\n        return !this.disabled;\n    }\n    get kStateDisabledClass() {\n        return this.disabled;\n    }\n    get kStateExpandedClass() {\n        return !this.disabled && this.expanded && (this.hasChildItems || this.hasContent);\n    }\n    get itemId() {\n        return 'k-panelbar-' + this.eventService.pbId + '-item-' + this.id;\n    }\n    get ariaExpanded() {\n        return (this.hasChildItems || this.hasContent) ? !this.disabled && this.expanded : null;\n    }\n    get ariaSelected() {\n        return !this.disabled && this.selected;\n    }\n    get ariaDisabled() {\n        return this.disabled ? true : null;\n    }\n    /**\n     * @hidden\n     */\n    get titleTemplate() {\n        return this.titleTemplates.length > 0 ? this.titleTemplates.toArray()[0].templateRef : undefined;\n    }\n    /**\n     * @hidden\n     */\n    headerHeight() {\n        return this.element.nativeElement.offsetHeight - (this.contentWrapper ? this.contentWrapper.nativeElement.offsetHeight : 0);\n    }\n    /**\n     * @hidden\n     */\n    ngAfterContentChecked() {\n        this.hasItems = this.items && this.items.filter(item => !item.hidden).length > 0;\n        this.hasChildItems = this.contentItems.length > 1 || this.hasItems;\n        this.hasContent = (this.contentTemplate !== undefined && this.contentTemplate.length > 0) ||\n            this.content !== undefined;\n        this.validateConfiguration();\n    }\n    /**\n     * @hidden\n     */\n    ngAfterViewChecked() {\n        if (this.items) {\n            this.childrenItems = this.viewChildItems.toArray();\n        }\n        else {\n            this.childrenItems = this.contentItems.filter(item => item !== this);\n        }\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n        this.subscriptions.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n    onItemAction() {\n        if (!this.disabled) {\n            this.eventService.onSelect(this);\n        }\n    }\n    /**\n     * @hidden\n     */\n    onItemClick(e) {\n        if (!isFocusable(e.target)) {\n            this.onItemAction();\n        }\n    }\n    /**\n     * @hidden\n     */\n    get iconClasses() {\n        let icon = this.icon ? 'k-i-' + this.icon : null;\n        return {\n            [icon || this.iconClass]: true\n        };\n    }\n    /**\n     * @hidden\n     */\n    serialize() {\n        return {\n            content: this.content,\n            disabled: this.disabled,\n            expanded: this.expanded,\n            focused: this.focused,\n            icon: this.icon,\n            iconClass: this.iconClass,\n            id: this.id,\n            imageUrl: this.imageUrl,\n            selected: this.selected,\n            title: this.title\n        };\n    }\n    /**\n     * @hidden\n     */\n    subTreeViewItems() {\n        let subTree = [];\n        this.viewChildItems.forEach(item => {\n            subTree = subTree.concat(item.subTreeViewItems());\n            subTree.push(item);\n        });\n        return subTree;\n    }\n    /**\n     * @hidden\n     */\n    validateConfiguration() {\n        if (isDevMode()) {\n            if (this.content && (this.contentTemplate !== undefined && this.contentTemplate.length > 0)) {\n                throw new Error(\"Invalid configuration: mixed template components and component property.\");\n            }\n        }\n    }\n    /**\n     * @hidden\n     */\n    toggleAnimationState(value) {\n        if (!this.animate) {\n            return;\n        }\n        this.state = value ? 'active' : 'activeWithoutAnimation';\n    }\n    /**\n     * @hidden\n     */\n    toggleExpandedChildAnimations(value) {\n        if (this.childrenItems) {\n            this.childrenItems.forEach(child => {\n                if (child.expanded) {\n                    child.toggleAnimationState(value);\n                    child.toggleExpandedChildAnimations(value);\n                }\n            });\n        }\n    }\n    onWrapperFocusChange(focused) {\n        this.wrapperFocused = focused;\n    }\n}\nPanelBarItemComponent.decorators = [\n    { type: Component, args: [{\n                animations: [\n                    trigger('toggle', [\n                        state('inactive', style({ display: 'none' })),\n                        transition('* => active', [\n                            style({ overflow: 'hidden', display: 'block', height: 0 }),\n                            animate(200, style({ height: AUTO_STYLE }))\n                        ]),\n                        transition('active => *', [\n                            style({ overflow: 'hidden', height: '*' }),\n                            animate(200, style({ height: 0, display: 'none' }))\n                        ])\n                    ])\n                ],\n                exportAs: 'kendoPanelbarItem',\n                selector: \"kendo-panelbar-item\",\n                template: `<span\n                #header\n                [class.k-link]=\"true\"\n                [class.k-header]=\"!parent\"\n                [class.k-state-selected]=\"!disabled && selected\"\n                [class.k-state-focused]=\"!disabled && focused && wrapperFocused\"\n                (click)=\"onItemClick($event)\">\n            <span\n                *ngIf=\"icon || iconClass\"\n                class=\"k-icon\"\n                [ngClass]=\"iconClasses\">\n            </span>\n            <img\n                *ngIf=\"imageUrl\"\n                class=\"k-image\"\n                [src]=\"imageUrl\"\n                alt=\"\">\n            {{title}}\n            <ng-template [ngTemplateOutlet]=\"titleTemplate\"></ng-template>\n            <span *ngIf=\"hasChildItems || hasContent\"\n                [class.k-icon]=\"true\"\n                [class.k-i-arrow-n]=\"expanded\"\n                [class.k-panelbar-collapse]=\"expanded\"\n                [class.k-i-arrow-s]=\"!expanded\"\n                [class.k-panelbar-expand]=\"!expanded\">\n            </span>\n        </span>\n        <div #contentWrapper\n            *ngIf=\"keepContent || (!disabled && expanded && (hasChildItems || hasContent))\"\n            [@toggle]=\"state\"\n            [attr.role]=\"'group'\"\n            [attr.aria-hidden]=\"!disabled && !expanded\">\n            <div\n                *ngIf=\"hasChildItems && !items?.length\"\n                [style.overflow]=\"contentOverflow\"\n                [style.height]=\"contentHeight\"\n                class=\"k-panel k-group\">\n                    <ng-content select=\"kendo-panelbar-item\"></ng-content>\n            </div>\n            <div\n                *ngIf=\"hasContent && !content\"\n                [style.overflow]=\"contentOverflow\"\n                [style.height]=\"contentHeight\"\n                class=\"k-content\">\n                <ng-template\n                    [ngTemplateOutlet]=\"contentTemplate.first.templateRef\"\n                    [ngTemplateOutletContext]=\"{\n                        $implicit: {\n                            title: title,\n                            id: id,\n                            icon: icon,\n                            imageUrl: imageUrl,\n                            disabled: disabled,\n                            content: content\n                        }\n                    }\">\n                </ng-template>\n            </div>\n            <div *ngIf=\"hasItems\"\n                [style.overflow]=\"contentOverflow\"\n                [style.height]=\"contentHeight\"\n                class=\"k-panel k-group\">\n                <ng-container *ngFor=\"let item of items\">\n                    <kendo-panelbar-item *ngIf=\"!item.hidden\"\n                        [title]=\"item.title\"\n                        [id]=\"item.id\"\n                        [icon]=\"item.icon\"\n                        [iconClass]=\"item.iconClass\"\n                        [imageUrl]=\"item.imageUrl\"\n                        [selected]=\"!!item.selected\"\n                        [expanded]=\"!!item.expanded\"\n                        [disabled]=\"!!item.disabled\"\n                        [template]=\"template\"\n                        [items]=\"item.children\"\n                        [content]=\"item.content\">\n                    </kendo-panelbar-item>\n                </ng-container>\n            </div>\n            <div\n                *ngIf=\"content\"\n                [style.overflow]=\"contentOverflow\"\n                [style.height]=\"contentHeight\"\n                class=\"k-content\">\n                <ng-template\n                    [ngTemplateOutlet]=\"template\"\n                    [ngTemplateOutletContext]=\"{\n                        $implicit: {\n                            title: title,\n                            id: id,\n                            icon: icon,\n                            imageUrl: imageUrl,\n                            disabled: disabled,\n                            content: content\n                        }\n                    }\">\n                </ng-template>\n                <ng-template [ngIf]=\"!template\">{{content}}</ng-template>\n            </div>\n        </div>`\n            },] },\n];\n/** @nocollapse */\nPanelBarItemComponent.ctorParameters = () => [\n    { type: PanelBarItemComponent, decorators: [{ type: SkipSelf }, { type: Host }, { type: Optional }] },\n    { type: PanelBarService },\n    { type: ElementRef }\n];\nPanelBarItemComponent.propDecorators = {\n    title: [{ type: Input }],\n    id: [{ type: Input }],\n    icon: [{ type: Input }],\n    iconClass: [{ type: Input }],\n    imageUrl: [{ type: Input }],\n    disabled: [{ type: Input }],\n    expanded: [{ type: Input }],\n    selected: [{ type: Input }],\n    content: [{ type: Input }],\n    items: [{ type: Input }],\n    template: [{ type: Input }],\n    header: [{ type: ViewChild, args: ['header', {},] }],\n    contentWrapper: [{ type: ViewChild, args: ['contentWrapper', {},] }],\n    role: [{ type: HostBinding, args: ['attr.role',] }],\n    titleAttribute: [{ type: HostBinding, args: ['attr.title',] }],\n    kItemClass: [{ type: HostBinding, args: ['class.k-item',] }],\n    kStateDefaultClass: [{ type: HostBinding, args: ['class.k-state-default',] }],\n    kStateDisabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }],\n    kStateExpandedClass: [{ type: HostBinding, args: ['class.k-state-expanded',] }],\n    itemId: [{ type: HostBinding, args: ['id',] }],\n    ariaExpanded: [{ type: HostBinding, args: ['attr.aria-expanded',] }],\n    ariaSelected: [{ type: HostBinding, args: ['attr.aria-selected',] }],\n    ariaDisabled: [{ type: HostBinding, args: ['attr.aria-disabled',] }],\n    viewChildItems: [{ type: ViewChildren, args: [PanelBarItemComponent,] }],\n    contentItems: [{ type: ContentChildren, args: [PanelBarItemComponent,] }],\n    contentTemplate: [{ type: ContentChildren, args: [PanelBarContentDirective, { descendants: false },] }],\n    titleTemplates: [{ type: ContentChildren, args: [PanelBarItemTitleDirective, { descendants: false },] }]\n};\n\n/**\n * Represents the template directive of the PanelBar which helps to customize the item content.\n */\nclass PanelBarItemTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nPanelBarItemTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoPanelBarItemTemplate]'\n            },] },\n];\n/** @nocollapse */\nPanelBarItemTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef, decorators: [{ type: Optional }] }\n];\n\nlet nextId$1 = 0;\nconst parsePanelBarItems = (data) => {\n    return data.map((item) => {\n        if (!item.id) {\n            item.id = `default-${nextId$1++}`;\n        }\n        if (item.children) {\n            item.children = parsePanelBarItems(item.children);\n        }\n        return item;\n    });\n};\nvar util = {\n    parsePanelBarItems\n};\n\n/**\n * Represents the [Kendo UI PanelBar component for Angular]({% slug overview_panelbar %}).\n */\n// TODO: add styles as input prop\nclass PanelBarComponent {\n    constructor(elementRef, eventService, localization) {\n        this.localization = localization;\n        /**\n         * Sets the expand mode of the PanelBar through the `PanelBarExpandMode` enum ([see example]({% slug expandmodes_panelbar %})).\n         *\n         * The available modes are:\n         * - `\"single\"`&mdash;Expands only one item at a time. Expanding an item collapses the item that was previously expanded.\n         * - `\"multiple\"`&mdash;The default mode of the PanelBar.\n         * Expands more than one item at a time. Items can also be toggled.\n         * - `\"full\"`&mdash;Expands only one item at a time.\n         * The expanded area occupies the entire height of the PanelBar. Requires you to set the `height` property.\n         */\n        this.expandMode = PanelBarExpandMode.Default;\n        /**\n         * Allows the PanelBar to modify the selected state of the items.\n         */\n        this.selectable = true;\n        /**\n         * Sets the animate state of the PanelBar ([see example]({% slug animations_panelbar %})).\n         */\n        this.animate = true;\n        /**\n         * Sets the height of the component when the `\"full\"` expand mode is used.\n         * This option is ignored in the `\"multiple\"` and `\"single\"` expand modes.\n         */\n        this.height = \"400px\";\n        /**\n         * Fires each time the user interacts with a PanelBar item\n         * ([see example]({% slug routing_panelbar %}#toc-getting-the-selected-item)).\n         * The event data contains all items that are modified.\n         */\n        this.stateChange = new EventEmitter();\n        this.tabIndex = 0;\n        this.role = \"tree\";\n        this.activeDescendant = \"\";\n        this.isViewInit = true;\n        this.focused = false;\n        this._keepItemContent = false;\n        this.updateChildrenHeight = () => {\n            let childrenHeight = 0;\n            const panelbarHeight = this.elementRef.nativeElement.offsetHeight;\n            const contentOverflow = this.expandMode === PanelBarExpandMode.Full ? 'auto' : 'visible';\n            this.childrenItems.forEach(item => {\n                childrenHeight += item.headerHeight();\n            });\n            this.childrenItems.forEach(item => {\n                item.contentHeight = PanelBarExpandMode.Full === this.expandMode ? (panelbarHeight - childrenHeight) + \"px\" : 'auto';\n                item.contentOverflow = contentOverflow;\n            });\n        };\n        this.keyBindings = this.computedKeys;\n        this.elementRef = elementRef;\n        this.eventService = eventService;\n        this.eventService.children$.subscribe(event => this.onItemAction(event));\n    }\n    /**\n     * When set to `true`, the PanelBar renders the content of all items and they are persisted in the DOM\n     * ([see example]({% slug templates_panelbar %}#toc-collections)).\n     * By default, this option is set to `false`.\n     */\n    get keepItemContent() {\n        return this._keepItemContent;\n    }\n    set keepItemContent(keepItemContent) {\n        this._keepItemContent = keepItemContent;\n        this.eventService.onKeepContent(keepItemContent);\n    }\n    /**\n     * Sets the items of the PanelBar as an array of `PanelBarItemModel` instances\n     * ([see example]({% slug items_panelbar %})).\n     */\n    set items(data) {\n        if (data) {\n            this._items = util.parsePanelBarItems(data);\n        }\n    }\n    get items() {\n        return this._items;\n    }\n    get hostHeight() {\n        return this.expandMode === PanelBarExpandMode.Full ? this.height : 'auto';\n    }\n    get overflow() {\n        return this.expandMode === PanelBarExpandMode.Full ? \"hidden\" : \"visible\";\n    }\n    get dir() {\n        return this.localization.rtl ? 'rtl' : 'ltr';\n    }\n    /**\n     * @hidden\n     */\n    invertKeys(original, inverted) {\n        return this.localization.rtl ? inverted : original;\n    }\n    get computedKeys() {\n        return {\n            [Keys.Space]: () => this.selectFocusedItem(),\n            [Keys.Enter]: () => this.selectFocusedItem(),\n            [Keys.ArrowUp]: () => this.focusPreviousItem(),\n            [this.invertKeys(Keys.ArrowLeft, Keys.ArrowRight)]: () => this.collapseItem(),\n            [Keys.ArrowDown]: () => this.focusNextItem(),\n            [this.invertKeys(Keys.ArrowRight, Keys.ArrowLeft)]: () => this.expandItem(),\n            [Keys.End]: () => this.focusLastItem(),\n            [Keys.Home]: () => this.focusFirstItem()\n        };\n    }\n    ngOnDestroy() {\n        if (this.localizationChangeSubscription) {\n            this.localizationChangeSubscription.unsubscribe();\n        }\n    }\n    ngOnInit() {\n        this.localizationChangeSubscription = this.localization\n            .changes.subscribe(() => this.keyBindings = this.computedKeys);\n        this.eventService.animate = this.animate;\n    }\n    ngAfterViewChecked() {\n        if (this.items) {\n            this.childrenItems = this.viewChildItems.toArray();\n            this.allItems = this.viewItems;\n        }\n        else {\n            this.childrenItems = this.contentChildItems.toArray();\n            this.allItems = this.contentItems.toArray();\n        }\n        if (this.isViewInit && this.childrenItems.length) {\n            this.isViewInit = false;\n            setTimeout(() => this.updateChildrenHeight());\n        }\n        this.validateConfiguration();\n    }\n    ngOnChanges(changes) {\n        if (changes['height'] || changes['expandMode'] || changes[\"items\"]) { // tslint:disable-line\n            if (this.childrenItems) {\n                setTimeout(this.updateChildrenHeight);\n            }\n        }\n        if (changes.animate) {\n            this.eventService.animate = this.animate;\n        }\n    }\n    get templateRef() {\n        return this.template ? this.template.templateRef : undefined;\n    }\n    /**\n     * @hidden\n     */\n    onComponentClick(event) {\n        const itemClicked = this.visibleItems().some((item) => {\n            return item.header.nativeElement.contains(event.target);\n        });\n        if (!this.focused && itemClicked) {\n            this.elementRef.nativeElement.focus();\n        }\n    }\n    /**\n     * @hidden\n     */\n    onComponentFocus() {\n        this.eventService.onFocus();\n        this.focused = true;\n        if (this.allItems.length > 0) {\n            const visibleItems = this.visibleItems();\n            const focusedItems = visibleItems.filter(item => item.focused);\n            if (!focusedItems.length && visibleItems.length > 0) {\n                visibleItems[0].focused = true;\n                this.activeDescendant = visibleItems[0].itemId;\n            }\n        }\n    }\n    /**\n     * @hidden\n     */\n    onComponentBlur() {\n        this.eventService.onBlur();\n        this.focused = false;\n        this.activeDescendant = \"\";\n    }\n    /**\n     * @hidden\n     */\n    onComponentKeyDown(event) {\n        if (event.target === this.elementRef.nativeElement) {\n            if (event.keyCode === Keys.Space || event.keyCode === Keys.ArrowUp || event.keyCode === Keys.ArrowDown ||\n                event.keyCode === Keys.ArrowLeft || event.keyCode === Keys.ArrowRight || event.keyCode === Keys.Home ||\n                event.keyCode === Keys.End || event.keyCode === Keys.PageUp || event.keyCode === Keys.PageDown) {\n                event.preventDefault();\n            }\n            const handler = this.keyBindings[event.keyCode];\n            //TODO: check if next item is disabled and skip operation?\n            if (handler) {\n                handler();\n            }\n        }\n    }\n    get viewItems() {\n        let treeItems = [];\n        this.viewChildItems.toArray().forEach(item => {\n            treeItems.push(item);\n            treeItems = treeItems.concat(item.subTreeViewItems());\n        });\n        return treeItems;\n    }\n    validateConfiguration() {\n        if (isDevMode()) {\n            if (this.items && (this.contentItems && this.contentItems.length > 0)) {\n                throw new Error(\"Invalid configuration: mixed template components and items property.\");\n            }\n        }\n    }\n    onItemAction(item) {\n        if (!item) {\n            return;\n        }\n        let modifiedItems = new Array();\n        this.allItems\n            .forEach((currentItem) => {\n            let selectedState = currentItem === item;\n            let focusedState = selectedState;\n            selectedState = this.selectable ? selectedState : currentItem.selected;\n            if (currentItem.selected !== selectedState || currentItem.focused !== focusedState) {\n                currentItem.selected = selectedState;\n                currentItem.focused = focusedState;\n                this.activeDescendant = focusedState ? currentItem.itemId : \"\";\n                modifiedItems.push(currentItem);\n            }\n        });\n        if (this.expandMode === PanelBarExpandMode.Multiple) {\n            if (item.hasChildItems || item.hasContent) {\n                item.expanded = !item.expanded;\n            }\n            if (modifiedItems.indexOf(item) < 0) {\n                modifiedItems.push(item);\n            }\n        }\n        else {\n            let siblings = item.parent ? item.parent.childrenItems : this.childrenItems;\n            if (item.hasChildItems || item.hasContent) {\n                siblings\n                    .forEach((currentItem) => {\n                    let expandedState = currentItem === item;\n                    if (currentItem.expanded !== expandedState) {\n                        currentItem.expanded = expandedState;\n                        if (modifiedItems.indexOf(currentItem) < 0) {\n                            modifiedItems.push(currentItem);\n                        }\n                    }\n                });\n            }\n        }\n        if (modifiedItems.length > 0) {\n            this.stateChange.emit(modifiedItems.map(currentItem => currentItem.serialize()));\n        }\n    }\n    get hostClasses() {\n        return true;\n    }\n    isVisible(item) {\n        const visibleItems = this.visibleItems();\n        return visibleItems.some(i => i === item);\n    }\n    getVisibleParent(item) {\n        const visibleItems = this.visibleItems();\n        if (!item.parent) {\n            return item;\n        }\n        return visibleItems.some(i => i === item.parent) ? item.parent : this.getVisibleParent(item.parent);\n    }\n    focusItem(action) {\n        const visibleItems = this.visibleItems();\n        let currentIndex = visibleItems.findIndex(item => item.focused);\n        let currentItem = visibleItems[currentIndex];\n        let nextItem;\n        if (currentIndex === -1) {\n            let focusedItem = this.allItems.find(item => item.focused);\n            focusedItem.focused = false;\n            currentItem = this.getVisibleParent(focusedItem);\n            currentIndex = visibleItems.findIndex(item => item === currentItem);\n        }\n        switch (action) {\n            case \"lastItem\":\n                nextItem = visibleItems[visibleItems.length - 1];\n                break;\n            case \"firstItem\":\n                nextItem = visibleItems[0];\n                break;\n            case \"nextItem\":\n                nextItem = visibleItems[currentIndex < visibleItems.length - 1 ? currentIndex + 1 : 0];\n                break;\n            case \"previousItem\":\n                nextItem = visibleItems[currentIndex > 0 ? currentIndex - 1 : visibleItems.length - 1];\n                break;\n            default:\n        }\n        if (currentItem && nextItem && currentItem !== nextItem) {\n            this.moveFocus(currentItem, nextItem);\n        }\n    }\n    moveFocus(from, to) {\n        from.focused = false;\n        to.focused = true;\n        this.activeDescendant = to.itemId;\n        const modifiedItems = new Array(from.serialize(), to.serialize());\n        this.stateChange.emit(modifiedItems);\n    }\n    focusLastItem() {\n        this.focusItem(\"lastItem\");\n    }\n    focusFirstItem() {\n        this.focusItem(\"firstItem\");\n    }\n    focusNextItem() {\n        this.focusItem(\"nextItem\");\n    }\n    focusPreviousItem() {\n        this.focusItem(\"previousItem\");\n    }\n    expandItem() {\n        let currentItem = this.allItems.filter(item => item.focused)[0];\n        if (!this.isVisible(currentItem)) {\n            currentItem.focused = false;\n            currentItem = this.getVisibleParent(currentItem);\n        }\n        if (currentItem.hasChildItems || currentItem.hasContent) {\n            if (!currentItem.expanded) {\n                this.onItemAction(currentItem);\n            }\n            else if (currentItem.hasChildItems) {\n                const firstChildIndex = currentItem.childrenItems.findIndex(item => !item.disabled);\n                if (firstChildIndex > -1) {\n                    this.moveFocus(currentItem, currentItem.childrenItems[firstChildIndex]);\n                }\n            }\n        }\n    }\n    collapseItem() {\n        const currentItem = this.allItems.filter(item => item.focused)[0];\n        if (currentItem.expanded) {\n            this.onItemAction(currentItem);\n        }\n        else if (currentItem.parent) {\n            this.moveFocus(currentItem, currentItem.parent);\n        }\n    }\n    selectFocusedItem() {\n        let focusedItem = this.allItems.filter(item => item.focused)[0];\n        if (!this.isVisible(focusedItem)) {\n            focusedItem.focused = false;\n            focusedItem = this.getVisibleParent(focusedItem);\n        }\n        if (focusedItem) {\n            focusedItem.onItemAction();\n        }\n    }\n    visibleItems() {\n        return this.flatVisibleItems(this.childrenItems);\n    }\n    flatVisibleItems(listOfItems = new Array(), flattedItems = new Array()) {\n        listOfItems.forEach(item => {\n            if (!item.disabled) {\n                flattedItems.push(item);\n                if (item.expanded && item.hasChildItems) {\n                    this.flatVisibleItems(item.childrenItems, flattedItems);\n                }\n            }\n        });\n        return flattedItems;\n    }\n}\nPanelBarComponent.decorators = [\n    { type: Component, args: [{\n                exportAs: 'kendoPanelbar',\n                providers: [\n                    PanelBarService,\n                    LocalizationService,\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.panelbar'\n                    }\n                ],\n                selector: 'kendo-panelbar',\n                template: `\n        <ng-content *ngIf=\"contentChildItems && !items\" select=\"kendo-panelbar-item\"></ng-content>\n        <ng-template [ngIf]=\"items?.length\">\n            <ng-container *ngFor=\"let item of items\">\n                <kendo-panelbar-item *ngIf=\"!item.hidden\"\n                     [title]=\"item.title\"\n                     [id]=\"item.id\"\n                     [icon]=\"item.icon\"\n                     [iconClass]=\"item.iconClass\"\n                     [imageUrl]=\"item.imageUrl\"\n                     [selected]=\"!!item.selected\"\n                     [expanded]=\"!!item.expanded\"\n                     [disabled]=\"!!item.disabled\"\n                     [template]=\"templateRef\"\n                     [items]=\"item.children\"\n                     [content]=\"item.content\"\n                >\n                </kendo-panelbar-item>\n            </ng-container>\n        </ng-template>\n    `\n            },] },\n];\n/** @nocollapse */\nPanelBarComponent.ctorParameters = () => [\n    { type: ElementRef },\n    { type: PanelBarService },\n    { type: LocalizationService }\n];\nPanelBarComponent.propDecorators = {\n    expandMode: [{ type: Input }],\n    selectable: [{ type: Input }],\n    animate: [{ type: Input }],\n    height: [{ type: Input }],\n    keepItemContent: [{ type: Input }],\n    items: [{ type: Input }],\n    stateChange: [{ type: Output }],\n    tabIndex: [{ type: HostBinding, args: ['attr.tabIndex',] }],\n    role: [{ type: HostBinding, args: ['attr.role',] }],\n    activeDescendant: [{ type: HostBinding, args: ['attr.aria-activedescendant',] }],\n    hostHeight: [{ type: HostBinding, args: ['style.height',] }],\n    overflow: [{ type: HostBinding, args: ['style.overflow',] }],\n    dir: [{ type: HostBinding, args: ['attr.dir',] }],\n    template: [{ type: ContentChild, args: [PanelBarItemTemplateDirective,] }],\n    contentItems: [{ type: ContentChildren, args: [PanelBarItemComponent, { descendants: true },] }],\n    contentChildItems: [{ type: ContentChildren, args: [PanelBarItemComponent,] }],\n    viewChildItems: [{ type: ViewChildren, args: [PanelBarItemComponent,] }],\n    onComponentClick: [{ type: HostListener, args: ['click', ['$event'],] }],\n    onComponentFocus: [{ type: HostListener, args: ['focus',] }],\n    onComponentBlur: [{ type: HostListener, args: ['blur',] }],\n    onComponentKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }],\n    hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-panelbar',] }]\n};\n\n/**\n * Represents the pane component of the Splitter.\n */\nclass SplitterPaneComponent {\n    constructor(element, renderer, cdr) {\n        this.element = element;\n        this.renderer = renderer;\n        this.cdr = cdr;\n        /**\n         * Specifies if the user is allowed to resize the pane and provide space for other panes.\n         */\n        this.resizable = true;\n        /**\n         * Specifies if the user is allowed to hide the pane and provide space for other panes.\n         */\n        this.collapsible = false;\n        /**\n         * Specifies if overflowing content is scrollable or hidden.\n         */\n        this.scrollable = true;\n        /**\n         * Specifies if the pane is initially collapsed.\n         */\n        this.collapsed = false;\n        /**\n         * @hidden\n         */\n        this.orientation = 'horizontal';\n        /**\n         * @hidden\n         */\n        this.containsSplitter = false;\n        /**\n         * @hidden\n         */\n        this.overlayContent = false;\n        /**\n         * Fires each time the user resizes the Splitter pane.\n         * The event data contains the new pane size.\n         * Allows a two-way binding of the pane `size` property.\n         */\n        this.sizeChange = new EventEmitter();\n        /**\n         * Fires each time the `collapsed` property changes.\n         * The event data contains the new property state.\n         * Allows a two-way binding of the `collapsed` pane property.\n         */\n        this.collapsedChange = new EventEmitter();\n        this.hostClass = true;\n        /**\n         * @hidden\n         */\n        this.forceExpand = false;\n    }\n    /**\n     * @hidden\n     */\n    set order(paneOrder) {\n        this._order = paneOrder;\n        this.setOrderStyles();\n    }\n    get order() {\n        return this._order;\n    }\n    /**\n     * Sets the initial size of the pane.\n     * Has to be between the `min` and `max` properties.\n     */\n    set size(newSize) {\n        this._size = newSize;\n        const element = this.element.nativeElement;\n        this.renderer.setStyle(element, '-ms-flex-preferred-size', newSize);\n        this.renderer.setStyle(element, 'flex-basis', newSize);\n        if (this.staticPaneClass) {\n            this.renderer.addClass(element, 'k-pane-static');\n        }\n        else {\n            this.renderer.removeClass(element, 'k-pane-static');\n        }\n    }\n    get size() {\n        return this._size;\n    }\n    get isHidden() {\n        return this.collapsed;\n    }\n    get styleDisplayFlex() {\n        return this.containsSplitter;\n    }\n    get staticPaneClass() {\n        if (this.forceExpand) {\n            return false;\n        }\n        return !this.resizable && !this.collapsible || this.fixedSize;\n    }\n    get scrollablePaneClass() {\n        return this.scrollable;\n    }\n    get fixedSize() {\n        return this.size && this.size.length > 0;\n    }\n    ngAfterViewChecked() {\n        const element = this.element.nativeElement;\n        if (this.isHidden) {\n            this.renderer.addClass(element, 'k-state-hidden');\n            this.renderer.addClass(element, 'hidden');\n        }\n        else {\n            this.renderer.removeClass(element, 'k-state-hidden');\n            this.renderer.removeClass(element, 'hidden');\n        }\n    }\n    /**\n     * @hidden\n     */\n    get computedSize() {\n        if (this.orientation === 'vertical') {\n            return this.element.nativeElement.offsetHeight;\n        }\n        else {\n            return this.element.nativeElement.offsetWidth;\n        }\n    }\n    /**\n     * @hidden\n     */\n    toggleOverlay(show) {\n        this.overlayContent = show;\n        this.cdr.detectChanges();\n    }\n    /**\n     * @hidden\n     */\n    detectChanges() {\n        this.cdr.detectChanges();\n    }\n    /**\n     * @hidden\n     */\n    setOrderStyles() {\n        const element = this.element.nativeElement;\n        this.renderer.setStyle(element, '-ms-flex-order', this.order);\n        this.renderer.setStyle(element, 'order', this.order);\n    }\n}\nSplitterPaneComponent.decorators = [\n    { type: Component, args: [{\n                exportAs: 'kendoSplitterPane',\n                selector: 'kendo-splitter-pane',\n                template: `\n        <ng-container *ngIf=\"!collapsed\"><ng-content></ng-content></ng-container>\n        <div *ngIf=\"overlayContent\" class=\"k-splitter-overlay k-overlay\"></div>\n    `\n            },] },\n];\n/** @nocollapse */\nSplitterPaneComponent.ctorParameters = () => [\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: ChangeDetectorRef }\n];\nSplitterPaneComponent.propDecorators = {\n    order: [{ type: Input }],\n    size: [{ type: Input }],\n    min: [{ type: Input }],\n    max: [{ type: Input }],\n    resizable: [{ type: Input }],\n    collapsible: [{ type: Input }],\n    scrollable: [{ type: Input }],\n    collapsed: [{ type: Input }],\n    orientation: [{ type: Input }],\n    containsSplitter: [{ type: Input }],\n    overlayContent: [{ type: Input }],\n    sizeChange: [{ type: Output }],\n    collapsedChange: [{ type: Output }],\n    styleDisplayFlex: [{ type: HostBinding, args: ['class.k-pane-flex',] }],\n    hostClass: [{ type: HostBinding, args: ['class.k-pane',] }],\n    staticPaneClass: [{ type: HostBinding, args: ['class.k-pane-static',] }],\n    scrollablePaneClass: [{ type: HostBinding, args: ['class.k-scrollable',] }]\n};\n\nconst SIZING_DOC_LINK = 'https://www.telerik.com/kendo-angular-ui/components/layout/splitter/panes/#toc-size';\n/**\n * @hidden\n */\nclass SplitterService {\n    constructor(zone) {\n        this.zone = zone;\n        this.layoutChange = new EventEmitter();\n        this.containerSize = () => { };\n    }\n    tryToggle(paneIndex) {\n        const pane = this.pane(paneIndex);\n        if (pane.collapsible) {\n            pane.collapsed = !pane.collapsed;\n            pane.collapsedChange.emit(pane.collapsed);\n            this.emit(this.layoutChange, {});\n            if (pane.collapsed) {\n                pane.detectChanges();\n            }\n        }\n        const notCollapsed = this.panes.filter(p => !p.collapsed);\n        const allHaveFixedSize = notCollapsed.every(p => p.fixedSize);\n        notCollapsed[notCollapsed.length - 1].forceExpand = allHaveFixedSize ? true : false;\n        return pane.collapsible;\n    }\n    toggleContentOverlay(index, show) {\n        this.pane(index).toggleOverlay(show);\n        this.pane(index + 1).toggleOverlay(show);\n    }\n    dragState(splitbarIndex) {\n        let prev = this.pane(splitbarIndex);\n        let next = this.pane(splitbarIndex + 1);\n        const total = prev.computedSize + next.computedSize;\n        const px = s => this.toPixels(s);\n        return {\n            prev: {\n                index: splitbarIndex,\n                initialSize: prev.computedSize,\n                min: px(prev.min) || total - px(next.max) || 0,\n                max: px(prev.max) || total - px(next.min) || total\n            },\n            next: {\n                index: splitbarIndex + 1,\n                initialSize: next.computedSize,\n                min: px(next.min) || total - px(prev.max) || 0,\n                max: px(next.max) || total - px(prev.min) || total\n            }\n        };\n    }\n    setSize(state$$1, delta) {\n        const clamp = (min, max, v) => Math.min(max, Math.max(min, v));\n        const resize = (paneState, change) => {\n            const pane = this.pane(paneState.index);\n            const splitterSize = this.containerSize();\n            const newSize = clamp(paneState.min, paneState.max, paneState.initialSize + change);\n            let size = \"\";\n            if (this.isPercent(pane.size)) {\n                size = (100 * newSize / splitterSize) + \"%\";\n            }\n            else {\n                size = newSize + \"px\";\n            }\n            pane.size = size;\n            this.emit(pane.sizeChange, size);\n        };\n        const prev = this.pane(state$$1.prev.index);\n        const next = this.pane(state$$1.next.index);\n        // determine which pane to resize\n        if (prev.fixedSize && next.fixedSize) {\n            // resizing both panes\n            resize(state$$1.prev, delta);\n            resize(state$$1.next, -delta);\n        }\n        else if (next.collapsible || next.fixedSize) {\n            // resizing next\n            resize(state$$1.next, -delta);\n        }\n        else {\n            // resizing prev\n            resize(state$$1.prev, delta);\n        }\n        this.emit(this.layoutChange, {});\n    }\n    isDraggable(splitBarIndex) {\n        const prev = this.pane(splitBarIndex);\n        const next = this.pane(splitBarIndex + 1);\n        const betweenResizablePanes = prev.resizable && next.resizable;\n        const nearCollapsedPane = prev.collapsed || next.collapsed;\n        return betweenResizablePanes && !nearCollapsedPane;\n    }\n    isStatic(splitBarIndex) {\n        const prev = this.pane(splitBarIndex);\n        const next = this.pane(splitBarIndex + 1);\n        const betweenResizablePanes = prev.resizable && next.resizable;\n        const nearCollapsiblePane = prev.collapsible || next.collapsible;\n        return !betweenResizablePanes && !nearCollapsiblePane;\n    }\n    pane(index) {\n        if (!this.panes) {\n            throw new Error(\"Panes not initialized\");\n        }\n        if (index < 0 || index >= this.panes.length) {\n            throw new Error(\"Index out of range\");\n        }\n        return this.panes[index];\n    }\n    configure({ panes, orientation, containerSize }) {\n        this.panes = panes;\n        this.panes.forEach((pane, index) => {\n            pane.order = index * 2;\n            pane.orientation = orientation;\n        });\n        if (isDevMode()) {\n            const allFixed = panes.length && !panes.some(pane => !pane.fixedSize);\n            if (allFixed) {\n                throw new Error(`\n                    The Splitter should have at least one pane without a set size.\n                    See ${SIZING_DOC_LINK} for more information.\n                `);\n            }\n        }\n        this.containerSize = containerSize;\n    }\n    isPercent(size) {\n        return /%$/.test(size);\n    }\n    toPixels(size) {\n        let result = parseFloat(size);\n        if (this.isPercent(size)) {\n            result = (this.containerSize() * result / 100);\n        }\n        return result;\n    }\n    emit(emitter, args) {\n        if (emitter.observers.length) {\n            this.zone.run(() => emitter.emit(args));\n        }\n    }\n}\nSplitterService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nSplitterService.ctorParameters = () => [\n    { type: NgZone }\n];\n\n/**\n * Represents the [Kendo UI Splitter component for Angular]({% slug overview_splitter %}).\n *\n * ```ts-preview\n *\n *  @Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-splitter style=\"height: 280px;\">\n *\n *          <kendo-splitter-pane [collapsible]=\"true\" size=\"30%\">\n *            <h3>Inner splitter / left pane</h3>\n *            <p>Resizable and collapsible.</p>\n *          </kendo-splitter-pane>\n *\n *          <kendo-splitter-pane>\n *            <h3>Inner splitter / center pane</h3>\n *            <p>Resizable only.</p>\n *          </kendo-splitter-pane>\n *\n *          <kendo-splitter-pane [collapsible]=\"true\" size=\"30%\">\n *            <h3>Inner splitter / right pane</h3>\n *            <p>Resizable and collapsible.</p>\n *          </kendo-splitter-pane>\n *\n *        </kendo-splitter>\n *      `,\n *    styles: [ `\n *        h3 { font-size: 1.2em; }\n *        h3, p { margin: 10px; padding: 0; }\n *    ` ]\n *  })\n *  class AppComponent {}\n * ```\n */\nclass SplitterComponent {\n    constructor(element, splitterService, localization, enclosingPane) {\n        this.element = element;\n        this.splitterService = splitterService;\n        this.localization = localization;\n        /**\n         * Specifies the orientation of the panes within the Splitter.\n         * Panes in a horizontal Splitter are placed horizontally.\n         * Panes in a vertical Splitter are placed vertically.\n         */\n        this.orientation = 'horizontal';\n        this.ariaRole = 'splitter';\n        if (enclosingPane) {\n            enclosingPane.containsSplitter = true;\n        }\n        // the handler only runs in NgZone if there are bound handlers\n        // this line merges both streams\n        this.layoutChange = this.splitterService.layoutChange;\n        this.configure = this.configure.bind(this);\n    }\n    get hostClasses() {\n        return true;\n    }\n    get horizontalHostClasses() {\n        return this.orientation === 'horizontal';\n    }\n    get verticalHostClasses() {\n        return this.orientation === 'vertical';\n    }\n    get dir() {\n        return this.direction;\n    }\n    ngAfterContentInit() {\n        this.reconfigure();\n    }\n    ngOnChanges(changes) {\n        if (changes.orientation && !changes.orientation.isFirstChange()) {\n            this.reconfigure();\n        }\n    }\n    ngOnDestroy() {\n        this.unsubscribeChanges();\n    }\n    reconfigure() {\n        this.unsubscribeChanges();\n        this.configure();\n        this.paneChangesSubscription = this.panes.changes.subscribe(this.configure);\n    }\n    unsubscribeChanges() {\n        if (this.paneChangesSubscription) {\n            this.paneChangesSubscription.unsubscribe();\n            this.paneChangesSubscription = null;\n        }\n    }\n    configure() {\n        this.splitterService.configure({\n            panes: this.panes.toArray(),\n            orientation: this.orientation,\n            containerSize: () => {\n                if (this.orientation === 'vertical') {\n                    return this.element.nativeElement.clientHeight;\n                }\n                else {\n                    return this.element.nativeElement.clientWidth;\n                }\n            }\n        });\n    }\n    get direction() {\n        return this.localization.rtl ? 'rtl' : 'ltr';\n    }\n}\nSplitterComponent.decorators = [\n    { type: Component, args: [{\n                exportAs: 'kendoSplitter',\n                selector: 'kendo-splitter',\n                providers: [\n                    SplitterService,\n                    LocalizationService,\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.spliter'\n                    }\n                ],\n                template: `\n      <ng-content select=\"kendo-splitter-pane\"></ng-content>\n      <ng-container *ngFor=\"\n        let pane of panes;\n        let index = index;\n        let last = last;\n      \">\n        <kendo-splitter-bar\n          kendoDraggable\n          *ngIf=\"!last\"\n          [index]=\"index\"\n          [orientation]=\"orientation\">\n        </kendo-splitter-bar>\n      </ng-container>\n    `\n            },] },\n];\n/** @nocollapse */\nSplitterComponent.ctorParameters = () => [\n    { type: ElementRef },\n    { type: SplitterService },\n    { type: LocalizationService },\n    { type: SplitterPaneComponent, decorators: [{ type: Optional }, { type: Host }, { type: Inject, args: [SplitterPaneComponent,] }] }\n];\nSplitterComponent.propDecorators = {\n    orientation: [{ type: Input }],\n    layoutChange: [{ type: Output }],\n    hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-splitter',] }, { type: HostBinding, args: ['class.k-splitter-flex',] }],\n    horizontalHostClasses: [{ type: HostBinding, args: ['class.k-splitter-horizontal',] }],\n    verticalHostClasses: [{ type: HostBinding, args: ['class.k-splitter-vertical',] }],\n    dir: [{ type: HostBinding, args: ['attr.dir',] }],\n    ariaRole: [{ type: HostBinding, args: ['attr.role',] }],\n    panes: [{ type: ContentChildren, args: [SplitterPaneComponent,] }]\n};\n\n/**\n * Represents the content template of the Kendo UI TabStrip.\n * To define the template, nest a `<ng-template>` tag with the `kendoTabContent` inside the component tag.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *         <kendo-tabstrip [ngStyle]=\"{'width': '400px'}\" [animate]=\"true\">\n *           <kendo-tabstrip-tab [title]=\"'Paris'\" [selected]=\"true\">\n *             <ng-template kendoTabContent>\n *               <h3>Content 1</h3>\n *             </ng-template>\n *           </kendo-tabstrip-tab>\n *\n *           <kendo-tabstrip-tab [title]=\"'Sofia'\">\n *             <ng-template kendoTabContent>\n *               <h3>Content 2</h3>\n *             </ng-template>\n *           </kendo-tabstrip-tab>\n *         </kendo-tabstrip>\n *     `\n * })\n *\n * class AppComponent {}\n *\n * ```\n */\nclass TabContentDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nTabContentDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoTabContent]'\n            },] },\n];\n/** @nocollapse */\nTabContentDirective.ctorParameters = () => [\n    { type: TemplateRef }\n];\n\n/**\n * Represents the title template of the Kendo UI TabStrip.\n * To define the template, nest a `<ng-template>` tag with the `kendoTabTitle` directive inside the component tag.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *         <kendo-tabstrip [ngStyle]=\"{'width': '400px'}\" [animate]=\"true\">\n *           <kendo-tabstrip-tab [title]=\"'Paris'\" [selected]=\"true\">\n *             <ng-template kendoTabTitle>\n *               Title\n *             </ng-template>\n *             <ng-template kendoTabContent>\n *               <h3>Content 1</h3>\n *             </ng-template>\n *           </kendo-tabstrip-tab>\n *\n *           <kendo-tabstrip-tab [title]=\"'Sofia'\">\n *             <ng-template kendoTabContent>\n *               <h3>Content 2</h3>\n *             </ng-template>\n *           </kendo-tabstrip-tab>\n *         </kendo-tabstrip>\n *     `\n * })\n *\n * class AppComponent {}\n *\n * ```\n */\nclass TabTitleDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nTabTitleDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoTabTitle]'\n            },] },\n];\n/** @nocollapse */\nTabTitleDirective.ctorParameters = () => [\n    { type: TemplateRef }\n];\n\n/**\n * Represents the tab component of the TabStrip.\n */\nclass TabStripTabComponent {\n    constructor() {\n        this.active = false;\n        this._tabContent = new QueryList();\n    }\n    get tabContent() {\n        return this._tabContent.first;\n    }\n    ngAfterContentInit() {\n        this.active = this.selected;\n    }\n    ngOnChanges(changes) {\n        if (changes['selected'] && !changes['selected'].isFirstChange()) { // tslint:disable-line\n            this.active = this.selected;\n        }\n    }\n}\nTabStripTabComponent.decorators = [\n    { type: Component, args: [{\n                exportAs: 'kendoTabStripTab',\n                selector: 'kendo-tabstrip-tab',\n                template: ``\n            },] },\n];\nTabStripTabComponent.propDecorators = {\n    title: [{ type: Input }],\n    disabled: [{ type: Input }],\n    cssClass: [{ type: Input }],\n    selected: [{ type: Input }],\n    _tabContent: [{ type: ContentChildren, args: [TabContentDirective,] }],\n    tabTitle: [{ type: ContentChild, args: [TabTitleDirective,] }]\n};\n\n/**\n * @hidden\n */\nclass PreventableEvent {\n    /**\n     * @hidden\n     */\n    constructor(args) {\n        this.prevented = false;\n        Object.assign(this, args);\n    }\n    /**\n     * Prevents the default action for a specified event.\n     * In this way, the source component suppresses\n     * the built-in behavior that follows the event.\n     */\n    preventDefault() {\n        this.prevented = true;\n    }\n    /**\n     * Returns `true` if the event was prevented\n     * by any of its subscribers.\n     *\n     * @returns `true` if the default action was prevented.\n     * Otherwise, returns `false`.\n     */\n    isDefaultPrevented() {\n        return this.prevented;\n    }\n}\n\n/**\n * Arguments for the `select` event of the TabStrip.\n * The `select` event fires when a tab is selected (clicked).\n */\nclass SelectEvent extends PreventableEvent {\n    /**\n     * Constructs the event arguments for the `select` event.\n     * @param index - The index of the selected tab.\n     * @param title - The title of the selected tab.\n     */\n    constructor(index, title) {\n        super();\n        this.index = index;\n        this.title = title;\n    }\n}\n\n/**\n * Represents the [Kendo UI TabStrip component for Angular]({% slug overview_tabstrip %}).\n */\nclass TabStripComponent {\n    constructor(localization, renderer, wrapper) {\n        this.localization = localization;\n        this.renderer = renderer;\n        this.wrapper = wrapper;\n        /**\n         * Enables the tab animation.\n         */\n        this.animate = true;\n        /**\n         * Sets the position of the tabs. Defaults to `top`.\n         */\n        this.tabPosition = 'top';\n        /**\n         * When set to `true`, the component renders all tabs and they are persisted in the DOM.\n         * By default, `keepTabContent` is `false`.\n         */\n        this.keepTabContent = false;\n        /**\n         * Fires each time the user selects a tab ([see example]({% slug overview_tabstrip %}#toc-basic-usage)).\n         * The event data contains the index of the selected tab and its title.\n         */\n        this.tabSelect = new EventEmitter();\n        this.hostClasses = true;\n        /**\n         * @hidden\n         */\n        this._animate = false;\n        this.keyBindings = this.computedKeys;\n    }\n    /**\n     * Sets the height of the TabStrip.\n     */\n    set height(value) {\n        this._height = value;\n        this.renderer.setStyle(this.wrapper.nativeElement, 'height', value);\n    }\n    get height() {\n        return this._height;\n    }\n    get tabsAtTop() {\n        return this.tabPosition === 'top';\n    }\n    get tabsAtRight() {\n        return this.tabPosition === 'right';\n    }\n    get tabsAtBottom() {\n        return this.tabPosition === 'bottom';\n    }\n    get tabsAtLeft() {\n        return this.tabPosition === 'left';\n    }\n    get dir() {\n        return this.localization.rtl ? 'rtl' : 'ltr';\n    }\n    /**\n     * @hidden\n     */\n    contentClass(active) {\n        const visible = !this.keepTabContent || active;\n        return visible ? 'k-content k-state-active' : 'k-content';\n    }\n    get computedKeys() {\n        return {\n            [this.invertKeys(Keys.ArrowLeft, Keys.ArrowRight)]: (selectedIndex) => this.prevNavigatableIndex(selectedIndex),\n            [this.invertKeys(Keys.ArrowRight, Keys.ArrowLeft)]: (selectedIndex) => this.nextNavigatableIndex(selectedIndex),\n            [this.invertKeys(Keys.ArrowDown, Keys.ArrowUp)]: (selectedIndex) => this.nextNavigatableIndex(selectedIndex),\n            [this.invertKeys(Keys.ArrowUp, Keys.ArrowDown)]: (selectedIndex) => this.prevNavigatableIndex(selectedIndex),\n            [Keys.Home]: () => this.firstNavigatableIndex(),\n            [Keys.End]: () => this.lastNavigatableIndex()\n        };\n    }\n    /**\n     * @hidden\n     */\n    get tabsAlignment() {\n        return {\n            start: 'flex-start',\n            end: 'flex-end',\n            center: 'center',\n            justify: 'space-between'\n        }[this.tabAlignment];\n    }\n    /**\n     * @hidden\n     */\n    invertKeys(original, inverted) {\n        return this.localization.rtl ? inverted : original;\n    }\n    /**\n     * @hidden\n     */\n    onKeyDown(event) {\n        if (event.currentTarget !== this.tablist.nativeElement) {\n            return;\n        }\n        const isHorizontal = this.tabPosition === 'top' || this.tabPosition === 'bottom';\n        const isArrowUp = event.keyCode === Keys.ArrowUp;\n        const isArrowDown = event.keyCode === Keys.ArrowDown;\n        const isArrowLeft = event.keyCode === Keys.ArrowLeft;\n        const isArrowRight = event.keyCode === Keys.ArrowRight;\n        if (isHorizontal && (isArrowUp || isArrowDown)) {\n            return;\n        }\n        if (!isHorizontal && (isArrowLeft || isArrowRight)) {\n            return;\n        }\n        if (event.keyCode === Keys.Space || isArrowUp || isArrowDown || isArrowLeft || isArrowRight || event.keyCode === Keys.Home ||\n            event.keyCode === Keys.End || event.keyCode === Keys.PageUp || event.keyCode === Keys.PageDown) {\n            event.preventDefault();\n        }\n        const selectedIndex = this.tabs.toArray().findIndex(tab => tab.active && !tab.disabled);\n        if (selectedIndex === -1) {\n            this.selectTab(this.firstNavigatableIndex());\n        }\n        else {\n            const getTabIndex = this.keyBindings[event.keyCode];\n            if (getTabIndex) {\n                const nextIndex = getTabIndex(selectedIndex);\n                if (selectedIndex !== nextIndex) {\n                    this.selectTab(getTabIndex(selectedIndex));\n                }\n            }\n        }\n    }\n    /**\n     * @hidden\n     */\n    tabPanelId(id) {\n        return 'k-tabstrip-tabpanel-' + id;\n    }\n    /**\n     * @hidden\n     */\n    tabId(id) {\n        return 'k-tabstrip-tab-' + id;\n    }\n    /**\n     * Allows the user to select a tab programmatically.\n     * @param {number} index - The index of the tab that will be selected.\n     */\n    selectTab(index) {\n        const tab = this.tabs.toArray()[index];\n        if (!tab || Boolean(tab.disabled)) {\n            return;\n        }\n        this.tabHeadingContainers.toArray()[index].nativeElement.focus();\n        this.emitEvent(tab, index);\n    }\n    /**\n     * @hidden\n     */\n    onTabClick(originalEvent, tabIndex) {\n        if (isFocusable(originalEvent.target)) {\n            return;\n        }\n        this.selectTab(tabIndex);\n    }\n    ngOnInit() {\n        this.localizationChangeSubscription = this.localization\n            .changes.subscribe(() => this.keyBindings = this.computedKeys);\n    }\n    ngOnDestroy() {\n        if (this.localizationChangeSubscription) {\n            this.localizationChangeSubscription.unsubscribe();\n        }\n    }\n    firstNavigatableIndex() {\n        const tabs = this.tabs.toArray();\n        for (let i = 0; i < tabs.length; i++) {\n            if (!tabs[i].disabled) {\n                return i;\n            }\n        }\n    }\n    lastNavigatableIndex() {\n        const tabs = this.tabs.toArray();\n        for (let i = tabs.length - 1; i > 0; i--) {\n            if (!tabs[i].disabled) {\n                return i;\n            }\n        }\n    }\n    prevNavigatableIndex(selectedIndex) {\n        if (selectedIndex - 1 < 0) {\n            return this.lastNavigatableIndex();\n        }\n        const tabs = this.tabs.toArray();\n        for (let i = selectedIndex - 1; i > -1; i--) {\n            if (!tabs[i].disabled) {\n                return i;\n            }\n            if (i === 0) {\n                return this.lastNavigatableIndex();\n            }\n        }\n        return selectedIndex;\n    }\n    nextNavigatableIndex(selectedIndex) {\n        if (selectedIndex + 1 >= this.tabs.length) {\n            return this.firstNavigatableIndex();\n        }\n        const tabs = this.tabs.toArray();\n        for (let i = selectedIndex + 1; i < tabs.length; i++) {\n            if (!tabs[i].disabled) {\n                return i;\n            }\n            if (i + 1 === tabs.length) {\n                return this.firstNavigatableIndex();\n            }\n        }\n    }\n    emitEvent(tab, selectedIndex) {\n        const selectArgs = new SelectEvent(selectedIndex, tab.title);\n        this.tabSelect.emit(selectArgs);\n        if (!selectArgs.isDefaultPrevented() && !tab.active) {\n            this._animate = this.animate;\n            this.deactivateAll();\n            tab.active = true;\n        }\n    }\n    deactivateAll() {\n        this.tabs.forEach((tab) => {\n            tab.active = false;\n        });\n    }\n}\nTabStripComponent.decorators = [\n    { type: Component, args: [{\n                animations: [\n                    trigger('state', [\n                        state('active', style({ opacity: 1 })),\n                        transition('* => active', [\n                            style({ opacity: 0 }),\n                            animate('400ms ease-in')\n                        ])\n                    ])\n                ],\n                providers: [\n                    LocalizationService,\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.tabstrip'\n                    }\n                ],\n                exportAs: 'kendoTabStrip',\n                selector: 'kendo-tabstrip',\n                template: `\n        <ng-container *ngIf=\"!tabsAtBottom\">\n            <ng-container *ngTemplateOutlet=\"heading\">\n            </ng-container>\n            <ng-container *ngTemplateOutlet=\"content\">\n            </ng-container>\n        </ng-container>\n\n        <ng-container *ngIf=\"tabsAtBottom\">\n            <ng-container *ngTemplateOutlet=\"content\">\n            </ng-container>\n            <ng-container *ngTemplateOutlet=\"heading\">\n            </ng-container>\n        </ng-container>\n\n        <ng-template #heading>\n            <ul\n                class=\"k-reset k-tabstrip-items\"\n                [style.justifyContent]=\"tabsAlignment\"\n                role=\"tablist\"\n                (keydown)=\"onKeyDown($event)\"\n                #tablist\n            >\n                <li *ngFor=\"let tab of tabs; let i = index;\" (click)=\"onTabClick($event, i)\"\n                    #tabHeadingContainer\n                    role=\"tab\"\n                    [id]=\"tabId(i)\"\n                    [tabIndex]=\"tab.active ? 0 : -1\"\n                    [ngClass]=\"tab.cssClass\"\n                    [class.k-item]=\"true\"\n                    [class.k-state-default]=\"true\"\n                    [class.k-state-active]=\"tab.active\"\n                    [class.k-state-disabled]=\"tab.disabled\"\n                    [attr.aria-selected]=\"tab.active\"\n                    [attr.aria-controls]=\"tabPanelId(i)\"\n                    [attr.aria-disabled]=\"tab.disabled\"\n                ><span class=\"k-link\">{{ tab.title }}<ng-template [ngTemplateOutlet]=\"tab.tabTitle?.templateRef\"></ng-template></span></li>\n            </ul>\n        </ng-template>\n        <ng-template #content>\n            <ng-template ngFor let-tab [ngForOf]=\"tabs\" let-i=\"index\">\n                <div\n                    [@state]=\"tab.active && _animate ? 'active' : 'inactive'\"\n                    *ngIf=\"tab.active || keepTabContent\"\n                    [ngClass]=\"contentClass(tab.active)\"\n                    [tabIndex]=\"0\"\n                    role=\"tabpanel\"\n                    [id]=\"tabPanelId(i)\"\n                    [attr.aria-hidden]=\"!tab.active\"\n                    [attr.aria-expanded]=\"tab.active\"\n                    [attr.aria-labelledby]=\"tabId(i)\"\n                    [attr.aria-disabled]=\"tab.disabled\"\n                >\n                    <ng-template [ngTemplateOutlet]=\"tab.tabContent?.templateRef\"></ng-template>\n                </div>\n            </ng-template>\n        </ng-template>\n    `\n            },] },\n];\n/** @nocollapse */\nTabStripComponent.ctorParameters = () => [\n    { type: LocalizationService },\n    { type: Renderer2 },\n    { type: ElementRef }\n];\nTabStripComponent.propDecorators = {\n    height: [{ type: Input }],\n    animate: [{ type: Input }],\n    tabAlignment: [{ type: Input }],\n    tabPosition: [{ type: Input }],\n    keepTabContent: [{ type: Input }],\n    tablist: [{ type: ViewChild, args: ['tablist',] }],\n    tabSelect: [{ type: Output }],\n    hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-tabstrip',] }, { type: HostBinding, args: ['class.k-floatwrap',] }, { type: HostBinding, args: ['class.k-header',] }],\n    tabsAtTop: [{ type: HostBinding, args: ['class.k-tabstrip-top',] }],\n    tabsAtRight: [{ type: HostBinding, args: ['class.k-tabstrip-right',] }],\n    tabsAtBottom: [{ type: HostBinding, args: ['class.k-tabstrip-bottom',] }],\n    tabsAtLeft: [{ type: HostBinding, args: ['class.k-tabstrip-left',] }],\n    dir: [{ type: HostBinding, args: ['attr.dir',] }],\n    tabs: [{ type: ContentChildren, args: [TabStripTabComponent,] }],\n    tabHeadingContainers: [{ type: ViewChildren, args: ['tabHeadingContainer',] }]\n};\n\n/**\n * Represents a template that defines the content of the Drawer.\n * To define the template, nest an `<ng-template>` tag\n * with the `kendoDrawerTemplate` directive inside the `<kendo-drawer>` tag.\n * Using this template directive will override all other templates,\n * for example, `kendoDrawerHeaderTemplate` and `kendoDrawerItemTemplate`.\n */\nclass DrawerTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nDrawerTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoDrawerTemplate]'\n            },] },\n];\n/** @nocollapse */\nDrawerTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef, decorators: [{ type: Optional }] }\n];\n\n/**\n * Represents a template that defines the item content of the Drawer.\n * To define the template, nest an `<ng-template>` tag\n * with the `kendoDrawerItemTemplate` directive inside the `<kendo-drawer>` tag.\n */\nclass DrawerItemTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nDrawerItemTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoDrawerItemTemplate]'\n            },] },\n];\n/** @nocollapse */\nDrawerItemTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef, decorators: [{ type: Optional }] }\n];\n\n/**\n * Represents a template that defines the header content of the Drawer.\n * To define the template, nest an `<ng-template>` tag\n * with the `kendoDrawerHeaderTemplate` directive inside the `<kendo-drawer>` tag.\n */\nclass DrawerHeaderTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nDrawerHeaderTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoDrawerHeaderTemplate]'\n            },] },\n];\n/** @nocollapse */\nDrawerHeaderTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef, decorators: [{ type: Optional }] }\n];\n\n/**\n * Represents a template that defines the footer content of the Drawer.\n * To define the template, nest an `<ng-template>` tag\n * with the `kendoDrawerFooterTemplate` directive inside the `<kendo-drawer>` tag.\n */\nclass DrawerFooterTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nDrawerFooterTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoDrawerFooterTemplate]'\n            },] },\n];\n/** @nocollapse */\nDrawerFooterTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef, decorators: [{ type: Optional }] }\n];\n\n/**\n * @hidden\n */\nfunction miniExpandPush(duration, width, miniWidth) {\n    return [\n        style({ overflow: 'hidden', flexBasis: `${miniWidth}px` }),\n        animate(`${duration}ms ease-in`, style({ flexBasis: `${width}px` }))\n    ];\n}\n/**\n * @hidden\n */\nfunction miniCollapsePush(duration, width, miniWidth) {\n    return [\n        style({ overflow: 'hidden', flexBasis: `${width}px` }),\n        animate(`${duration}ms ease-in`, style({ flexBasis: `${miniWidth}px` }))\n    ];\n}\n/**\n * @hidden\n *\n */\nfunction miniExpandOverlay(duration, width, miniWidth) {\n    return [\n        style({ width: `${miniWidth}px` }),\n        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', width: `${width}px` }))\n    ];\n}\n/**\n * @hidden\n */\nfunction expandPush(duration, width) {\n    return [\n        style({ overflow: 'hidden', flexBasis: '0px' }),\n        animate(`${duration}ms ease-in`, style({ flexBasis: `${width}px` }))\n    ];\n}\n/**\n * @hidden\n */\nfunction collapsePush(duration, width) {\n    return [\n        style({ flexBasis: `${width}px` }),\n        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', flexBasis: `0px` }))\n    ];\n}\n/**\n * @hidden\n */\nfunction expandRTLOverlay(duration) {\n    return [\n        style({ transform: `translateX(100%)` }),\n        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', transform: `translateX(0)` }))\n    ];\n}\n/**\n * @hidden\n */\nfunction expandOverlay(duration, position) {\n    const translateDir = position !== 'end' ? `-100%` : `100%`;\n    return [\n        style({ transform: `translateX(${translateDir})` }),\n        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', transform: `translateX(0)` }))\n    ];\n}\n/**\n * @hidden\n */\nfunction miniCollapseOverlay(duration, width, miniWidth) {\n    return [\n        style({ width: `${width}px` }),\n        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', width: `${miniWidth}px` }))\n    ];\n}\n/**\n * @hidden\n */\nfunction collapseOverlay(duration, position) {\n    const translateDir = position !== 'end' ? '-100%' : '100%';\n    return [\n        style({ transform: `translateX(0)` }),\n        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', transform: `translateX(${translateDir})` }))\n    ];\n}\n/**\n * @hidden\n */\nfunction collapseRTLOverlay(duration) {\n    return [\n        style({ transform: `translateX(0)` }),\n        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', transform: `translateX(100%)` }))\n    ];\n}\n/**\n * @hidden\n */\nfunction expandAnimation(settings) {\n    const duration = settings.animation.duration;\n    const width = settings.width;\n    const miniWidth = settings.miniWidth;\n    const mode = settings.mode;\n    const mini = settings.mini;\n    const rtl = settings.rtl;\n    const position = settings.position;\n    if (mini && mode === 'push') {\n        return miniExpandPush(duration, width, miniWidth);\n    }\n    if (!mini && mode === 'push') {\n        return expandPush(duration, width);\n    }\n    if (!mini && mode === 'overlay') {\n        return rtl ? expandRTLOverlay(duration) : expandOverlay(duration, position);\n    }\n    if (mini && mode === 'overlay') {\n        return miniExpandOverlay(duration, width, miniWidth);\n    }\n}\n/**\n * @hidden\n */\nfunction collapseAnimation(settings) {\n    const duration = settings.animation.duration;\n    const width = settings.width;\n    const miniWidth = settings.miniWidth;\n    const mode = settings.mode;\n    const mini = settings.mini;\n    const rtl = settings.rtl;\n    const position = settings.position;\n    if (mini && mode === 'push') {\n        return miniCollapsePush(duration, width, miniWidth);\n    }\n    if (!mini && mode === 'push') {\n        return collapsePush(duration, width);\n    }\n    if (!mini && mode === 'overlay') {\n        return rtl ? collapseRTLOverlay(duration) : collapseOverlay(duration, position);\n    }\n    if (mini && mode === 'overlay') {\n        return miniCollapseOverlay(duration, width, miniWidth);\n    }\n}\n\n/**\n * Arguments for the `select` event of the Drawer.\n */\nclass DrawerSelectEvent extends PreventableEvent {\n}\n\n/**\n * @hidden\n */\nclass DrawerService {\n    constructor() {\n        this.selectedIndices = [];\n    }\n    emit(event, args) {\n        const drawer = this.owner;\n        const eventArgs = new DrawerSelectEvent(Object.assign({}, args, { sender: drawer }));\n        if (hasObservers(drawer[event])) {\n            drawer[event].emit(eventArgs);\n        }\n        return eventArgs.isDefaultPrevented();\n    }\n    onSelect(selectedIdx) {\n        this.selectedIndices = [selectedIdx];\n        const drawer = this.owner;\n        if (drawer.autoCollapse && !drawer.minimized) {\n            drawer.toggle(false);\n        }\n    }\n    initSelection() {\n        const items = this.owner.items;\n        this.selectedIndices = [];\n        for (let i = 0; i < items.length; i++) {\n            if (items[i].selected) {\n                this.selectedIndices.push(i);\n            }\n        }\n    }\n}\nDrawerService.decorators = [\n    { type: Injectable },\n];\n\nconst DEFAULT_ANIMATION = { type: 'slide', duration: 200 };\n/**\n * Represents the [Kendo UI Drawer component for Angular]({% slug overview_drawer %}).\n *\n * @example\n * ```ts-preview\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-drawer [items]=\"items\">\n *        </kendo-drawer>\n *    `\n * })\n * class AppComponent {\n *    public items: any[] = [{ text: 'Inbox', icon: 'k-i-inbox' }];\n * }\n * ```\n */\nclass DrawerComponent {\n    constructor(element, builder, localizationService, drawerService) {\n        this.element = element;\n        this.builder = builder;\n        this.localizationService = localizationService;\n        this.drawerService = drawerService;\n        this.hostClasses = true;\n        /**\n         * Specifies the mode in which the Drawer will be displayed.\n         *\n         * The possible values are:\n         * * (Default) `overlay`\n         * * `push`\n         */\n        this.mode = 'overlay';\n        /**\n         * Specifies the position of the Drawer\n         * ([see example]({% slug positioning_drawer %})).\n         *\n         * The possible values are:\n         * * (Default) `start`\n         * * `end`\n         */\n        this.position = 'start';\n        /**\n         * Enables the mini (compact) view of the Drawer which is displayed when the component is collapsed\n         * ([see example]({% slug expandmodespositions_drawer %}#toc-mini-view)).\n         */\n        this.mini = false;\n        /**\n         * Specifies the state of the Drawer.\n         */\n        this.expanded = false;\n        /**\n         * Defines the width of the Drawer when it is expanded.\n         * Defaults to `240`.\n         */\n        this.width = 240;\n        /**\n         * Defines the width of the Drawer when the mini view is enabled\n         * and the component is collapsed. Defaults to `60`.\n         */\n        this.miniWidth = 50;\n        /**\n         * Specifies if the Drawer will be automatically collapsed when an item\n         * or the overlay is clicked. Defaults to `true`.\n         */\n        this.autoCollapse = true;\n        /**\n         * Specifies the animation settings of the Drawer.\n         * ([see example]({% slug interaction_drawer %}#toc-toggling-between-states)).\n         *\n         * The possible values are:\n         * * Boolean\n         *    * (Default) `true`\n         *    * `false`\n         * * `DrawerAnimation`\n         *    * (Default) `type?: 'slide'`\n         *    * `duration`&mdash;Accepts a number in milliseconds. Defaults to `300ms`.\n         */\n        this.animation = DEFAULT_ANIMATION;\n        /**\n         * Fires when the Drawer is expanded and its animation is complete.\n         */\n        this.expand = new EventEmitter();\n        /**\n         * Fires when the Drawer is collapsed and its animation is complete.\n         */\n        this.collapse = new EventEmitter();\n        /**\n         * Fires when a Drawer item is selected. This event is preventable.\n         */\n        this.select = new EventEmitter();\n        /**\n         * Fires when the `expanded` property of the component was updated.\n         * Used to provide a two-way binding for the `expanded` property.\n         */\n        this.expandedChange = new EventEmitter();\n        this.animationEnd = new EventEmitter();\n        this.rtl = false;\n        this._items = [];\n        this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({ rtl }) => {\n            this.rtl = rtl;\n            this.direction = this.rtl ? 'rtl' : 'ltr';\n        });\n        this.drawerService.owner = this;\n    }\n    get startPositionClass() {\n        return this.position === 'start';\n    }\n    get endPositionClass() {\n        return this.position === 'end';\n    }\n    get overlayTransofrmStyles() {\n        if (this.mode === 'push') {\n            return;\n        }\n        if (this.expanded || this.minimized) {\n            return `translateX(0px)`;\n        }\n        return `translateX(-100%)`;\n    }\n    get flexStyles() {\n        if (this.mode === 'overlay') {\n            return;\n        }\n        if (!this.expanded && !this.minimized) {\n            return 0;\n        }\n        return this.drawerWidth;\n    }\n    /**\n     * The collection of items that will be rendered in the Drawer.\n     */\n    set items(items) {\n        if (isPresent(items) && items.length > 0) {\n            this._items = items;\n            this.drawerService.initSelection();\n        }\n    }\n    get items() {\n        return this._items;\n    }\n    ngOnDestroy() {\n        if (this.dynamicRTLSubscription) {\n            this.dynamicRTLSubscription.unsubscribe();\n        }\n    }\n    /**\n     * @hidden\n     */\n    get minimized() {\n        return this.mini && !this.expanded;\n    }\n    /**\n     * @hidden\n     */\n    get drawerWidth() {\n        return this.minimized ? this.miniWidth : this.width;\n    }\n    /**\n     * Toggles the visibility of the Drawer.\n     *\n     * @param expanded? - Boolean. Specifies if the Drawer will be expanded or collapsed.\n     */\n    toggle(expanded) {\n        const previous = this.expanded;\n        const current = isPresent(expanded) ? expanded : !previous;\n        if (current === previous) {\n            return;\n        }\n        if (current === true) {\n            this.setExpanded(true);\n        }\n        else if (current === false && !this.animation) {\n            this.setExpanded(false);\n        }\n        if (this.animation) {\n            this.animationEnd.pipe(take(1))\n                .subscribe(() => { this.onAnimationEnd(current); });\n            this.animate(current);\n        }\n        else {\n            this[current ? 'expand' : 'collapse'].emit();\n        }\n    }\n    onAnimationEnd(currentExpanded) {\n        if (currentExpanded) {\n            this.expand.emit();\n        }\n        else {\n            this.setExpanded(false);\n            this.collapse.emit();\n        }\n    }\n    setExpanded(value) {\n        this.expanded = value;\n        this.expandedChange.emit(value);\n    }\n    animate(expanded) {\n        const settings = {\n            mode: this.mode,\n            mini: this.mini,\n            miniWidth: this.miniWidth,\n            width: this.width,\n            rtl: this.rtl,\n            position: this.position,\n            animation: (typeof this.animation !== 'boolean') ? this.animation : DEFAULT_ANIMATION\n        };\n        const animation = expanded ? expandAnimation(settings) : collapseAnimation(settings);\n        const player = this.createPlayer(animation, this.element.nativeElement);\n        player.play();\n    }\n    createPlayer(animation, animatedElement) {\n        const factory = this.builder.build(animation);\n        let player = factory.create(animatedElement);\n        player.onDone(() => {\n            if (player) {\n                this.animationEnd.emit();\n                player.destroy();\n                player = null;\n            }\n        });\n        return player;\n    }\n}\nDrawerComponent.decorators = [\n    { type: Component, args: [{\n                exportAs: 'kendoDrawer',\n                providers: [\n                    LocalizationService,\n                    DrawerService,\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.drawer'\n                    }\n                ],\n                selector: 'kendo-drawer',\n                template: `\n        <div class=\"k-drawer-wrapper\" *ngIf=\"expanded || mini\" [style.width.px]=\"drawerWidth\">\n            <ng-container *ngIf=\"!drawerTemplate\">\n                <ng-template *ngIf=\"headerTemplate\"\n                    [ngTemplateOutlet]=\"headerTemplate?.templateRef\">\n                </ng-template>\n\n                <ul kendoDrawerList\n                    [items]=\"items\" [mini]=\"mini\" [expanded]=\"expanded\"\n                    [itemTemplate]=\"itemTemplate?.templateRef\"\n                    class=\"k-drawer-items\">\n                </ul>\n\n                <ng-template *ngIf=\"footerTemplate\"\n                    [ngTemplateOutlet]=\"footerTemplate?.templateRef\">\n                </ng-template>\n            </ng-container>\n\n            <ng-template *ngIf=\"drawerTemplate\"\n                [ngTemplateOutlet]=\"drawerTemplate?.templateRef\">\n            </ng-template>\n        </div>\n    `\n            },] },\n];\n/** @nocollapse */\nDrawerComponent.ctorParameters = () => [\n    { type: ElementRef },\n    { type: AnimationBuilder },\n    { type: LocalizationService },\n    { type: DrawerService }\n];\nDrawerComponent.propDecorators = {\n    hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-drawer',] }],\n    startPositionClass: [{ type: HostBinding, args: ['class.k-drawer-start',] }],\n    endPositionClass: [{ type: HostBinding, args: ['class.k-drawer-end',] }],\n    overlayTransofrmStyles: [{ type: HostBinding, args: ['style.transform',] }],\n    flexStyles: [{ type: HostBinding, args: ['style.flexBasis.px',] }],\n    mode: [{ type: Input }],\n    position: [{ type: Input }],\n    mini: [{ type: Input }],\n    expanded: [{ type: Input }],\n    width: [{ type: Input }],\n    miniWidth: [{ type: Input }],\n    autoCollapse: [{ type: Input }],\n    items: [{ type: Input }],\n    direction: [{ type: HostBinding, args: ['attr.dir',] }],\n    animation: [{ type: Input }],\n    expand: [{ type: Output }],\n    collapse: [{ type: Output }],\n    select: [{ type: Output }],\n    expandedChange: [{ type: Output }],\n    drawerTemplate: [{ type: ContentChild, args: [DrawerTemplateDirective,] }],\n    footerTemplate: [{ type: ContentChild, args: [DrawerFooterTemplateDirective,] }],\n    headerTemplate: [{ type: ContentChild, args: [DrawerHeaderTemplateDirective,] }],\n    itemTemplate: [{ type: ContentChild, args: [DrawerItemTemplateDirective,] }]\n};\n\n/**\n * Displays images, icons or initials representing people or other entities.\n */\nclass AvatarComponent {\n    constructor() {\n        this.hostClass = true;\n        /**\n         * Sets the shape for the avatar.\n         *\n         * Possible values are:\n         * * (Default) `square`\n         * * `circle`\n         * * `rounded`\n         *\n         */\n        this.shape = 'square';\n        /**\n         * Sets the width of the avatar.\n         */\n        this.width = '32px';\n        /**\n         * Sets the height of the avatar.\n         */\n        this.height = '32px';\n    }\n    /**\n     * @hidden\n     */\n    get circleClass() {\n        return this.shape === 'circle';\n    }\n    /**\n     * @hidden\n     */\n    get roundedClass() {\n        return this.shape === 'rounded';\n    }\n    /**\n     * @hidden\n     */\n    get squareClass() {\n        return this.shape === 'square';\n    }\n    /**\n     * @hidden\n     */\n    get avatarWidth() {\n        return this.width;\n    }\n    /**\n     * @hidden\n     */\n    get avatarHeight() {\n        return this.height;\n    }\n    /**\n     * @hidden\n     */\n    get initialsAvatar() {\n        return Boolean(this.initials);\n    }\n    /**\n     * @hidden\n     */\n    get imageAvatar() {\n        return Boolean(this.imageSrc);\n    }\n    /**\n     * @hidden\n     */\n    get iconAvatar() {\n        return Boolean(this.icon || this.iconClass);\n    }\n    /**\n     * @hidden\n     */\n    get imageUrl() {\n        return `url(${this.imageSrc})`;\n    }\n    ngOnInit() {\n        this.verifyProperties();\n    }\n    /**\n     * @hidden\n     */\n    iconClasses() {\n        if (this.icon) {\n            return `k-icon k-i-${this.icon}`;\n        }\n        if (this.iconClass) {\n            return `${this.iconClass}`;\n        }\n    }\n    /**\n     * @hidden\n     */\n    get customAvatar() {\n        return !(this.imageSrc || this.initials || this.icon || this.iconClass);\n    }\n    verifyProperties() {\n        if (!isDevMode()) {\n            return;\n        }\n        const inputs = [this.icon || this.iconClass, this.imageSrc, this.initials];\n        const inputsLength = inputs.filter((value) => value).length;\n        if (inputsLength > 1) {\n            throw new Error(`\n                Invalid property configuration given.\n                The kendo-avatar component can accept only one of:\n                icon, imageSrc or initials properties.\n            `);\n        }\n    }\n}\nAvatarComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-avatar',\n                template: `\n        <ng-content *ngIf=\"customAvatar\"></ng-content>\n\n        <ng-container *ngIf=\"imageSrc\">\n            <div [style.width]=\"width\" [style.height]=\"height\" [ngStyle]=\"cssStyle\" [style.backgroundImage]=\"imageUrl\"></div>\n        </ng-container>\n\n        <ng-container *ngIf=\"initials\">\n            <span [ngStyle]=\"cssStyle\">{{ initials.substring(0, 2) }}</span>\n        </ng-container>\n\n        <ng-container *ngIf=\"icon || iconClass\">\n            <span [ngStyle]=\"cssStyle\" [ngClass]=\"iconClasses()\"></span>\n        </ng-container>\n    `\n            },] },\n];\nAvatarComponent.propDecorators = {\n    hostClass: [{ type: HostBinding, args: ['class.k-avatar',] }],\n    shape: [{ type: Input }],\n    circleClass: [{ type: HostBinding, args: ['class.k-avatar-circle',] }],\n    roundedClass: [{ type: HostBinding, args: ['class.k-avatar-rounded',] }],\n    squareClass: [{ type: HostBinding, args: ['class.k-avatar-square',] }],\n    iconClass: [{ type: Input }],\n    width: [{ type: Input }],\n    avatarWidth: [{ type: HostBinding, args: ['style.width',] }],\n    height: [{ type: Input }],\n    avatarHeight: [{ type: HostBinding, args: ['style.height',] }],\n    initialsAvatar: [{ type: HostBinding, args: ['class.k-avatar-initials',] }],\n    imageAvatar: [{ type: HostBinding, args: ['class.k-avatar-image',] }],\n    iconAvatar: [{ type: HostBinding, args: ['class.k-avatar-icon',] }],\n    cssStyle: [{ type: Input }],\n    initials: [{ type: Input }],\n    icon: [{ type: Input }],\n    imageSrc: [{ type: Input }]\n};\n\n/**\n * Represents the [Kendo UI Card component for Angular]({% slug overview_card %})\n */\nclass CardComponent {\n    constructor(localizationService) {\n        this.localizationService = localizationService;\n        this.hostClass = true;\n        /**\n         * Specifies the layout of the Card content.\n         *\n         * The possible values are:\n         * * (Default) `vertical`\n         * * `horizontal`\n         *\n         */\n        this.orientation = 'vertical';\n        /**\n         * Defines the width of the Card.\n         * Defaults to `285px`.\n         */\n        this.width = '285px';\n        this.rtl = false;\n        this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({ rtl }) => {\n            this.rtl = rtl;\n            this.direction = this.rtl ? 'rtl' : 'ltr';\n        });\n    }\n    get widthStyle() {\n        return this.width;\n    }\n    get vertical() {\n        return this.orientation === 'vertical';\n    }\n    get horizontal() {\n        return this.orientation === 'horizontal';\n    }\n    ngOnDestroy() {\n        if (this.dynamicRTLSubscription) {\n            this.dynamicRTLSubscription.unsubscribe();\n        }\n    }\n}\nCardComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-card',\n                providers: [\n                    LocalizationService,\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.card.component'\n                    }\n                ],\n                template: `\n        <ng-content></ng-content>\n    `\n            },] },\n];\n/** @nocollapse */\nCardComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\nCardComponent.propDecorators = {\n    hostClass: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-card',] }],\n    widthStyle: [{ type: HostBinding, args: ['style.width',] }],\n    vertical: [{ type: HostBinding, args: ['class.k-card-vertical',] }],\n    horizontal: [{ type: HostBinding, args: ['class.k-card-horizontal',] }],\n    direction: [{ type: HostBinding, args: ['attr.dir',] }],\n    orientation: [{ type: Input }],\n    width: [{ type: Input }]\n};\n\n/**\n * Specifies the content in the Card header.\n */\nclass CardHeaderComponent {\n    constructor() {\n        this.hostClass = true;\n    }\n}\nCardHeaderComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-card-header',\n                template: `\n        <ng-content></ng-content>\n    `\n            },] },\n];\nCardHeaderComponent.propDecorators = {\n    hostClass: [{ type: HostBinding, args: ['class.k-card-header',] }]\n};\n\n/**\n * Specifies the content in the Card body.\n */\nclass CardBodyComponent {\n    constructor() {\n        this.hostClass = true;\n    }\n}\nCardBodyComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-card-body',\n                template: `\n        <ng-content></ng-content>\n    `\n            },] },\n];\nCardBodyComponent.propDecorators = {\n    hostClass: [{ type: HostBinding, args: ['class.k-card-body',] }]\n};\n\n/**\n * Specifies the content in the Card footer.\n */\nclass CardFooterComponent {\n    constructor() {\n        this.hostClass = true;\n    }\n}\nCardFooterComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-card-footer',\n                template: `\n        <ng-content></ng-content>\n    `\n            },] },\n];\nCardFooterComponent.propDecorators = {\n    hostClass: [{ type: HostBinding, args: ['class.k-card-footer',] }]\n};\n\n/**\n * Specifies the action buttons of the Card.\n * * ([see example]({% slug actions_card %})).\n */\nclass CardActionsComponent {\n    constructor() {\n        this.hostClass = true;\n        /**\n         * Specifies the layout of the Card action buttons.\n         *\n         * * The possible values are:\n         * * (Default) `horizontal`\n         * * `vertical`\n         *\n         */\n        this.orientation = 'horizontal';\n        /**\n         * Specifies the layout of the Card action buttons.\n         *\n         * The possible values are:\n         * * (Default) `start`\n         * * `center`\n         * * `end`\n         * * `stretched`\n         *\n         */\n        this.layout = 'start';\n        /**\n         * Fires when the user clicks an action button.\n         */\n        this.action = new EventEmitter();\n    }\n    get stretchedClass() {\n        return this.layout === 'stretched';\n    }\n    get startClass() {\n        return this.layout === 'start';\n    }\n    get endClass() {\n        return this.layout === 'end';\n    }\n    get centerClass() {\n        return this.layout === 'center';\n    }\n    get verticalClass() {\n        return this.orientation === 'vertical';\n    }\n    get horizontalClass() {\n        return this.orientation === 'horizontal';\n    }\n    /**\n     * @hidden\n     */\n    onClick(action) {\n        this.action.emit(action);\n    }\n    /**\n     * @hidden\n     */\n    actionTemplate() {\n        return this.actions instanceof TemplateRef;\n    }\n}\nCardActionsComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-card-actions',\n                template: `\n        <ng-content *ngIf=\"!actions\"></ng-content>\n\n        <ng-container *ngIf=\"!actionTemplate()\">\n            <button type=\"button\"\n                class=\"k-button\"\n                [class.k-primary]=\"action.primary\"\n                [class.k-flat]=\"action.flat\"\n                (click)=\"onClick(action)\"\n                *ngFor=\"let action of actions\"\n            >\n                {{ action.text }}\n            </button>\n        </ng-container>\n\n        <ng-template [ngTemplateOutlet]=\"actions\" *ngIf=\"actionTemplate()\"></ng-template>\n    `\n            },] },\n];\nCardActionsComponent.propDecorators = {\n    hostClass: [{ type: HostBinding, args: ['class.k-card-actions',] }],\n    stretchedClass: [{ type: HostBinding, args: ['class.k-card-actions-stretched',] }],\n    startClass: [{ type: HostBinding, args: ['class.k-card-actions-start',] }],\n    endClass: [{ type: HostBinding, args: ['class.k-card-actions-end',] }],\n    centerClass: [{ type: HostBinding, args: ['class.k-card-actions-center',] }],\n    verticalClass: [{ type: HostBinding, args: ['class.k-card-actions-vertical',] }],\n    horizontalClass: [{ type: HostBinding, args: ['class.k-card-actions-horizontal',] }],\n    orientation: [{ type: Input }],\n    layout: [{ type: Input }],\n    actions: [{ type: Input }],\n    action: [{ type: Output }]\n};\n\n/**\n * Specifies a separator in the content of the Card.\n */\nclass CardSeparatorDirective {\n    constructor() {\n        this.hostClass = true;\n        /**\n         * Specifies the orientation of the Card separator.\n         *\n         * The possible values are:\n         * (Default) `horizontal`\n         * `vertical`\n         */\n        this.orientation = 'horizontal';\n    }\n    get verticalClass() {\n        return this.orientation === 'vertical';\n    }\n    get horizontalClass() {\n        return this.orientation === 'horizontal';\n    }\n}\nCardSeparatorDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoCardSeparator]'\n            },] },\n];\nCardSeparatorDirective.propDecorators = {\n    hostClass: [{ type: HostBinding, args: ['class.k-card-separator',] }],\n    verticalClass: [{ type: HostBinding, args: ['class.k-separator-vertical',] }],\n    horizontalClass: [{ type: HostBinding, args: ['class.k-separator-horizontal',] }],\n    color: [{ type: HostBinding, args: ['style.color',] }, { type: Input }],\n    orientation: [{ type: Input }]\n};\n\n/**\n * Specifies the text and styles for the title of the Card.\n */\nclass CardTitleDirective {\n    constructor() {\n        this.hostClass = true;\n    }\n}\nCardTitleDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoCardTitle]'\n            },] },\n];\nCardTitleDirective.propDecorators = {\n    hostClass: [{ type: HostBinding, args: ['class.k-card-title',] }]\n};\n\n/**\n * Specifies the text and styles for the subtitle of the Card.\n */\nclass CardSubtitleDirective {\n    constructor() {\n        this.hostClass = true;\n    }\n}\nCardSubtitleDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoCardSubtitle]'\n            },] },\n];\nCardSubtitleDirective.propDecorators = {\n    hostClass: [{ type: HostBinding, args: ['class.k-card-subtitle',] }]\n};\n\n/**\n * Specifies any media that will be displayed and aligned in the Card.\n */\nclass CardMediaDirective {\n    constructor() {\n        this.hostClass = true;\n    }\n}\nCardMediaDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoCardMedia]'\n            },] },\n];\nCardMediaDirective.propDecorators = {\n    hostClass: [{ type: HostBinding, args: ['class.k-card-media',] }]\n};\n\n/**\n * The settings of the Card action buttons.\n */\nclass CardAction {\n}\n\nconst exportedModules = [\n    PanelBarComponent,\n    PanelBarItemComponent,\n    PanelBarContentDirective,\n    PanelBarItemTemplateDirective,\n    PanelBarItemTitleDirective\n];\nconst declarations = [\n    ...exportedModules\n];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the PanelBar component.\n *\n * The module registers:\n * - `PanelBarComponent`&mdash;The `PanelBar` component class.\n * - `PanelBarItemComponent`&mdash;The `PanelBarItem` component class.\n * - `PanelBarContentComponent`&mdash;The `PanelBarContent` component class.\n * - `PanelBarItemTemplateDirective&mdash;The `PanelBarItemTemplate` directive.\n * - `PanelBarItemTitleDirective&mdash;The `PanelBarItemTitle` directive.\n */\nclass PanelBarModule {\n}\nPanelBarModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [declarations],\n                exports: [exportedModules],\n                imports: [CommonModule]\n            },] },\n];\n\nconst stopPropagation = ({ originalEvent: event }) => {\n    event.stopPropagation();\n    event.preventDefault();\n};\nconst preventOnDblClick = release => mouseDown => of(mouseDown).pipe(delay(150), takeUntil(release));\nconst classFromObject = classes => Object.keys(classes).filter(c => classes[c]).join(' ');\nconst createMoveStream = (draggable) => mouseDown => draggable.kendoDrag\n    .pipe(takeUntil(draggable.kendoRelease), map(({ pageX, pageY }) => ({\n    originalX: mouseDown.pageX,\n    originalY: mouseDown.pageY,\n    pageX,\n    pageY\n})));\n/**\n * @hidden\n */\nclass SplitterBarComponent {\n    constructor(draggable, splitter, localization) {\n        this.draggable = draggable;\n        this.splitter = splitter;\n        this.localization = localization;\n        this.orientation = 'horizontal';\n        this.index = 0;\n        this.ariaRole = 'separator';\n        this.focused = false;\n        this.subscriptions = new Subscription();\n    }\n    get direction() {\n        return this.localization.rtl ? 'rtl' : 'ltr';\n    }\n    get tabIndex() {\n        return this.splitter.isStatic(this.index) ? -1 : 0;\n    }\n    get hostClasses() {\n        const isHorizontal = this.orientation === 'horizontal';\n        const isDraggable = this.splitter.isDraggable(this.index);\n        const isStatic = this.splitter.isStatic(this.index);\n        return classFromObject({\n            'k-state-focused': this.focused,\n            'k-splitbar': true,\n            'k-splitbar-horizontal': isHorizontal,\n            'k-splitbar-vertical': !isHorizontal,\n            'k-splitbar-draggable-horizontal': isHorizontal && isDraggable,\n            'k-splitbar-draggable-vertical': !isHorizontal && isDraggable,\n            'k-splitbar-static-horizontal': isHorizontal && isStatic,\n            'k-splitbar-static-vertical': !isHorizontal && isStatic\n        });\n    }\n    get touchAction() {\n        if (this.splitter.isDraggable(this.index)) {\n            return 'none';\n        }\n    }\n    get order() {\n        return 2 * this.index + 1;\n    }\n    collapseAny() {\n        this.tryToggleNearest();\n    }\n    onFocusIn() {\n        this.focused = true;\n    }\n    onFocusOut() {\n        this.focused = false;\n    }\n    onKeyDown(event) {\n        const keyCode = event && event.keyCode;\n        const isHorizontal = this.orientation === 'horizontal';\n        const resize = delta => {\n            event.preventDefault();\n            const state$$1 = this.splitter.dragState(this.index);\n            this.splitter.setSize(state$$1, delta);\n        };\n        if (keyCode === Keys.Enter) {\n            event.preventDefault();\n            this.tryToggleNearest();\n        }\n        else if (isHorizontal && keyCode === Keys.ArrowLeft) {\n            resize(-10);\n        }\n        else if (isHorizontal && keyCode === Keys.ArrowRight) {\n            resize(10);\n        }\n        else if (!isHorizontal && keyCode === Keys.ArrowUp) {\n            resize(-10);\n        }\n        else if (!isHorizontal && keyCode === Keys.ArrowDown) {\n            resize(10);\n        }\n    }\n    ngOnInit() {\n        let state$$1;\n        const listener = this.draggable.kendoPress.pipe(tap(stopPropagation), filter(() => this.splitter.isDraggable(this.index)), tap(() => state$$1 = this.splitter.dragState(this.index)), tap(() => this.splitter.toggleContentOverlay(this.index, true)), switchMap(preventOnDblClick(this.draggable.kendoRelease)), switchMap(createMoveStream(this.draggable))).subscribe(({ pageX, pageY, originalX, originalY }) => {\n            let delta;\n            if (this.orientation === 'vertical') {\n                delta = pageY - originalY;\n            }\n            else if (this.direction === 'rtl') {\n                delta = originalX - pageX;\n            }\n            else {\n                delta = pageX - originalX;\n            }\n            this.splitter.setSize(state$$1, delta);\n        });\n        this.subscriptions.add(listener);\n        this.subscriptions.add(this.draggable.kendoRelease.subscribe(() => this.splitter.toggleContentOverlay(this.index, false)));\n    }\n    ngOnDestroy() {\n        if (this.subscriptions) {\n            this.subscriptions.unsubscribe();\n        }\n    }\n    togglePrevious() {\n        this.splitter.tryToggle(this.index);\n    }\n    toggleNext() {\n        this.splitter.tryToggle(this.index + 1);\n    }\n    previousArrowClass() {\n        const pane = this.splitter.pane(this.index);\n        const nextPane = this.splitter.pane(this.index + 1);\n        const isCollapsible = pane.collapsible;\n        const isCollapsed = pane.collapsed;\n        const isHorizontal = this.orientation === 'horizontal';\n        return classFromObject({\n            'k-icon': true,\n            'k-hidden': !isCollapsible || nextPane.isHidden,\n            'k-collapse-prev': isCollapsible,\n            'k-i-arrow-60-left': isCollapsible && isHorizontal && !isCollapsed,\n            'k-i-arrow-60-right': isCollapsible && isHorizontal && isCollapsed,\n            'k-i-arrow-60-up': isCollapsible && !isHorizontal && !isCollapsed,\n            'k-i-arrow-60-down': isCollapsible && !isHorizontal && isCollapsed\n        });\n    }\n    nextArrowClass() {\n        const pane = this.splitter.pane(this.index + 1);\n        const prevPane = this.splitter.pane(this.index);\n        const isCollapsible = pane.collapsible;\n        const isCollapsed = pane.collapsed;\n        const isHorizontal = this.orientation === 'horizontal';\n        return classFromObject({\n            'k-icon': true,\n            'k-hidden': !isCollapsible || prevPane.isHidden,\n            'k-collapse-next': isCollapsible,\n            'k-i-arrow-60-right': isCollapsible && isHorizontal && !isCollapsed,\n            'k-i-arrow-60-left': isCollapsible && isHorizontal && isCollapsed,\n            'k-i-arrow-60-down': isCollapsible && !isHorizontal && !isCollapsed,\n            'k-i-arrow-60-up': isCollapsible && !isHorizontal && isCollapsed\n        });\n    }\n    tryToggleNearest() {\n        const prev = this.index;\n        const next = this.index + 1;\n        if (!this.splitter.tryToggle(prev)) {\n            this.splitter.tryToggle(next);\n        }\n    }\n}\nSplitterBarComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-splitter-bar',\n                template: `\n      <div [class]=\"previousArrowClass()\" (click)=\"togglePrevious()\"></div>\n      <div class=\"k-resize-handle\"></div>\n      <div [class]=\"nextArrowClass()\" (click)=\"toggleNext()\"></div>\n    `\n            },] },\n];\n/** @nocollapse */\nSplitterBarComponent.ctorParameters = () => [\n    { type: DraggableDirective, decorators: [{ type: Host }] },\n    { type: SplitterService },\n    { type: LocalizationService }\n];\nSplitterBarComponent.propDecorators = {\n    orientation: [{ type: Input }, { type: HostBinding, args: ['attr.aria-orientation',] }],\n    index: [{ type: Input }],\n    ariaRole: [{ type: HostBinding, args: ['attr.role',] }],\n    focused: [{ type: HostBinding, args: ['class.k-state-focused',] }],\n    tabIndex: [{ type: HostBinding, args: ['attr.tabindex',] }],\n    hostClasses: [{ type: HostBinding, args: ['class',] }],\n    touchAction: [{ type: HostBinding, args: ['style.touch-action',] }],\n    order: [{ type: HostBinding, args: ['style.-ms-flex-order',] }, { type: HostBinding, args: ['style.order',] }],\n    collapseAny: [{ type: HostListener, args: ['dblclick',] }],\n    onFocusIn: [{ type: HostListener, args: ['focusin',] }],\n    onFocusOut: [{ type: HostListener, args: ['focusout',] }],\n    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]\n};\n\nconst exportedModules$1 = [\n    SplitterComponent,\n    SplitterPaneComponent\n];\nconst declarations$1 = [\n    SplitterBarComponent,\n    ...exportedModules$1\n];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Splitter component.\n *\n * The module registers:\n * - `SplitterComponent`&mdash;The `Splitter` component class.\n * - `SplitterPaneComponent`&mdash;The `SplitterPane` component class.\n */\nclass SplitterModule {\n}\nSplitterModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [declarations$1],\n                exports: [exportedModules$1],\n                imports: [\n                    CommonModule,\n                    DraggableModule\n                ]\n            },] },\n];\n\nconst exportedModules$2 = [\n    TabStripComponent,\n    TabStripTabComponent,\n    TabContentDirective,\n    TabTitleDirective\n];\nconst declarations$2 = [\n    ...exportedModules$2\n];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the TabStrip component.\n *\n * The module registers:\n * - `TabStripComponent`&mdash;The `TabStrip` component class.\n * - `TabStripTabComponent`&mdash;The `TabStripTab` component class.\n * - `TabContentDirective`&mdash;The tab content directive used on the `<ng-template>` tag.\n * - `TabTitleDirective`&mdash;The tab title directive used on the `<ng-template>` tag.\n */\nclass TabStripModule {\n}\nTabStripModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [declarations$2],\n                exports: [exportedModules$2],\n                imports: [CommonModule]\n            },] },\n];\n\n/**\n * @hidden\n */\nclass DrawerContainerComponent {\n    constructor(localizationService) {\n        this.localizationService = localizationService;\n        this.rtl = false;\n        this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({ rtl }) => {\n            this.rtl = rtl;\n            this.direction = this.rtl ? 'rtl' : 'ltr';\n        });\n    }\n    get hostClass() {\n        return true;\n    }\n    get overlayClass() {\n        return this.drawer.mode === 'overlay';\n    }\n    get miniClass() {\n        return this.drawer.mini;\n    }\n    get pushClass() {\n        return this.drawer.mode === 'push';\n    }\n    get isExpandedClass() {\n        return this.drawer.expanded;\n    }\n    ngOnDestroy() {\n        if (this.dynamicRTLSubscription) {\n            this.dynamicRTLSubscription.unsubscribe();\n        }\n    }\n    get overlay() {\n        return isPresent(this.drawer) &&\n            this.drawer.expanded &&\n            this.drawer.mode === 'overlay';\n    }\n    /**\n     * @hidden\n     */\n    closeDrawer() {\n        if (this.overlay && this.drawer.autoCollapse) {\n            this.drawer.toggle(false);\n        }\n    }\n}\nDrawerContainerComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-drawer-container',\n                providers: [\n                    LocalizationService,\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.drawer.container'\n                    }\n                ],\n                template: `\n        <div class=\"k-overlay\" *ngIf=\"overlay\" (click)=\"closeDrawer()\"></div>\n        <ng-content></ng-content>\n    `\n            },] },\n];\n/** @nocollapse */\nDrawerContainerComponent.ctorParameters = () => [\n    { type: LocalizationService }\n];\nDrawerContainerComponent.propDecorators = {\n    hostClass: [{ type: HostBinding, args: ['class.k-drawer-container',] }],\n    overlayClass: [{ type: HostBinding, args: ['class.k-drawer-overlay',] }],\n    miniClass: [{ type: HostBinding, args: ['class.k-drawer-mini',] }],\n    pushClass: [{ type: HostBinding, args: ['class.k-drawer-push',] }],\n    isExpandedClass: [{ type: HostBinding, args: ['class.k-drawer-expanded',] }],\n    direction: [{ type: HostBinding, args: ['attr.dir',] }],\n    drawer: [{ type: ContentChild, args: [DrawerComponent,] }]\n};\n\n/**\n * @hidden\n */\nclass DrawerContentComponent {\n    constructor() {\n        this.hostClasses = true;\n    }\n}\nDrawerContentComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-drawer-content',\n                template: `\n        <ng-content></ng-content>\n    `,\n                encapsulation: ViewEncapsulation.None\n            },] },\n];\n/** @nocollapse */\nDrawerContentComponent.ctorParameters = () => [];\nDrawerContentComponent.propDecorators = {\n    hostClasses: [{ type: HostBinding, args: ['class.k-drawer-content',] }]\n};\n\n/**\n * @hidden\n */\nclass DrawerItemComponent {\n    constructor(drawer) {\n        this.drawer = drawer;\n    }\n    get disabledClass() {\n        return this.item.disabled;\n    }\n    get selectedClass() {\n        return this.drawer.selectedIndices.indexOf(this.index) >= 0;\n    }\n    /**\n     * @hidden\n     */\n    iconClasses(icon) {\n        return `k-icon ${icon}`;\n    }\n}\nDrawerItemComponent.decorators = [\n    { type: Component, args: [{\n                selector: '[kendoDrawerItem]',\n                template: `\n        <ng-template *ngIf=\"itemTemplate; else defaultTemplate\"\n            [ngTemplateOutlet]=\"itemTemplate\"\n            [ngTemplateOutletContext]=\"{ $implicit: item }\">\n        </ng-template>\n\n        <ng-template #defaultTemplate>\n            <ng-container *ngIf=\"expanded\">\n                <span [ngClass]=\"iconClasses(item.icon)\"></span>\n                <span class=\"k-item-text\">{{ item.text }}</span>\n            </ng-container>\n            <ng-container *ngIf=\"mini && !expanded\">\n                <span [ngClass]=\"iconClasses(item.icon)\"></span>\n            </ng-container>\n        </ng-template>\n    `\n            },] },\n];\n/** @nocollapse */\nDrawerItemComponent.ctorParameters = () => [\n    { type: DrawerService }\n];\nDrawerItemComponent.propDecorators = {\n    item: [{ type: Input }],\n    index: [{ type: Input }],\n    itemTemplate: [{ type: Input }],\n    mini: [{ type: Input }],\n    expanded: [{ type: Input }],\n    disabled: [{ type: Input }],\n    cssClass: [{ type: Input }],\n    cssStyle: [{ type: Input }],\n    disabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }],\n    selectedClass: [{ type: HostBinding, args: ['class.k-state-selected',] }]\n};\n\n/**\n * @hidden\n */\nclass DrawerListComponent {\n    constructor(drawerService, renderer, ngZone, changeDetector, element) {\n        this.drawerService = drawerService;\n        this.renderer = renderer;\n        this.ngZone = ngZone;\n        this.changeDetector = changeDetector;\n        this.element = element;\n    }\n    ngOnInit() {\n        this.initialSelection();\n        this.initDomEvents();\n    }\n    ngOnDestroy() {\n        if (this.clickSubscription) {\n            this.clickSubscription();\n        }\n    }\n    initialSelection() {\n        /* Differentiates a user selected item */\n        if (this.drawerService.selectedIndices.length === 0) {\n            this.drawerService.initSelection();\n        }\n    }\n    initDomEvents() {\n        if (!this.element) {\n            return;\n        }\n        this.ngZone.runOutsideAngular(() => {\n            const nativeElement = this.element.nativeElement;\n            this.clickSubscription = this.renderer.listen(nativeElement, 'click', this.clickHandler.bind(this));\n        });\n    }\n    clickHandler(e) {\n        // if (isFocusable(e.target) && !hasClass(e.target, 'k-drawer-item')) {\n        //     return;\n        // }\n        const itemIdx = this.getDrawerItemIndex(e.target);\n        const item = this.items[itemIdx];\n        if (!item) {\n            return;\n        }\n        if (item.disabled) {\n            e.preventDefault();\n            return;\n        }\n        const args = {\n            index: itemIdx,\n            item: item,\n            originalEvent: e\n        };\n        this.ngZone.run(() => {\n            if (!this.drawerService.emit('select', args)) {\n                this.drawerService.onSelect(itemIdx);\n                this.changeDetector.detectChanges();\n            }\n        });\n    }\n    getDrawerItemIndex(target) {\n        const item = closestItem(target, this.element.nativeElement);\n        if (item) {\n            return itemIndex(item);\n        }\n    }\n}\nDrawerListComponent.decorators = [\n    { type: Component, args: [{\n                selector: '[kendoDrawerList]',\n                template: `\n        <ng-container *ngFor=\"let item of items; let idx = index\">\n            <li *ngIf=\"!item.separator\" kendoDrawerItem\n                class=\"k-drawer-item\"\n                [item]=\"item\"\n                [index]=\"idx\"\n                [mini]=\"mini\"\n                [expanded]=\"expanded\"\n                [itemTemplate]=\"itemTemplate\"\n                [attr.${ITEM_INDEX}]=\"idx\"\n                [ngClass]=\"item.cssClass\"\n                [ngStyle]=\"item.cssStyle\">\n            </li>\n\n            <li *ngIf=\"item.separator\"\n                class=\"k-drawer-item k-drawer-separator\"\n                [ngClass]=\"item.cssClass\"\n                [ngStyle]=\"item.cssStyle\">\n                &nbsp;\n            </li>\n        </ng-container>\n    `\n            },] },\n];\n/** @nocollapse */\nDrawerListComponent.ctorParameters = () => [\n    { type: DrawerService },\n    { type: Renderer2 },\n    { type: NgZone },\n    { type: ChangeDetectorRef },\n    { type: ElementRef }\n];\nDrawerListComponent.propDecorators = {\n    items: [{ type: Input }],\n    itemTemplate: [{ type: Input }],\n    mini: [{ type: Input }],\n    expanded: [{ type: Input }]\n};\n\nconst templateDirectives = [\n    DrawerTemplateDirective,\n    DrawerHeaderTemplateDirective,\n    DrawerFooterTemplateDirective,\n    DrawerItemTemplateDirective\n];\nconst exportedModules$3 = [\n    DrawerComponent,\n    DrawerContainerComponent,\n    DrawerContentComponent,\n    ...templateDirectives\n];\nconst declarations$3 = [\n    DrawerItemComponent,\n    DrawerListComponent,\n    ...exportedModules$3\n];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Drawer component.\n */\nclass DrawerModule {\n}\nDrawerModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [declarations$3],\n                exports: [exportedModules$3],\n                imports: [CommonModule]\n            },] },\n];\n\nconst cardDirectives = [\n    CardTitleDirective,\n    CardSubtitleDirective,\n    CardSeparatorDirective,\n    CardMediaDirective\n];\nconst exportedModules$4 = [\n    CardComponent,\n    CardHeaderComponent,\n    CardBodyComponent,\n    CardFooterComponent,\n    CardActionsComponent,\n    ...cardDirectives\n];\nconst declarations$4 = [...exportedModules$4];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Card component.\n */\nclass CardModule {\n}\nCardModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [declarations$4],\n                exports: [exportedModules$4],\n                imports: [CommonModule]\n            },] },\n];\n\nconst exportedModules$5 = [\n    AvatarComponent\n];\nconst declarations$5 = [\n    ...exportedModules$5\n];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Avatar component.\n */\nclass AvatarModule {\n}\nAvatarModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [declarations$5],\n                exports: [exportedModules$5],\n                imports: [CommonModule]\n            },] },\n];\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Layout components.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Layout module\n * import { LayoutModule } from '@progress/kendo-angular-layout';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, LayoutModule], // import Layout module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nclass LayoutModule {\n}\nLayoutModule.decorators = [\n    { type: NgModule, args: [{\n                exports: [\n                    PanelBarModule,\n                    SplitterModule,\n                    TabStripModule,\n                    DrawerModule,\n                    AvatarModule,\n                    CardModule\n                ]\n            },] },\n];\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { PreventableEvent, DrawerContainerComponent, DrawerContentComponent, DrawerService, DrawerItemComponent, DrawerListComponent, ITEM_INDEX, PanelBarService, SplitterBarComponent, SplitterService, PanelBarComponent, PanelBarItemComponent, PanelBarContentDirective, PanelBarItemTemplateDirective, PanelBarItemTitleDirective, PanelBarExpandMode, SplitterComponent, SplitterPaneComponent, TabStripComponent, TabStripTabComponent, TabContentDirective, TabTitleDirective, SelectEvent, DrawerComponent, DrawerSelectEvent, AvatarComponent, CardComponent, CardHeaderComponent, CardBodyComponent, CardFooterComponent, CardActionsComponent, CardSeparatorDirective, CardTitleDirective, CardSubtitleDirective, CardMediaDirective, CardAction, LayoutModule, PanelBarModule, SplitterModule, TabStripModule, DrawerModule, AvatarModule, CardModule, DrawerTemplateDirective, DrawerItemTemplateDirective, DrawerHeaderTemplateDirective, DrawerFooterTemplateDirective };\n"],"names":[],"mappings":"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"}