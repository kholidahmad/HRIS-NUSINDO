{"version":3,"file":"index.js","sources":["D:/project/projek_angular/hris_rni/node_modules/@progress/kendo-angular-popup/dist/fesm5/index.js"],"sourcesContent":["/**-----------------------------------------------------------------------------------------\n* Copyright Â© 2020 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport { ApplicationRef, Component, ComponentFactoryResolver, ElementRef, EventEmitter, Inject, Injectable, InjectionToken, Injector, Input, NgModule, NgZone, Optional, Output, Renderer2, TemplateRef, ViewChild, isDevMode } from '@angular/core';\nimport { addScroll, align, boundingOffset, getWindowViewPort, offset, parents, positionWithScroll, removeScroll, restrictToView, scrollPosition, siblingContainer } from '@progress/kendo-popup-common';\nimport { ResizeSensorComponent, ResizeSensorModule, hasObservers, isDocumentAvailable } from '@progress/kendo-angular-common';\nimport { from, fromEvent, merge } from 'rxjs';\nimport { auditTime } from 'rxjs/operators';\nimport { AnimationBuilder, animate, style } from '@angular/animations';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @hidden\n */\nvar eitherRect = function (rect, offset$$1) {\n    if (!rect) {\n        return { height: 0, left: offset$$1.left, top: offset$$1.top, width: 0 };\n    }\n    return rect;\n};\n/**\n * @hidden\n */\n\n/**\n * @hidden\n */\nvar removeStackingOffset = function (rect, stackingOffset) {\n    if (!stackingOffset) {\n        return rect;\n    }\n    var result = {\n        height: rect.height,\n        left: rect.left - stackingOffset.left,\n        top: rect.top - stackingOffset.top,\n        width: rect.width\n    };\n    return result;\n};\n/**\n * @hidden\n */\nvar isDifferentOffset = function (oldOffset, newOffset) {\n    var oldLeft = oldOffset.left, oldTop = oldOffset.top;\n    var newLeft = newOffset.left, newTop = newOffset.top;\n    return Math.abs(oldLeft - newLeft) >= 1 || Math.abs(oldTop - newTop) >= 1;\n};\n/**\n * @hidden\n */\nvar isWindowAvailable = function () {\n    return typeof window !== 'undefined';\n};\n/**\n * @hidden\n */\n\n/**\n * @hidden\n */\nvar OVERFLOW_REGEXP = /auto|scroll/;\nvar overflowElementStyle = function (element) {\n    return \"\" + element.style.overflow + element.style.overflowX + element.style.overflowY;\n};\nvar overflowComputedStyle = function (element) {\n    var styles = window.getComputedStyle(element);\n    return \"\" + styles.overflow + styles.overflowX + styles.overflowY;\n};\nvar overflowStyle = function (element) {\n    return overflowElementStyle(element) || overflowComputedStyle(element);\n};\n/**\n * @hidden\n */\nvar scrollableParents = function (element) {\n    var parentElements = [];\n    if (!isDocumentAvailable() || !isWindowAvailable()) {\n        return parentElements;\n    }\n    var parent = element.parentElement;\n    while (parent) {\n        if (OVERFLOW_REGEXP.test(overflowStyle(parent)) || parent.hasAttribute('data-scrollable')) {\n            parentElements.push(parent);\n        }\n        parent = parent.parentElement;\n    }\n    parentElements.push(window);\n    return parentElements;\n};\n/**\n * @hidden\n */\nvar FRAME_DURATION = 1000 / 60; //1000ms divided by 60fps\nfunction memoize(fun) {\n    var result;\n    var called = false;\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (called) {\n            return result;\n        }\n        result = fun.apply(void 0, args);\n        called = true;\n        return result;\n    };\n}\n/**\n * @hidden\n */\nvar hasRelativeStackingContext = memoize(function () {\n    if (!isDocumentAvailable() && document.body !== null) {\n        return false;\n    }\n    var top = 10;\n    var parent = document.createElement(\"div\");\n    parent.style.transform = \"matrix(10, 0, 0, 10, 0, 0)\";\n    parent.innerHTML = \"<div style=\\\"position: fixed; top: \" + top + \"px;\\\">child</div>\";\n    document.body.appendChild(parent);\n    var isDifferent = parent.children[0].getBoundingClientRect().top !== top;\n    document.body.removeChild(parent);\n    return isDifferent;\n});\n/**\n * @hidden\n */\nvar zIndex = function (anchor, container) {\n    if (!anchor || !isDocumentAvailable() || !isWindowAvailable()) {\n        return null;\n    }\n    var sibling = siblingContainer(anchor, container);\n    if (!sibling) {\n        return null;\n    }\n    var result = [anchor].concat(parents(anchor, sibling)).reduce(function (index, p) {\n        var zIndexStyle = p.style.zIndex || window.getComputedStyle(p).zIndex;\n        var current = parseInt(zIndexStyle, 10);\n        return current > index ? current : index;\n    }, 0);\n    return result ? (result + 1) : null;\n};\n/**\n * @hidden\n */\nvar scaleRect = function (rect, scale) {\n    if (!rect || scale === 1) {\n        return rect;\n    }\n    return {\n        height: rect.height / scale,\n        left: rect.left / scale,\n        top: rect.top / scale,\n        width: rect.width / scale\n    };\n};\n\nvar STYLES = [\n    'font-size',\n    'font-family',\n    'font-stretch',\n    'font-style',\n    'font-weight',\n    'line-height'\n];\n/**\n * @hidden\n */\nvar DOMService = /** @class */ (function () {\n    function DOMService() {\n    }\n    DOMService.prototype.addOffset = function (current, addition) {\n        return {\n            left: current.left + addition.left,\n            top: current.top + addition.top\n        };\n    };\n    DOMService.prototype.addScroll = function (rect, scroll) {\n        return addScroll(rect, scroll);\n    };\n    DOMService.prototype.align = function (settings) {\n        return align(settings);\n    };\n    DOMService.prototype.boundingOffset = function (el) {\n        return boundingOffset(this.nativeElement(el));\n    };\n    DOMService.prototype.getFontStyles = function (el) {\n        var window = this.getWindow();\n        if (!window || !el) {\n            return [];\n        }\n        var computedStyles = window.getComputedStyle(this.nativeElement(el));\n        return STYLES.map(function (font) { return ({ key: font, value: computedStyles[font] }); });\n    };\n    DOMService.prototype.getWindow = function () {\n        return isWindowAvailable() ? window : null;\n    };\n    DOMService.prototype.hasOffsetParent = function (el) {\n        if (!el) {\n            return false;\n        }\n        return !!this.nativeElement(el).offsetParent;\n    };\n    DOMService.prototype.offset = function (el) {\n        if (!el) {\n            return null;\n        }\n        return offset(this.nativeElement(el));\n    };\n    DOMService.prototype.offsetAtPoint = function (el, currentLocation) {\n        if (!el) {\n            return null;\n        }\n        var element = this.nativeElement(el);\n        var _a = element.style, left = _a.left, top = _a.top, transition = _a.transition;\n        element.style.transition = 'none';\n        element.style.left = currentLocation.left + \"px\";\n        element.style.top = currentLocation.top + \"px\";\n        var currentOffset = offset(element);\n        element.style.left = left;\n        element.style.top = top;\n        // prevents elements with transition to be animated because of the change\n        // tslint:disable-next-line:no-unused-expression\n        element.offsetHeight;\n        element.style.transition = transition;\n        return currentOffset;\n    };\n    DOMService.prototype.nativeElement = function (el) {\n        if (!el) {\n            return null;\n        }\n        return el.nativeElement || el;\n    };\n    DOMService.prototype.position = function (element, popup, scale) {\n        if (scale === void 0) { scale = 1; }\n        if (!element || !popup) {\n            return null;\n        }\n        return positionWithScroll(this.nativeElement(element), this.nativeElement(popup), scale);\n    };\n    DOMService.prototype.removeScroll = function (rect, scroll) {\n        return removeScroll(rect, scroll);\n    };\n    DOMService.prototype.restrictToView = function (settings) {\n        return restrictToView(settings);\n    };\n    DOMService.prototype.scrollPosition = function (el) {\n        return scrollPosition(this.nativeElement(el));\n    };\n    DOMService.prototype.scrollableParents = function (el) {\n        return scrollableParents(this.nativeElement(el));\n    };\n    DOMService.prototype.stackingElementOffset = function (el) {\n        var relativeContextElement = this.getRelativeContextElement(el);\n        if (!relativeContextElement) {\n            return null;\n        }\n        return offset(relativeContextElement);\n    };\n    DOMService.prototype.stackingElementScroll = function (el) {\n        var relativeContextElement = this.getRelativeContextElement(el);\n        if (!relativeContextElement) {\n            return { x: 0, y: 0 };\n        }\n        return {\n            x: relativeContextElement.scrollLeft,\n            y: relativeContextElement.scrollTop\n        };\n    };\n    DOMService.prototype.getRelativeContextElement = function (el) {\n        if (!el || !hasRelativeStackingContext()) {\n            return null;\n        }\n        var parent = this.nativeElement(el).parentElement;\n        while (parent) {\n            if (window.getComputedStyle(parent).transform !== 'none') {\n                return parent;\n            }\n            parent = parent.parentElement;\n        }\n        return null;\n    };\n    DOMService.prototype.useRelativePosition = function (el) {\n        return !!this.getRelativeContextElement(el);\n    };\n    DOMService.prototype.windowViewPort = function (el) {\n        return getWindowViewPort(this.nativeElement(el));\n    };\n    DOMService.prototype.zIndex = function (anchor, container) {\n        return zIndex(this.nativeElement(anchor), this.nativeElement(container));\n    };\n    DOMService.prototype.zoomLevel = function () {\n        if (!isDocumentAvailable() || !isWindowAvailable()) {\n            return 1;\n        }\n        return parseFloat((document.documentElement.clientWidth / window.innerWidth).toFixed(2)) || 1;\n    };\n    DOMService.prototype.isZoomed = function () {\n        return this.zoomLevel() > 1;\n    };\n    DOMService.decorators = [\n        { type: Injectable },\n    ];\n    return DOMService;\n}());\n\n/**\n * Used to set the document scale when using a [scale transform](https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/scale).\n *\n * The document or container scale is required to compute the popup position correctly. Detecting the scale is not reliable and must be set by providing a value for SCALE. See [Support for Document Scale]({% slug documentscale_popup %}).\n *\n * > Using this token is not necessary for user-applied browser zoom.\n *\n * {% meta height:300 %}\n * {% embed_file scale/app.component.ts preview %}\n * {% embed_file scale/app.module.ts %}\n * {% embed_file scale/main.ts %}\n * {% endmeta %}\n *\n *\n */\nvar SCALE = new InjectionToken('Popup Document Scale');\n\n/**\n * @hidden\n */\nvar AlignService = /** @class */ (function () {\n    function AlignService(_dom, scale) {\n        if (scale === void 0) { scale = 1; }\n        this._dom = _dom;\n        this.scale = scale;\n    }\n    AlignService.prototype.alignElement = function (settings) {\n        var anchor = settings.anchor, element = settings.element, anchorAlign = settings.anchorAlign, elementAlign = settings.elementAlign, margin = settings.margin, offset$$1 = settings.offset, positionMode = settings.positionMode;\n        var scale = this.scale || 1;\n        var fixedMode = positionMode === 'fixed' || !this._dom.hasOffsetParent(element);\n        var anchorRect = fixedMode ? this.absoluteRect(anchor, element, offset$$1, scale) : this.relativeRect(anchor, element, offset$$1, scale);\n        var elementRect = scaleRect(this._dom.offset(element), scale);\n        var result = this._dom.align({\n            anchorAlign: anchorAlign,\n            anchorRect: anchorRect,\n            elementAlign: elementAlign,\n            elementRect: elementRect,\n            margin: margin\n        });\n        return result;\n    };\n    AlignService.prototype.absoluteRect = function (anchor, element, offset$$1, scale) {\n        var scrollPos = this.elementScrollPosition(anchor, element);\n        var rect = eitherRect(this._dom.offset(anchor), offset$$1);\n        var stackScale = 2 * scale;\n        var stackScroll = this._dom.stackingElementScroll(element);\n        if (scale !== 1 && stackScroll) {\n            stackScroll.x /= stackScale;\n            stackScroll.y /= stackScale;\n        }\n        var stackOffset = this._dom.stackingElementOffset(element);\n        if (scale !== 1 && stackOffset) {\n            stackOffset.left /= stackScale;\n            stackOffset.top /= stackScale;\n        }\n        return this._dom.removeScroll(this._dom.addScroll(removeStackingOffset(scaleRect(rect, scale), stackOffset), stackScroll), scrollPos);\n    };\n    AlignService.prototype.elementScrollPosition = function (anchor, element) {\n        return anchor ? { x: 0, y: 0 } : this._dom.scrollPosition(element);\n    };\n    AlignService.prototype.relativeRect = function (anchor, element, offset$$1, scale) {\n        var rect = eitherRect(this._dom.position(anchor, element, scale), offset$$1);\n        return scaleRect(rect, scale);\n    };\n    AlignService.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    AlignService.ctorParameters = function () { return [\n        { type: DOMService },\n        { type: Number, decorators: [{ type: Inject, args: [SCALE,] }, { type: Optional }] }\n    ]; };\n    return AlignService;\n}());\n\n/**\n * @hidden\n */\nvar PositionService = /** @class */ (function () {\n    function PositionService(_dom, scale) {\n        if (scale === void 0) { scale = 1; }\n        this._dom = _dom;\n        this.scale = scale;\n    }\n    PositionService.prototype.positionElement = function (settings) {\n        var anchor = settings.anchor, currentLocation = settings.currentLocation, element = settings.element, anchorAlign = settings.anchorAlign, elementAlign = settings.elementAlign, collisions = settings.collisions, margin = settings.margin;\n        var dom = this._dom;\n        var scale = this.scale || 1;\n        var elementOffset = dom.offsetAtPoint(element, currentLocation);\n        var elementRect = scaleRect(elementOffset, scale);\n        var anchorOffset = scaleRect(dom.offset(anchor), scale);\n        var anchorRect = eitherRect(anchorOffset, currentLocation);\n        var viewPort = settings.viewPort || dom.windowViewPort(element);\n        viewPort.width = viewPort.width / scale;\n        viewPort.height = viewPort.height / scale;\n        var result = dom.restrictToView({\n            anchorAlign: anchorAlign,\n            anchorRect: anchorRect,\n            collisions: collisions,\n            elementAlign: elementAlign,\n            elementRect: elementRect,\n            margin: margin,\n            viewPort: viewPort\n        });\n        var offset$$1 = dom.addOffset(currentLocation, result.offset);\n        return {\n            flip: result.flip,\n            flipped: result.flipped,\n            offset: offset$$1\n        };\n    };\n    PositionService.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    PositionService.ctorParameters = function () { return [\n        { type: DOMService },\n        { type: Number, decorators: [{ type: Inject, args: [SCALE,] }, { type: Optional }] }\n    ]; };\n    return PositionService;\n}());\n\n/**\n * @hidden\n */\nvar ResizeService = /** @class */ (function () {\n    function ResizeService(_dom, _zone) {\n        this._dom = _dom;\n        this._zone = _zone;\n    }\n    ResizeService.prototype.subscribe = function (callback) {\n        var _this = this;\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        this._zone.runOutsideAngular(function () {\n            _this.subscription = fromEvent(_this._dom.getWindow(), \"resize\")\n                .pipe(auditTime(FRAME_DURATION))\n                .subscribe(function () { return callback(); });\n        });\n    };\n    ResizeService.prototype.unsubscribe = function () {\n        if (!this.subscription) {\n            return;\n        }\n        this.subscription.unsubscribe();\n    };\n    ResizeService.prototype.isUnsubscribed = function () {\n        return this.subscription && this.subscription.closed;\n    };\n    ResizeService.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    ResizeService.ctorParameters = function () { return [\n        { type: DOMService },\n        { type: NgZone }\n    ]; };\n    return ResizeService;\n}());\n\n/**\n * @hidden\n */\nvar THRESHOLD_DIFF = 1;\n/**\n * @hidden\n */\nvar ScrollableService = /** @class */ (function () {\n    function ScrollableService(_dom, _zone) {\n        this._dom = _dom;\n        this._zone = _zone;\n    }\n    ScrollableService.prototype.forElement = function (element) {\n        this.unsubscribe();\n        this.element = element;\n        return this;\n    };\n    ScrollableService.prototype.subscribe = function (callback) {\n        var _this = this;\n        if (!callback || !isDocumentAvailable() || !this.element) {\n            return;\n        }\n        var nativeElement = this._dom.nativeElement(this.element);\n        var parents$$1 = this._dom.scrollableParents(this.element);\n        this._zone.runOutsideAngular(function () {\n            var observables = parents$$1.map(function (p) { return fromEvent(p, \"scroll\").pipe(auditTime(FRAME_DURATION)); });\n            var subscriber = function (e) {\n                var target = e.target;\n                var isParent = parents$$1.filter(function (p) { return p === target; }).length > 0;\n                var isDocument = target === document;\n                var isWindow = target === window;\n                if (isParent || isDocument || isWindow) {\n                    callback(_this.isVisible(nativeElement, target));\n                }\n            };\n            _this.subscription = merge.apply(void 0, observables).subscribe(subscriber);\n        });\n    };\n    ScrollableService.prototype.unsubscribe = function () {\n        if (!this.subscription) {\n            return;\n        }\n        this.subscription.unsubscribe();\n    };\n    ScrollableService.prototype.isVisible = function (elem, container) {\n        var elemRect = this._dom.boundingOffset(elem);\n        var containerRect = this._dom.boundingOffset(container);\n        if (THRESHOLD_DIFF < (containerRect.top - elemRect.bottom)) {\n            return false;\n        }\n        if (THRESHOLD_DIFF < (elemRect.top - containerRect.bottom)) {\n            return false;\n        }\n        if (THRESHOLD_DIFF < (elemRect.left - containerRect.right)) {\n            return false;\n        }\n        if (THRESHOLD_DIFF < (containerRect.left - elemRect.right)) {\n            return false;\n        }\n        return true;\n    };\n    ScrollableService.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    ScrollableService.ctorParameters = function () { return [\n        { type: DOMService },\n        { type: NgZone }\n    ]; };\n    return ScrollableService;\n}());\n\nvar LEFT = 'left';\nvar RIGHT = 'right';\nvar DOWN = 'down';\nvar UP = 'up';\nvar DEFAULT_TYPE = 'slide';\nvar DEFAULT_DURATION = 100;\nvar animationTypes = {};\n/* tslint:disable:object-literal-sort-keys */\nanimationTypes.expand = function (direction) {\n    var scale = direction === UP || direction === DOWN ? 'scaleY' : 'scaleX';\n    var startScale = 0;\n    var endScale = 1;\n    var origin;\n    if (direction === DOWN) {\n        origin = 'top';\n    }\n    else if (direction === LEFT) {\n        origin = RIGHT;\n    }\n    else if (direction === RIGHT) {\n        origin = LEFT;\n    }\n    else {\n        origin = 'bottom';\n    }\n    return {\n        start: { transform: scale + \"(\" + startScale + \")\", transformOrigin: origin },\n        end: { transform: scale + \"(\" + endScale + \")\" }\n    };\n};\nanimationTypes.slide = function (direction) {\n    var translate = direction === LEFT || direction === RIGHT ? 'translateX' : 'translateY';\n    var start = direction === RIGHT || direction === DOWN ? -100 : 100;\n    var end = 0;\n    return {\n        start: { transform: translate + \"(\" + start + \"%)\" },\n        end: { transform: translate + \"(\" + end + \"%)\" }\n    };\n};\nanimationTypes.fade = function () {\n    return {\n        start: { opacity: 0 },\n        end: { opacity: 1 }\n    };\n};\nanimationTypes.zoom = function () {\n    var start = 0;\n    var end = 1;\n    return {\n        start: { transform: \"scale(\" + start + \")\" },\n        end: { transform: \"scale(\" + end + \")\" }\n    };\n};\n/**\n * @hidden\n */\nvar AnimationService = /** @class */ (function () {\n    function AnimationService(animationBuilder) {\n        this.animationBuilder = animationBuilder;\n        this.start = new EventEmitter();\n        this.end = new EventEmitter();\n    }\n    AnimationService.prototype.play = function (element, options, flip) {\n        if (!this.flip || this.flip.horizontal !== flip.horizontal ||\n            this.flip.vertical !== flip.vertical) {\n            this.flip = flip;\n            var type = options.type || DEFAULT_TYPE;\n            var statesFn = animationTypes[type];\n            if (statesFn) {\n                var direction = this.getDirection(flip, options);\n                var states = statesFn(direction);\n                this.playStates(element, states, options);\n            }\n            else if (isDevMode()) {\n                throw new Error(\"Unsupported animation type: \\\"\" + type + \"\\\". The supported types are slide, expand, fade and zoom.\");\n            }\n        }\n    };\n    AnimationService.prototype.ngOnDestroy = function () {\n        this.stopPlayer();\n    };\n    AnimationService.prototype.playStates = function (element, states, options) {\n        var _this = this;\n        this.stopPlayer();\n        var duration = options.duration || DEFAULT_DURATION;\n        var factory = this.animationBuilder.build([\n            style(states.start),\n            animate(duration + \"ms ease-in\", style(states.end))\n        ]);\n        var player = this.player = factory.create(element);\n        player.onDone(function () {\n            _this.end.emit();\n            _this.stopPlayer();\n        });\n        this.start.emit();\n        player.play();\n    };\n    AnimationService.prototype.getDirection = function (flip, options) {\n        var direction = options.direction || DOWN;\n        if (flip.horizontal) {\n            if (direction === LEFT) {\n                direction = RIGHT;\n            }\n            else if (direction === RIGHT) {\n                direction = LEFT;\n            }\n        }\n        if (flip.vertical) {\n            if (direction === DOWN) {\n                direction = UP;\n            }\n            else if (direction === UP) {\n                direction = DOWN;\n            }\n        }\n        return direction;\n    };\n    AnimationService.prototype.stopPlayer = function () {\n        if (this.player) {\n            this.player.destroy();\n            this.player = null;\n        }\n    };\n    AnimationService.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    AnimationService.ctorParameters = function () { return [\n        { type: AnimationBuilder }\n    ]; };\n    return AnimationService;\n}());\n\nvar DEFAULT_OFFSET = { left: -10000, top: 0 };\nvar ANIMATION_CONTAINER = 'k-animation-container';\nvar ANIMATION_CONTAINER_FIXED = 'k-animation-container-fixed';\n/**\n * Represents the [Kendo UI Popup component for Angular]({% slug overview_popup %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <button #anchor (click)=\"show=!show\">Toggle</button>\n *  <kendo-popup *ngIf=\"show\" [anchor]=\"anchor\">\n *      <strong>Popup content!</strong>\n *  </kendo-popup>\n * `\n * })\n * class AppComponent {\n *   public show: boolean = false;\n * }\n * ```\n */\nvar PopupComponent = /** @class */ (function () {\n    function PopupComponent(container, _alignService, domService, _positionService, _resizeService, _scrollableService, animationService, _renderer, _zone) {\n        this.container = container;\n        this._alignService = _alignService;\n        this.domService = domService;\n        this._positionService = _positionService;\n        this._resizeService = _resizeService;\n        this._scrollableService = _scrollableService;\n        this.animationService = animationService;\n        this._renderer = _renderer;\n        this._zone = _zone;\n        /**\n         * Controls the Popup animation. By default, the opening and closing animations\n         * are enabled ([see example]({% slug animations_popup %})).\n         */\n        this.animate = true;\n        /**\n         * Specifies the anchor pivot point\n         * ([see example]({% slug alignmentpositioning_popup %}#toc-positioning)).\n         */\n        this.anchorAlign = { horizontal: 'left', vertical: 'bottom' };\n        /**\n         * Configures the collision behavior of the Popup\n         * ([see example]({% slug viewportboundarydetection_popup %})).\n         */\n        this.collision = { horizontal: 'fit', vertical: 'flip' };\n        /**\n         * Specifies the pivot point of the Popup\n         * ([see example]({% slug alignmentpositioning_popup %}#toc-positioning)).\n         */\n        this.popupAlign = { horizontal: 'left', vertical: 'top' };\n        /**\n         * Controls whether the component will copy the `anchor` font styles.\n         */\n        this.copyAnchorStyles = false;\n        /**\n         * Specifies the position mode of the component. By default, the Popup uses fixed positioning.\n         * To make the Popup acquire absolute positioning, set this option to `absolute`.\n         *\n         * > If you need to support mobile browsers with the zoom option,\n         * use the `absolute` positioning of the Popup.\n         *\n         * @example\n         * ```html\n         * <style>\n         *  .parent-content {\n         *     position: relative;\n         *     width: 200px;\n         *     height: 200px;\n         *     overflow: auto;\n         *     margin: 200px auto;\n         *     border: 1px solid red;\n         *  }\n         *  .content {\n         *     position: relative;\n         *     width: 100px;\n         *     height: 100px;\n         *     overflow: auto;\n         *     margin: 300px;\n         *     border: 1px solid blue;\n         *  }\n         *  .anchor {\n         *     position: absolute;\n         *     top: 200px;\n         *     left: 200px;\n         *  }\n         * </style>\n         * ```\n         * ```ts\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *   <div class=\"example-config\">\n         *      Position mode:\n         *      <label><input type=\"radio\" value=\"fixed\" [(ngModel)]=\"mode\" /> Fixed</label>\n         *      <label><input type=\"radio\" value=\"absolute\" [(ngModel)]=\"mode\" /> Absolute</label>\n         *   </div>\n         *   <div class=\"example-config\">\n         *       Append to\n         *       <label>\n         *           <input type=\"radio\" name=\"place\" [value]=\"1\" [(ngModel)]=\"checked\" />\n         *           Root component\n         *       </label>\n         *       <label>\n         *           <input type=\"radio\" name=\"place\" [value]=\"2\" [(ngModel)]=\"checked\" />\n         *           <span style=\"color: red\">Red Container</span>\n         *       </label>\n         *       <label>\n         *           <input type=\"radio\" name=\"place\" [value]=\"3\" [(ngModel)]=\"checked\" />\n         *           <span style=\"color: blue\">Blue Container</span>\n         *       </label>\n         *   </div>\n         *   <div class=\"example\">\n         *     <div class=\"parent-content\" [scrollLeft]=\"250\" [scrollTop]=\"230\">\n         *         <div class=\"content\" [scrollLeft]=\"170\" [scrollTop]=\"165\">\n         *           <button #anchor class=\"anchor\" (click)=\"show = !show\">Toggle</button>\n         *           <kendo-popup [positionMode]=\"mode\" [anchor]=\"anchor\" (anchorViewportLeave)=\"show=false\" *ngIf=\"show && checked === 3\">\n         *             <ul>\n         *                 <li>Item1</li>\n         *                 <li>Item2</li>\n         *                 <li>Item3</li>\n         *             </ul>\n         *           </kendo-popup>\n         *           <span style=\"position: absolute; top: 400px; left: 400px\">Bottom/Right</span>\n         *         </div>\n         *         <kendo-popup [positionMode]=\"mode\" [anchor]=\"anchor\" (anchorViewportLeave)=\"show=false\" *ngIf=\"show && checked === 2\">\n         *           <ul>\n         *               <li>Item1</li>\n         *               <li>Item2</li>\n         *               <li>Item3</li>\n         *           </ul>\n         *         </kendo-popup>\n         *         <span style=\"position: absolute; top: 600px; left: 600px\">Bottom/Right</span>\n         *     </div>\n         *     <kendo-popup [positionMode]=\"mode\" [anchor]=\"anchor\" (anchorViewportLeave)=\"show=false\" *ngIf=\"show && checked === 1\">\n         *       <ul>\n         *           <li>Item1</li>\n         *           <li>Item2</li>\n         *           <li>Item3</li>\n         *       </ul>\n         *     </kendo-popup>\n         *   </div>\n         * `\n         * })\n         * class AppComponent {\n         *   public checked: number = 3;\n         *   public mode: string = 'absolute';\n         *   public show: boolean = true;\n         * }\n         * ```\n         */\n        this.positionMode = 'fixed';\n        /**\n         * Specifies the absolute position of the element\n         * ([see example]({% slug alignmentpositioning_popup %}#toc-aligning-to-absolute-points)).\n         * The Popup opens next to that point. The Popup pivot point is defined by the `popupAlign` configuration option.\n         * The boundary detection is applied by using the window viewport.\n         */\n        this.offset = DEFAULT_OFFSET;\n        /**\n         * Fires when the anchor is scrolled outside the screen boundaries.\n         * ([see example]({% slug closing_popup %}#toc-after-leaving-the-viewport)).\n         */\n        this.anchorViewportLeave = new EventEmitter();\n        /**\n         * Fires after the component is closed.\n         */\n        this.close = new EventEmitter();\n        /**\n         * Fires after the component is opened and the opening animation ends.\n         */\n        this.open = new EventEmitter();\n        /**\n         * Fires after the component is opened and the Popup is positioned.\n         */\n        this.positionChange = new EventEmitter();\n        this.resolvedPromise = Promise.resolve(null);\n        this.initialCheck = true;\n        this._renderer.addClass(container.nativeElement, ANIMATION_CONTAINER);\n        this.updateFixedClass();\n    }\n    PopupComponent.prototype.ngOnInit = function () {\n        this.reposition = this.reposition.bind(this);\n        this._resizeService.subscribe(this.reposition);\n        this.animationSubscriptions = this.animationService.start.subscribe(this.onAnimationStart.bind(this));\n        this.animationSubscriptions.add(this.animationService.end.subscribe(this.onAnimationEnd.bind(this)));\n        this._scrollableService.forElement(this.anchor || this.container).subscribe(this.onScroll.bind(this));\n        this.currentOffset = DEFAULT_OFFSET;\n        this.setZIndex();\n        this.copyFontStyles();\n        this.updateFixedClass();\n    };\n    PopupComponent.prototype.ngOnChanges = function (changes) {\n        if (changes.copyAnchorStyles) {\n            this.copyFontStyles();\n        }\n        if (changes.positionMode) {\n            this.updateFixedClass();\n        }\n    };\n    PopupComponent.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        this.reposition();\n        if (!this.animate) {\n            this.resolvedPromise.then(function () {\n                _this.onAnimationEnd();\n            });\n        }\n    };\n    PopupComponent.prototype.ngAfterViewChecked = function () {\n        var _this = this;\n        if (this.initialCheck) {\n            this.initialCheck = false;\n            return;\n        }\n        this._zone.runOutsideAngular(function () {\n            // workarounds https://github.com/angular/angular/issues/19094\n            // uses promise because it is executed synchronously after the content is updated\n            // does not use onStable in case the current zone is not the angular one.\n            _this.unsubscribeReposition();\n            _this.repositionSubscription = from(_this.resolvedPromise)\n                .subscribe(_this.reposition);\n        });\n    };\n    PopupComponent.prototype.ngOnDestroy = function () {\n        this.anchorViewportLeave.complete();\n        this.positionChange.complete();\n        this.close.emit();\n        this.close.complete();\n        this._resizeService.unsubscribe();\n        this._scrollableService.unsubscribe();\n        this.animationSubscriptions.unsubscribe();\n        this.unsubscribeReposition();\n    };\n    /**\n     * @hidden\n     */\n    PopupComponent.prototype.onResize = function () {\n        this.reposition();\n    };\n    PopupComponent.prototype.onAnimationStart = function () {\n        this._renderer.removeClass(this.container.nativeElement, 'k-animation-container-shown');\n    };\n    PopupComponent.prototype.onAnimationEnd = function () {\n        this._renderer.addClass(this.container.nativeElement, 'k-animation-container-shown');\n        this.open.emit();\n        this.open.complete();\n    };\n    Object.defineProperty(PopupComponent.prototype, \"currentOffset\", {\n        get: function () {\n            return this._currentOffset;\n        },\n        set: function (offset$$1) {\n            this.setContainerStyle('left', offset$$1.left + \"px\");\n            this.setContainerStyle('top', offset$$1.top + \"px\");\n            this._currentOffset = offset$$1;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PopupComponent.prototype.setZIndex = function () {\n        if (this.anchor) {\n            this.setContainerStyle('z-index', String(this.domService.zIndex(this.anchor, this.container)));\n        }\n    };\n    PopupComponent.prototype.reposition = function () {\n        var _this = this;\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        var _a = this.position(), flip = _a.flip, offset$$1 = _a.offset;\n        if (!this.currentOffset || isDifferentOffset(this.currentOffset, offset$$1)) {\n            this.currentOffset = offset$$1;\n            if (hasObservers(this.positionChange)) {\n                this._zone.run(function () { return _this.positionChange.emit({ offset: offset$$1, flip: flip }); });\n            }\n        }\n        if (this.animate) {\n            this.animationService.play(this.contentContainer.nativeElement, this.animate, flip);\n        }\n        this.resizeSensor.acceptSize();\n    };\n    PopupComponent.prototype.position = function () {\n        var alignedOffset = this._alignService.alignElement({\n            anchor: this.anchor,\n            anchorAlign: this.anchorAlign,\n            element: this.container,\n            elementAlign: this.popupAlign,\n            margin: this.margin,\n            offset: this.offset,\n            positionMode: this.positionMode\n        });\n        return this._positionService.positionElement({\n            anchor: this.anchor,\n            anchorAlign: this.anchorAlign,\n            collisions: this.collision,\n            currentLocation: alignedOffset,\n            element: this.container,\n            elementAlign: this.popupAlign,\n            margin: this.margin\n        });\n    };\n    PopupComponent.prototype.onScroll = function (isInViewPort) {\n        var _this = this;\n        var hasLeaveObservers = hasObservers(this.anchorViewportLeave);\n        if (isInViewPort || !hasLeaveObservers) {\n            this.reposition();\n        }\n        else if (hasLeaveObservers) {\n            this._zone.run(function () {\n                _this.anchorViewportLeave.emit();\n            });\n        }\n    };\n    PopupComponent.prototype.copyFontStyles = function () {\n        var _this = this;\n        if (!this.anchor || !this.copyAnchorStyles) {\n            return;\n        }\n        this.domService.getFontStyles(this.anchor)\n            .forEach(function (s) { return _this.setContainerStyle(s.key, s.value); });\n    };\n    PopupComponent.prototype.updateFixedClass = function () {\n        var action = this.positionMode === 'fixed' ? 'addClass' : 'removeClass';\n        this._renderer[action](this.container.nativeElement, ANIMATION_CONTAINER_FIXED);\n    };\n    PopupComponent.prototype.setContainerStyle = function (name, value) {\n        this._renderer.setStyle(this.container.nativeElement, name, value);\n    };\n    PopupComponent.prototype.unsubscribeReposition = function () {\n        if (this.repositionSubscription) {\n            this.repositionSubscription.unsubscribe();\n        }\n    };\n    PopupComponent.decorators = [\n        { type: Component, args: [{\n                    exportAs: 'kendo-popup',\n                    providers: [AlignService, AnimationService, DOMService, PositionService, ResizeService, ScrollableService],\n                    selector: 'kendo-popup',\n                    template: \"\\n        <div class=\\\"k-popup\\\" [ngClass]=\\\"popupClass\\\" #container>\\n            <ng-content></ng-content>\\n            <ng-template [ngTemplateOutlet]=\\\"content\\\" [ngIf]=\\\"content\\\"></ng-template>\\n            <kendo-resize-sensor [rateLimit]=\\\"100\\\" (resize)=\\\"onResize()\\\">\\n            </kendo-resize-sensor>\\n        </div>\\n     \"\n                },] },\n    ];\n    /** @nocollapse */\n    PopupComponent.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: AlignService },\n        { type: DOMService },\n        { type: PositionService },\n        { type: ResizeService },\n        { type: ScrollableService },\n        { type: AnimationService },\n        { type: Renderer2 },\n        { type: NgZone }\n    ]; };\n    PopupComponent.propDecorators = {\n        animate: [{ type: Input }],\n        anchor: [{ type: Input }],\n        anchorAlign: [{ type: Input }],\n        collision: [{ type: Input }],\n        popupAlign: [{ type: Input }],\n        copyAnchorStyles: [{ type: Input }],\n        popupClass: [{ type: Input }],\n        positionMode: [{ type: Input }],\n        offset: [{ type: Input }],\n        margin: [{ type: Input }],\n        anchorViewportLeave: [{ type: Output }],\n        close: [{ type: Output }],\n        open: [{ type: Output }],\n        positionChange: [{ type: Output }],\n        contentContainer: [{ type: ViewChild, args: ['container',] }],\n        resizeSensor: [{ type: ViewChild, args: [ResizeSensorComponent,] }]\n    };\n    return PopupComponent;\n}());\n\nvar removeElement = function (element) {\n    if (element && element.parentNode) {\n        element.parentNode.removeChild(element);\n    }\n};\n/**\n * Used to inject the Popup container. If not provided, the first root component of\n * the application is used.\n *\n * > The `POPUP_CONTAINER` can be used only with the [`PopupService`]({% slug service_popup %}) class.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Popup module\n * import { PopupModule, POPUP_CONTAINER } from '@progress/kendo-angular-popup';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { ElementRef, NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, PopupModule], // import Popup module\n *     bootstrap:    [AppComponent],\n *     providers: [{\n *       provide: POPUP_CONTAINER,\n *       useFactory: () => {\n *          //return the container ElementRef, where the popup will be injected\n *          return { nativeElement: document.body } as ElementRef;\n *       }\n *     }]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n * ```\n */\nvar POPUP_CONTAINER = new InjectionToken('Popup Container');\n/**\n * A service for opening Popup components dynamically\n * ([see example]({% slug service_popup %})).\n *\n * @export\n * @class PopupService\n */\nvar PopupService = /** @class */ (function () {\n    function PopupService(applicationRef, componentFactoryResolver, injector, container) {\n        this.applicationRef = applicationRef;\n        this.componentFactoryResolver = componentFactoryResolver;\n        this.injector = injector;\n        this.container = container;\n    }\n    Object.defineProperty(PopupService.prototype, \"rootViewContainer\", {\n        /**\n         * Gets the root view container into which the component will be injected.\n         *\n         * @returns {ComponentRef<any>}\n         */\n        get: function () {\n            // https://github.com/angular/angular/blob/4.0.x/packages/core/src/application_ref.ts#L571\n            var rootComponents = this.applicationRef.components || [];\n            if (rootComponents[0]) {\n                return rootComponents[0];\n            }\n            throw new Error(\"\\n            View Container not found! Inject the POPUP_CONTAINER or define a specific ViewContainerRef via the appendTo option.\\n            See http://www.telerik.com/kendo-angular-ui/components/popup/api/POPUP_CONTAINER/ for more details.\\n        \");\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PopupService.prototype, \"rootViewContainerNode\", {\n        /**\n         * Sets or gets the HTML element of the root component container.\n         *\n         * @returns {HTMLElement}\n         */\n        get: function () {\n            return this.container ? this.container.nativeElement : this.getComponentRootNode(this.rootViewContainer);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Opens a Popup component. Created Popups are mounted\n     * in the DOM directly in the root application component.\n     *\n     * @param {PopupSettings} options - The options which define the Popup.\n     * @returns {ComponentRef<PopupComponent>} - A reference to the Popup object.\n     *\n     * @example\n     *\n     * ```ts-no-run\n     * _@Component({\n     *   selector: 'my-app',\n     *   template: `\n     *     <ng-template #template>\n     *      Popup content\n     *     </ng-template>\n     *     <button #anchor kendoButton (click)=\"open(anchor, template)\">Open</button>\n     *   `\n     * })\n     * export class AppComponent {\n     *     public popupRef: PopupRef;\n     *\n     *     constructor( private popupService: PopupService ) {}\n     *\n     *     public open(anchor: ElementRef, template: TemplateRef<any>): void {\n     *         if (this.popupRef) {\n     *              this.popupRef.close();\n     *              this.popupRef = null;\n     *              return;\n     *         }\n     *\n     *         this.popupRef = this.popupService.open({\n     *           anchor: anchor,\n     *           content: template\n     *         });\n     *     }\n     * }\n     * ```\n     */\n    PopupService.prototype.open = function (options) {\n        if (options === void 0) { options = {}; }\n        var _a = this.contentFrom(options.content), component = _a.component, nodes = _a.nodes;\n        var popupComponentRef = this.appendPopup(nodes, options.appendTo);\n        var popupInstance = popupComponentRef.instance;\n        this.projectComponentInputs(popupComponentRef, options);\n        popupComponentRef.changeDetectorRef.detectChanges();\n        if (component) {\n            component.changeDetectorRef.detectChanges();\n        }\n        var popupElement = this.getComponentRootNode(popupComponentRef);\n        return {\n            close: function () {\n                if (component) {\n                    component.destroy();\n                }\n                popupComponentRef.destroy();\n                // Angular will not remove the element unless the change detection is triggered\n                removeElement(popupElement);\n            },\n            content: component,\n            popup: popupComponentRef,\n            popupAnchorViewportLeave: popupInstance.anchorViewportLeave,\n            popupClose: popupInstance.close,\n            popupElement: popupElement,\n            popupOpen: popupInstance.open,\n            popupPositionChange: popupInstance.positionChange\n        };\n    };\n    PopupService.prototype.appendPopup = function (nodes, container) {\n        var popupComponentRef = this.createComponent(PopupComponent, nodes, container);\n        if (!container) {\n            this.rootViewContainerNode.appendChild(this.getComponentRootNode(popupComponentRef));\n        }\n        return popupComponentRef;\n    };\n    /**\n     * Gets the HTML element for a component reference.\n     *\n     * @param {ComponentRef<any>} componentRef\n     * @returns {HTMLElement}\n     */\n    PopupService.prototype.getComponentRootNode = function (componentRef) {\n        return componentRef.location.nativeElement;\n    };\n    /**\n     * Gets the `ComponentFactory` instance by its type.\n     *\n     * @param {*} componentClass\n     * @param {*} nodes\n     * @returns {ComponentRef<any>}\n     */\n    PopupService.prototype.getComponentFactory = function (componentClass) {\n        return this.componentFactoryResolver.resolveComponentFactory(componentClass);\n    };\n    /**\n     * Creates a component reference from a `Component` type class.\n     *\n     * @param {*} componentClass\n     * @param {*} nodes\n     * @returns {ComponentRef<any>}\n     */\n    PopupService.prototype.createComponent = function (componentClass, nodes, container) {\n        var factory = this.getComponentFactory(componentClass);\n        if (container) {\n            return container.createComponent(factory, undefined, this.injector, nodes);\n        }\n        else {\n            var component = factory.create(this.injector, nodes);\n            this.applicationRef.attachView(component.hostView);\n            return component;\n        }\n    };\n    /**\n     * Projects the inputs on the component.\n     *\n     * @param {ComponentRef<any>} component\n     * @param {*} options\n     * @returns {ComponentRef<any>}\n     */\n    PopupService.prototype.projectComponentInputs = function (component, options) {\n        Object.getOwnPropertyNames(options)\n            .filter(function (prop) { return prop !== 'content' || options.content instanceof TemplateRef; })\n            .map(function (prop) {\n            component.instance[prop] = options[prop];\n        });\n        return component;\n    };\n    /**\n     * Gets the component and the nodes to append from the `content` option.\n     *\n     * @param {*} content\n     * @returns {any}\n     */\n    PopupService.prototype.contentFrom = function (content) {\n        if (!content || content instanceof TemplateRef) {\n            return { component: null, nodes: [[]] };\n        }\n        var component = this.createComponent(content);\n        var nodes = component ? [component.location.nativeElement] : [];\n        return {\n            component: component,\n            nodes: [\n                nodes // <ng-content>\n            ]\n        };\n    };\n    PopupService.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    PopupService.ctorParameters = function () { return [\n        { type: ApplicationRef },\n        { type: ComponentFactoryResolver },\n        { type: Injector },\n        { type: ElementRef, decorators: [{ type: Inject, args: [POPUP_CONTAINER,] }, { type: Optional }] }\n    ]; };\n    return PopupService;\n}());\n\nvar POPUP_DIRECTIVES = [PopupComponent];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Popup component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Popup module\n * import { PopupModule } from '@progress/kendo-angular-popup';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, PopupModule], // import Popup module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nvar PopupModule = /** @class */ (function () {\n    function PopupModule() {\n    }\n    PopupModule.decorators = [\n        { type: NgModule, args: [{\n                    declarations: [POPUP_DIRECTIVES],\n                    entryComponents: [POPUP_DIRECTIVES],\n                    exports: [POPUP_DIRECTIVES],\n                    imports: [CommonModule, ResizeSensorModule],\n                    providers: [PopupService]\n                },] },\n    ];\n    return PopupModule;\n}());\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AlignService, AnimationService, DOMService, PositionService, ResizeService, ScrollableService, PopupService, POPUP_CONTAINER, PopupComponent, PopupModule, SCALE };\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;AAeA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA8RM;;;;;gDAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAmEA,AAGA;;;;;;;;;;;;;;;kCAKG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAuCH,AAGA;;;;;;;;;;;;;;;kCAKG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA+BH,AAGA;;;;;;;;;;6FAKG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAgEH,AAGA;;;;;;;;;;6FAKG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA8HH,AAGA;;;;;;;;;iFAIG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAmVH,AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBA8BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA6OA,AAGA;;;;;;;;;;;;;;;;;kCAOG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAsCJ;;;;;;;;;;;;;gDASC;;;;;;;;;"}