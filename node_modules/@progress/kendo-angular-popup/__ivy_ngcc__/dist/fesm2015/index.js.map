{"version":3,"file":"index.js","sources":["D:/project/projek_angular/hris_rni/node_modules/@progress/kendo-angular-popup/dist/fesm2015/index.js"],"sourcesContent":["/**-----------------------------------------------------------------------------------------\n* Copyright Â© 2020 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport { ApplicationRef, Component, ComponentFactoryResolver, ElementRef, EventEmitter, Inject, Injectable, InjectionToken, Injector, Input, NgModule, NgZone, Optional, Output, Renderer2, TemplateRef, ViewChild, isDevMode } from '@angular/core';\nimport { addScroll, align, boundingOffset, getWindowViewPort, offset, parents, positionWithScroll, removeScroll, restrictToView, scrollPosition, siblingContainer } from '@progress/kendo-popup-common';\nimport { ResizeSensorComponent, ResizeSensorModule, hasObservers, isDocumentAvailable } from '@progress/kendo-angular-common';\nimport { from, fromEvent, merge } from 'rxjs';\nimport { auditTime } from 'rxjs/operators';\nimport { AnimationBuilder, animate, style } from '@angular/animations';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @hidden\n */\nconst eitherRect = (rect, offset$$1) => {\n    if (!rect) {\n        return { height: 0, left: offset$$1.left, top: offset$$1.top, width: 0 };\n    }\n    return rect;\n};\n/**\n * @hidden\n */\n\n/**\n * @hidden\n */\nconst removeStackingOffset = (rect, stackingOffset) => {\n    if (!stackingOffset) {\n        return rect;\n    }\n    const result = {\n        height: rect.height,\n        left: rect.left - stackingOffset.left,\n        top: rect.top - stackingOffset.top,\n        width: rect.width\n    };\n    return result;\n};\n/**\n * @hidden\n */\nconst isDifferentOffset = (oldOffset, newOffset) => {\n    const { left: oldLeft, top: oldTop } = oldOffset;\n    const { left: newLeft, top: newTop } = newOffset;\n    return Math.abs(oldLeft - newLeft) >= 1 || Math.abs(oldTop - newTop) >= 1;\n};\n/**\n * @hidden\n */\nconst isWindowAvailable = () => {\n    return typeof window !== 'undefined';\n};\n/**\n * @hidden\n */\n\n/**\n * @hidden\n */\nconst OVERFLOW_REGEXP = /auto|scroll/;\nconst overflowElementStyle = (element) => {\n    return `${element.style.overflow}${element.style.overflowX}${element.style.overflowY}`;\n};\nconst overflowComputedStyle = (element) => {\n    const styles = window.getComputedStyle(element);\n    return `${styles.overflow}${styles.overflowX}${styles.overflowY}`;\n};\nconst overflowStyle = (element) => {\n    return overflowElementStyle(element) || overflowComputedStyle(element);\n};\n/**\n * @hidden\n */\nconst scrollableParents = (element) => {\n    const parentElements = [];\n    if (!isDocumentAvailable() || !isWindowAvailable()) {\n        return parentElements;\n    }\n    let parent = element.parentElement;\n    while (parent) {\n        if (OVERFLOW_REGEXP.test(overflowStyle(parent)) || parent.hasAttribute('data-scrollable')) {\n            parentElements.push(parent);\n        }\n        parent = parent.parentElement;\n    }\n    parentElements.push(window);\n    return parentElements;\n};\n/**\n * @hidden\n */\nconst FRAME_DURATION = 1000 / 60; //1000ms divided by 60fps\nfunction memoize(fun) {\n    let result;\n    let called = false;\n    return (...args) => {\n        if (called) {\n            return result;\n        }\n        result = fun(...args);\n        called = true;\n        return result;\n    };\n}\n/**\n * @hidden\n */\nconst hasRelativeStackingContext = memoize(() => {\n    if (!isDocumentAvailable() && document.body !== null) {\n        return false;\n    }\n    const top = 10;\n    const parent = document.createElement(\"div\");\n    parent.style.transform = \"matrix(10, 0, 0, 10, 0, 0)\";\n    parent.innerHTML = `<div style=\"position: fixed; top: ${top}px;\">child</div>`;\n    document.body.appendChild(parent);\n    const isDifferent = parent.children[0].getBoundingClientRect().top !== top;\n    document.body.removeChild(parent);\n    return isDifferent;\n});\n/**\n * @hidden\n */\nconst zIndex = (anchor, container) => {\n    if (!anchor || !isDocumentAvailable() || !isWindowAvailable()) {\n        return null;\n    }\n    const sibling = siblingContainer(anchor, container);\n    if (!sibling) {\n        return null;\n    }\n    const result = [anchor].concat(parents(anchor, sibling)).reduce((index, p) => {\n        const zIndexStyle = p.style.zIndex || window.getComputedStyle(p).zIndex;\n        const current = parseInt(zIndexStyle, 10);\n        return current > index ? current : index;\n    }, 0);\n    return result ? (result + 1) : null;\n};\n/**\n * @hidden\n */\nconst scaleRect = (rect, scale) => {\n    if (!rect || scale === 1) {\n        return rect;\n    }\n    return {\n        height: rect.height / scale,\n        left: rect.left / scale,\n        top: rect.top / scale,\n        width: rect.width / scale\n    };\n};\n\nconst STYLES = [\n    'font-size',\n    'font-family',\n    'font-stretch',\n    'font-style',\n    'font-weight',\n    'line-height'\n];\n/**\n * @hidden\n */\nclass DOMService {\n    addOffset(current, addition) {\n        return {\n            left: current.left + addition.left,\n            top: current.top + addition.top\n        };\n    }\n    addScroll(rect, scroll) {\n        return addScroll(rect, scroll);\n    }\n    align(settings) {\n        return align(settings);\n    }\n    boundingOffset(el) {\n        return boundingOffset(this.nativeElement(el));\n    }\n    getFontStyles(el) {\n        const window = this.getWindow();\n        if (!window || !el) {\n            return [];\n        }\n        const computedStyles = window.getComputedStyle(this.nativeElement(el));\n        return STYLES.map(font => ({ key: font, value: computedStyles[font] }));\n    }\n    getWindow() {\n        return isWindowAvailable() ? window : null;\n    }\n    hasOffsetParent(el) {\n        if (!el) {\n            return false;\n        }\n        return !!this.nativeElement(el).offsetParent;\n    }\n    offset(el) {\n        if (!el) {\n            return null;\n        }\n        return offset(this.nativeElement(el));\n    }\n    offsetAtPoint(el, currentLocation) {\n        if (!el) {\n            return null;\n        }\n        const element = this.nativeElement(el);\n        const { left, top, transition } = element.style;\n        element.style.transition = 'none';\n        element.style.left = `${currentLocation.left}px`;\n        element.style.top = `${currentLocation.top}px`;\n        const currentOffset = offset(element);\n        element.style.left = left;\n        element.style.top = top;\n        // prevents elements with transition to be animated because of the change\n        // tslint:disable-next-line:no-unused-expression\n        element.offsetHeight;\n        element.style.transition = transition;\n        return currentOffset;\n    }\n    nativeElement(el) {\n        if (!el) {\n            return null;\n        }\n        return el.nativeElement || el;\n    }\n    position(element, popup, scale = 1) {\n        if (!element || !popup) {\n            return null;\n        }\n        return positionWithScroll(this.nativeElement(element), this.nativeElement(popup), scale);\n    }\n    removeScroll(rect, scroll) {\n        return removeScroll(rect, scroll);\n    }\n    restrictToView(settings) {\n        return restrictToView(settings);\n    }\n    scrollPosition(el) {\n        return scrollPosition(this.nativeElement(el));\n    }\n    scrollableParents(el) {\n        return scrollableParents(this.nativeElement(el));\n    }\n    stackingElementOffset(el) {\n        const relativeContextElement = this.getRelativeContextElement(el);\n        if (!relativeContextElement) {\n            return null;\n        }\n        return offset(relativeContextElement);\n    }\n    stackingElementScroll(el) {\n        const relativeContextElement = this.getRelativeContextElement(el);\n        if (!relativeContextElement) {\n            return { x: 0, y: 0 };\n        }\n        return {\n            x: relativeContextElement.scrollLeft,\n            y: relativeContextElement.scrollTop\n        };\n    }\n    getRelativeContextElement(el) {\n        if (!el || !hasRelativeStackingContext()) {\n            return null;\n        }\n        let parent = this.nativeElement(el).parentElement;\n        while (parent) {\n            if (window.getComputedStyle(parent).transform !== 'none') {\n                return parent;\n            }\n            parent = parent.parentElement;\n        }\n        return null;\n    }\n    useRelativePosition(el) {\n        return !!this.getRelativeContextElement(el);\n    }\n    windowViewPort(el) {\n        return getWindowViewPort(this.nativeElement(el));\n    }\n    zIndex(anchor, container) {\n        return zIndex(this.nativeElement(anchor), this.nativeElement(container));\n    }\n    zoomLevel() {\n        if (!isDocumentAvailable() || !isWindowAvailable()) {\n            return 1;\n        }\n        return parseFloat((document.documentElement.clientWidth / window.innerWidth).toFixed(2)) || 1;\n    }\n    isZoomed() {\n        return this.zoomLevel() > 1;\n    }\n}\nDOMService.decorators = [\n    { type: Injectable },\n];\n\n/**\n * Used to set the document scale when using a [scale transform](https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/scale).\n *\n * The document or container scale is required to compute the popup position correctly. Detecting the scale is not reliable and must be set by providing a value for SCALE. See [Support for Document Scale]({% slug documentscale_popup %}).\n *\n * > Using this token is not necessary for user-applied browser zoom.\n *\n * {% meta height:300 %}\n * {% embed_file scale/app.component.ts preview %}\n * {% embed_file scale/app.module.ts %}\n * {% embed_file scale/main.ts %}\n * {% endmeta %}\n *\n *\n */\nconst SCALE = new InjectionToken('Popup Document Scale');\n\n/**\n * @hidden\n */\nclass AlignService {\n    constructor(_dom, scale = 1) {\n        this._dom = _dom;\n        this.scale = scale;\n    }\n    alignElement(settings) {\n        const { anchor, element, anchorAlign, elementAlign, margin, offset: offset$$1, positionMode } = settings;\n        const scale = this.scale || 1;\n        const fixedMode = positionMode === 'fixed' || !this._dom.hasOffsetParent(element);\n        const anchorRect = fixedMode ? this.absoluteRect(anchor, element, offset$$1, scale) : this.relativeRect(anchor, element, offset$$1, scale);\n        const elementRect = scaleRect(this._dom.offset(element), scale);\n        const result = this._dom.align({\n            anchorAlign: anchorAlign,\n            anchorRect: anchorRect,\n            elementAlign: elementAlign,\n            elementRect: elementRect,\n            margin\n        });\n        return result;\n    }\n    absoluteRect(anchor, element, offset$$1, scale) {\n        const scrollPos = this.elementScrollPosition(anchor, element);\n        const rect = eitherRect(this._dom.offset(anchor), offset$$1);\n        const stackScale = 2 * scale;\n        const stackScroll = this._dom.stackingElementScroll(element);\n        if (scale !== 1 && stackScroll) {\n            stackScroll.x /= stackScale;\n            stackScroll.y /= stackScale;\n        }\n        const stackOffset = this._dom.stackingElementOffset(element);\n        if (scale !== 1 && stackOffset) {\n            stackOffset.left /= stackScale;\n            stackOffset.top /= stackScale;\n        }\n        return this._dom.removeScroll(this._dom.addScroll(removeStackingOffset(scaleRect(rect, scale), stackOffset), stackScroll), scrollPos);\n    }\n    elementScrollPosition(anchor, element) {\n        return anchor ? { x: 0, y: 0 } : this._dom.scrollPosition(element);\n    }\n    relativeRect(anchor, element, offset$$1, scale) {\n        const rect = eitherRect(this._dom.position(anchor, element, scale), offset$$1);\n        return scaleRect(rect, scale);\n    }\n}\nAlignService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nAlignService.ctorParameters = () => [\n    { type: DOMService },\n    { type: Number, decorators: [{ type: Inject, args: [SCALE,] }, { type: Optional }] }\n];\n\n/**\n * @hidden\n */\nclass PositionService {\n    constructor(_dom, scale = 1) {\n        this._dom = _dom;\n        this.scale = scale;\n    }\n    positionElement(settings) {\n        const { anchor, currentLocation, element, anchorAlign, elementAlign, collisions, margin } = settings;\n        const dom = this._dom;\n        const scale = this.scale || 1;\n        const elementOffset = dom.offsetAtPoint(element, currentLocation);\n        const elementRect = scaleRect(elementOffset, scale);\n        const anchorOffset = scaleRect(dom.offset(anchor), scale);\n        const anchorRect = eitherRect(anchorOffset, currentLocation);\n        const viewPort = settings.viewPort || dom.windowViewPort(element);\n        viewPort.width = viewPort.width / scale;\n        viewPort.height = viewPort.height / scale;\n        const result = dom.restrictToView({\n            anchorAlign,\n            anchorRect,\n            collisions,\n            elementAlign,\n            elementRect,\n            margin,\n            viewPort\n        });\n        const offset$$1 = dom.addOffset(currentLocation, result.offset);\n        return {\n            flip: result.flip,\n            flipped: result.flipped,\n            offset: offset$$1\n        };\n    }\n}\nPositionService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nPositionService.ctorParameters = () => [\n    { type: DOMService },\n    { type: Number, decorators: [{ type: Inject, args: [SCALE,] }, { type: Optional }] }\n];\n\n/**\n * @hidden\n */\nclass ResizeService {\n    constructor(_dom, _zone) {\n        this._dom = _dom;\n        this._zone = _zone;\n    }\n    subscribe(callback) {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        this._zone.runOutsideAngular(() => {\n            this.subscription = fromEvent(this._dom.getWindow(), \"resize\")\n                .pipe(auditTime(FRAME_DURATION))\n                .subscribe(() => callback());\n        });\n    }\n    unsubscribe() {\n        if (!this.subscription) {\n            return;\n        }\n        this.subscription.unsubscribe();\n    }\n    isUnsubscribed() {\n        return this.subscription && this.subscription.closed;\n    }\n}\nResizeService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nResizeService.ctorParameters = () => [\n    { type: DOMService },\n    { type: NgZone }\n];\n\n/**\n * @hidden\n */\nconst THRESHOLD_DIFF = 1;\n/**\n * @hidden\n */\nclass ScrollableService {\n    constructor(_dom, _zone) {\n        this._dom = _dom;\n        this._zone = _zone;\n    }\n    forElement(element) {\n        this.unsubscribe();\n        this.element = element;\n        return this;\n    }\n    subscribe(callback) {\n        if (!callback || !isDocumentAvailable() || !this.element) {\n            return;\n        }\n        const nativeElement = this._dom.nativeElement(this.element);\n        const parents$$1 = this._dom.scrollableParents(this.element);\n        this._zone.runOutsideAngular(() => {\n            const observables = parents$$1.map(p => fromEvent(p, \"scroll\").pipe(auditTime(FRAME_DURATION)));\n            const subscriber = (e) => {\n                const target = e.target;\n                const isParent = parents$$1.filter(p => p === target).length > 0;\n                const isDocument = target === document;\n                const isWindow = target === window;\n                if (isParent || isDocument || isWindow) {\n                    callback(this.isVisible(nativeElement, target));\n                }\n            };\n            this.subscription = merge(...observables).subscribe(subscriber);\n        });\n    }\n    unsubscribe() {\n        if (!this.subscription) {\n            return;\n        }\n        this.subscription.unsubscribe();\n    }\n    isVisible(elem, container) {\n        const elemRect = this._dom.boundingOffset(elem);\n        const containerRect = this._dom.boundingOffset(container);\n        if (THRESHOLD_DIFF < (containerRect.top - elemRect.bottom)) {\n            return false;\n        }\n        if (THRESHOLD_DIFF < (elemRect.top - containerRect.bottom)) {\n            return false;\n        }\n        if (THRESHOLD_DIFF < (elemRect.left - containerRect.right)) {\n            return false;\n        }\n        if (THRESHOLD_DIFF < (containerRect.left - elemRect.right)) {\n            return false;\n        }\n        return true;\n    }\n}\nScrollableService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nScrollableService.ctorParameters = () => [\n    { type: DOMService },\n    { type: NgZone }\n];\n\nconst LEFT = 'left';\nconst RIGHT = 'right';\nconst DOWN = 'down';\nconst UP = 'up';\nconst DEFAULT_TYPE = 'slide';\nconst DEFAULT_DURATION = 100;\nconst animationTypes = {};\n/* tslint:disable:object-literal-sort-keys */\nanimationTypes.expand = (direction) => {\n    const scale = direction === UP || direction === DOWN ? 'scaleY' : 'scaleX';\n    const startScale = 0;\n    const endScale = 1;\n    let origin;\n    if (direction === DOWN) {\n        origin = 'top';\n    }\n    else if (direction === LEFT) {\n        origin = RIGHT;\n    }\n    else if (direction === RIGHT) {\n        origin = LEFT;\n    }\n    else {\n        origin = 'bottom';\n    }\n    return {\n        start: { transform: `${scale}(${startScale})`, transformOrigin: origin },\n        end: { transform: `${scale}(${endScale})` }\n    };\n};\nanimationTypes.slide = (direction) => {\n    const translate = direction === LEFT || direction === RIGHT ? 'translateX' : 'translateY';\n    const start = direction === RIGHT || direction === DOWN ? -100 : 100;\n    const end = 0;\n    return {\n        start: { transform: `${translate}(${start}%)` },\n        end: { transform: `${translate}(${end}%)` }\n    };\n};\nanimationTypes.fade = () => {\n    return {\n        start: { opacity: 0 },\n        end: { opacity: 1 }\n    };\n};\nanimationTypes.zoom = () => {\n    const start = 0;\n    const end = 1;\n    return {\n        start: { transform: `scale(${start})` },\n        end: { transform: `scale(${end})` }\n    };\n};\n/**\n * @hidden\n */\nclass AnimationService {\n    constructor(animationBuilder) {\n        this.animationBuilder = animationBuilder;\n        this.start = new EventEmitter();\n        this.end = new EventEmitter();\n    }\n    play(element, options, flip) {\n        if (!this.flip || this.flip.horizontal !== flip.horizontal ||\n            this.flip.vertical !== flip.vertical) {\n            this.flip = flip;\n            const type = options.type || DEFAULT_TYPE;\n            const statesFn = animationTypes[type];\n            if (statesFn) {\n                const direction = this.getDirection(flip, options);\n                const states = statesFn(direction);\n                this.playStates(element, states, options);\n            }\n            else if (isDevMode()) {\n                throw new Error(`Unsupported animation type: \"${type}\". The supported types are slide, expand, fade and zoom.`);\n            }\n        }\n    }\n    ngOnDestroy() {\n        this.stopPlayer();\n    }\n    playStates(element, states, options) {\n        this.stopPlayer();\n        const duration = options.duration || DEFAULT_DURATION;\n        const factory = this.animationBuilder.build([\n            style(states.start),\n            animate(`${duration}ms ease-in`, style(states.end))\n        ]);\n        const player = this.player = factory.create(element);\n        player.onDone(() => {\n            this.end.emit();\n            this.stopPlayer();\n        });\n        this.start.emit();\n        player.play();\n    }\n    getDirection(flip, options) {\n        let direction = options.direction || DOWN;\n        if (flip.horizontal) {\n            if (direction === LEFT) {\n                direction = RIGHT;\n            }\n            else if (direction === RIGHT) {\n                direction = LEFT;\n            }\n        }\n        if (flip.vertical) {\n            if (direction === DOWN) {\n                direction = UP;\n            }\n            else if (direction === UP) {\n                direction = DOWN;\n            }\n        }\n        return direction;\n    }\n    stopPlayer() {\n        if (this.player) {\n            this.player.destroy();\n            this.player = null;\n        }\n    }\n}\nAnimationService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nAnimationService.ctorParameters = () => [\n    { type: AnimationBuilder }\n];\n\nconst DEFAULT_OFFSET = { left: -10000, top: 0 };\nconst ANIMATION_CONTAINER = 'k-animation-container';\nconst ANIMATION_CONTAINER_FIXED = 'k-animation-container-fixed';\n/**\n * Represents the [Kendo UI Popup component for Angular]({% slug overview_popup %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <button #anchor (click)=\"show=!show\">Toggle</button>\n *  <kendo-popup *ngIf=\"show\" [anchor]=\"anchor\">\n *      <strong>Popup content!</strong>\n *  </kendo-popup>\n * `\n * })\n * class AppComponent {\n *   public show: boolean = false;\n * }\n * ```\n */\nclass PopupComponent {\n    constructor(container, _alignService, domService, _positionService, _resizeService, _scrollableService, animationService, _renderer, _zone) {\n        this.container = container;\n        this._alignService = _alignService;\n        this.domService = domService;\n        this._positionService = _positionService;\n        this._resizeService = _resizeService;\n        this._scrollableService = _scrollableService;\n        this.animationService = animationService;\n        this._renderer = _renderer;\n        this._zone = _zone;\n        /**\n         * Controls the Popup animation. By default, the opening and closing animations\n         * are enabled ([see example]({% slug animations_popup %})).\n         */\n        this.animate = true;\n        /**\n         * Specifies the anchor pivot point\n         * ([see example]({% slug alignmentpositioning_popup %}#toc-positioning)).\n         */\n        this.anchorAlign = { horizontal: 'left', vertical: 'bottom' };\n        /**\n         * Configures the collision behavior of the Popup\n         * ([see example]({% slug viewportboundarydetection_popup %})).\n         */\n        this.collision = { horizontal: 'fit', vertical: 'flip' };\n        /**\n         * Specifies the pivot point of the Popup\n         * ([see example]({% slug alignmentpositioning_popup %}#toc-positioning)).\n         */\n        this.popupAlign = { horizontal: 'left', vertical: 'top' };\n        /**\n         * Controls whether the component will copy the `anchor` font styles.\n         */\n        this.copyAnchorStyles = false;\n        /**\n         * Specifies the position mode of the component. By default, the Popup uses fixed positioning.\n         * To make the Popup acquire absolute positioning, set this option to `absolute`.\n         *\n         * > If you need to support mobile browsers with the zoom option,\n         * use the `absolute` positioning of the Popup.\n         *\n         * @example\n         * ```html\n         * <style>\n         *  .parent-content {\n         *     position: relative;\n         *     width: 200px;\n         *     height: 200px;\n         *     overflow: auto;\n         *     margin: 200px auto;\n         *     border: 1px solid red;\n         *  }\n         *  .content {\n         *     position: relative;\n         *     width: 100px;\n         *     height: 100px;\n         *     overflow: auto;\n         *     margin: 300px;\n         *     border: 1px solid blue;\n         *  }\n         *  .anchor {\n         *     position: absolute;\n         *     top: 200px;\n         *     left: 200px;\n         *  }\n         * </style>\n         * ```\n         * ```ts\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *   <div class=\"example-config\">\n         *      Position mode:\n         *      <label><input type=\"radio\" value=\"fixed\" [(ngModel)]=\"mode\" /> Fixed</label>\n         *      <label><input type=\"radio\" value=\"absolute\" [(ngModel)]=\"mode\" /> Absolute</label>\n         *   </div>\n         *   <div class=\"example-config\">\n         *       Append to\n         *       <label>\n         *           <input type=\"radio\" name=\"place\" [value]=\"1\" [(ngModel)]=\"checked\" />\n         *           Root component\n         *       </label>\n         *       <label>\n         *           <input type=\"radio\" name=\"place\" [value]=\"2\" [(ngModel)]=\"checked\" />\n         *           <span style=\"color: red\">Red Container</span>\n         *       </label>\n         *       <label>\n         *           <input type=\"radio\" name=\"place\" [value]=\"3\" [(ngModel)]=\"checked\" />\n         *           <span style=\"color: blue\">Blue Container</span>\n         *       </label>\n         *   </div>\n         *   <div class=\"example\">\n         *     <div class=\"parent-content\" [scrollLeft]=\"250\" [scrollTop]=\"230\">\n         *         <div class=\"content\" [scrollLeft]=\"170\" [scrollTop]=\"165\">\n         *           <button #anchor class=\"anchor\" (click)=\"show = !show\">Toggle</button>\n         *           <kendo-popup [positionMode]=\"mode\" [anchor]=\"anchor\" (anchorViewportLeave)=\"show=false\" *ngIf=\"show && checked === 3\">\n         *             <ul>\n         *                 <li>Item1</li>\n         *                 <li>Item2</li>\n         *                 <li>Item3</li>\n         *             </ul>\n         *           </kendo-popup>\n         *           <span style=\"position: absolute; top: 400px; left: 400px\">Bottom/Right</span>\n         *         </div>\n         *         <kendo-popup [positionMode]=\"mode\" [anchor]=\"anchor\" (anchorViewportLeave)=\"show=false\" *ngIf=\"show && checked === 2\">\n         *           <ul>\n         *               <li>Item1</li>\n         *               <li>Item2</li>\n         *               <li>Item3</li>\n         *           </ul>\n         *         </kendo-popup>\n         *         <span style=\"position: absolute; top: 600px; left: 600px\">Bottom/Right</span>\n         *     </div>\n         *     <kendo-popup [positionMode]=\"mode\" [anchor]=\"anchor\" (anchorViewportLeave)=\"show=false\" *ngIf=\"show && checked === 1\">\n         *       <ul>\n         *           <li>Item1</li>\n         *           <li>Item2</li>\n         *           <li>Item3</li>\n         *       </ul>\n         *     </kendo-popup>\n         *   </div>\n         * `\n         * })\n         * class AppComponent {\n         *   public checked: number = 3;\n         *   public mode: string = 'absolute';\n         *   public show: boolean = true;\n         * }\n         * ```\n         */\n        this.positionMode = 'fixed';\n        /**\n         * Specifies the absolute position of the element\n         * ([see example]({% slug alignmentpositioning_popup %}#toc-aligning-to-absolute-points)).\n         * The Popup opens next to that point. The Popup pivot point is defined by the `popupAlign` configuration option.\n         * The boundary detection is applied by using the window viewport.\n         */\n        this.offset = DEFAULT_OFFSET;\n        /**\n         * Fires when the anchor is scrolled outside the screen boundaries.\n         * ([see example]({% slug closing_popup %}#toc-after-leaving-the-viewport)).\n         */\n        this.anchorViewportLeave = new EventEmitter();\n        /**\n         * Fires after the component is closed.\n         */\n        this.close = new EventEmitter();\n        /**\n         * Fires after the component is opened and the opening animation ends.\n         */\n        this.open = new EventEmitter();\n        /**\n         * Fires after the component is opened and the Popup is positioned.\n         */\n        this.positionChange = new EventEmitter();\n        this.resolvedPromise = Promise.resolve(null);\n        this.initialCheck = true;\n        this._renderer.addClass(container.nativeElement, ANIMATION_CONTAINER);\n        this.updateFixedClass();\n    }\n    ngOnInit() {\n        this.reposition = this.reposition.bind(this);\n        this._resizeService.subscribe(this.reposition);\n        this.animationSubscriptions = this.animationService.start.subscribe(this.onAnimationStart.bind(this));\n        this.animationSubscriptions.add(this.animationService.end.subscribe(this.onAnimationEnd.bind(this)));\n        this._scrollableService.forElement(this.anchor || this.container).subscribe(this.onScroll.bind(this));\n        this.currentOffset = DEFAULT_OFFSET;\n        this.setZIndex();\n        this.copyFontStyles();\n        this.updateFixedClass();\n    }\n    ngOnChanges(changes) {\n        if (changes.copyAnchorStyles) {\n            this.copyFontStyles();\n        }\n        if (changes.positionMode) {\n            this.updateFixedClass();\n        }\n    }\n    ngAfterViewInit() {\n        this.reposition();\n        if (!this.animate) {\n            this.resolvedPromise.then(() => {\n                this.onAnimationEnd();\n            });\n        }\n    }\n    ngAfterViewChecked() {\n        if (this.initialCheck) {\n            this.initialCheck = false;\n            return;\n        }\n        this._zone.runOutsideAngular(() => {\n            // workarounds https://github.com/angular/angular/issues/19094\n            // uses promise because it is executed synchronously after the content is updated\n            // does not use onStable in case the current zone is not the angular one.\n            this.unsubscribeReposition();\n            this.repositionSubscription = from(this.resolvedPromise)\n                .subscribe(this.reposition);\n        });\n    }\n    ngOnDestroy() {\n        this.anchorViewportLeave.complete();\n        this.positionChange.complete();\n        this.close.emit();\n        this.close.complete();\n        this._resizeService.unsubscribe();\n        this._scrollableService.unsubscribe();\n        this.animationSubscriptions.unsubscribe();\n        this.unsubscribeReposition();\n    }\n    /**\n     * @hidden\n     */\n    onResize() {\n        this.reposition();\n    }\n    onAnimationStart() {\n        this._renderer.removeClass(this.container.nativeElement, 'k-animation-container-shown');\n    }\n    onAnimationEnd() {\n        this._renderer.addClass(this.container.nativeElement, 'k-animation-container-shown');\n        this.open.emit();\n        this.open.complete();\n    }\n    get currentOffset() {\n        return this._currentOffset;\n    }\n    set currentOffset(offset$$1) {\n        this.setContainerStyle('left', `${offset$$1.left}px`);\n        this.setContainerStyle('top', `${offset$$1.top}px`);\n        this._currentOffset = offset$$1;\n    }\n    setZIndex() {\n        if (this.anchor) {\n            this.setContainerStyle('z-index', String(this.domService.zIndex(this.anchor, this.container)));\n        }\n    }\n    reposition() {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        const { flip, offset: offset$$1 } = this.position();\n        if (!this.currentOffset || isDifferentOffset(this.currentOffset, offset$$1)) {\n            this.currentOffset = offset$$1;\n            if (hasObservers(this.positionChange)) {\n                this._zone.run(() => this.positionChange.emit({ offset: offset$$1, flip }));\n            }\n        }\n        if (this.animate) {\n            this.animationService.play(this.contentContainer.nativeElement, this.animate, flip);\n        }\n        this.resizeSensor.acceptSize();\n    }\n    position() {\n        const alignedOffset = this._alignService.alignElement({\n            anchor: this.anchor,\n            anchorAlign: this.anchorAlign,\n            element: this.container,\n            elementAlign: this.popupAlign,\n            margin: this.margin,\n            offset: this.offset,\n            positionMode: this.positionMode\n        });\n        return this._positionService.positionElement({\n            anchor: this.anchor,\n            anchorAlign: this.anchorAlign,\n            collisions: this.collision,\n            currentLocation: alignedOffset,\n            element: this.container,\n            elementAlign: this.popupAlign,\n            margin: this.margin\n        });\n    }\n    onScroll(isInViewPort) {\n        const hasLeaveObservers = hasObservers(this.anchorViewportLeave);\n        if (isInViewPort || !hasLeaveObservers) {\n            this.reposition();\n        }\n        else if (hasLeaveObservers) {\n            this._zone.run(() => {\n                this.anchorViewportLeave.emit();\n            });\n        }\n    }\n    copyFontStyles() {\n        if (!this.anchor || !this.copyAnchorStyles) {\n            return;\n        }\n        this.domService.getFontStyles(this.anchor)\n            .forEach(s => this.setContainerStyle(s.key, s.value));\n    }\n    updateFixedClass() {\n        const action = this.positionMode === 'fixed' ? 'addClass' : 'removeClass';\n        this._renderer[action](this.container.nativeElement, ANIMATION_CONTAINER_FIXED);\n    }\n    setContainerStyle(name, value) {\n        this._renderer.setStyle(this.container.nativeElement, name, value);\n    }\n    unsubscribeReposition() {\n        if (this.repositionSubscription) {\n            this.repositionSubscription.unsubscribe();\n        }\n    }\n}\nPopupComponent.decorators = [\n    { type: Component, args: [{\n                exportAs: 'kendo-popup',\n                providers: [AlignService, AnimationService, DOMService, PositionService, ResizeService, ScrollableService],\n                selector: 'kendo-popup',\n                template: `\n        <div class=\"k-popup\" [ngClass]=\"popupClass\" #container>\n            <ng-content></ng-content>\n            <ng-template [ngTemplateOutlet]=\"content\" [ngIf]=\"content\"></ng-template>\n            <kendo-resize-sensor [rateLimit]=\"100\" (resize)=\"onResize()\">\n            </kendo-resize-sensor>\n        </div>\n     `\n            },] },\n];\n/** @nocollapse */\nPopupComponent.ctorParameters = () => [\n    { type: ElementRef },\n    { type: AlignService },\n    { type: DOMService },\n    { type: PositionService },\n    { type: ResizeService },\n    { type: ScrollableService },\n    { type: AnimationService },\n    { type: Renderer2 },\n    { type: NgZone }\n];\nPopupComponent.propDecorators = {\n    animate: [{ type: Input }],\n    anchor: [{ type: Input }],\n    anchorAlign: [{ type: Input }],\n    collision: [{ type: Input }],\n    popupAlign: [{ type: Input }],\n    copyAnchorStyles: [{ type: Input }],\n    popupClass: [{ type: Input }],\n    positionMode: [{ type: Input }],\n    offset: [{ type: Input }],\n    margin: [{ type: Input }],\n    anchorViewportLeave: [{ type: Output }],\n    close: [{ type: Output }],\n    open: [{ type: Output }],\n    positionChange: [{ type: Output }],\n    contentContainer: [{ type: ViewChild, args: ['container',] }],\n    resizeSensor: [{ type: ViewChild, args: [ResizeSensorComponent,] }]\n};\n\nconst removeElement = (element) => {\n    if (element && element.parentNode) {\n        element.parentNode.removeChild(element);\n    }\n};\n/**\n * Used to inject the Popup container. If not provided, the first root component of\n * the application is used.\n *\n * > The `POPUP_CONTAINER` can be used only with the [`PopupService`]({% slug service_popup %}) class.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Popup module\n * import { PopupModule, POPUP_CONTAINER } from '@progress/kendo-angular-popup';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { ElementRef, NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, PopupModule], // import Popup module\n *     bootstrap:    [AppComponent],\n *     providers: [{\n *       provide: POPUP_CONTAINER,\n *       useFactory: () => {\n *          //return the container ElementRef, where the popup will be injected\n *          return { nativeElement: document.body } as ElementRef;\n *       }\n *     }]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n * ```\n */\nconst POPUP_CONTAINER = new InjectionToken('Popup Container');\n/**\n * A service for opening Popup components dynamically\n * ([see example]({% slug service_popup %})).\n *\n * @export\n * @class PopupService\n */\nclass PopupService {\n    constructor(applicationRef, componentFactoryResolver, injector, container) {\n        this.applicationRef = applicationRef;\n        this.componentFactoryResolver = componentFactoryResolver;\n        this.injector = injector;\n        this.container = container;\n    }\n    /**\n     * Gets the root view container into which the component will be injected.\n     *\n     * @returns {ComponentRef<any>}\n     */\n    get rootViewContainer() {\n        // https://github.com/angular/angular/blob/4.0.x/packages/core/src/application_ref.ts#L571\n        const rootComponents = this.applicationRef.components || [];\n        if (rootComponents[0]) {\n            return rootComponents[0];\n        }\n        throw new Error(`\n            View Container not found! Inject the POPUP_CONTAINER or define a specific ViewContainerRef via the appendTo option.\n            See http://www.telerik.com/kendo-angular-ui/components/popup/api/POPUP_CONTAINER/ for more details.\n        `);\n    }\n    /**\n     * Sets or gets the HTML element of the root component container.\n     *\n     * @returns {HTMLElement}\n     */\n    get rootViewContainerNode() {\n        return this.container ? this.container.nativeElement : this.getComponentRootNode(this.rootViewContainer);\n    }\n    /**\n     * Opens a Popup component. Created Popups are mounted\n     * in the DOM directly in the root application component.\n     *\n     * @param {PopupSettings} options - The options which define the Popup.\n     * @returns {ComponentRef<PopupComponent>} - A reference to the Popup object.\n     *\n     * @example\n     *\n     * ```ts-no-run\n     * _@Component({\n     *   selector: 'my-app',\n     *   template: `\n     *     <ng-template #template>\n     *      Popup content\n     *     </ng-template>\n     *     <button #anchor kendoButton (click)=\"open(anchor, template)\">Open</button>\n     *   `\n     * })\n     * export class AppComponent {\n     *     public popupRef: PopupRef;\n     *\n     *     constructor( private popupService: PopupService ) {}\n     *\n     *     public open(anchor: ElementRef, template: TemplateRef<any>): void {\n     *         if (this.popupRef) {\n     *              this.popupRef.close();\n     *              this.popupRef = null;\n     *              return;\n     *         }\n     *\n     *         this.popupRef = this.popupService.open({\n     *           anchor: anchor,\n     *           content: template\n     *         });\n     *     }\n     * }\n     * ```\n     */\n    open(options = {}) {\n        const { component, nodes } = this.contentFrom(options.content);\n        const popupComponentRef = this.appendPopup(nodes, options.appendTo);\n        const popupInstance = popupComponentRef.instance;\n        this.projectComponentInputs(popupComponentRef, options);\n        popupComponentRef.changeDetectorRef.detectChanges();\n        if (component) {\n            component.changeDetectorRef.detectChanges();\n        }\n        const popupElement = this.getComponentRootNode(popupComponentRef);\n        return {\n            close: () => {\n                if (component) {\n                    component.destroy();\n                }\n                popupComponentRef.destroy();\n                // Angular will not remove the element unless the change detection is triggered\n                removeElement(popupElement);\n            },\n            content: component,\n            popup: popupComponentRef,\n            popupAnchorViewportLeave: popupInstance.anchorViewportLeave,\n            popupClose: popupInstance.close,\n            popupElement: popupElement,\n            popupOpen: popupInstance.open,\n            popupPositionChange: popupInstance.positionChange\n        };\n    }\n    appendPopup(nodes, container) {\n        const popupComponentRef = this.createComponent(PopupComponent, nodes, container);\n        if (!container) {\n            this.rootViewContainerNode.appendChild(this.getComponentRootNode(popupComponentRef));\n        }\n        return popupComponentRef;\n    }\n    /**\n     * Gets the HTML element for a component reference.\n     *\n     * @param {ComponentRef<any>} componentRef\n     * @returns {HTMLElement}\n     */\n    getComponentRootNode(componentRef) {\n        return componentRef.location.nativeElement;\n    }\n    /**\n     * Gets the `ComponentFactory` instance by its type.\n     *\n     * @param {*} componentClass\n     * @param {*} nodes\n     * @returns {ComponentRef<any>}\n     */\n    getComponentFactory(componentClass) {\n        return this.componentFactoryResolver.resolveComponentFactory(componentClass);\n    }\n    /**\n     * Creates a component reference from a `Component` type class.\n     *\n     * @param {*} componentClass\n     * @param {*} nodes\n     * @returns {ComponentRef<any>}\n     */\n    createComponent(componentClass, nodes, container) {\n        const factory = this.getComponentFactory(componentClass);\n        if (container) {\n            return container.createComponent(factory, undefined, this.injector, nodes);\n        }\n        else {\n            const component = factory.create(this.injector, nodes);\n            this.applicationRef.attachView(component.hostView);\n            return component;\n        }\n    }\n    /**\n     * Projects the inputs on the component.\n     *\n     * @param {ComponentRef<any>} component\n     * @param {*} options\n     * @returns {ComponentRef<any>}\n     */\n    projectComponentInputs(component, options) {\n        Object.getOwnPropertyNames(options)\n            .filter(prop => prop !== 'content' || options.content instanceof TemplateRef)\n            .map((prop) => {\n            component.instance[prop] = options[prop];\n        });\n        return component;\n    }\n    /**\n     * Gets the component and the nodes to append from the `content` option.\n     *\n     * @param {*} content\n     * @returns {any}\n     */\n    contentFrom(content) {\n        if (!content || content instanceof TemplateRef) {\n            return { component: null, nodes: [[]] };\n        }\n        const component = this.createComponent(content);\n        const nodes = component ? [component.location.nativeElement] : [];\n        return {\n            component: component,\n            nodes: [\n                nodes // <ng-content>\n            ]\n        };\n    }\n}\nPopupService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nPopupService.ctorParameters = () => [\n    { type: ApplicationRef },\n    { type: ComponentFactoryResolver },\n    { type: Injector },\n    { type: ElementRef, decorators: [{ type: Inject, args: [POPUP_CONTAINER,] }, { type: Optional }] }\n];\n\nconst POPUP_DIRECTIVES = [PopupComponent];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Popup component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Popup module\n * import { PopupModule } from '@progress/kendo-angular-popup';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, PopupModule], // import Popup module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nclass PopupModule {\n}\nPopupModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [POPUP_DIRECTIVES],\n                entryComponents: [POPUP_DIRECTIVES],\n                exports: [POPUP_DIRECTIVES],\n                imports: [CommonModule, ResizeSensorModule],\n                providers: [PopupService]\n            },] },\n];\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AlignService, AnimationService, DOMService, PositionService, ResizeService, ScrollableService, PopupService, POPUP_CONTAINER, PopupComponent, PopupModule, SCALE };\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;AAeA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwRC;;;0BAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiED,mGAGC;;;;;;;;;;;;;kCAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAqCD,4GAGC;;;;;;;;;;;;;kCAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6BD,sGAGC;;;;;;;;6FAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8DD,kHAGC;;;;;;;;6FAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4HD,+GAGC;;;;;;;iFAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAyUD,8HAeC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBA8BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsOD,mGAGC;;;;;;;;;;;;;;;kCAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmCD;;;;;;;;;;;0BASC;;;;;;;"}