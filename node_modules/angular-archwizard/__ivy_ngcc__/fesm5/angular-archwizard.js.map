{"version":3,"sources":["D:/project/projek_angular/hris_rni/node_modules/angular-archwizard/fesm5/angular-archwizard.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoBA;;;;;;;;KAQK,AAKC;;;;;;;;;;;;4EAIG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KA+BJ,AAKC;;;;;;;;;;;;4EAIG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2OH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2FAoEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAgDD;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAgBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAkvCA,AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA2NA,AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;oBAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAkED;;;;;;;;;;;;;;;;;;;;;;0BAYC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAyDA,AAKA;;;;;;;;;;;;;;;;;;;oBAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAwLA,AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAmFA,AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAoDA,AAKA;;;;;;;;;;;;;;kCAIG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAoFH,AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAmDA,AAKA;;;;;;;;;;;;;;;;;;;;;;;oBAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA2CA,AAKA;;;;;;;;;;;;;;kCAIG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAgDJ;;;;;;;;;;;;;;;;;;;;;;;;0BAeC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAiED;;;;;;;;;;;;;;;;;;0BAWC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAmFA,AAKA;;;;;;;;;;;;;;;;;;;;;;;oBASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAgEA,AAKA;;;;;;;;;;;;;;;;;;;;oBAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAgCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gDA6CA","file":"angular-archwizard.js","sourcesContent":["import { __extends } from 'tslib';\nimport { Directive, TemplateRef, ContentChild, Input, Output, HostBinding, EventEmitter, Component, forwardRef, ContentChildren, Host, Optional, HostListener, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `awWizardStepSymbol` directive can be used as an alternative to the `navigationSymbol` input of a [[WizardStep]]\n * to define the step symbol inside the navigation bar.  This way step symbol may contain arbitrary content.\n *\n * ### Syntax\n *\n * ```html\n * <ng-template awWizardStepSymbol>\n *     ...\n * </ng-template>\n * ```\n */\nvar WizardStepSymbolDirective = /** @class */ (function () {\n    /**\n     * Constructor\n     *\n     * @param templateRef A reference to the content of the `ng-template` that contains this [[WizardStepSymbolDirective]]\n     */\n    function WizardStepSymbolDirective(templateRef) {\n        this.templateRef = templateRef;\n    }\n    WizardStepSymbolDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: 'ng-template[awStepSymbol], ng-template[awWizardStepSymbol]'\n                },] }\n    ];\n    /** @nocollapse */\n    WizardStepSymbolDirective.ctorParameters = function () { return [\n        { type: TemplateRef }\n    ]; };\n    return WizardStepSymbolDirective;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `awWizardStepTitle` directive can be used as an alternative to the `stepTitle` input of a [[WizardStep]]\n * to define the content of a step title inside the navigation bar.\n * This step title can be freely created and can contain more than only plain text\n *\n * ### Syntax\n *\n * ```html\n * <ng-template awWizardStepTitle>\n *     ...\n * </ng-template>\n * ```\n *\n * @author Marc Arndt\n */\nvar WizardStepTitleDirective = /** @class */ (function () {\n    /**\n     * Constructor\n     *\n     * @param templateRef A reference to the content of the `ng-template` that contains this [[WizardStepTitleDirective]]\n     */\n    function WizardStepTitleDirective(templateRef) {\n        this.templateRef = templateRef;\n    }\n    WizardStepTitleDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: 'ng-template[awStepTitle], ng-template[awWizardStepTitle]'\n                },] }\n    ];\n    /** @nocollapse */\n    WizardStepTitleDirective.ctorParameters = function () { return [\n        { type: TemplateRef }\n    ]; };\n    return WizardStepTitleDirective;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Basic functionality every type of wizard step needs to provide\n *\n * @author Marc Arndt\n * @abstract\n */\nvar WizardStep = /** @class */ (function () {\n    function WizardStep() {\n        /**\n         * A symbol property, which contains an optional symbol for the step inside the navigation bar.\n         * Takes effect when `stepSymbolTemplate` is not defined or null.\n         */\n        this.navigationSymbol = { symbol: '' };\n        /**\n         * A boolean describing if the wizard step is currently selected\n         */\n        this.selected = false;\n        /**\n         * A boolean describing if the wizard step has been completed\n         */\n        this.completed = false;\n        /**\n         * A boolean describing if the wizard step is shown as completed when the wizard is presented to the user\n         *\n         * Users will typically use `CompletedStepDirective` to set this flag\n         */\n        this.initiallyCompleted = false;\n        /**\n         * A boolean describing if the wizard step is being edited after being competed\n         *\n         * This flag can only be true when `selected` is true.\n         */\n        this.editing = false;\n        /**\n         * A boolean describing, if the wizard step should be selected by default, i.e. after the wizard has been initialized as the initial step\n         */\n        this.defaultSelected = false;\n        /**\n         * A boolean describing if the wizard step is an optional step\n         */\n        this.optional = false;\n        /**\n         * A function or boolean deciding, if this step can be entered\n         */\n        this.canEnter = true;\n        /**\n         * A function or boolean deciding, if this step can be exited\n         */\n        this.canExit = true;\n        /**\n         * This [[EventEmitter]] is called when the step is entered.\n         * The bound method should be used to do initialization work.\n         */\n        this.stepEnter = new EventEmitter();\n        /**\n         * This [[EventEmitter]] is called when the step is exited.\n         * The bound method can be used to do cleanup work.\n         */\n        this.stepExit = new EventEmitter();\n    }\n    Object.defineProperty(WizardStep.prototype, \"hidden\", {\n        /**\n         * Returns if this wizard step should be visible to the user.\n         * If the step should be visible to the user false is returned, otherwise true\n         */\n        get: /**\n         * Returns if this wizard step should be visible to the user.\n         * If the step should be visible to the user false is returned, otherwise true\n         * @return {?}\n         */\n        function () {\n            return !this.selected;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * This method returns true, if this wizard step can be transitioned with a given direction.\n     * Transitioned in this case means either entered or exited, depending on the given `condition` parameter.\n     *\n     * @param condition A condition variable, deciding if the step can be transitioned\n     * @param direction The direction in which this step should be transitioned\n     * @returns A [[Promise]] containing `true`, if this step can transitioned in the given direction\n     * @throws An `Error` is thrown if `condition` is neither a function nor a boolean\n     */\n    /**\n     * This method returns true, if this wizard step can be transitioned with a given direction.\n     * Transitioned in this case means either entered or exited, depending on the given `condition` parameter.\n     *\n     * @throws An `Error` is thrown if `condition` is neither a function nor a boolean\n     * @private\n     * @param {?} condition A condition variable, deciding if the step can be transitioned\n     * @param {?} direction The direction in which this step should be transitioned\n     * @return {?} A [[Promise]] containing `true`, if this step can transitioned in the given direction\n     */\n    WizardStep.canTransitionStep = /**\n     * This method returns true, if this wizard step can be transitioned with a given direction.\n     * Transitioned in this case means either entered or exited, depending on the given `condition` parameter.\n     *\n     * @throws An `Error` is thrown if `condition` is neither a function nor a boolean\n     * @private\n     * @param {?} condition A condition variable, deciding if the step can be transitioned\n     * @param {?} direction The direction in which this step should be transitioned\n     * @return {?} A [[Promise]] containing `true`, if this step can transitioned in the given direction\n     */\n    function (condition, direction) {\n        if (typeof (condition) === typeof (true)) {\n            return Promise.resolve((/** @type {?} */ (condition)));\n        }\n        else if (condition instanceof Function) {\n            return Promise.resolve(condition(direction));\n        }\n        else {\n            return Promise.reject(new Error(\"Input value '\" + condition + \"' is neither a boolean nor a function\"));\n        }\n    };\n    /**\n     * A function called when the step is entered\n     *\n     * @param direction The direction in which the step is entered\n     */\n    /**\n     * A function called when the step is entered\n     *\n     * @param {?} direction The direction in which the step is entered\n     * @return {?}\n     */\n    WizardStep.prototype.enter = /**\n     * A function called when the step is entered\n     *\n     * @param {?} direction The direction in which the step is entered\n     * @return {?}\n     */\n    function (direction) {\n        this.stepEnter.emit(direction);\n    };\n    /**\n     * A function called when the step is exited\n     *\n     * @param direction The direction in which the step is exited\n     */\n    /**\n     * A function called when the step is exited\n     *\n     * @param {?} direction The direction in which the step is exited\n     * @return {?}\n     */\n    WizardStep.prototype.exit = /**\n     * A function called when the step is exited\n     *\n     * @param {?} direction The direction in which the step is exited\n     * @return {?}\n     */\n    function (direction) {\n        this.stepExit.emit(direction);\n    };\n    /**\n     * This method returns true, if this wizard step can be entered from the given direction.\n     * Because this method depends on the value `canEnter`, it will throw an error, if `canEnter` is neither a boolean\n     * nor a function.\n     *\n     * @param direction The direction in which this step should be entered\n     * @returns A [[Promise]] containing `true`, if the step can be entered in the given direction, false otherwise\n     * @throws An `Error` is thrown if `anEnter` is neither a function nor a boolean\n     */\n    /**\n     * This method returns true, if this wizard step can be entered from the given direction.\n     * Because this method depends on the value `canEnter`, it will throw an error, if `canEnter` is neither a boolean\n     * nor a function.\n     *\n     * @throws An `Error` is thrown if `anEnter` is neither a function nor a boolean\n     * @param {?} direction The direction in which this step should be entered\n     * @return {?} A [[Promise]] containing `true`, if the step can be entered in the given direction, false otherwise\n     */\n    WizardStep.prototype.canEnterStep = /**\n     * This method returns true, if this wizard step can be entered from the given direction.\n     * Because this method depends on the value `canEnter`, it will throw an error, if `canEnter` is neither a boolean\n     * nor a function.\n     *\n     * @throws An `Error` is thrown if `anEnter` is neither a function nor a boolean\n     * @param {?} direction The direction in which this step should be entered\n     * @return {?} A [[Promise]] containing `true`, if the step can be entered in the given direction, false otherwise\n     */\n    function (direction) {\n        return WizardStep.canTransitionStep(this.canEnter, direction);\n    };\n    /**\n     * This method returns true, if this wizard step can be exited into given direction.\n     * Because this method depends on the value `canExit`, it will throw an error, if `canExit` is neither a boolean\n     * nor a function.\n     *\n     * @param direction The direction in which this step should be left\n     * @returns A [[Promise]] containing `true`, if the step can be exited in the given direction, false otherwise\n     * @throws An `Error` is thrown if `canExit` is neither a function nor a boolean\n     */\n    /**\n     * This method returns true, if this wizard step can be exited into given direction.\n     * Because this method depends on the value `canExit`, it will throw an error, if `canExit` is neither a boolean\n     * nor a function.\n     *\n     * @throws An `Error` is thrown if `canExit` is neither a function nor a boolean\n     * @param {?} direction The direction in which this step should be left\n     * @return {?} A [[Promise]] containing `true`, if the step can be exited in the given direction, false otherwise\n     */\n    WizardStep.prototype.canExitStep = /**\n     * This method returns true, if this wizard step can be exited into given direction.\n     * Because this method depends on the value `canExit`, it will throw an error, if `canExit` is neither a boolean\n     * nor a function.\n     *\n     * @throws An `Error` is thrown if `canExit` is neither a function nor a boolean\n     * @param {?} direction The direction in which this step should be left\n     * @return {?} A [[Promise]] containing `true`, if the step can be exited in the given direction, false otherwise\n     */\n    function (direction) {\n        return WizardStep.canTransitionStep(this.canExit, direction);\n    };\n    WizardStep.propDecorators = {\n        stepTitleTemplate: [{ type: ContentChild, args: [WizardStepTitleDirective, { static: false },] }],\n        stepSymbolTemplate: [{ type: ContentChild, args: [WizardStepSymbolDirective, { static: false },] }],\n        stepId: [{ type: Input }],\n        stepTitle: [{ type: Input }],\n        navigationSymbol: [{ type: Input }],\n        canEnter: [{ type: Input }],\n        canExit: [{ type: Input }],\n        stepEnter: [{ type: Output }],\n        stepExit: [{ type: Output }],\n        hidden: [{ type: HostBinding, args: ['hidden',] }]\n    };\n    return WizardStep;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Basic functionality every wizard completion step needs to provide\n *\n * @author Marc Arndt\n * @abstract\n */\nvar  /**\n * Basic functionality every wizard completion step needs to provide\n *\n * @author Marc Arndt\n * @abstract\n */\nWizardCompletionStep = /** @class */ (function (_super) {\n    __extends(WizardCompletionStep, _super);\n    function WizardCompletionStep() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         * @inheritDoc\n         */\n        _this.stepExit = new EventEmitter();\n        /**\n         * @inheritDoc\n         */\n        _this.canExit = false;\n        return _this;\n    }\n    /**\n     * @inheritDoc\n     */\n    /**\n     * @inheritDoc\n     * @param {?} direction\n     * @return {?}\n     */\n    WizardCompletionStep.prototype.enter = /**\n     * @inheritDoc\n     * @param {?} direction\n     * @return {?}\n     */\n    function (direction) {\n        this.completed = true;\n        this.stepEnter.emit(direction);\n    };\n    /**\n     * @inheritDoc\n     */\n    /**\n     * @inheritDoc\n     * @param {?} direction\n     * @return {?}\n     */\n    WizardCompletionStep.prototype.exit = /**\n     * @inheritDoc\n     * @param {?} direction\n     * @return {?}\n     */\n    function (direction) {\n        // set this completion step as incomplete (unless it happens to be initiallyCompleted)\n        this.completed = this.initiallyCompleted;\n        this.stepExit.emit(direction);\n    };\n    return WizardCompletionStep;\n}(WizardStep));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `aw-wizard-completion-step` component can be used to define a completion/success step at the end of your wizard\n * After a `aw-wizard-completion-step` has been entered, it has the characteristic that the user is blocked from\n * leaving it again to a previous step.\n * In addition entering a `aw-wizard-completion-step` automatically sets the `aw-wizard` and all steps inside the `aw-wizard`\n * as completed.\n *\n * ### Syntax\n *\n * ```html\n * <aw-wizard-completion-step [stepTitle]=\"title of the wizard step\"\n *    [navigationSymbol]=\"{ symbol: 'navigation symbol', fontFamily: 'navigation symbol font family' }\"\n *    (stepEnter)=\"event emitter to be called when the wizard step is entered\"\n *    (stepExit)=\"event emitter to be called when the wizard step is exited\">\n *    ...\n * </aw-wizard-completion-step>\n * ```\n *\n * ### Example\n *\n * ```html\n * <aw-wizard-completion-step stepTitle=\"Step 1\" [navigationSymbol]=\"{ symbol: '1' }\">\n *    ...\n * </aw-wizard-completion-step>\n * ```\n *\n * With a navigation symbol from the `font-awesome` font:\n *\n * ```html\n * <aw-wizard-completion-step stepTitle=\"Step 1\" [navigationSymbol]=\"{ symbol: '&#xf1ba;', fontFamily: 'FontAwesome' }\">\n *    ...\n * </aw-wizard-completion-step>\n * ```\n *\n * @author Marc Arndt\n */\nvar WizardCompletionStepComponent = /** @class */ (function (_super) {\n    __extends(WizardCompletionStepComponent, _super);\n    function WizardCompletionStepComponent() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    WizardCompletionStepComponent.decorators = [\n        { type: Component, args: [{\n                    selector: 'aw-wizard-completion-step',\n                    template: \"<ng-content></ng-content>\\n\",\n                    providers: [\n                        { provide: WizardStep, useExisting: forwardRef((/**\n                             * @return {?}\n                             */\n                            function () { return WizardCompletionStepComponent; })) },\n                        { provide: WizardCompletionStep, useExisting: forwardRef((/**\n                             * @return {?}\n                             */\n                            function () { return WizardCompletionStepComponent; })) }\n                    ]\n                }] }\n    ];\n    return WizardCompletionStepComponent;\n}(WizardCompletionStep));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The direction in which a step transition was made\n *\n * @author Marc Arndt\n */\n/** @enum {number} */\nvar MovingDirection = {\n    /**\n     * A forward step transition\n     */\n    Forwards: 0,\n    /**\n     * A backward step transition\n     */\n    Backwards: 1,\n    /**\n     * No step transition was done\n     */\n    Stay: 2,\n};\nMovingDirection[MovingDirection.Forwards] = 'Forwards';\nMovingDirection[MovingDirection.Backwards] = 'Backwards';\nMovingDirection[MovingDirection.Stay] = 'Stay';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Base implementation of [[NavigationMode]]\n *\n * Note: Built-in [[NavigationMode]] classes should be stateless, allowing the library user to easily create\n * an instance of a particular [[NavigationMode]] class and pass it to `<aw-wizard [navigationMode]=\"...\">`.\n *\n * @author Marc Arndt\n * @abstract\n */\nvar  /**\n * Base implementation of [[NavigationMode]]\n *\n * Note: Built-in [[NavigationMode]] classes should be stateless, allowing the library user to easily create\n * an instance of a particular [[NavigationMode]] class and pass it to `<aw-wizard [navigationMode]=\"...\">`.\n *\n * @author Marc Arndt\n * @abstract\n */\nBaseNavigationMode = /** @class */ (function () {\n    function BaseNavigationMode() {\n    }\n    /**\n     * Checks, whether a wizard step, as defined by the given destination index, can be transitioned to.\n     *\n     * This method controls navigation by [[goToStep]], [[goToPreviousStep]], and [[goToNextStep]] directives.\n     * Navigation by navigation bar is governed by [[isNavigable]].\n     *\n     * In this implementation, a destination wizard step can be entered if:\n     * - it exists\n     * - the current step can be exited in the direction of the destination step\n     * - the destination step can be entered in the direction from the current step\n     *\n     * Subclasses can impose additional restrictions, see [[canTransitionToStep]].\n     *\n     * @param wizard The wizard component to operate on\n     * @param destinationIndex The index of the destination step\n     * @returns A [[Promise]] containing `true`, if the destination step can be transitioned to and `false` otherwise\n     */\n    /**\n     * Checks, whether a wizard step, as defined by the given destination index, can be transitioned to.\n     *\n     * This method controls navigation by [[goToStep]], [[goToPreviousStep]], and [[goToNextStep]] directives.\n     * Navigation by navigation bar is governed by [[isNavigable]].\n     *\n     * In this implementation, a destination wizard step can be entered if:\n     * - it exists\n     * - the current step can be exited in the direction of the destination step\n     * - the destination step can be entered in the direction from the current step\n     *\n     * Subclasses can impose additional restrictions, see [[canTransitionToStep]].\n     *\n     * @param {?} wizard The wizard component to operate on\n     * @param {?} destinationIndex The index of the destination step\n     * @return {?} A [[Promise]] containing `true`, if the destination step can be transitioned to and `false` otherwise\n     */\n    BaseNavigationMode.prototype.canGoToStep = /**\n     * Checks, whether a wizard step, as defined by the given destination index, can be transitioned to.\n     *\n     * This method controls navigation by [[goToStep]], [[goToPreviousStep]], and [[goToNextStep]] directives.\n     * Navigation by navigation bar is governed by [[isNavigable]].\n     *\n     * In this implementation, a destination wizard step can be entered if:\n     * - it exists\n     * - the current step can be exited in the direction of the destination step\n     * - the destination step can be entered in the direction from the current step\n     *\n     * Subclasses can impose additional restrictions, see [[canTransitionToStep]].\n     *\n     * @param {?} wizard The wizard component to operate on\n     * @param {?} destinationIndex The index of the destination step\n     * @return {?} A [[Promise]] containing `true`, if the destination step can be transitioned to and `false` otherwise\n     */\n    function (wizard, destinationIndex) {\n        var _this = this;\n        /** @type {?} */\n        var hasStep = wizard.hasStep(destinationIndex);\n        /** @type {?} */\n        var movingDirection = wizard.getMovingDirection(destinationIndex);\n        /** @type {?} */\n        var canExitCurrentStep = (/**\n         * @param {?} previous\n         * @return {?}\n         */\n        function (previous) {\n            return previous && wizard.currentStep.canExitStep(movingDirection);\n        });\n        /** @type {?} */\n        var canEnterDestinationStep = (/**\n         * @param {?} previous\n         * @return {?}\n         */\n        function (previous) {\n            return previous && wizard.getStepAtIndex(destinationIndex).canEnterStep(movingDirection);\n        });\n        /** @type {?} */\n        var canTransitionToStep = (/**\n         * @param {?} previous\n         * @return {?}\n         */\n        function (previous) {\n            return previous && _this.canTransitionToStep(wizard, destinationIndex);\n        });\n        return Promise.resolve(hasStep)\n            .then(canTransitionToStep)\n            // Apply user-defined checks at the end.  They can involve user interaction\n            // which is better to be avoided if navigation mode does not actually allow the transition\n            // (`canTransitionToStep` returns `false`).\n            .then(canExitCurrentStep)\n            .then(canEnterDestinationStep);\n    };\n    /**\n     * Imposes additional restrictions for `canGoToStep` in current navigation mode.\n     *\n     * The base implementation allows transition iff the given step is navigable from the navigation bar (see `isNavigable`).\n     * However, in some navigation modes `canTransitionToStep` can be more relaxed to allow navigation to certain steps\n     * by previous/next buttons, but not using the navigation bar.\n     *\n     * @param wizard The wizard component to operate on\n     * @param destinationIndex The index of the destination step\n     * @returns `true`, if the destination step can be transitioned to and `false` otherwise\n     */\n    /**\n     * Imposes additional restrictions for `canGoToStep` in current navigation mode.\n     *\n     * The base implementation allows transition iff the given step is navigable from the navigation bar (see `isNavigable`).\n     * However, in some navigation modes `canTransitionToStep` can be more relaxed to allow navigation to certain steps\n     * by previous/next buttons, but not using the navigation bar.\n     *\n     * @protected\n     * @param {?} wizard The wizard component to operate on\n     * @param {?} destinationIndex The index of the destination step\n     * @return {?} `true`, if the destination step can be transitioned to and `false` otherwise\n     */\n    BaseNavigationMode.prototype.canTransitionToStep = /**\n     * Imposes additional restrictions for `canGoToStep` in current navigation mode.\n     *\n     * The base implementation allows transition iff the given step is navigable from the navigation bar (see `isNavigable`).\n     * However, in some navigation modes `canTransitionToStep` can be more relaxed to allow navigation to certain steps\n     * by previous/next buttons, but not using the navigation bar.\n     *\n     * @protected\n     * @param {?} wizard The wizard component to operate on\n     * @param {?} destinationIndex The index of the destination step\n     * @return {?} `true`, if the destination step can be transitioned to and `false` otherwise\n     */\n    function (wizard, destinationIndex) {\n        return this.isNavigable(wizard, destinationIndex);\n    };\n    /**\n     * Tries to transition to the wizard step, as denoted by the given destination index.\n     *\n     * When entering the destination step, the following actions are done:\n     * - the old current step is set as completed\n     * - the old current step is set as unselected\n     * - the old current step is exited\n     * - the destination step is set as selected\n     * - the destination step is entered\n     *\n     * When the destination step couldn't be entered, the following actions are done:\n     * - the current step is exited and entered in the direction `MovingDirection.Stay`\n     *\n     * @param wizard The wizard component to operate on\n     * @param destinationIndex The index of the destination wizard step, which should be entered\n     * @param preFinalize An event emitter, to be called before the step has been transitioned\n     * @param postFinalize An event emitter, to be called after the step has been transitioned\n     */\n    /**\n     * Tries to transition to the wizard step, as denoted by the given destination index.\n     *\n     * When entering the destination step, the following actions are done:\n     * - the old current step is set as completed\n     * - the old current step is set as unselected\n     * - the old current step is exited\n     * - the destination step is set as selected\n     * - the destination step is entered\n     *\n     * When the destination step couldn't be entered, the following actions are done:\n     * - the current step is exited and entered in the direction `MovingDirection.Stay`\n     *\n     * @param {?} wizard The wizard component to operate on\n     * @param {?} destinationIndex The index of the destination wizard step, which should be entered\n     * @param {?=} preFinalize An event emitter, to be called before the step has been transitioned\n     * @param {?=} postFinalize An event emitter, to be called after the step has been transitioned\n     * @return {?}\n     */\n    BaseNavigationMode.prototype.goToStep = /**\n     * Tries to transition to the wizard step, as denoted by the given destination index.\n     *\n     * When entering the destination step, the following actions are done:\n     * - the old current step is set as completed\n     * - the old current step is set as unselected\n     * - the old current step is exited\n     * - the destination step is set as selected\n     * - the destination step is entered\n     *\n     * When the destination step couldn't be entered, the following actions are done:\n     * - the current step is exited and entered in the direction `MovingDirection.Stay`\n     *\n     * @param {?} wizard The wizard component to operate on\n     * @param {?} destinationIndex The index of the destination wizard step, which should be entered\n     * @param {?=} preFinalize An event emitter, to be called before the step has been transitioned\n     * @param {?=} postFinalize An event emitter, to be called after the step has been transitioned\n     * @return {?}\n     */\n    function (wizard, destinationIndex, preFinalize, postFinalize) {\n        var _this = this;\n        this.canGoToStep(wizard, destinationIndex).then((/**\n         * @param {?} navigationAllowed\n         * @return {?}\n         */\n        function (navigationAllowed) {\n            if (navigationAllowed) {\n                // the current step can be exited in the given direction\n                /** @type {?} */\n                var movingDirection = wizard.getMovingDirection(destinationIndex);\n                /* istanbul ignore if */\n                if (preFinalize) {\n                    preFinalize.emit();\n                }\n                // leave current step\n                wizard.currentStep.completed = true;\n                wizard.currentStep.exit(movingDirection);\n                wizard.currentStep.editing = false;\n                wizard.currentStep.selected = false;\n                _this.transition(wizard, destinationIndex);\n                // remember if the next step is already completed before entering it to properly set `editing` flag\n                /** @type {?} */\n                var wasCompleted = wizard.completed || wizard.currentStep.completed;\n                // go to next step\n                wizard.currentStep.enter(movingDirection);\n                wizard.currentStep.selected = true;\n                if (wasCompleted) {\n                    wizard.currentStep.editing = true;\n                }\n                /* istanbul ignore if */\n                if (postFinalize) {\n                    postFinalize.emit();\n                }\n            }\n            else {\n                // if the current step can't be left, reenter the current step\n                wizard.currentStep.exit(MovingDirection.Stay);\n                wizard.currentStep.enter(MovingDirection.Stay);\n            }\n        }));\n    };\n    /**\n     * Transitions the wizard to the given step index.\n     *\n     * Can perform additional actions in particular navigation mode implementations.\n     *\n     * @param wizard The wizard component to operate on\n     * @param destinationIndex The index of the destination wizard step\n     */\n    /**\n     * Transitions the wizard to the given step index.\n     *\n     * Can perform additional actions in particular navigation mode implementations.\n     *\n     * @protected\n     * @param {?} wizard The wizard component to operate on\n     * @param {?} destinationIndex The index of the destination wizard step\n     * @return {?}\n     */\n    BaseNavigationMode.prototype.transition = /**\n     * Transitions the wizard to the given step index.\n     *\n     * Can perform additional actions in particular navigation mode implementations.\n     *\n     * @protected\n     * @param {?} wizard The wizard component to operate on\n     * @param {?} destinationIndex The index of the destination wizard step\n     * @return {?}\n     */\n    function (wizard, destinationIndex) {\n        wizard.currentStepIndex = destinationIndex;\n    };\n    /**\n     * Resets the state of this wizard.\n     *\n     * A reset transitions the wizard automatically to the first step and sets all steps as incomplete.\n     * In addition the whole wizard is set as incomplete.\n     *\n     * @param wizard The wizard component to operate on\n     */\n    /**\n     * Resets the state of this wizard.\n     *\n     * A reset transitions the wizard automatically to the first step and sets all steps as incomplete.\n     * In addition the whole wizard is set as incomplete.\n     *\n     * @param {?} wizard The wizard component to operate on\n     * @return {?}\n     */\n    BaseNavigationMode.prototype.reset = /**\n     * Resets the state of this wizard.\n     *\n     * A reset transitions the wizard automatically to the first step and sets all steps as incomplete.\n     * In addition the whole wizard is set as incomplete.\n     *\n     * @param {?} wizard The wizard component to operate on\n     * @return {?}\n     */\n    function (wizard) {\n        this.ensureCanReset(wizard);\n        // reset the step internal state\n        wizard.wizardSteps.forEach((/**\n         * @param {?} step\n         * @return {?}\n         */\n        function (step) {\n            step.completed = step.initiallyCompleted;\n            step.selected = false;\n            step.editing = false;\n        }));\n        // set the first step as the current step\n        wizard.currentStepIndex = wizard.defaultStepIndex;\n        wizard.currentStep.selected = true;\n        wizard.currentStep.enter(MovingDirection.Forwards);\n    };\n    /**\n     * Checks if wizard configuration allows to perform reset.\n     *\n     * A check failure is indicated by throwing an `Error` with the message discribing the discovered misconfiguration issue.\n     *\n     * Can include additional checks in particular navigation mode implementations.\n     *\n     * @param wizard The wizard component to operate on\n     * @throws An `Error` is thrown, if a micconfiguration issue is discovered.\n     */\n    /**\n     * Checks if wizard configuration allows to perform reset.\n     *\n     * A check failure is indicated by throwing an `Error` with the message discribing the discovered misconfiguration issue.\n     *\n     * Can include additional checks in particular navigation mode implementations.\n     *\n     * @throws An `Error` is thrown, if a micconfiguration issue is discovered.\n     * @protected\n     * @param {?} wizard The wizard component to operate on\n     * @return {?}\n     */\n    BaseNavigationMode.prototype.ensureCanReset = /**\n     * Checks if wizard configuration allows to perform reset.\n     *\n     * A check failure is indicated by throwing an `Error` with the message discribing the discovered misconfiguration issue.\n     *\n     * Can include additional checks in particular navigation mode implementations.\n     *\n     * @throws An `Error` is thrown, if a micconfiguration issue is discovered.\n     * @protected\n     * @param {?} wizard The wizard component to operate on\n     * @return {?}\n     */\n    function (wizard) {\n        // the wizard doesn't contain a step with the default step index\n        if (!wizard.hasStep(wizard.defaultStepIndex)) {\n            throw new Error(\"The wizard doesn't contain a step with index \" + wizard.defaultStepIndex);\n        }\n    };\n    return BaseNavigationMode;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The default navigation mode used by [[WizardComponent]] and [[NavigationModeDirective]].\n *\n * It is parameterized with two navigation policies passed to constructor:\n *\n * - [[navigateBackward]] policy controls whether wizard steps before the current step are navigable:\n *\n *   - `\"deny\"` -- the steps are not navigable\n *   - `\"allow\"` -- the steps are navigable\n *   - If the corresponding constructor argument is omitted or is `null` or `undefined`,\n *     then the default value is applied which is `\"deny\"`\n *\n * - [[navigateForward]] policy controls whether wizard steps after the current step are navigable:\n *\n *   - `\"deny\"` -- the steps are not navigable\n *   - `\"allow\"` -- the steps are navigable\n *   - `\"visited\"` -- a step is navigable iff it was already visited before\n *   - If the corresponding constructor argument is omitted or is `null` or `undefined`,\n *     then the default value is applied which is `\"allow\"`\n */\nvar  /**\n * The default navigation mode used by [[WizardComponent]] and [[NavigationModeDirective]].\n *\n * It is parameterized with two navigation policies passed to constructor:\n *\n * - [[navigateBackward]] policy controls whether wizard steps before the current step are navigable:\n *\n *   - `\"deny\"` -- the steps are not navigable\n *   - `\"allow\"` -- the steps are navigable\n *   - If the corresponding constructor argument is omitted or is `null` or `undefined`,\n *     then the default value is applied which is `\"deny\"`\n *\n * - [[navigateForward]] policy controls whether wizard steps after the current step are navigable:\n *\n *   - `\"deny\"` -- the steps are not navigable\n *   - `\"allow\"` -- the steps are navigable\n *   - `\"visited\"` -- a step is navigable iff it was already visited before\n *   - If the corresponding constructor argument is omitted or is `null` or `undefined`,\n *     then the default value is applied which is `\"allow\"`\n */\nConfigurableNavigationMode = /** @class */ (function (_super) {\n    __extends(ConfigurableNavigationMode, _super);\n    /**\n     * Constructor\n     *\n     * @param navigateBackward Controls whether wizard steps before the current step are navigable\n     * @param navigateForward Controls whether wizard steps before the current step are navigable\n     */\n    function ConfigurableNavigationMode(navigateBackward, navigateForward) {\n        if (navigateBackward === void 0) { navigateBackward = null; }\n        if (navigateForward === void 0) { navigateForward = null; }\n        var _this = _super.call(this) || this;\n        _this.navigateBackward = navigateBackward;\n        _this.navigateForward = navigateForward;\n        _this.navigateBackward = _this.navigateBackward || 'allow';\n        _this.navigateForward = _this.navigateForward || 'deny';\n        return _this;\n    }\n    /**\n     * @inheritDoc\n     */\n    /**\n     * @inheritDoc\n     * @protected\n     * @param {?} wizard\n     * @param {?} destinationIndex\n     * @return {?}\n     */\n    ConfigurableNavigationMode.prototype.canTransitionToStep = /**\n     * @inheritDoc\n     * @protected\n     * @param {?} wizard\n     * @param {?} destinationIndex\n     * @return {?}\n     */\n    function (wizard, destinationIndex) {\n        // if the destination step can be navigated to using the navigation bar,\n        // it should be accessible with [goToStep] as well\n        if (this.isNavigable(wizard, destinationIndex)) {\n            return true;\n        }\n        // navigation with [goToStep] is permitted if all previous steps\n        // to the destination step have been completed or are optional\n        return wizard.wizardSteps\n            .filter((/**\n         * @param {?} step\n         * @param {?} index\n         * @return {?}\n         */\n        function (step, index) { return index < destinationIndex && index !== wizard.currentStepIndex; }))\n            .every((/**\n         * @param {?} step\n         * @return {?}\n         */\n        function (step) { return step.completed || step.optional; }));\n    };\n    /**\n     * @inheritDoc\n     */\n    /**\n     * @inheritDoc\n     * @protected\n     * @param {?} wizard\n     * @param {?} destinationIndex\n     * @return {?}\n     */\n    ConfigurableNavigationMode.prototype.transition = /**\n     * @inheritDoc\n     * @protected\n     * @param {?} wizard\n     * @param {?} destinationIndex\n     * @return {?}\n     */\n    function (wizard, destinationIndex) {\n        if (this.navigateForward === 'deny') {\n            // set all steps after the destination step to incomplete\n            wizard.wizardSteps\n                .filter((/**\n             * @param {?} step\n             * @param {?} index\n             * @return {?}\n             */\n            function (step, index) { return wizard.currentStepIndex > destinationIndex && index > destinationIndex; }))\n                .forEach((/**\n             * @param {?} step\n             * @return {?}\n             */\n            function (step) { return step.completed = false; }));\n        }\n        _super.prototype.transition.call(this, wizard, destinationIndex);\n    };\n    /**\n     * @inheritDoc\n     */\n    /**\n     * @inheritDoc\n     * @param {?} wizard\n     * @param {?} destinationIndex\n     * @return {?}\n     */\n    ConfigurableNavigationMode.prototype.isNavigable = /**\n     * @inheritDoc\n     * @param {?} wizard\n     * @param {?} destinationIndex\n     * @return {?}\n     */\n    function (wizard, destinationIndex) {\n        // Check if the destination step can be navigated to\n        /** @type {?} */\n        var destinationStep = wizard.getStepAtIndex(destinationIndex);\n        if (destinationStep instanceof WizardCompletionStep) {\n            // A completion step can only be entered, if all previous steps have been completed, are optional, or selected\n            /** @type {?} */\n            var previousStepsCompleted = wizard.wizardSteps\n                .filter((/**\n             * @param {?} step\n             * @param {?} index\n             * @return {?}\n             */\n            function (step, index) { return index < destinationIndex; }))\n                .every((/**\n             * @param {?} step\n             * @return {?}\n             */\n            function (step) { return step.completed || step.optional || step.selected; }));\n            if (!previousStepsCompleted) {\n                return false;\n            }\n        }\n        // Apply navigation pocicies\n        if (destinationIndex < wizard.currentStepIndex) {\n            // If the destination step is before current, apply the `navigateBackward` policy\n            switch (this.navigateBackward) {\n                case 'allow': return true;\n                case 'deny': return false;\n                default:\n                    throw new Error(\"Invalid value for navigateBackward: \" + this.navigateBackward);\n            }\n        }\n        else if (destinationIndex > wizard.currentStepIndex) {\n            // If the destination step is after current, apply the `navigateForward` policy\n            switch (this.navigateForward) {\n                case 'allow': return true;\n                case 'deny': return false;\n                case 'visited': return destinationStep.completed;\n                default:\n                    throw new Error(\"Invalid value for navigateForward: \" + this.navigateForward);\n            }\n        }\n        else {\n            // Re-entering the current step is not allowed\n            return false;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    /**\n     * @inheritDoc\n     * @protected\n     * @param {?} wizard\n     * @return {?}\n     */\n    ConfigurableNavigationMode.prototype.ensureCanReset = /**\n     * @inheritDoc\n     * @protected\n     * @param {?} wizard\n     * @return {?}\n     */\n    function (wizard) {\n        _super.prototype.ensureCanReset.call(this, wizard);\n        // the default step is a completion step and the wizard contains more than one step\n        /** @type {?} */\n        var defaultWizardStep = wizard.getStepAtIndex(wizard.defaultStepIndex);\n        /** @type {?} */\n        var defaultCompletionStep = defaultWizardStep instanceof WizardCompletionStep;\n        if (defaultCompletionStep && wizard.wizardSteps.length !== 1) {\n            throw new Error(\"The default step index \" + wizard.defaultStepIndex + \" references a completion step\");\n        }\n    };\n    return ConfigurableNavigationMode;\n}(BaseNavigationMode));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `aw-wizard` component defines the root component of a wizard.\n * Through the setting of input parameters for the `aw-wizard` component it's possible to change the location and size\n * of its navigation bar.\n *\n * ### Syntax\n * ```html\n * <aw-wizard [navBarLocation]=\"location of navigation bar\" [navBarLayout]=\"layout of navigation bar\">\n *     ...\n * </aw-wizard>\n * ```\n *\n * ### Example\n *\n * Without completion step:\n *\n * ```html\n * <aw-wizard navBarLocation=\"top\" navBarLayout=\"small\">\n *     <aw-wizard-step>...</aw-wizard-step>\n *     <aw-wizard-step>...</aw-wizard-step>\n * </aw-wizard>\n * ```\n *\n * With completion step:\n *\n * ```html\n * <aw-wizard navBarLocation=\"top\" navBarLayout=\"small\">\n *     <aw-wizard-step>...</aw-wizard-step>\n *     <aw-wizard-step>...</aw-wizard-step>\n *     <aw-wizard-completion-step>...</aw-wizard-completion-step>\n * </aw-wizard>\n * ```\n *\n * @author Marc Arndt\n */\nvar WizardComponent = /** @class */ (function () {\n    /**\n     * Constructor\n     */\n    function WizardComponent() {\n        /**\n         * The location of the navigation bar inside the wizard.\n         * This location can be either top, bottom, left or right\n         */\n        this.navBarLocation = 'top';\n        /**\n         * The layout of the navigation bar inside the wizard.\n         * The layout can be either small, large-filled, large-empty or large-symbols\n         */\n        this.navBarLayout = 'small';\n        /**\n         * The direction in which the steps inside the navigation bar should be shown.\n         * The direction can be either `left-to-right` or `right-to-left`\n         */\n        this.navBarDirection = 'left-to-right';\n        this._defaultStepIndex = 0;\n        /**\n         * True, if the navigation bar shouldn't be used for navigating\n         */\n        this.disableNavigationBar = false;\n        /**\n         * The navigation mode used to navigate inside the wizard\n         *\n         * For outside access, use the [[navigation]] getter.\n         */\n        this._navigation = new ConfigurableNavigationMode();\n        /**\n         * An array representation of all wizard steps belonging to this model\n         *\n         * For outside access, use the [[wizardSteps]] getter.\n         */\n        this._wizardSteps = [];\n        /**\n         * The index of the currently visible and selected step inside the wizardSteps QueryList.\n         * If this wizard contains no steps, currentStepIndex is -1\n         *\n         * Note: Do not modify this field directly.  Instead, use navigation methods:\n         * [[goToStep]], [[goToPreviousStep]], [[goToNextStep]].\n         */\n        this.currentStepIndex = -1;\n    }\n    Object.defineProperty(WizardComponent.prototype, \"defaultStepIndex\", {\n        /**\n         * The initially selected step, represented by its index\n         * Beware: This initial default is only used if no wizard step has been enhanced with the `selected` directive\n         */\n        get: /**\n         * The initially selected step, represented by its index\n         * Beware: This initial default is only used if no wizard step has been enhanced with the `selected` directive\n         * @return {?}\n         */\n        function () {\n            // This value can be either:\n            // - the index of a wizard step with a `selected` directive, or\n            // - the default step index, set in the [[WizardComponent]]\n            // This value can be either:\n            // - the index of a wizard step with a `selected` directive, or\n            // - the default step index, set in the [[WizardComponent]]\n            /** @type {?} */\n            var foundDefaultStep = this.wizardSteps.find((/**\n             * @param {?} step\n             * @return {?}\n             */\n            function (step) { return step.defaultSelected; }));\n            if (foundDefaultStep) {\n                return this.getIndexOfStep(foundDefaultStep);\n            }\n            else {\n                return this._defaultStepIndex;\n            }\n        },\n        set: /**\n         * @param {?} defaultStepIndex\n         * @return {?}\n         */\n        function (defaultStepIndex) {\n            this._defaultStepIndex = defaultStepIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(WizardComponent.prototype, \"horizontalOrientation\", {\n        /**\n         * Returns true if this wizard uses a horizontal orientation.\n         * The wizard uses a horizontal orientation, iff the navigation bar is shown at the top or bottom of this wizard\n         *\n         * @returns True if this wizard uses a horizontal orientation\n         */\n        get: /**\n         * Returns true if this wizard uses a horizontal orientation.\n         * The wizard uses a horizontal orientation, iff the navigation bar is shown at the top or bottom of this wizard\n         *\n         * @return {?} True if this wizard uses a horizontal orientation\n         */\n        function () {\n            return this.navBarLocation === 'top' || this.navBarLocation === 'bottom';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(WizardComponent.prototype, \"verticalOrientation\", {\n        /**\n         * Returns true if this wizard uses a vertical orientation.\n         * The wizard uses a vertical orientation, iff the navigation bar is shown at the left or right of this wizard\n         *\n         * @returns True if this wizard uses a vertical orientation\n         */\n        get: /**\n         * Returns true if this wizard uses a vertical orientation.\n         * The wizard uses a vertical orientation, iff the navigation bar is shown at the left or right of this wizard\n         *\n         * @return {?} True if this wizard uses a vertical orientation\n         */\n        function () {\n            return this.navBarLocation === 'left' || this.navBarLocation === 'right';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Initialization work\n     */\n    /**\n     * Initialization work\n     * @return {?}\n     */\n    WizardComponent.prototype.ngAfterContentInit = /**\n     * Initialization work\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // add a subscriber to the wizard steps QueryList to listen to changes in the DOM\n        this.wizardStepsQueryList.changes.subscribe((/**\n         * @param {?} changedWizardSteps\n         * @return {?}\n         */\n        function (changedWizardSteps) {\n            _this.updateWizardSteps(changedWizardSteps.toArray());\n        }));\n        // initialize the model\n        this.updateWizardSteps(this.wizardStepsQueryList.toArray());\n        // finally reset the whole wizard componennt\n        this.reset();\n    };\n    Object.defineProperty(WizardComponent.prototype, \"currentStep\", {\n        /**\n         * The WizardStep object belonging to the currently visible and selected step.\n         * The currentStep is always the currently selected wizard step.\n         * The currentStep can be either completed, if it was visited earlier,\n         * or not completed, if it is visited for the first time or its state is currently out of date.\n         *\n         * If this wizard contains no steps, currentStep is null\n         */\n        get: /**\n         * The WizardStep object belonging to the currently visible and selected step.\n         * The currentStep is always the currently selected wizard step.\n         * The currentStep can be either completed, if it was visited earlier,\n         * or not completed, if it is visited for the first time or its state is currently out of date.\n         *\n         * If this wizard contains no steps, currentStep is null\n         * @return {?}\n         */\n        function () {\n            if (this.hasStep(this.currentStepIndex)) {\n                return this.wizardSteps[this.currentStepIndex];\n            }\n            else {\n                return null;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(WizardComponent.prototype, \"completed\", {\n        /**\n         * The completeness of the wizard.\n         * If the wizard has been completed, i.e. all steps are either completed or optional, this value is true, otherwise it is false\n         */\n        get: /**\n         * The completeness of the wizard.\n         * If the wizard has been completed, i.e. all steps are either completed or optional, this value is true, otherwise it is false\n         * @return {?}\n         */\n        function () {\n            return this.wizardSteps.every((/**\n             * @param {?} step\n             * @return {?}\n             */\n            function (step) { return step.completed || step.optional; }));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(WizardComponent.prototype, \"wizardSteps\", {\n        /**\n         * An array representation of all wizard steps belonging to this model\n         */\n        get: /**\n         * An array representation of all wizard steps belonging to this model\n         * @return {?}\n         */\n        function () {\n            return this._wizardSteps;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Updates the wizard steps to the new array\n     *\n     * @param wizardSteps The updated wizard steps\n     */\n    /**\n     * Updates the wizard steps to the new array\n     *\n     * @private\n     * @param {?} wizardSteps The updated wizard steps\n     * @return {?}\n     */\n    WizardComponent.prototype.updateWizardSteps = /**\n     * Updates the wizard steps to the new array\n     *\n     * @private\n     * @param {?} wizardSteps The updated wizard steps\n     * @return {?}\n     */\n    function (wizardSteps) {\n        // the wizard is currently not in the initialization phase\n        if (this.wizardSteps.length > 0 && this.currentStepIndex > -1) {\n            this.currentStepIndex = wizardSteps.indexOf(this.wizardSteps[this.currentStepIndex]);\n        }\n        this._wizardSteps = wizardSteps;\n    };\n    Object.defineProperty(WizardComponent.prototype, \"navigation\", {\n        /**\n         * The navigation mode used to navigate inside the wizard\n         */\n        get: /**\n         * The navigation mode used to navigate inside the wizard\n         * @return {?}\n         */\n        function () {\n            return this._navigation;\n        },\n        /**\n         * Updates the navigation mode for this wizard component\n         *\n         * @param navigation The updated navigation mode\n         */\n        set: /**\n         * Updates the navigation mode for this wizard component\n         *\n         * @param {?} navigation The updated navigation mode\n         * @return {?}\n         */\n        function (navigation) {\n            this._navigation = navigation;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Checks if a given index `stepIndex` is inside the range of possible wizard steps inside this wizard\n     *\n     * @param stepIndex The to be checked index of a step inside this wizard\n     * @returns True if the given `stepIndex` is contained inside this wizard, false otherwise\n     */\n    /**\n     * Checks if a given index `stepIndex` is inside the range of possible wizard steps inside this wizard\n     *\n     * @param {?} stepIndex The to be checked index of a step inside this wizard\n     * @return {?} True if the given `stepIndex` is contained inside this wizard, false otherwise\n     */\n    WizardComponent.prototype.hasStep = /**\n     * Checks if a given index `stepIndex` is inside the range of possible wizard steps inside this wizard\n     *\n     * @param {?} stepIndex The to be checked index of a step inside this wizard\n     * @return {?} True if the given `stepIndex` is contained inside this wizard, false otherwise\n     */\n    function (stepIndex) {\n        return this.wizardSteps.length > 0 && 0 <= stepIndex && stepIndex < this.wizardSteps.length;\n    };\n    /**\n     * Checks if this wizard has a previous step, compared to the current step\n     *\n     * @returns True if this wizard has a previous step before the current step\n     */\n    /**\n     * Checks if this wizard has a previous step, compared to the current step\n     *\n     * @return {?} True if this wizard has a previous step before the current step\n     */\n    WizardComponent.prototype.hasPreviousStep = /**\n     * Checks if this wizard has a previous step, compared to the current step\n     *\n     * @return {?} True if this wizard has a previous step before the current step\n     */\n    function () {\n        return this.hasStep(this.currentStepIndex - 1);\n    };\n    /**\n     * Checks if this wizard has a next step, compared to the current step\n     *\n     * @returns True if this wizard has a next step after the current step\n     */\n    /**\n     * Checks if this wizard has a next step, compared to the current step\n     *\n     * @return {?} True if this wizard has a next step after the current step\n     */\n    WizardComponent.prototype.hasNextStep = /**\n     * Checks if this wizard has a next step, compared to the current step\n     *\n     * @return {?} True if this wizard has a next step after the current step\n     */\n    function () {\n        return this.hasStep(this.currentStepIndex + 1);\n    };\n    /**\n     * Checks if this wizard is currently inside its last step\n     *\n     * @returns True if the wizard is currently inside its last step\n     */\n    /**\n     * Checks if this wizard is currently inside its last step\n     *\n     * @return {?} True if the wizard is currently inside its last step\n     */\n    WizardComponent.prototype.isLastStep = /**\n     * Checks if this wizard is currently inside its last step\n     *\n     * @return {?} True if the wizard is currently inside its last step\n     */\n    function () {\n        return this.wizardSteps.length > 0 && this.currentStepIndex === this.wizardSteps.length - 1;\n    };\n    /**\n     * Finds the [[WizardStep]] at the given index `stepIndex`.\n     * If no [[WizardStep]] exists at the given index an Error is thrown\n     *\n     * @param stepIndex The given index\n     * @returns The found [[WizardStep]] at the given index `stepIndex`\n     * @throws An `Error` is thrown, if the given index `stepIndex` doesn't exist\n     */\n    /**\n     * Finds the [[WizardStep]] at the given index `stepIndex`.\n     * If no [[WizardStep]] exists at the given index an Error is thrown\n     *\n     * @throws An `Error` is thrown, if the given index `stepIndex` doesn't exist\n     * @param {?} stepIndex The given index\n     * @return {?} The found [[WizardStep]] at the given index `stepIndex`\n     */\n    WizardComponent.prototype.getStepAtIndex = /**\n     * Finds the [[WizardStep]] at the given index `stepIndex`.\n     * If no [[WizardStep]] exists at the given index an Error is thrown\n     *\n     * @throws An `Error` is thrown, if the given index `stepIndex` doesn't exist\n     * @param {?} stepIndex The given index\n     * @return {?} The found [[WizardStep]] at the given index `stepIndex`\n     */\n    function (stepIndex) {\n        if (!this.hasStep(stepIndex)) {\n            throw new Error(\"Expected a known step, but got stepIndex: \" + stepIndex + \".\");\n        }\n        return this.wizardSteps[stepIndex];\n    };\n    /**\n     * Finds the index of the step with the given `stepId`.\n     * If no step with the given `stepId` exists, `-1` is returned\n     *\n     * @param stepId The given step id\n     * @returns The found index of a step with the given step id, or `-1` if no step with the given id is included in the wizard\n     */\n    /**\n     * Finds the index of the step with the given `stepId`.\n     * If no step with the given `stepId` exists, `-1` is returned\n     *\n     * @param {?} stepId The given step id\n     * @return {?} The found index of a step with the given step id, or `-1` if no step with the given id is included in the wizard\n     */\n    WizardComponent.prototype.getIndexOfStepWithId = /**\n     * Finds the index of the step with the given `stepId`.\n     * If no step with the given `stepId` exists, `-1` is returned\n     *\n     * @param {?} stepId The given step id\n     * @return {?} The found index of a step with the given step id, or `-1` if no step with the given id is included in the wizard\n     */\n    function (stepId) {\n        return this.wizardSteps.findIndex((/**\n         * @param {?} step\n         * @return {?}\n         */\n        function (step) { return step.stepId === stepId; }));\n    };\n    /**\n     * Finds the index of the given [[WizardStep]] `step`.\n     * If the given [[WizardStep]] is not contained inside this wizard, `-1` is returned\n     *\n     * @param step The given [[WizardStep]]\n     * @returns The found index of `step` or `-1` if the step is not included in the wizard\n     */\n    /**\n     * Finds the index of the given [[WizardStep]] `step`.\n     * If the given [[WizardStep]] is not contained inside this wizard, `-1` is returned\n     *\n     * @param {?} step The given [[WizardStep]]\n     * @return {?} The found index of `step` or `-1` if the step is not included in the wizard\n     */\n    WizardComponent.prototype.getIndexOfStep = /**\n     * Finds the index of the given [[WizardStep]] `step`.\n     * If the given [[WizardStep]] is not contained inside this wizard, `-1` is returned\n     *\n     * @param {?} step The given [[WizardStep]]\n     * @return {?} The found index of `step` or `-1` if the step is not included in the wizard\n     */\n    function (step) {\n        return this.wizardSteps.indexOf(step);\n    };\n    /**\n     * Calculates the correct [[MovingDirection]] value for a given `destinationStep` compared to the `currentStepIndex`.\n     *\n     * @param destinationStep The given destination step\n     * @returns The calculated [[MovingDirection]]\n     */\n    /**\n     * Calculates the correct [[MovingDirection]] value for a given `destinationStep` compared to the `currentStepIndex`.\n     *\n     * @param {?} destinationStep The given destination step\n     * @return {?} The calculated [[MovingDirection]]\n     */\n    WizardComponent.prototype.getMovingDirection = /**\n     * Calculates the correct [[MovingDirection]] value for a given `destinationStep` compared to the `currentStepIndex`.\n     *\n     * @param {?} destinationStep The given destination step\n     * @return {?} The calculated [[MovingDirection]]\n     */\n    function (destinationStep) {\n        /** @type {?} */\n        var movingDirection;\n        if (destinationStep > this.currentStepIndex) {\n            movingDirection = MovingDirection.Forwards;\n        }\n        else if (destinationStep < this.currentStepIndex) {\n            movingDirection = MovingDirection.Backwards;\n        }\n        else {\n            movingDirection = MovingDirection.Stay;\n        }\n        return movingDirection;\n    };\n    /**\n     * Checks, whether a wizard step, as defined by the given destination index, can be transitioned to.\n     *\n     * This method controls navigation by [[goToStep]], [[goToPreviousStep]], and [[goToNextStep]] directives.\n     * Navigation by navigation bar is governed by [[isNavigable]].\n     *\n     * @param destinationIndex The index of the destination step\n     * @returns A [[Promise]] containing `true`, if the destination step can be transitioned to and false otherwise\n     */\n    /**\n     * Checks, whether a wizard step, as defined by the given destination index, can be transitioned to.\n     *\n     * This method controls navigation by [[goToStep]], [[goToPreviousStep]], and [[goToNextStep]] directives.\n     * Navigation by navigation bar is governed by [[isNavigable]].\n     *\n     * @param {?} destinationIndex The index of the destination step\n     * @return {?} A [[Promise]] containing `true`, if the destination step can be transitioned to and false otherwise\n     */\n    WizardComponent.prototype.canGoToStep = /**\n     * Checks, whether a wizard step, as defined by the given destination index, can be transitioned to.\n     *\n     * This method controls navigation by [[goToStep]], [[goToPreviousStep]], and [[goToNextStep]] directives.\n     * Navigation by navigation bar is governed by [[isNavigable]].\n     *\n     * @param {?} destinationIndex The index of the destination step\n     * @return {?} A [[Promise]] containing `true`, if the destination step can be transitioned to and false otherwise\n     */\n    function (destinationIndex) {\n        return this.navigation.canGoToStep(this, destinationIndex);\n    };\n    /**\n     * Tries to transition to the wizard step, as denoted by the given destination index.\n     *\n     * Note: You do not have to call [[canGoToStep]] before calling [[goToStep]].\n     * The [[canGoToStep]] method will be called automatically.\n     *\n     * @param destinationIndex The index of the destination wizard step, which should be entered\n     * @param preFinalize An event emitter, to be called before the step has been transitioned\n     * @param postFinalize An event emitter, to be called after the step has been transitioned\n     */\n    /**\n     * Tries to transition to the wizard step, as denoted by the given destination index.\n     *\n     * Note: You do not have to call [[canGoToStep]] before calling [[goToStep]].\n     * The [[canGoToStep]] method will be called automatically.\n     *\n     * @param {?} destinationIndex The index of the destination wizard step, which should be entered\n     * @param {?=} preFinalize An event emitter, to be called before the step has been transitioned\n     * @param {?=} postFinalize An event emitter, to be called after the step has been transitioned\n     * @return {?}\n     */\n    WizardComponent.prototype.goToStep = /**\n     * Tries to transition to the wizard step, as denoted by the given destination index.\n     *\n     * Note: You do not have to call [[canGoToStep]] before calling [[goToStep]].\n     * The [[canGoToStep]] method will be called automatically.\n     *\n     * @param {?} destinationIndex The index of the destination wizard step, which should be entered\n     * @param {?=} preFinalize An event emitter, to be called before the step has been transitioned\n     * @param {?=} postFinalize An event emitter, to be called after the step has been transitioned\n     * @return {?}\n     */\n    function (destinationIndex, preFinalize, postFinalize) {\n        return this.navigation.goToStep(this, destinationIndex, preFinalize, postFinalize);\n    };\n    /**\n     * Tries to transition the wizard to the previous step\n     *\n     * @param preFinalize An event emitter, to be called before the step has been transitioned\n     * @param postFinalize An event emitter, to be called after the step has been transitioned\n     */\n    /**\n     * Tries to transition the wizard to the previous step\n     *\n     * @param {?=} preFinalize An event emitter, to be called before the step has been transitioned\n     * @param {?=} postFinalize An event emitter, to be called after the step has been transitioned\n     * @return {?}\n     */\n    WizardComponent.prototype.goToPreviousStep = /**\n     * Tries to transition the wizard to the previous step\n     *\n     * @param {?=} preFinalize An event emitter, to be called before the step has been transitioned\n     * @param {?=} postFinalize An event emitter, to be called after the step has been transitioned\n     * @return {?}\n     */\n    function (preFinalize, postFinalize) {\n        return this.navigation.goToStep(this, this.currentStepIndex - 1, preFinalize, postFinalize);\n    };\n    /**\n     * Tries to transition the wizard to the next step\n     *\n     * @param preFinalize An event emitter, to be called before the step has been transitioned\n     * @param postFinalize An event emitter, to be called after the step has been transitioned\n     */\n    /**\n     * Tries to transition the wizard to the next step\n     *\n     * @param {?=} preFinalize An event emitter, to be called before the step has been transitioned\n     * @param {?=} postFinalize An event emitter, to be called after the step has been transitioned\n     * @return {?}\n     */\n    WizardComponent.prototype.goToNextStep = /**\n     * Tries to transition the wizard to the next step\n     *\n     * @param {?=} preFinalize An event emitter, to be called before the step has been transitioned\n     * @param {?=} postFinalize An event emitter, to be called after the step has been transitioned\n     * @return {?}\n     */\n    function (preFinalize, postFinalize) {\n        return this.navigation.goToStep(this, this.currentStepIndex + 1, preFinalize, postFinalize);\n    };\n    /**\n     * Checks, whether the wizard step, located at the given index, can be navigated to using the navigation bar.\n     *\n     * @param destinationIndex The index of the destination step\n     * @returns True if the step can be navigated to, false otherwise\n     */\n    /**\n     * Checks, whether the wizard step, located at the given index, can be navigated to using the navigation bar.\n     *\n     * @param {?} destinationIndex The index of the destination step\n     * @return {?} True if the step can be navigated to, false otherwise\n     */\n    WizardComponent.prototype.isNavigable = /**\n     * Checks, whether the wizard step, located at the given index, can be navigated to using the navigation bar.\n     *\n     * @param {?} destinationIndex The index of the destination step\n     * @return {?} True if the step can be navigated to, false otherwise\n     */\n    function (destinationIndex) {\n        return this.navigation.isNavigable(this, destinationIndex);\n    };\n    /**\n     * Resets the state of this wizard.\n     */\n    /**\n     * Resets the state of this wizard.\n     * @return {?}\n     */\n    WizardComponent.prototype.reset = /**\n     * Resets the state of this wizard.\n     * @return {?}\n     */\n    function () {\n        this.navigation.reset(this);\n    };\n    WizardComponent.decorators = [\n        { type: Component, args: [{\n                    selector: 'aw-wizard',\n                    template: \"<aw-wizard-navigation-bar\\n  [direction]=\\\"navBarDirection\\\"\\n  *ngIf=\\\"navBarLocation == 'top' || navBarLocation == 'left'\\\"\\n  [ngClass]=\\\"{\\n    vertical: navBarLocation == 'left',\\n    horizontal: navBarLocation == 'top',\\n    small: navBarLayout == 'small',\\n    'large-filled': navBarLayout == 'large-filled',\\n    'large-filled-symbols': navBarLayout == 'large-filled-symbols',\\n    'large-empty': navBarLayout == 'large-empty',\\n    'large-empty-symbols': navBarLayout == 'large-empty-symbols'\\n  }\\\">\\n</aw-wizard-navigation-bar>\\n\\n<div [ngClass]=\\\"{\\n  'wizard-steps': true,\\n  vertical: navBarLocation == 'left' || navBarLocation == 'right',\\n  horizontal: navBarLocation == 'top' || navBarLocation == 'bottom'\\n}\\\">\\n  <ng-content></ng-content>\\n</div>\\n\\n<aw-wizard-navigation-bar\\n  [direction]=\\\"navBarDirection\\\"\\n  *ngIf=\\\"navBarLocation == 'bottom' || navBarLocation == 'right'\\\"\\n  [ngClass]=\\\"{\\n    vertical: navBarLocation == 'right',\\n    horizontal: navBarLocation == 'bottom',\\n    small: navBarLayout == 'small',\\n    'large-filled': navBarLayout == 'large-filled',\\n    'large-filled-symbols': navBarLayout == 'large-filled-symbols',\\n    'large-empty': navBarLayout == 'large-empty',\\n    'large-empty-symbols': navBarLayout == 'large-empty-symbols'\\n  }\\\">\\n</aw-wizard-navigation-bar>\\n\"\n                }] }\n    ];\n    /** @nocollapse */\n    WizardComponent.ctorParameters = function () { return []; };\n    WizardComponent.propDecorators = {\n        wizardStepsQueryList: [{ type: ContentChildren, args: [WizardStep,] }],\n        navBarLocation: [{ type: Input }],\n        navBarLayout: [{ type: Input }],\n        navBarDirection: [{ type: Input }],\n        defaultStepIndex: [{ type: Input }],\n        disableNavigationBar: [{ type: Input }],\n        horizontalOrientation: [{ type: HostBinding, args: ['class.horizontal',] }],\n        verticalOrientation: [{ type: HostBinding, args: ['class.vertical',] }]\n    };\n    return WizardComponent;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `aw-wizard-navigation-bar` component contains the navigation bar inside a [[WizardComponent]].\n * To correctly display the navigation bar, it's required to set the right css classes for the navigation bar,\n * otherwise it will look like a normal `ul` component.\n *\n * ### Syntax\n *\n * ```html\n * <aw-wizard-navigation-bar></aw-wizard-navigation-bar>\n * ```\n *\n * @author Marc Arndt\n */\nvar WizardNavigationBarComponent = /** @class */ (function () {\n    /**\n     * Constructor\n     *\n     * @param wizard The state the wizard currently resides in\n     */\n    function WizardNavigationBarComponent(wizard) {\n        this.wizard = wizard;\n        /**\n         * The direction in which the wizard steps should be shown in the navigation bar.\n         * This value can be either `left-to-right` or `right-to-left`\n         */\n        this.direction = 'left-to-right';\n    }\n    Object.defineProperty(WizardNavigationBarComponent.prototype, \"wizardSteps\", {\n        /**\n         * Returns all [[WizardStep]]s contained in the wizard\n         *\n         * @returns An array containing all [[WizardStep]]s\n         */\n        get: /**\n         * Returns all [[WizardStep]]s contained in the wizard\n         *\n         * @return {?} An array containing all [[WizardStep]]s\n         */\n        function () {\n            switch (this.direction) {\n                case 'right-to-left':\n                    return this.wizard.wizardSteps.slice().reverse();\n                case 'left-to-right':\n                default:\n                    return this.wizard.wizardSteps;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(WizardNavigationBarComponent.prototype, \"numberOfWizardSteps\", {\n        /**\n         * Returns the number of wizard steps, that need to be displaced in the navigation bar\n         *\n         * @returns The number of wizard steps to be displayed\n         */\n        get: /**\n         * Returns the number of wizard steps, that need to be displaced in the navigation bar\n         *\n         * @return {?} The number of wizard steps to be displayed\n         */\n        function () {\n            return this.wizard.wizardSteps.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Checks, whether a [[WizardStep]] can be marked as `current` in the navigation bar\n     *\n     * @param wizardStep The wizard step to be checked\n     * @returns True if the step can be marked as `current`\n     */\n    /**\n     * Checks, whether a [[WizardStep]] can be marked as `current` in the navigation bar\n     *\n     * @param {?} wizardStep The wizard step to be checked\n     * @return {?} True if the step can be marked as `current`\n     */\n    WizardNavigationBarComponent.prototype.isCurrent = /**\n     * Checks, whether a [[WizardStep]] can be marked as `current` in the navigation bar\n     *\n     * @param {?} wizardStep The wizard step to be checked\n     * @return {?} True if the step can be marked as `current`\n     */\n    function (wizardStep) {\n        return wizardStep.selected;\n    };\n    /**\n     * Checks, whether a [[WizardStep]] can be marked as `editing` in the navigation bar\n     *\n     * @param wizardStep The wizard step to be checked\n     * @returns True if the step can be marked as `editing`\n     */\n    /**\n     * Checks, whether a [[WizardStep]] can be marked as `editing` in the navigation bar\n     *\n     * @param {?} wizardStep The wizard step to be checked\n     * @return {?} True if the step can be marked as `editing`\n     */\n    WizardNavigationBarComponent.prototype.isEditing = /**\n     * Checks, whether a [[WizardStep]] can be marked as `editing` in the navigation bar\n     *\n     * @param {?} wizardStep The wizard step to be checked\n     * @return {?} True if the step can be marked as `editing`\n     */\n    function (wizardStep) {\n        return wizardStep.editing;\n    };\n    /**\n     * Checks, whether a [[WizardStep]] can be marked as `done` in the navigation bar\n     *\n     * @param wizardStep The wizard step to be checked\n     * @returns True if the step can be marked as `done`\n     */\n    /**\n     * Checks, whether a [[WizardStep]] can be marked as `done` in the navigation bar\n     *\n     * @param {?} wizardStep The wizard step to be checked\n     * @return {?} True if the step can be marked as `done`\n     */\n    WizardNavigationBarComponent.prototype.isDone = /**\n     * Checks, whether a [[WizardStep]] can be marked as `done` in the navigation bar\n     *\n     * @param {?} wizardStep The wizard step to be checked\n     * @return {?} True if the step can be marked as `done`\n     */\n    function (wizardStep) {\n        return wizardStep.completed;\n    };\n    /**\n     * Checks, whether a [[WizardStep]] can be marked as `optional` in the navigation bar\n     *\n     * @param wizardStep The wizard step to be checked\n     * @returns True if the step can be marked as `optional`\n     */\n    /**\n     * Checks, whether a [[WizardStep]] can be marked as `optional` in the navigation bar\n     *\n     * @param {?} wizardStep The wizard step to be checked\n     * @return {?} True if the step can be marked as `optional`\n     */\n    WizardNavigationBarComponent.prototype.isOptional = /**\n     * Checks, whether a [[WizardStep]] can be marked as `optional` in the navigation bar\n     *\n     * @param {?} wizardStep The wizard step to be checked\n     * @return {?} True if the step can be marked as `optional`\n     */\n    function (wizardStep) {\n        return wizardStep.optional;\n    };\n    /**\n     * Checks, whether a [[WizardStep]] can be marked as `completed` in the navigation bar.\n     *\n     * The `completed` class is only applied to completion steps.\n     *\n     * @param wizardStep The wizard step to be checked\n     * @returns True if the step can be marked as `completed`\n     */\n    /**\n     * Checks, whether a [[WizardStep]] can be marked as `completed` in the navigation bar.\n     *\n     * The `completed` class is only applied to completion steps.\n     *\n     * @param {?} wizardStep The wizard step to be checked\n     * @return {?} True if the step can be marked as `completed`\n     */\n    WizardNavigationBarComponent.prototype.isCompleted = /**\n     * Checks, whether a [[WizardStep]] can be marked as `completed` in the navigation bar.\n     *\n     * The `completed` class is only applied to completion steps.\n     *\n     * @param {?} wizardStep The wizard step to be checked\n     * @return {?} True if the step can be marked as `completed`\n     */\n    function (wizardStep) {\n        return wizardStep instanceof WizardCompletionStep && this.wizard.completed;\n    };\n    /**\n     * Checks, whether a [[WizardStep]] can be marked as `navigable` in the navigation bar.\n     * A wizard step can be navigated to if:\n     * - the step is currently not selected\n     * - the navigation bar isn't disabled\n     * - the navigation mode allows navigation to the step\n     *\n     * @param wizardStep The wizard step to be checked\n     * @returns True if the step can be marked as navigable\n     */\n    /**\n     * Checks, whether a [[WizardStep]] can be marked as `navigable` in the navigation bar.\n     * A wizard step can be navigated to if:\n     * - the step is currently not selected\n     * - the navigation bar isn't disabled\n     * - the navigation mode allows navigation to the step\n     *\n     * @param {?} wizardStep The wizard step to be checked\n     * @return {?} True if the step can be marked as navigable\n     */\n    WizardNavigationBarComponent.prototype.isNavigable = /**\n     * Checks, whether a [[WizardStep]] can be marked as `navigable` in the navigation bar.\n     * A wizard step can be navigated to if:\n     * - the step is currently not selected\n     * - the navigation bar isn't disabled\n     * - the navigation mode allows navigation to the step\n     *\n     * @param {?} wizardStep The wizard step to be checked\n     * @return {?} True if the step can be marked as navigable\n     */\n    function (wizardStep) {\n        return !wizardStep.selected && !this.wizard.disableNavigationBar &&\n            this.wizard.isNavigable(this.wizard.getIndexOfStep(wizardStep));\n    };\n    WizardNavigationBarComponent.decorators = [\n        { type: Component, args: [{\n                    selector: 'aw-wizard-navigation-bar',\n                    template: \"<ul class=\\\"steps-indicator steps-{{numberOfWizardSteps}}\\\">\\n  <li [attr.id]=\\\"step.stepId\\\" *ngFor=\\\"let step of wizardSteps\\\"\\n      [ngClass]=\\\"{\\n        current: isCurrent(step),\\n        editing: isEditing(step),\\n        done: isDone(step),\\n        optional: isOptional(step),\\n        completed: isCompleted(step),\\n        navigable: isNavigable(step)\\n  }\\\">\\n    <a [awGoToStep]=\\\"step\\\">\\n      <div class=\\\"label\\\">\\n        <ng-container *ngIf=\\\"step.stepTitleTemplate\\\" [ngTemplateOutlet]=\\\"step.stepTitleTemplate.templateRef\\\"></ng-container>\\n        <ng-container *ngIf=\\\"!step.stepTitleTemplate\\\">{{step.stepTitle}}</ng-container>\\n      </div>\\n      <div class=\\\"step-indicator\\\" [ngStyle]=\\\"{ 'font-family': step.stepSymbolTemplate ? '' : step.navigationSymbol.fontFamily }\\\">\\n        <ng-container *ngIf=\\\"step.stepSymbolTemplate\\\" [ngTemplateOutlet]=\\\"step.stepSymbolTemplate.templateRef\\\"></ng-container>\\n        <ng-container *ngIf=\\\"!step.stepSymbolTemplate\\\">{{step.navigationSymbol.symbol}}</ng-container>\\n      </div>\\n    </a>\\n  </li>\\n</ul>\\n\"\n                }] }\n    ];\n    /** @nocollapse */\n    WizardNavigationBarComponent.ctorParameters = function () { return [\n        { type: WizardComponent }\n    ]; };\n    WizardNavigationBarComponent.propDecorators = {\n        direction: [{ type: Input }]\n    };\n    return WizardNavigationBarComponent;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `aw-wizard-step` component is used to define a normal step inside a wizard.\n *\n * ### Syntax\n *\n * With `stepTitle` and `navigationSymbol` inputs:\n *\n * ```html\n * <aw-wizard-step [stepTitle]=\"step title\" [navigationSymbol]=\"{ symbol: 'symbol', fontFamily: 'font-family' }\"\n *    [canExit]=\"deciding function\" (stepEnter)=\"enter function\" (stepExit)=\"exit function\">\n *    ...\n * </aw-wizard-step>\n * ```\n *\n * With `awWizardStepTitle` and `awWizardStepSymbol` directives:\n *\n * ```html\n * <aw-wizard-step\"\n *    [canExit]=\"deciding function\" (stepEnter)=\"enter function\" (stepExit)=\"exit function\">\n *    <ng-template awWizardStepTitle>\n *        step title\n *    </ng-template>\n *    <ng-template awWizardStepSymbol>\n *        symbol\n *    </ng-template>\n *    ...\n * </aw-wizard-step>\n * ```\n *\n * ### Example\n *\n * With `stepTitle` and `navigationSymbol` inputs:\n *\n * ```html\n * <aw-wizard-step stepTitle=\"Address information\" [navigationSymbol]=\"{ symbol: '&#xf1ba;', fontFamily: 'FontAwesome' }\">\n *    ...\n * </aw-wizard-step>\n * ```\n *\n * With `awWizardStepTitle` and `awWizardStepSymbol` directives:\n *\n * ```html\n * <aw-wizard-step>\n *    <ng-template awWizardStepTitle>\n *        Address information\n *    </ng-template>\n *    <ng-template awWizardStepSymbol>\n *        <i class=\"fa fa-taxi\"></i>\n *    </ng-template>\n * </aw-wizard-step>\n * ```\n *\n * @author Marc Arndt\n */\nvar WizardStepComponent = /** @class */ (function (_super) {\n    __extends(WizardStepComponent, _super);\n    function WizardStepComponent() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    WizardStepComponent.decorators = [\n        { type: Component, args: [{\n                    selector: 'aw-wizard-step',\n                    template: \"<ng-content></ng-content>\\n\",\n                    providers: [\n                        { provide: WizardStep, useExisting: forwardRef((/**\n                             * @return {?}\n                             */\n                            function () { return WizardStepComponent; })) }\n                    ]\n                }] }\n    ];\n    return WizardStepComponent;\n}(WizardStep));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `awEnableBackLinks` directive can be used to allow the user to leave a [[WizardCompletionStep]] after is has been entered.\n *\n * ### Syntax\n *\n * ```html\n * <aw-wizard-completion-step awEnableBackLinks (stepExit)=\"exit function\">\n *     ...\n * </aw-wizard-completion-step>\n * ```\n *\n * ### Example\n *\n * ```html\n * <aw-wizard-completion-step stepTitle=\"Final step\" awEnableBackLinks>\n *     ...\n * </aw-wizard-completion-step>\n * ```\n *\n * @author Marc Arndt\n */\nvar EnableBackLinksDirective = /** @class */ (function () {\n    /**\n     * Constructor\n     *\n     * @param completionStep The wizard completion step, which should be exitable\n     */\n    function EnableBackLinksDirective(completionStep) {\n        this.completionStep = completionStep;\n        /**\n         * This EventEmitter is called when the step is exited.\n         * The bound method can be used to do cleanup work.\n         */\n        this.stepExit = new EventEmitter();\n    }\n    /**\n     * Initialization work\n     */\n    /**\n     * Initialization work\n     * @return {?}\n     */\n    EnableBackLinksDirective.prototype.ngOnInit = /**\n     * Initialization work\n     * @return {?}\n     */\n    function () {\n        this.completionStep.canExit = true;\n        this.completionStep.stepExit = this.stepExit;\n    };\n    EnableBackLinksDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[awEnableBackLinks]'\n                },] }\n    ];\n    /** @nocollapse */\n    EnableBackLinksDirective.ctorParameters = function () { return [\n        { type: WizardCompletionStep, decorators: [{ type: Host }] }\n    ]; };\n    EnableBackLinksDirective.propDecorators = {\n        stepExit: [{ type: Output }]\n    };\n    return EnableBackLinksDirective;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Checks whether the given `value` implements the interface [[StepId]].\n *\n * @param {?} value The value to be checked\n * @return {?} True if the given value implements [[StepId]] and false otherwise\n */\nfunction isStepId(value) {\n    return value.hasOwnProperty('stepId') && !(value instanceof WizardStep);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Checks whether the given `value` implements the interface [[StepIndex]].\n *\n * @param {?} value The value to be checked\n * @return {?} True if the given value implements [[StepIndex]] and false otherwise\n */\nfunction isStepIndex(value) {\n    return value.hasOwnProperty('stepIndex');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Checks whether the given `value` implements the interface [[StepOffset]].\n *\n * @param {?} value The value to be checked\n * @return {?} True if the given value implements [[StepOffset]] and false otherwise\n */\nfunction isStepOffset(value) {\n    return value.hasOwnProperty('stepOffset');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `awGoToStep` directive can be used to navigate to a given step.\n * This step can be defined in one of multiple formats\n *\n * ### Syntax\n *\n * With absolute step index:\n *\n * ```html\n * <button [awGoToStep]=\"{ stepIndex: absolute step index }\" (finalize)=\"finalize method\">...</button>\n * ```\n *\n * With unique step id:\n *\n * ```html\n * <button [awGoToStep]=\"{ stepId: 'step id of destination step' }\" (finalize)=\"finalize method\">...</button>\n * ```\n *\n * With a wizard step object:\n *\n * ```html\n * <button [awGoToStep]=\"wizard step object\" (finalize)=\"finalize method\">...</button>\n * ```\n *\n * With an offset to the defining step:\n *\n * ```html\n * <button [awGoToStep]=\"{ stepOffset: offset }\" (finalize)=\"finalize method\">...</button>\n * ```\n *\n * @author Marc Arndt\n */\nvar GoToStepDirective = /** @class */ (function () {\n    /**\n     * Constructor\n     *\n     * @param wizard The wizard component\n     * @param wizardStep The wizard step, which contains this [[GoToStepDirective]]\n     */\n    function GoToStepDirective(wizard, wizardStep) {\n        this.wizard = wizard;\n        this.wizardStep = wizardStep;\n        /**\n         * This [[EventEmitter]] is called directly before the current step is exited during a transition through a component with this directive.\n         */\n        this.preFinalize = new EventEmitter();\n        /**\n         * This [[EventEmitter]] is called directly after the current step is exited during a transition through a component with this directive.\n         */\n        this.postFinalize = new EventEmitter();\n    }\n    Object.defineProperty(GoToStepDirective.prototype, \"finalize\", {\n        /**\n         * A convenience field for `preFinalize`\n         */\n        get: /**\n         * A convenience field for `preFinalize`\n         * @return {?}\n         */\n        function () {\n            return this.preFinalize;\n        },\n        /**\n         * A convenience name for `preFinalize`\n         *\n         * @param emitter The [[EventEmitter]] to be set\n         */\n        set: /**\n         * A convenience name for `preFinalize`\n         *\n         * @param {?} emitter The [[EventEmitter]] to be set\n         * @return {?}\n         */\n        function (emitter) {\n            /* istanbul ignore next */\n            this.preFinalize = emitter;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GoToStepDirective.prototype, \"destinationStep\", {\n        /**\n         * Returns the destination step of this directive as an absolute step index inside the wizard\n         *\n         * @returns The index of the destination step\n         * @throws If `targetStep` is of an unknown type an `Error` is thrown\n         */\n        get: /**\n         * Returns the destination step of this directive as an absolute step index inside the wizard\n         *\n         * @throws If `targetStep` is of an unknown type an `Error` is thrown\n         * @return {?} The index of the destination step\n         */\n        function () {\n            /** @type {?} */\n            var destinationStep;\n            if (isStepIndex(this.targetStep)) {\n                destinationStep = this.targetStep.stepIndex;\n            }\n            else if (isStepId(this.targetStep)) {\n                destinationStep = this.wizard.getIndexOfStepWithId(this.targetStep.stepId);\n            }\n            else if (isStepOffset(this.targetStep) && this.wizardStep !== null) {\n                destinationStep = this.wizard.getIndexOfStep(this.wizardStep) + this.targetStep.stepOffset;\n            }\n            else if (this.targetStep instanceof WizardStep) {\n                destinationStep = this.wizard.getIndexOfStep(this.targetStep);\n            }\n            else {\n                throw new Error(\"Input 'targetStep' is neither a WizardStep, StepOffset, StepIndex or StepId\");\n            }\n            return destinationStep;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Listener method for `click` events on the component with this directive.\n     * After this method is called the wizard will try to transition to the `destinationStep`\n     */\n    /**\n     * Listener method for `click` events on the component with this directive.\n     * After this method is called the wizard will try to transition to the `destinationStep`\n     * @param {?} event\n     * @return {?}\n     */\n    GoToStepDirective.prototype.onClick = /**\n     * Listener method for `click` events on the component with this directive.\n     * After this method is called the wizard will try to transition to the `destinationStep`\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        this.wizard.goToStep(this.destinationStep, this.preFinalize, this.postFinalize);\n    };\n    GoToStepDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[awGoToStep]'\n                },] }\n    ];\n    /** @nocollapse */\n    GoToStepDirective.ctorParameters = function () { return [\n        { type: WizardComponent },\n        { type: WizardStep, decorators: [{ type: Optional }] }\n    ]; };\n    GoToStepDirective.propDecorators = {\n        preFinalize: [{ type: Output }],\n        postFinalize: [{ type: Output }],\n        targetStep: [{ type: Input, args: ['awGoToStep',] }],\n        finalize: [{ type: Output }],\n        onClick: [{ type: HostListener, args: ['click', ['$event'],] }]\n    };\n    return GoToStepDirective;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `awNextStep` directive can be used to navigate to the next step.\n *\n * ### Syntax\n *\n * ```html\n * <button awNextStep (finalize)=\"finalize method\">...</button>\n * ```\n *\n * @author Marc Arndt\n */\nvar NextStepDirective = /** @class */ (function () {\n    /**\n     * Constructor\n     *\n     * @param wizard The state of the wizard\n     */\n    function NextStepDirective(wizard) {\n        this.wizard = wizard;\n        /**\n         * This [[EventEmitter]] is called directly before the current step is exited during a transition through a component with this directive.\n         */\n        this.preFinalize = new EventEmitter();\n        /**\n         * This [[EventEmitter]] is called directly after the current step is exited during a transition through a component with this directive.\n         */\n        this.postFinalize = new EventEmitter();\n    }\n    Object.defineProperty(NextStepDirective.prototype, \"finalize\", {\n        /**\n         * A convenience field for `preFinalize`\n         */\n        get: /**\n         * A convenience field for `preFinalize`\n         * @return {?}\n         */\n        function () {\n            return this.preFinalize;\n        },\n        /**\n         * A convenience name for `preFinalize`\n         *\n         * @param emitter The [[EventEmitter]] to be set\n         */\n        set: /**\n         * A convenience name for `preFinalize`\n         *\n         * @param {?} emitter The [[EventEmitter]] to be set\n         * @return {?}\n         */\n        function (emitter) {\n            /* istanbul ignore next */\n            this.preFinalize = emitter;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Listener method for `click` events on the component with this directive.\n     * After this method is called the wizard will try to transition to the next step\n     */\n    /**\n     * Listener method for `click` events on the component with this directive.\n     * After this method is called the wizard will try to transition to the next step\n     * @param {?} event\n     * @return {?}\n     */\n    NextStepDirective.prototype.onClick = /**\n     * Listener method for `click` events on the component with this directive.\n     * After this method is called the wizard will try to transition to the next step\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        this.wizard.goToNextStep(this.preFinalize, this.postFinalize);\n    };\n    NextStepDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[awNextStep]'\n                },] }\n    ];\n    /** @nocollapse */\n    NextStepDirective.ctorParameters = function () { return [\n        { type: WizardComponent }\n    ]; };\n    NextStepDirective.propDecorators = {\n        preFinalize: [{ type: Output }],\n        postFinalize: [{ type: Output }],\n        finalize: [{ type: Output }],\n        onClick: [{ type: HostListener, args: ['click', ['$event'],] }]\n    };\n    return NextStepDirective;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `awOptionalStep` directive can be used to define an optional `wizard-step`.\n * An optional wizard step is a [[WizardStep]] that doesn't need to be completed to transition to later wizard steps.\n *\n * ### Syntax\n *\n * ```html\n * <aw-wizard-step awOptionalStep>\n *     ...\n * </aw-wizard-step>\n * ```\n *\n * ### Example\n *\n * ```html\n * <aw-wizard-step stepTitle=\"Second step\" awOptionalStep>\n *     ...\n * </aw-wizard-step>\n * ```\n *\n * @author Marc Arndt\n */\nvar OptionalStepDirective = /** @class */ (function () {\n    /**\n     * Constructor\n     *\n     * @param wizardStep The wizard step, which contains this [[OptionalStepDirective]]\n     */\n    function OptionalStepDirective(wizardStep) {\n        this.wizardStep = wizardStep;\n    }\n    /**\n     * Initialization work\n     */\n    /**\n     * Initialization work\n     * @return {?}\n     */\n    OptionalStepDirective.prototype.ngOnInit = /**\n     * Initialization work\n     * @return {?}\n     */\n    function () {\n        this.wizardStep.optional = true;\n    };\n    OptionalStepDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[awOptionalStep]'\n                },] }\n    ];\n    /** @nocollapse */\n    OptionalStepDirective.ctorParameters = function () { return [\n        { type: WizardStep, decorators: [{ type: Host }] }\n    ]; };\n    return OptionalStepDirective;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `awPreviousStep` directive can be used to navigate to the previous step.\n * Compared to the [[NextStepDirective]] it's important to note, that this directive doesn't contain a `finalize` output method.\n *\n * ### Syntax\n *\n * ```html\n * <button awPreviousStep>...</button>\n * ```\n *\n * @author Marc Arndt\n */\nvar PreviousStepDirective = /** @class */ (function () {\n    /**\n     * Constructor\n     *\n     * @param wizard The state of the wizard\n     */\n    function PreviousStepDirective(wizard) {\n        this.wizard = wizard;\n        /**\n         * This [[EventEmitter]] is called directly before the current step is exited during a transition through a component with this directive.\n         */\n        this.preFinalize = new EventEmitter();\n        /**\n         * This [[EventEmitter]] is called directly after the current step is exited during a transition through a component with this directive.\n         */\n        this.postFinalize = new EventEmitter();\n    }\n    Object.defineProperty(PreviousStepDirective.prototype, \"finalize\", {\n        /**\n         * A convenience field for `preFinalize`\n         */\n        get: /**\n         * A convenience field for `preFinalize`\n         * @return {?}\n         */\n        function () {\n            return this.preFinalize;\n        },\n        /**\n         * A convenience field for `preFinalize`\n         *\n         * @param emitter The [[EventEmitter]] to be set\n         */\n        set: /**\n         * A convenience field for `preFinalize`\n         *\n         * @param {?} emitter The [[EventEmitter]] to be set\n         * @return {?}\n         */\n        function (emitter) {\n            /* istanbul ignore next */\n            this.preFinalize = emitter;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Listener method for `click` events on the component with this directive.\n     * After this method is called the wizard will try to transition to the previous step\n     */\n    /**\n     * Listener method for `click` events on the component with this directive.\n     * After this method is called the wizard will try to transition to the previous step\n     * @param {?} event\n     * @return {?}\n     */\n    PreviousStepDirective.prototype.onClick = /**\n     * Listener method for `click` events on the component with this directive.\n     * After this method is called the wizard will try to transition to the previous step\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        this.wizard.goToPreviousStep(this.preFinalize, this.postFinalize);\n    };\n    PreviousStepDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[awPreviousStep]'\n                },] }\n    ];\n    /** @nocollapse */\n    PreviousStepDirective.ctorParameters = function () { return [\n        { type: WizardComponent }\n    ]; };\n    PreviousStepDirective.propDecorators = {\n        preFinalize: [{ type: Output }],\n        postFinalize: [{ type: Output }],\n        finalize: [{ type: Output }],\n        onClick: [{ type: HostListener, args: ['click', ['$event'],] }]\n    };\n    return PreviousStepDirective;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `awResetWizard` directive can be used to reset the wizard to its initial state.\n * This directive accepts an output, which can be used to specify some custom cleanup work during the reset process.\n *\n * ### Syntax\n *\n * ```html\n * <button awResetWizard (finalize)=\"custom reset task\">...</button>\n * ```\n *\n * @author Marc Arndt\n */\nvar ResetWizardDirective = /** @class */ (function () {\n    /**\n     * Constructor\n     *\n     * @param wizard The wizard component\n     */\n    function ResetWizardDirective(wizard) {\n        this.wizard = wizard;\n        /**\n         * An [[EventEmitter]] containing some tasks to be done, directly before the wizard is being reset\n         */\n        this.finalize = new EventEmitter();\n    }\n    /**\n     * Resets the wizard\n     */\n    /**\n     * Resets the wizard\n     * @param {?} event\n     * @return {?}\n     */\n    ResetWizardDirective.prototype.onClick = /**\n     * Resets the wizard\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        // do some optional cleanup work\n        this.finalize.emit();\n        // reset the wizard to its initial state\n        this.wizard.reset();\n    };\n    ResetWizardDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[awResetWizard]'\n                },] }\n    ];\n    /** @nocollapse */\n    ResetWizardDirective.ctorParameters = function () { return [\n        { type: WizardComponent }\n    ]; };\n    ResetWizardDirective.propDecorators = {\n        finalize: [{ type: Output }],\n        onClick: [{ type: HostListener, args: ['click', ['$event'],] }]\n    };\n    return ResetWizardDirective;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `awSelectedStep` directive can be used on a [[WizardStep]] to set it as selected after the wizard initialisation or a reset.\n *\n * ### Syntax\n *\n * ```html\n * <aw-wizard-step stepTitle=\"Step title\" awSelectedStep>\n *     ...\n * </aw-wizard-step>\n * ```\n *\n * @author Marc Arndt\n */\nvar SelectedStepDirective = /** @class */ (function () {\n    /**\n     * Constructor\n     *\n     * @param wizardStep The wizard step, which should be selected by default\n     */\n    function SelectedStepDirective(wizardStep) {\n        this.wizardStep = wizardStep;\n    }\n    /**\n     * Initialization work\n     */\n    /**\n     * Initialization work\n     * @return {?}\n     */\n    SelectedStepDirective.prototype.ngOnInit = /**\n     * Initialization work\n     * @return {?}\n     */\n    function () {\n        this.wizardStep.defaultSelected = true;\n    };\n    SelectedStepDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[awSelectedStep]'\n                },] }\n    ];\n    /** @nocollapse */\n    SelectedStepDirective.ctorParameters = function () { return [\n        { type: WizardStep, decorators: [{ type: Host }] }\n    ]; };\n    return SelectedStepDirective;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `awWizardCompletionStep` directive can be used to define a completion/success step at the end of your wizard\n * After a [[WizardCompletionStep]] has been entered, it has the characteristic that the user is blocked from\n * leaving it again to a previous step.\n * In addition entering a [[WizardCompletionStep]] automatically sets the `wizard`, and all steps inside the `wizard`,\n * as completed.\n *\n * ### Syntax\n *\n * ```html\n * <div awWizardCompletionStep [stepTitle]=\"title of the wizard step\"\n *    [navigationSymbol]=\"{ symbol: 'navigation symbol', fontFamily: 'font-family' }\"\n *    (stepEnter)=\"event emitter to be called when the wizard step is entered\"\n *    (stepExit)=\"event emitter to be called when the wizard step is exited\">\n *    ...\n * </div>\n * ```\n *\n * ### Example\n *\n * ```html\n * <div awWizardCompletionStep stepTitle=\"Step 1\" [navigationSymbol]=\"{ symbol: '1' }\">\n *    ...\n * </div>\n * ```\n *\n * With a navigation symbol from the `font-awesome` font:\n *\n * ```html\n * <div awWizardCompletionStep stepTitle=\"Step 1\" [navigationSymbol]=\"{ symbol: '&#xf1ba;', fontFamily: 'FontAwesome' }\">\n *    ...\n * </div>\n * ```\n *\n * @author Marc Arndt\n */\nvar WizardCompletionStepDirective = /** @class */ (function (_super) {\n    __extends(WizardCompletionStepDirective, _super);\n    function WizardCompletionStepDirective() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    WizardCompletionStepDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[awWizardCompletionStep]',\n                    providers: [\n                        { provide: WizardStep, useExisting: forwardRef((/**\n                             * @return {?}\n                             */\n                            function () { return WizardCompletionStepDirective; })) },\n                        { provide: WizardCompletionStep, useExisting: forwardRef((/**\n                             * @return {?}\n                             */\n                            function () { return WizardCompletionStepDirective; })) }\n                    ]\n                },] }\n    ];\n    return WizardCompletionStepDirective;\n}(WizardCompletionStep));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `awWizardStep` directive can be used to define a normal step inside a wizard.\n *\n * ### Syntax\n *\n * With `stepTitle` and `navigationSymbol` inputs:\n *\n * ```html\n * <div awWizardStep [stepTitle]=\"step title\" [navigationSymbol]=\"{ symbol: 'symbol', fontFamily: 'font-family' }\"\n *    [canExit]=\"deciding function\" (stepEnter)=\"enter function\" (stepExit)=\"exit function\">\n *    ...\n * </div>\n * ```\n *\n * With `awWizardStepTitle` and `awWizardStepSymbol` directives:\n *\n * ```html\n * <div awWizardStep [canExit]=\"deciding function\" (stepEnter)=\"enter function\" (stepExit)=\"exit function\">\n *    <ng-template awWizardStepTitle>\n *        step title\n *    </ng-template>\n *    <ng-template awWizardStepSymbol>\n *        symbol\n *    </ng-template>\n *    ...\n * </div>\n * ```\n *\n * ### Example\n *\n * With `stepTitle` and `navigationSymbol` inputs:\n *\n * ```html\n * <div awWizardStep stepTitle=\"Address information\" [navigationSymbol]=\"{ symbol: '&#xf1ba;', fontFamily: 'FontAwesome' }\">\n *    ...\n * </div>\n * ```\n *\n * With `awWizardStepTitle` and `awWizardStepSymbol` directives:\n *\n * ```html\n * <div awWizardStep>\n *    <ng-template awWizardStepTitle>\n *        Address information\n *    </ng-template>\n *    <ng-template awWizardStepSymbol>\n *        <i class=\"fa fa-taxi\"></i>\n *    </ng-template>\n * </div>\n * ```\n *\n * @author Marc Arndt\n */\nvar WizardStepDirective = /** @class */ (function (_super) {\n    __extends(WizardStepDirective, _super);\n    function WizardStepDirective() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    WizardStepDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[awWizardStep]',\n                    providers: [\n                        { provide: WizardStep, useExisting: forwardRef((/**\n                             * @return {?}\n                             */\n                            function () { return WizardStepDirective; })) }\n                    ]\n                },] }\n    ];\n    return WizardStepDirective;\n}(WizardStep));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The [[awNavigationMode]] directive can be used to customize wizard'd navigation mode.\n *\n * There are several usage options:\n *\n * ### Option 1. Customize the default navigation mode with [[navigateBackward]] and/or [[navigateForward]] inputs.\n *\n * ```html\n * <aw-wizard [awNavigationMode] navigateBackward=\"deny\" navigateForward=\"allow\">...</aw-wizard>\n * ```\n *\n * ### Option 2. Pass in a custom navigation mode\n *\n * ```typescript\n * import { BaseNavigationMode } from 'angular-archwizard'\n *\n * class CustomNavigationMode extends BaseNavigationMode {\n *\n *   // ...\n * }\n * ```\n *\n * ```typescript\n * \\@Component({\n *   // ...\n * })\n * class MyComponent {\n *\n *   navigationMode = new CustomNavigationMode();\n * }\n * ```\n *\n * ```html\n * <aw-wizard [awNavigationMode]=\"navigationMode\">...</aw-wizard>\n * ```\n *\n * ### Additional Notes\n *\n * - Specifying a custom navigation mode takes priority over [[navigateBackward]] and [[navigateForward]] inputs\n *\n * - Omitting the [[awNavigationMode]] directive or, equally, specifying just [[awNavigationMode]] without\n *   any inputs or parameters causes the wizard to use the default \"strict\" navigation mode equivalent to\n *\n * ```html\n * <aw-wizard [awNavigationMode] navigateBackward=\"deny\" navigateForward=\"allow\">...</aw-wizard>\n * ````\n */\nvar NavigationModeDirective = /** @class */ (function () {\n    function NavigationModeDirective(wizard) {\n        this.wizard = wizard;\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    NavigationModeDirective.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n    function (changes) {\n        this.wizard.navigation = this.getNavigationMode();\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    NavigationModeDirective.prototype.getNavigationMode = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        if (this.awNavigationMode) {\n            return this.awNavigationMode;\n        }\n        return new ConfigurableNavigationMode(this.navigateBackward, this.navigateForward);\n    };\n    NavigationModeDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[awNavigationMode]',\n                },] }\n    ];\n    /** @nocollapse */\n    NavigationModeDirective.ctorParameters = function () { return [\n        { type: WizardComponent }\n    ]; };\n    NavigationModeDirective.propDecorators = {\n        awNavigationMode: [{ type: Input }],\n        navigateBackward: [{ type: Input }],\n        navigateForward: [{ type: Input }]\n    };\n    return NavigationModeDirective;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The `awCompletedStep` directive can be used to make a wizard step initially completed.\n *\n * Initially completed steps are shown as completed when the wizard is presented to the user.\n *\n * A typical use case is to make a step initially completed if it is automatically filled with some derived/predefined information.\n *\n * ### Syntax\n *\n * ```html\n * <aw-wizard-step awCompletedStep>\n *     ...\n * </aw-wizard-step>\n * ```\n *\n * An optional boolean condition can be specified:\n *\n * ```html\n * <aw-wizard-step [awCompletedStep]=\"shouldBeCompleted\">\n *     ...\n * </aw-wizard-step>\n * ```\n *\n * ### Example\n *\n * ```html\n * <aw-wizard-step stepTitle=\"First step\" [awCompletedStep]=\"firstStepPrefilled\">\n *     ...\n * </aw-wizard-step>\n * ```\n */\nvar CompletedStepDirective = /** @class */ (function () {\n    /**\n     * Constructor\n     *\n     * @param wizardStep The wizard step, which contains this [[CompletedStepDirective]]\n     */\n    function CompletedStepDirective(wizardStep) {\n        this.wizardStep = wizardStep;\n        // tslint:disable-next-line:no-input-rename\n        this.initiallyCompleted = true;\n    }\n    /**\n     * Initialization work\n     */\n    /**\n     * Initialization work\n     * @return {?}\n     */\n    CompletedStepDirective.prototype.ngOnInit = /**\n     * Initialization work\n     * @return {?}\n     */\n    function () {\n        // The input receives '' when specified in the template without a value.  In this case, apply the default value (`true`).\n        this.wizardStep.initiallyCompleted = this.initiallyCompleted || (/** @type {?} */ (this.initiallyCompleted)) === '';\n    };\n    CompletedStepDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[awCompletedStep]'\n                },] }\n    ];\n    /** @nocollapse */\n    CompletedStepDirective.ctorParameters = function () { return [\n        { type: WizardStep, decorators: [{ type: Host }] }\n    ]; };\n    CompletedStepDirective.propDecorators = {\n        initiallyCompleted: [{ type: Input, args: ['awCompletedStep',] }]\n    };\n    return CompletedStepDirective;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The module defining all the content inside `angular-archwizard`\n *\n * @author Marc Arndt\n */\nvar ArchwizardModule = /** @class */ (function () {\n    function ArchwizardModule() {\n    }\n    /* istanbul ignore next */\n    /* istanbul ignore next */\n    /**\n     * @return {?}\n     */\n    ArchwizardModule.forRoot = /* istanbul ignore next */\n    /**\n     * @return {?}\n     */\n    function () {\n        return {\n            ngModule: ArchwizardModule,\n            providers: [\n            // Nothing here yet\n            ]\n        };\n    };\n    ArchwizardModule.decorators = [\n        { type: NgModule, args: [{\n                    declarations: [\n                        WizardComponent,\n                        WizardStepComponent,\n                        WizardNavigationBarComponent,\n                        WizardCompletionStepComponent,\n                        GoToStepDirective,\n                        NextStepDirective,\n                        PreviousStepDirective,\n                        OptionalStepDirective,\n                        WizardStepSymbolDirective,\n                        WizardStepTitleDirective,\n                        EnableBackLinksDirective,\n                        WizardStepDirective,\n                        WizardCompletionStepDirective,\n                        SelectedStepDirective,\n                        ResetWizardDirective,\n                        NavigationModeDirective,\n                        CompletedStepDirective,\n                    ],\n                    imports: [\n                        CommonModule\n                    ],\n                    exports: [\n                        WizardComponent,\n                        WizardStepComponent,\n                        WizardNavigationBarComponent,\n                        WizardCompletionStepComponent,\n                        GoToStepDirective,\n                        NextStepDirective,\n                        PreviousStepDirective,\n                        OptionalStepDirective,\n                        WizardStepSymbolDirective,\n                        WizardStepTitleDirective,\n                        EnableBackLinksDirective,\n                        WizardStepDirective,\n                        WizardCompletionStepDirective,\n                        SelectedStepDirective,\n                        ResetWizardDirective,\n                        NavigationModeDirective,\n                        CompletedStepDirective,\n                    ]\n                },] }\n    ];\n    return ArchwizardModule;\n}());\n\nexport { ArchwizardModule, BaseNavigationMode, CompletedStepDirective, ConfigurableNavigationMode, EnableBackLinksDirective, GoToStepDirective, MovingDirection, NavigationModeDirective, NextStepDirective, OptionalStepDirective, PreviousStepDirective, ResetWizardDirective, SelectedStepDirective, WizardCompletionStep, WizardCompletionStepComponent, WizardCompletionStepDirective, WizardComponent, WizardNavigationBarComponent, WizardStep, WizardStepComponent, WizardStepDirective, WizardStepTitleDirective, isStepId, isStepIndex, isStepOffset, WizardStepSymbolDirective as a };\n"]}